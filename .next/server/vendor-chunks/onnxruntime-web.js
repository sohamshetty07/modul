"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-web";
exports.ids = ["vendor-chunks/onnxruntime-web"];
exports.modules = {

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.2e583633.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?8254":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.InferenceSession),\n/* harmony export */   TRACE: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN),\n/* harmony export */   TRACE_FUNC_END: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END),\n/* harmony export */   Tensor: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor),\n/* harmony export */   \"default\": () => (/* binding */ Cr),\n/* harmony export */   env: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   registerBackend: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-common */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/index.js\");\n/*!\n * ONNX Runtime Web v1.21.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nconst require=(0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.node.min.mjs\");\nvar ue=Object.defineProperty;var pt=Object.getOwnPropertyDescriptor;var mt=Object.getOwnPropertyNames;var gt=Object.prototype.hasOwnProperty;var ce=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,o)=>(typeof require<\"u\"?require:t)[o]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var C=(e,t)=>()=>(e&&(t=e(e=0)),t);var bt=(e,t)=>{for(var o in t)ue(e,o,{get:t[o],enumerable:!0})},yt=(e,t,o,s)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of mt(t))!gt.call(e,r)&&r!==o&&ue(e,r,{get:()=>t[r],enumerable:!(s=pt(t,r))||s.enumerable});return e};var wt=e=>yt(ue({},\"__esModule\",{value:!0}),e);var M,Q=C(()=>{\"use strict\";M=!!(typeof process<\"u\"&&process.versions&&process.versions.node)});var Pe,ht,k,xe,ve,St,Et,Ot,Tt,Le,Ie,le=C(()=>{\"use strict\";Q();Pe=M||typeof location>\"u\"?void 0:location.origin,ht=()=>{if(!M)return \"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.node.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.node.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?ee8e\")).href,Pe).href:\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.node.min.mjs\"},k=ht(),xe=()=>{if(k&&!k.startsWith(\"blob:\"))return k.substring(0,k.lastIndexOf(\"/\")+1)},ve=(e,t)=>{try{let o=t??k;return(o?new URL(e,o):new URL(e)).origin===Pe}catch{return!1}},St=(e,t)=>{let o=t??k;try{return(o?new URL(e,o):new URL(e)).href}catch{return}},Et=(e,t)=>`${t??\"./\"}${e}`,Ot=async e=>{let o=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(o)},Tt=async e=>(await import(/*webpackIgnore:true*/e)).default,Le=void 0,Ie=async(e,t,o)=>{if(!e&&!t&&Le&&k&&ve(k))return[void 0,Le];{let s=\"ort-wasm-simd-threaded.mjs\",r=e??St(s,t),a=!M&&o&&r&&!ve(r,t),n=a?await Ot(r):r??Et(s,t);return[a?n:void 0,await Tt(n)]}}});var fe,de,ee,_e,vt,Lt,Ae,E,z=C(()=>{\"use strict\";le();de=!1,ee=!1,_e=!1,vt=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Ae=async e=>{if(de)return Promise.resolve();if(ee)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(_e)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");ee=!0;let t=e.initTimeout,o=e.numThreads;if(!Lt())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let s=vt();o>1&&!s&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+o+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=o=1);let r=e.wasmPaths,a=typeof r==\"string\"?r:void 0,n=r?.mjs,i=n?.href??n,c=r?.wasm,f=c?.href??c,h=e.wasmBinary,[y,u]=await Ie(i,a,o>1),l=!1,x=[];if(t>0&&x.push(new Promise(S=>{setTimeout(()=>{l=!0,S()},t)})),x.push(new Promise((S,m)=>{let b={numThreads:o};if(h)b.wasmBinary=h;else if(f||a)b.locateFile=d=>f??a+d;else if(i&&i.indexOf(\"blob:\")!==0)b.locateFile=d=>new URL(d,i).href;else if(y){let d=xe();d&&(b.locateFile=w=>d+w)}u(b).then(d=>{ee=!1,de=!0,fe=d,S(),y&&URL.revokeObjectURL(y)},d=>{ee=!1,_e=!0,m(d)})})),await Promise.race(x),l)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},E=()=>{if(de&&fe)return fe;throw new Error(\"WebAssembly is not initialized yet.\")}});var O,J,g,te=C(()=>{\"use strict\";z();O=(e,t)=>{let o=E(),s=o.lengthBytesUTF8(e)+1,r=o._malloc(s);return o.stringToUTF8(e,r,s),t.push(r),r},J=(e,t,o,s)=>{if(typeof e==\"object\"&&e!==null){if(o.has(e))throw new Error(\"Circular reference in options\");o.add(e)}Object.entries(e).forEach(([r,a])=>{let n=t?t+r:r;if(typeof a==\"object\")J(a,n+\".\",o,s);else if(typeof a==\"string\"||typeof a==\"number\")s(n,a.toString());else if(typeof a==\"boolean\")s(n,a?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},g=e=>{let t=E(),o=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetLastError(r,r+s);let a=Number(t.getValue(r,s===4?\"i32\":\"i64\")),n=t.getValue(r+s,\"*\"),i=n?t.UTF8ToString(n):\"\";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(o)}}});var Ce,Ue=C(()=>{\"use strict\";z();te();Ce=e=>{let t=E(),o=0,s=[],r=e||{};try{if(e?.logSeverityLevel===void 0)r.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)r.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(r.terminate=!1);let a=0;return e?.tag!==void 0&&(a=O(e.tag,s)),o=t._OrtCreateRunOptions(r.logSeverityLevel,r.logVerbosityLevel,!!r.terminate,a),o===0&&g(\"Can't create run options.\"),e?.extra!==void 0&&J(e.extra,\"\",new WeakSet,(n,i)=>{let c=O(n,s),f=O(i,s);t._OrtAddRunConfigEntry(o,c,f)!==0&&g(`Can't set a run config entry: ${n} - ${i}.`)}),[o,s]}catch(a){throw o!==0&&t._OrtReleaseRunOptions(o),s.forEach(n=>t._free(n)),a}}});var Pt,xt,It,_t,Be,Me=C(()=>{\"use strict\";z();te();Pt=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},xt=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},It=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(o=>(typeof o==\"string\"?o:o.name)===\"webgpu\")&&(e.enableMemPattern=!1)},_t=(e,t,o)=>{for(let s of t){let r=typeof s==\"string\"?s:s.name;switch(r){case\"webnn\":if(r=\"WEBNN\",typeof s!=\"string\"){let i=s?.deviceType;if(i){let c=O(\"deviceType\",o),f=O(i,o);E()._OrtAddSessionConfigEntry(e,c,f)!==0&&g(`Can't set a session config entry: 'deviceType' - ${i}.`)}}break;case\"webgpu\":if(r=\"JS\",typeof s!=\"string\"){let n=s;if(n?.preferredLayout){if(n.preferredLayout!==\"NCHW\"&&n.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${n.preferredLayout}`);let i=O(\"preferredLayout\",o),c=O(n.preferredLayout,o);E()._OrtAddSessionConfigEntry(e,i,c)!==0&&g(`Can't set a session config entry: 'preferredLayout' - ${n.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${r}`)}let a=O(r,o);E()._OrtAppendExecutionProvider(e,a)!==0&&g(`Can't append execution provider: ${r}.`)}},Be=e=>{let t=E(),o=0,s=[],r=e||{};It(r);try{let a=Pt(r.graphOptimizationLevel??\"all\"),n=xt(r.executionMode??\"sequential\"),i=typeof r.logId==\"string\"?O(r.logId,s):0,c=r.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let f=r.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let h=typeof r.optimizedModelFilePath==\"string\"?O(r.optimizedModelFilePath,s):0;if(o=t._OrtCreateSessionOptions(a,!!r.enableCpuMemArena,!!r.enableMemPattern,n,!!r.enableProfiling,0,i,c,f,h),o===0&&g(\"Can't create session options.\"),r.executionProviders&&_t(o,r.executionProviders,s),r.enableGraphCapture!==void 0){if(typeof r.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);let y=O(\"enableGraphCapture\",s),u=O(r.enableGraphCapture.toString(),s);t._OrtAddSessionConfigEntry(o,y,u)!==0&&g(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`)}if(r.freeDimensionOverrides)for(let[y,u]of Object.entries(r.freeDimensionOverrides)){if(typeof y!=\"string\")throw new Error(`free dimension override name must be a string: ${y}`);if(typeof u!=\"number\"||!Number.isInteger(u)||u<0)throw new Error(`free dimension override value must be a non-negative integer: ${u}`);let l=O(y,s);t._OrtAddFreeDimensionOverride(o,l,u)!==0&&g(`Can't set a free dimension override: ${y} - ${u}.`)}return r.extra!==void 0&&J(r.extra,\"\",new WeakSet,(y,u)=>{let l=O(y,s),x=O(u,s);t._OrtAddSessionConfigEntry(o,l,x)!==0&&g(`Can't set a session config entry: ${y} - ${u}.`)}),[o,s]}catch(a){throw o!==0&&t._OrtReleaseSessionOptions(o)!==0&&g(\"Can't release session options.\"),s.forEach(n=>t._free(n)),a}}});var G,ke,H,De,We,re,ne,Fe,pe=C(()=>{\"use strict\";G=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},ke=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},H=(e,t)=>{let o=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],s=typeof t==\"number\"?t:t.reduce((r,a)=>r*a,1);return o>0?Math.ceil(s*o):void 0},De=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},We=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},re=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",ne=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Fe=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var Y,me=C(()=>{\"use strict\";Q();Y=async e=>{if(typeof e==\"string\")if(M)try{let{readFile:t}=ce(\"node:fs/promises\");return new Uint8Array(await t(e))}catch(t){if(t.code===\"ERR_FS_FILE_TOO_LARGE\"){let{createReadStream:o}=ce(\"node:fs\"),s=o(e),r=[];for await(let a of s)r.push(a);return new Uint8Array(Buffer.concat(r))}throw t}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let o=t.headers.get(\"Content-Length\"),s=o?parseInt(o,10):0;if(s<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(s)}catch(i){if(i instanceof RangeError){let c=Math.ceil(s/65536);a=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw i}let n=0;for(;;){let{done:i,value:c}=await r.read();if(i)break;let f=c.byteLength;new Uint8Array(a,n,f).set(c),n+=f}return new Uint8Array(a,0,s)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var At,Ne,je,V,Ct,ge,$e,ze,Re,Ge,He,Ve=C(()=>{\"use strict\";Ue();Me();pe();z();te();me();At=(e,t)=>{E()._OrtInit(e,t)!==0&&g(\"Can't initialize onnxruntime.\")},Ne=async e=>{At(e.wasm.numThreads,We(e.logLevel))},je=async(e,t)=>{},V=new Map,Ct=e=>{let t=E(),o=t.stackSave();try{let s=t.PTR_SIZE,r=t.stackAlloc(2*s);t._OrtGetInputOutputCount(e,r,r+s)!==0&&g(\"Can't get session input/output count.\");let n=s===4?\"i32\":\"i64\";return[Number(t.getValue(r,n)),Number(t.getValue(r+s,n))]}finally{t.stackRestore(o)}},ge=e=>{let t=E(),o=t._malloc(e.byteLength);if(o===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,o),[o,e.byteLength]},$e=async(e,t)=>{let o,s,r=E();Array.isArray(e)?[o,s]=e:e.buffer===r.HEAPU8.buffer?[o,s]=[e.byteOffset,e.byteLength]:[o,s]=ge(e);let a=0,n=0,i=0,c=[],f=[],h=[];try{if([n,c]=Be(t),t?.externalData&&r.mountExternalData){let d=[];for(let w of t.externalData){let v=typeof w==\"string\"?w:w.path;d.push(Y(typeof w==\"string\"?w:w.data).then(A=>{r.mountExternalData(v,A)}))}await Promise.all(d)}for(let d of t?.executionProviders??[])if((typeof d==\"string\"?d:d.name)===\"webnn\"){if(r.shouldTransferToMLTensor=!1,typeof d!=\"string\"){let v=d,A=v?.context,D=v?.gpuDevice,W=v?.deviceType,X=v?.powerPreference;A?r.currentContext=A:D?r.currentContext=await r.jsepCreateMLContext(D):r.currentContext=await r.jsepCreateMLContext({deviceType:W,powerPreference:X})}else r.currentContext=await r.jsepCreateMLContext();break}a=await r._OrtCreateSession(o,s,n),a===0&&g(\"Can't create a session.\"),r.jsepOnCreateSession?.(),r.currentContext&&(r.jsepRegisterMLContext(a,r.currentContext),r.currentContext=void 0,r.shouldTransferToMLTensor=!0);let[y,u]=Ct(a),l=!!t?.enableGraphCapture,x=[],S=[],m=[];for(let d=0;d<y;d++){let w=r._OrtGetInputName(a,d);w===0&&g(\"Can't get an input name.\"),f.push(w),x.push(r.UTF8ToString(w))}for(let d=0;d<u;d++){let w=r._OrtGetOutputName(a,d);w===0&&g(\"Can't get an output name.\"),h.push(w);let v=r.UTF8ToString(w);S.push(v)}return V.set(a,[a,f,h,null,l,!1]),[a,x,S]}catch(y){throw f.forEach(u=>r._OrtFree(u)),h.forEach(u=>r._OrtFree(u)),i!==0&&r._OrtReleaseBinding(i)!==0&&g(\"Can't release IO binding.\"),a!==0&&r._OrtReleaseSession(a)!==0&&g(\"Can't release session.\"),y}finally{r._free(o),n!==0&&r._OrtReleaseSessionOptions(n)!==0&&g(\"Can't release session options.\"),c.forEach(y=>r._free(y)),r.unmountExternalData?.()}},ze=e=>{let t=E(),o=V.get(e);if(!o)throw new Error(`cannot release session. invalid session id: ${e}`);let[s,r,a,n,i]=o;n&&(i&&t._OrtClearBoundOutputs(n.handle)!==0&&g(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(n.handle)!==0&&g(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),r.forEach(c=>t._OrtFree(c)),a.forEach(c=>t._OrtFree(c)),t._OrtReleaseSession(s)!==0&&g(\"Can't release session.\"),V.delete(e)},Re=async(e,t,o,s,r,a=!1)=>{if(!e){t.push(0);return}let n=E(),i=n.PTR_SIZE,c=e[0],f=e[1],h=e[3],y=h,u,l;if(c===\"string\"&&(h===\"gpu-buffer\"||h===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(a&&h!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);if(h===\"gpu-buffer\"){let m=e[2].gpuBuffer;l=H(G(c),f);let b=n.jsepRegisterBuffer;if(!b)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');u=b(s,r,m,l)}else if(h===\"ml-tensor\"){let m=e[2].mlTensor;l=H(G(c),f);let b=n.jsepRegisterMLTensor;if(!b)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');u=b(s,m,G(c),f)}else{let m=e[2];if(Array.isArray(m)){l=i*m.length,u=n._malloc(l),o.push(u);for(let b=0;b<m.length;b++){if(typeof m[b]!=\"string\")throw new TypeError(`tensor data at index ${b} is not a string`);n.setValue(u+b*i,O(m[b],o),\"*\")}}else{let b=n.jsepIsGraphInput;if(c!==\"string\"&&b){let d=n._OrtGetInputName(s,r),w=n.UTF8ToString(d);if(b(s,w)){let v=G(c);l=H(v,f),y=\"ml-tensor\";let A=n.jsepCreateTemporaryTensor,D=n.jsepUploadTensor;if(!A||!D)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');let W=await A(s,v,f);D(W,new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),u=W}else l=m.byteLength,u=n._malloc(l),o.push(u),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),u)}else l=m.byteLength,u=n._malloc(l),o.push(u),n.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),u)}}let x=n.stackSave(),S=n.stackAlloc(4*f.length);try{f.forEach((b,d)=>n.setValue(S+d*i,b,i===4?\"i32\":\"i64\"));let m=n._OrtCreateTensor(G(c),u,l,S,f.length,Fe(y));m===0&&g(`Can't create tensor for input/output. session=${s}, index=${r}.`),t.push(m)}finally{n.stackRestore(x)}},Ge=async(e,t,o,s,r,a)=>{let n=E(),i=n.PTR_SIZE,c=V.get(e);if(!c)throw new Error(`cannot run inference. invalid session id: ${e}`);let f=c[0],h=c[1],y=c[2],u=c[3],l=c[4],x=c[5],S=t.length,m=s.length,b=0,d=[],w=[],v=[],A=[],D=n.stackSave(),W=n.stackAlloc(S*i),X=n.stackAlloc(S*i),ae=n.stackAlloc(m*i),Se=n.stackAlloc(m*i);try{[b,d]=Ce(a);for(let p=0;p<S;p++)await Re(o[p],w,A,e,t[p],l);for(let p=0;p<m;p++)await Re(r[p],v,A,e,S+s[p],l);for(let p=0;p<S;p++)n.setValue(W+p*i,w[p],\"*\"),n.setValue(X+p*i,h[t[p]],\"*\");for(let p=0;p<m;p++)n.setValue(ae+p*i,v[p],\"*\"),n.setValue(Se+p*i,y[s[p]],\"*\");n.jsepOnRunStart?.(f);let U;U=await n._OrtRun(f,X,W,S,Se,m,ae,b),U!==0&&g(\"failed to call OrtRun().\");let j=[];for(let p=0;p<m;p++){let $=Number(n.getValue(ae+p*i,\"*\"));if($===v[p]){j.push(r[p]);continue}let Ee=n.stackSave(),B=n.stackAlloc(4*i),q=!1,L,I=0;try{n._OrtGetTensorData($,B,B+i,B+2*i,B+3*i)!==0&&g(`Can't access output tensor data on index ${p}.`);let ie=i===4?\"i32\":\"i64\",Z=Number(n.getValue(B,ie));I=n.getValue(B+i,\"*\");let Oe=n.getValue(B+i*2,\"*\"),lt=Number(n.getValue(B+i*3,ie)),F=[];for(let P=0;P<lt;P++)F.push(Number(n.getValue(Oe+P*i,ie)));n._OrtFree(Oe)!==0&&g(\"Can't free memory for tensor dims.\");let R=F.reduce((P,T)=>P*T,1);L=ke(Z);let K=u?.outputPreferredLocations[s[p]];if(L===\"string\"){if(K===\"gpu-buffer\"||K===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let P=[];for(let T=0;T<R;T++){let N=n.getValue(I+T*i,\"*\"),ft=n.getValue(I+(T+1)*i,\"*\"),dt=T===R-1?void 0:ft-N;P.push(n.UTF8ToString(N,dt))}j.push([L,F,P,\"cpu\"])}else if(K===\"gpu-buffer\"&&R>0){let P=n.jsepGetBuffer;if(!P)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let T=P(I),N=H(Z,R);if(N===void 0||!re(L))throw new Error(`Unsupported data type: ${L}`);q=!0,j.push([L,F,{gpuBuffer:T,download:n.jsepCreateDownloader(T,N,L),dispose:()=>{n._OrtReleaseTensor($)!==0&&g(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(K===\"ml-tensor\"&&R>0){let P=n.jsepEnsureTensor;if(!P)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(H(Z,R)===void 0||!ne(L))throw new Error(`Unsupported data type: ${L}`);let N=await P(e,I,Z,F,!1);q=!0,j.push([L,F,{mlTensor:N,download:n.jsepCreateMLTensorDownloader(I,L),dispose:()=>{n.jsepReleaseTensorId(I),n._OrtReleaseTensor($)}},\"ml-tensor\"])}else{let P=De(L),T=new P(R);new Uint8Array(T.buffer,T.byteOffset,T.byteLength).set(n.HEAPU8.subarray(I,I+T.byteLength)),j.push([L,F,T,\"cpu\"])}}finally{n.stackRestore(Ee),L===\"string\"&&I&&n._free(I),q||n._OrtReleaseTensor($),n.jsepOnRunEnd?.(f)}}return u&&!l&&(n._OrtClearBoundOutputs(u.handle)!==0&&g(\"Can't clear bound outputs.\"),V.set(e,[f,h,y,u,l,!1])),j}finally{n.stackRestore(D),w.forEach(U=>n._OrtReleaseTensor(U)),v.forEach(U=>n._OrtReleaseTensor(U)),A.forEach(U=>n._free(U)),b!==0&&n._OrtReleaseRunOptions(b),d.forEach(U=>n._free(U))}},He=e=>{let t=E(),o=V.get(e);if(!o)throw new Error(\"invalid session id\");let s=o[0],r=t._OrtEndProfiling(s);r===0&&g(\"Can't get an profile file name.\"),t._OrtFree(r)}});var be,qe,Je,Ye,Xe,Ze,Ke,Qe,et,tt,we=C(()=>{\"use strict\";Ve();z();le();be=!1,qe=!1,Je=!1,Ye=async()=>{if(!qe){if(be)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(Je)throw new Error(\"previous call to 'initWasm()' failed.\");be=!0;try{await Ae(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm),await Ne(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env),qe=!0}catch(e){throw Je=!0,e}finally{be=!1}}},Xe=async e=>{await je(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env,e)},Ze=async e=>ge(e),Ke=async(e,t)=>$e(e,t),Qe=async e=>{ze(e)},et=async(e,t,o,s,r,a)=>Ge(e,t,o,s,r,a),tt=async e=>{He(e)}});var ot,Bt,oe,st=C(()=>{\"use strict\";we();pe();Q();me();ot=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},Bt=e=>{switch(e[3]){case\"cpu\":return new onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!re(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:o,download:s,dispose:r}=e[2];return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromGpuBuffer(o,{dataType:t,dims:e[1],download:s,dispose:r})}case\"ml-tensor\":{let t=e[0];if(!ne(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:o,download:s,dispose:r}=e[2];return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromMLTensor(o,{dataType:t,dims:e[1],download:s,dispose:r})}default:throw new Error(`invalid data location: ${e[3]}`)}},oe=class{async fetchModelAndCopyToWasmMemory(t){return Ze(await Y(t))}async loadModel(t,o){(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();let s;typeof t==\"string\"?M?s=await Y(t):s=await this.fetchModelAndCopyToWasmMemory(t):s=t,[this.sessionId,this.inputNames,this.outputNames]=await Ke(s,o),(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)()}async dispose(){return Qe(this.sessionId)}async run(t,o,s){(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();let r=[],a=[];Object.entries(t).forEach(u=>{let l=u[0],x=u[1],S=this.inputNames.indexOf(l);if(S===-1)throw new Error(`invalid input '${l}'`);r.push(x),a.push(S)});let n=[],i=[];Object.entries(o).forEach(u=>{let l=u[0],x=u[1],S=this.outputNames.indexOf(l);if(S===-1)throw new Error(`invalid output '${l}'`);n.push(x),i.push(S)});let c=r.map((u,l)=>ot(u,()=>`input \"${this.inputNames[a[l]]}\"`)),f=n.map((u,l)=>u?ot(u,()=>`output \"${this.outputNames[i[l]]}\"`):null),h=await et(this.sessionId,a,c,i,f,s),y={};for(let u=0;u<h.length;u++)y[this.outputNames[i[u]]]=n[u]??Bt(h[u]);return (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)(),y}startProfiling(){}endProfiling(){tt(this.sessionId)}}});var it={};bt(it,{OnnxruntimeWebAssemblyBackend:()=>se,initializeFlags:()=>at,wasmBackend:()=>Mt});var at,se,Mt,ut=C(()=>{\"use strict\";we();st();at=()=>{if((typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout!=\"number\"||onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout<0)&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout=0),onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy!=\"boolean\"&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy=!1),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace!=\"boolean\"&&(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace=!1),typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads!=\"number\"||!Number.isInteger(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads)||onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?ce(\"node:os\").cpus().length:navigator.hardwareConcurrency;onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},se=class{async init(t){at(),await Ye(),await Xe(t)}async createInferenceSessionHandler(t,o){let s=new oe;return await s.loadModel(t,o),Promise.resolve(s)}},Mt=new se});var Te=\"1.21.0\";var Cr=onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__;{let e=(ut(),wt(it)).wasmBackend;(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"cpu\",e,10),(0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"wasm\",e,10)}Object.defineProperty(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.versions,\"web\",{value:Te,enumerable:!0});\n//# sourceMappingURL=ort.node.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm5vZGUubWluLm1qcz84MjU0IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDLGNBQWMscURBQWEsQ0FBQyw4RUFBZTtBQUM3RSw2QkFBNkIsdUNBQXVDLGtDQUFrQyx1Q0FBdUMsb0VBQW9FLDZDQUE2QyxpQkFBaUIsMkRBQTJELDJEQUEyRCxFQUFFLG1DQUFtQyxlQUFlLHVCQUF1Qix1QkFBdUIsRUFBRSxnQkFBZ0IsZ0dBQWdHLG1EQUFtRCxFQUFFLFVBQVUsa0JBQWtCLGVBQWUsU0FBUyxLQUFLLGVBQWUsYUFBYSxrRUFBa0UsRUFBRSw4Q0FBOEMsYUFBYSxJQUFJLHlEQUF5RCxhQUFhLDhFQUFlLDhCQUE4Qiw0SkFBMkMsZUFBZSw4RUFBZSxDQUFDLGdCQUFnQix3RUFBd0UsWUFBWSxJQUFJLFdBQVcsOENBQThDLE1BQU0sVUFBVSxZQUFZLFdBQVcsSUFBSSx1Q0FBdUMsTUFBTSxRQUFRLGNBQWMsUUFBUSxFQUFFLEVBQUUsZUFBZSwyQkFBMkIsMEJBQTBCLFVBQVUsOEJBQThCLHlGQUF5RiwyQ0FBMkMsZ0dBQWdHLGlDQUFpQyxFQUFFLG9DQUFvQyxhQUFhLEtBQUssMEJBQTBCLHlDQUF5QyxJQUFJLG1PQUFtTyxNQUFNLFVBQVUsU0FBUyxJQUFJLHlLQUF5SyxNQUFNLFVBQVUsY0FBYywrQkFBK0IsK0VBQStFLDRFQUE0RSxNQUFNLG1DQUFtQywwRkFBMEYsV0FBVyw0WEFBNFgsOElBQThJLCtCQUErQixnQkFBZ0IsU0FBUyxJQUFJLDhCQUE4QixPQUFPLGNBQWMsb0JBQW9CLG9DQUFvQyxvRUFBb0UsV0FBVyxXQUFXLHlCQUF5QixjQUFjLCtDQUErQyxLQUFLLGlCQUFpQixFQUFFLHNHQUFzRyxFQUFFLEtBQUssUUFBUSxvQkFBb0Isd0RBQXdELEVBQUUsb0JBQW9CLGFBQWEsSUFBSSxVQUFVLGtEQUFrRCx5Q0FBeUMs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LGlCQUFpQiwwQ0FBMEMsRUFBRSxrREFBa0QsS0FBSyxJQUFJLFVBQVUsdUNBQXVDLHNCQUFzQixxQkFBcUIsb0VBQUUsR0FBRyxNQUFNLG9KQUFvSixrRUFBRSxHQUFHLGdCQUFnQiwwQkFBMEIsaUJBQWlCLG9FQUFFLEdBQUcsY0FBYyw4QkFBOEIsK0NBQStDLDRDQUE0QyxFQUFFLElBQUksb0JBQW9CLEVBQUUsY0FBYyw4QkFBOEIsZ0RBQWdELDZDQUE2QyxFQUFFLElBQUksb0JBQW9CLEVBQUUsc0NBQXNDLHNCQUFzQiwwQ0FBMEMsdUJBQXVCLG9EQUFvRCxZQUFZLFdBQVcsNkNBQTZDLE9BQU8sa0VBQUUsS0FBSyxrQkFBa0IsZUFBZSxxQkFBcUIsRUFBRSxVQUFVLE9BQU8sK0VBQStFLEVBQTJDLHVCQUF1QixhQUFhLEtBQUssS0FBSyxRQUFRLFdBQVcsbURBQUMsNkJBQTZCLG1EQUFDLHVCQUF1QixtREFBQyxxQkFBcUIsbURBQUMscUtBQXFLLG1EQUFDLHlCQUF5QixtREFBQyx1QkFBdUIsbURBQUMseUJBQXlCLG1EQUFDLHVCQUF1QixtREFBQyw4Q0FBOEMsbURBQUMsbUJBQW1CLG1EQUFDLGtFQUFrRSxtREFBQyxtQkFBbUIsS0FBSyxxRkFBcUYsbURBQUMsa0RBQWtELFVBQVUsY0FBYyw0QkFBNEIseUNBQXlDLGFBQWEsa0RBQWtELFdBQVcsRUFBd0ksZ0JBQWdCLE9BQU8sK0NBQUUsRUFBRSxnQ0FBZ0MsbUVBQUUsYUFBYSxtRUFBRSxjQUFjLHNCQUFzQixtREFBRSxpQkFBaUIsdUJBQXVCLEVBQXdCO0FBQzFqdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm5vZGUubWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmltcG9ydHtjcmVhdGVSZXF1aXJlfWZyb21cIm1vZHVsZVwiO2NvbnN0IHJlcXVpcmU9Y3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xudmFyIHVlPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgcHQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgbXQ9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIGd0PU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIGNlPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LG8pPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtvXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgQz0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBidD0oZSx0KT0+e2Zvcih2YXIgbyBpbiB0KXVlKGUsbyx7Z2V0OnRbb10sZW51bWVyYWJsZTohMH0pfSx5dD0oZSx0LG8scyk9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IHIgb2YgbXQodCkpIWd0LmNhbGwoZSxyKSYmciE9PW8mJnVlKGUscix7Z2V0OigpPT50W3JdLGVudW1lcmFibGU6IShzPXB0KHQscikpfHxzLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIHd0PWU9Pnl0KHVlKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBNLFE9QygoKT0+e1widXNlIHN0cmljdFwiO009ISEodHlwZW9mIHByb2Nlc3M8XCJ1XCImJnByb2Nlc3MudmVyc2lvbnMmJnByb2Nlc3MudmVyc2lvbnMubm9kZSl9KTt2YXIgUGUsaHQsayx4ZSx2ZSxTdCxFdCxPdCxUdCxMZSxJZSxsZT1DKCgpPT57XCJ1c2Ugc3RyaWN0XCI7USgpO1BlPU18fHR5cGVvZiBsb2NhdGlvbj5cInVcIj92b2lkIDA6bG9jYXRpb24ub3JpZ2luLGh0PSgpPT57aWYoIU0pcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC5ub2RlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsUGUpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxrPWh0KCkseGU9KCk9PntpZihrJiYhay5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIGsuc3Vic3RyaW5nKDAsay5sYXN0SW5kZXhPZihcIi9cIikrMSl9LHZlPShlLHQpPT57dHJ5e2xldCBvPXQ/P2s7cmV0dXJuKG8/bmV3IFVSTChlLG8pOm5ldyBVUkwoZSkpLm9yaWdpbj09PVBlfWNhdGNoe3JldHVybiExfX0sU3Q9KGUsdCk9PntsZXQgbz10Pz9rO3RyeXtyZXR1cm4obz9uZXcgVVJMKGUsbyk6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxFdD0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLE90PWFzeW5jIGU9PntsZXQgbz1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG8pfSxUdD1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCxMZT12b2lkIDAsSWU9YXN5bmMoZSx0LG8pPT57aWYoIWUmJiF0JiZMZSYmayYmdmUoaykpcmV0dXJuW3ZvaWQgMCxMZV07e2xldCBzPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5tanNcIixyPWU/P1N0KHMsdCksYT0hTSYmbyYmciYmIXZlKHIsdCksbj1hP2F3YWl0IE90KHIpOnI/P0V0KHMsdCk7cmV0dXJuW2E/bjp2b2lkIDAsYXdhaXQgVHQobildfX19KTt2YXIgZmUsZGUsZWUsX2UsdnQsTHQsQWUsRSx6PUMoKCk9PntcInVzZSBzdHJpY3RcIjtsZSgpO2RlPSExLGVlPSExLF9lPSExLHZ0PSgpPT57aWYodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPlwidVwiKXJldHVybiExO3RyeXtyZXR1cm4gdHlwZW9mIE1lc3NhZ2VDaGFubmVsPFwidVwiJiZuZXcgTWVzc2FnZUNoYW5uZWwoKS5wb3J0MS5wb3N0TWVzc2FnZShuZXcgU2hhcmVkQXJyYXlCdWZmZXIoMSkpLFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCw1LDQsMSwzLDEsMSwxMCwxMSwxLDksMCw2NSwwLDI1NCwxNiwyLDAsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxMdD0oKT0+e3RyeXtyZXR1cm4gV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDEwLDMwLDEsMjgsMCw2NSwwLDI1MywxNSwyNTMsMTIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyNTMsMTg2LDEsMjYsMTFdKSl9Y2F0Y2h7cmV0dXJuITF9fSxBZT1hc3luYyBlPT57aWYoZGUpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO2lmKGVlKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZGV0ZWN0ZWQuXCIpO2lmKF9lKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBmYWlsZWQuXCIpO2VlPSEwO2xldCB0PWUuaW5pdFRpbWVvdXQsbz1lLm51bVRocmVhZHM7aWYoIUx0KCkpdGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgU0lNRCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LlwiKTtsZXQgcz12dCgpO28+MSYmIXMmJih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZCYmY29uc29sZS53YXJuKFwiZW52Lndhc20ubnVtVGhyZWFkcyBpcyBzZXQgdG8gXCIrbytcIiwgYnV0IHRoaXMgd2lsbCBub3Qgd29yayB1bmxlc3MgeW91IGVuYWJsZSBjcm9zc09yaWdpbklzb2xhdGVkIG1vZGUuIFNlZSBodHRwczovL3dlYi5kZXYvY3Jvc3Mtb3JpZ2luLWlzb2xhdGlvbi1ndWlkZS8gZm9yIG1vcmUgaW5mby5cIiksY29uc29sZS53YXJuKFwiV2ViQXNzZW1ibHkgbXVsdGktdGhyZWFkaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuIEZhbGxpbmcgYmFjayB0byBzaW5nbGUtdGhyZWFkaW5nLlwiKSxlLm51bVRocmVhZHM9bz0xKTtsZXQgcj1lLndhc21QYXRocyxhPXR5cGVvZiByPT1cInN0cmluZ1wiP3I6dm9pZCAwLG49cj8ubWpzLGk9bj8uaHJlZj8/bixjPXI/Lndhc20sZj1jPy5ocmVmPz9jLGg9ZS53YXNtQmluYXJ5LFt5LHVdPWF3YWl0IEllKGksYSxvPjEpLGw9ITEseD1bXTtpZih0PjAmJngucHVzaChuZXcgUHJvbWlzZShTPT57c2V0VGltZW91dCgoKT0+e2w9ITAsUygpfSx0KX0pKSx4LnB1c2gobmV3IFByb21pc2UoKFMsbSk9PntsZXQgYj17bnVtVGhyZWFkczpvfTtpZihoKWIud2FzbUJpbmFyeT1oO2Vsc2UgaWYoZnx8YSliLmxvY2F0ZUZpbGU9ZD0+Zj8/YStkO2Vsc2UgaWYoaSYmaS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKWIubG9jYXRlRmlsZT1kPT5uZXcgVVJMKGQsaSkuaHJlZjtlbHNlIGlmKHkpe2xldCBkPXhlKCk7ZCYmKGIubG9jYXRlRmlsZT13PT5kK3cpfXUoYikudGhlbihkPT57ZWU9ITEsZGU9ITAsZmU9ZCxTKCkseSYmVVJMLnJldm9rZU9iamVjdFVSTCh5KX0sZD0+e2VlPSExLF9lPSEwLG0oZCl9KX0pKSxhd2FpdCBQcm9taXNlLnJhY2UoeCksbCl0aHJvdyBuZXcgRXJyb3IoYFdlYkFzc2VtYmx5IGJhY2tlbmQgaW5pdGlhbGl6aW5nIGZhaWxlZCBkdWUgdG8gdGltZW91dDogJHt0fW1zYCl9LEU9KCk9PntpZihkZSYmZmUpcmV0dXJuIGZlO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBPLEosZyx0ZT1DKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eigpO089KGUsdCk9PntsZXQgbz1FKCkscz1vLmxlbmd0aEJ5dGVzVVRGOChlKSsxLHI9by5fbWFsbG9jKHMpO3JldHVybiBvLnN0cmluZ1RvVVRGOChlLHIscyksdC5wdXNoKHIpLHJ9LEo9KGUsdCxvLHMpPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihvLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtvLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbcixhXSk9PntsZXQgbj10P3QrcjpyO2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiKUooYSxuK1wiLlwiLG8scyk7ZWxzZSBpZih0eXBlb2YgYT09XCJzdHJpbmdcInx8dHlwZW9mIGE9PVwibnVtYmVyXCIpcyhuLGEudG9TdHJpbmcoKSk7ZWxzZSBpZih0eXBlb2YgYT09XCJib29sZWFuXCIpcyhuLGE/XCIxXCI6XCIwXCIpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBoYW5kbGUgZXh0cmEgY29uZmlnIHR5cGU6ICR7dHlwZW9mIGF9YCl9KX0sZz1lPT57bGV0IHQ9RSgpLG89dC5zdGFja1NhdmUoKTt0cnl7bGV0IHM9dC5QVFJfU0laRSxyPXQuc3RhY2tBbGxvYygyKnMpO3QuX09ydEdldExhc3RFcnJvcihyLHIrcyk7bGV0IGE9TnVtYmVyKHQuZ2V0VmFsdWUocixzPT09ND9cImkzMlwiOlwiaTY0XCIpKSxuPXQuZ2V0VmFsdWUocitzLFwiKlwiKSxpPW4/dC5VVEY4VG9TdHJpbmcobik6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHthfSwgRVJST1JfTUVTU0FHRTogJHtpfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobyl9fX0pO3ZhciBDZSxVZT1DKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eigpO3RlKCk7Q2U9ZT0+e2xldCB0PUUoKSxvPTAscz1bXSxyPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKXIubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKXIubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoci50ZXJtaW5hdGU9ITEpO2xldCBhPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGE9TyhlLnRhZyxzKSksbz10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKHIubG9nU2V2ZXJpdHlMZXZlbCxyLmxvZ1ZlcmJvc2l0eUxldmVsLCEhci50ZXJtaW5hdGUsYSksbz09PTAmJmcoXCJDYW4ndCBjcmVhdGUgcnVuIG9wdGlvbnMuXCIpLGU/LmV4dHJhIT09dm9pZCAwJiZKKGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwobixpKT0+e2xldCBjPU8obixzKSxmPU8oaSxzKTt0Ll9PcnRBZGRSdW5Db25maWdFbnRyeShvLGMsZikhPT0wJiZnKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke259IC0gJHtpfS5gKX0pLFtvLHNdfWNhdGNoKGEpe3Rocm93IG8hPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhvKSxzLmZvckVhY2gobj0+dC5fZnJlZShuKSksYX19fSk7dmFyIFB0LHh0LEl0LF90LEJlLE1lPUMoKCk9PntcInVzZSBzdHJpY3RcIjt6KCk7dGUoKTtQdD1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSx4dD1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sSXQ9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKG89Pih0eXBlb2Ygbz09XCJzdHJpbmdcIj9vOm8ubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LF90PShlLHQsbyk9Pntmb3IobGV0IHMgb2YgdCl7bGV0IHI9dHlwZW9mIHM9PVwic3RyaW5nXCI/czpzLm5hbWU7c3dpdGNoKHIpe2Nhc2VcIndlYm5uXCI6aWYocj1cIldFQk5OXCIsdHlwZW9mIHMhPVwic3RyaW5nXCIpe2xldCBpPXM/LmRldmljZVR5cGU7aWYoaSl7bGV0IGM9TyhcImRldmljZVR5cGVcIixvKSxmPU8oaSxvKTtFKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGMsZikhPT0wJiZnKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ2RldmljZVR5cGUnIC0gJHtpfS5gKX19YnJlYWs7Y2FzZVwid2ViZ3B1XCI6aWYocj1cIkpTXCIsdHlwZW9mIHMhPVwic3RyaW5nXCIpe2xldCBuPXM7aWYobj8ucHJlZmVycmVkTGF5b3V0KXtpZihuLnByZWZlcnJlZExheW91dCE9PVwiTkNIV1wiJiZuLnByZWZlcnJlZExheW91dCE9PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihgcHJlZmVycmVkTGF5b3V0IG11c3QgYmUgZWl0aGVyICdOQ0hXJyBvciAnTkhXQyc6ICR7bi5wcmVmZXJyZWRMYXlvdXR9YCk7bGV0IGk9TyhcInByZWZlcnJlZExheW91dFwiLG8pLGM9TyhuLnByZWZlcnJlZExheW91dCxvKTtFKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGksYykhPT0wJiZnKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke24ucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtyfWApfWxldCBhPU8ocixvKTtFKCkuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyKGUsYSkhPT0wJiZnKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke3J9LmApfX0sQmU9ZT0+e2xldCB0PUUoKSxvPTAscz1bXSxyPWV8fHt9O0l0KHIpO3RyeXtsZXQgYT1QdChyLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLG49eHQoci5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksaT10eXBlb2Ygci5sb2dJZD09XCJzdHJpbmdcIj9PKHIubG9nSWQscyk6MCxjPXIubG9nU2V2ZXJpdHlMZXZlbD8/MjtpZighTnVtYmVyLmlzSW50ZWdlcihjKXx8YzwwfHxjPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtjfWApO2xldCBmPXIubG9nVmVyYm9zaXR5TGV2ZWw/PzA7aWYoIU51bWJlci5pc0ludGVnZXIoZil8fGY8MHx8Zj40KXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7Zn1gKTtsZXQgaD10eXBlb2Ygci5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoPT1cInN0cmluZ1wiP08oci5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLHMpOjA7aWYobz10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhhLCEhci5lbmFibGVDcHVNZW1BcmVuYSwhIXIuZW5hYmxlTWVtUGF0dGVybixuLCEhci5lbmFibGVQcm9maWxpbmcsMCxpLGMsZixoKSxvPT09MCYmZyhcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHIuZXhlY3V0aW9uUHJvdmlkZXJzJiZfdChvLHIuZXhlY3V0aW9uUHJvdmlkZXJzLHMpLHIuZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygci5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke3IuZW5hYmxlR3JhcGhDYXB0dXJlfWApO2xldCB5PU8oXCJlbmFibGVHcmFwaENhcHR1cmVcIixzKSx1PU8oci5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxzKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobyx5LHUpIT09MCYmZyhgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtyLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCl9aWYoci5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbeSx1XW9mIE9iamVjdC5lbnRyaWVzKHIuZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB5IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3l9YCk7aWYodHlwZW9mIHUhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHUpfHx1PDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7dX1gKTtsZXQgbD1PKHkscyk7dC5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlKG8sbCx1KSE9PTAmJmcoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3l9IC0gJHt1fS5gKX1yZXR1cm4gci5leHRyYSE9PXZvaWQgMCYmSihyLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHksdSk9PntsZXQgbD1PKHkscykseD1PKHUscyk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG8sbCx4KSE9PTAmJmcoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3l9IC0gJHt1fS5gKX0pLFtvLHNdfWNhdGNoKGEpe3Rocm93IG8hPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobykhPT0wJiZnKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLHMuZm9yRWFjaChuPT50Ll9mcmVlKG4pKSxhfX19KTt2YXIgRyxrZSxILERlLFdlLHJlLG5lLEZlLHBlPUMoKCk9PntcInVzZSBzdHJpY3RcIjtHPWU9Pntzd2l0Y2goZSl7Y2FzZVwiaW50OFwiOnJldHVybiAzO2Nhc2VcInVpbnQ4XCI6cmV0dXJuIDI7Y2FzZVwiYm9vbFwiOnJldHVybiA5O2Nhc2VcImludDE2XCI6cmV0dXJuIDU7Y2FzZVwidWludDE2XCI6cmV0dXJuIDQ7Y2FzZVwiaW50MzJcIjpyZXR1cm4gNjtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gMTI7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiAxMDtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIDE7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiAxMTtjYXNlXCJzdHJpbmdcIjpyZXR1cm4gODtjYXNlXCJpbnQ2NFwiOnJldHVybiA3O2Nhc2VcInVpbnQ2NFwiOnJldHVybiAxMztjYXNlXCJpbnQ0XCI6cmV0dXJuIDIyO2Nhc2VcInVpbnQ0XCI6cmV0dXJuIDIxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LGtlPWU9Pntzd2l0Y2goZSl7Y2FzZSAzOnJldHVyblwiaW50OFwiO2Nhc2UgMjpyZXR1cm5cInVpbnQ4XCI7Y2FzZSA5OnJldHVyblwiYm9vbFwiO2Nhc2UgNTpyZXR1cm5cImludDE2XCI7Y2FzZSA0OnJldHVyblwidWludDE2XCI7Y2FzZSA2OnJldHVyblwiaW50MzJcIjtjYXNlIDEyOnJldHVyblwidWludDMyXCI7Y2FzZSAxMDpyZXR1cm5cImZsb2F0MTZcIjtjYXNlIDE6cmV0dXJuXCJmbG9hdDMyXCI7Y2FzZSAxMTpyZXR1cm5cImZsb2F0NjRcIjtjYXNlIDg6cmV0dXJuXCJzdHJpbmdcIjtjYXNlIDc6cmV0dXJuXCJpbnQ2NFwiO2Nhc2UgMTM6cmV0dXJuXCJ1aW50NjRcIjtjYXNlIDIyOnJldHVyblwiaW50NFwiO2Nhc2UgMjE6cmV0dXJuXCJ1aW50NFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZX1gKX19LEg9KGUsdCk9PntsZXQgbz1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLHM9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgocixhKT0+ciphLDEpO3JldHVybiBvPjA/TWF0aC5jZWlsKHMqbyk6dm9pZCAwfSxEZT1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxXZT1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0scmU9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixuZT1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLEZlPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBZLG1lPUMoKCk9PntcInVzZSBzdHJpY3RcIjtRKCk7WT1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoTSl0cnl7bGV0e3JlYWRGaWxlOnR9PWNlKFwibm9kZTpmcy9wcm9taXNlc1wiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdChlKSl9Y2F0Y2godCl7aWYodC5jb2RlPT09XCJFUlJfRlNfRklMRV9UT09fTEFSR0VcIil7bGV0e2NyZWF0ZVJlYWRTdHJlYW06b309Y2UoXCJub2RlOmZzXCIpLHM9byhlKSxyPVtdO2ZvciBhd2FpdChsZXQgYSBvZiBzKXIucHVzaChhKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChyKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IG89dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLHM9bz9wYXJzZUludChvLDEwKTowO2lmKHM8MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgcj10LmJvZHkuZ2V0UmVhZGVyKCksYTt0cnl7YT1uZXcgQXJyYXlCdWZmZXIocyl9Y2F0Y2goaSl7aWYoaSBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBjPU1hdGguY2VpbChzLzY1NTM2KTthPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6YyxtYXhpbXVtOmN9KS5idWZmZXJ9ZWxzZSB0aHJvdyBpfWxldCBuPTA7Zm9yKDs7KXtsZXR7ZG9uZTppLHZhbHVlOmN9PWF3YWl0IHIucmVhZCgpO2lmKGkpYnJlYWs7bGV0IGY9Yy5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KGEsbixmKS5zZXQoYyksbis9Zn1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSwwLHMpfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9fSk7dmFyIEF0LE5lLGplLFYsQ3QsZ2UsJGUsemUsUmUsR2UsSGUsVmU9QygoKT0+e1widXNlIHN0cmljdFwiO1VlKCk7TWUoKTtwZSgpO3ooKTt0ZSgpO21lKCk7QXQ9KGUsdCk9PntFKCkuX09ydEluaXQoZSx0KSE9PTAmJmcoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sTmU9YXN5bmMgZT0+e0F0KGUud2FzbS5udW1UaHJlYWRzLFdlKGUubG9nTGV2ZWwpKX0samU9YXN5bmMoZSx0KT0+e30sVj1uZXcgTWFwLEN0PWU9PntsZXQgdD1FKCksbz10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgcz10LlBUUl9TSVpFLHI9dC5zdGFja0FsbG9jKDIqcyk7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLHIscitzKSE9PTAmJmcoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpO2xldCBuPXM9PT00P1wiaTMyXCI6XCJpNjRcIjtyZXR1cm5bTnVtYmVyKHQuZ2V0VmFsdWUocixuKSksTnVtYmVyKHQuZ2V0VmFsdWUocitzLG4pKV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShvKX19LGdlPWU9PntsZXQgdD1FKCksbz10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihvPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbyksW28sZS5ieXRlTGVuZ3RoXX0sJGU9YXN5bmMoZSx0KT0+e2xldCBvLHMscj1FKCk7QXJyYXkuaXNBcnJheShlKT9bbyxzXT1lOmUuYnVmZmVyPT09ci5IRUFQVTguYnVmZmVyP1tvLHNdPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbbyxzXT1nZShlKTtsZXQgYT0wLG49MCxpPTAsYz1bXSxmPVtdLGg9W107dHJ5e2lmKFtuLGNdPUJlKHQpLHQ/LmV4dGVybmFsRGF0YSYmci5tb3VudEV4dGVybmFsRGF0YSl7bGV0IGQ9W107Zm9yKGxldCB3IG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgdj10eXBlb2Ygdz09XCJzdHJpbmdcIj93OncucGF0aDtkLnB1c2goWSh0eXBlb2Ygdz09XCJzdHJpbmdcIj93OncuZGF0YSkudGhlbihBPT57ci5tb3VudEV4dGVybmFsRGF0YSh2LEEpfSkpfWF3YWl0IFByb21pc2UuYWxsKGQpfWZvcihsZXQgZCBvZiB0Py5leGVjdXRpb25Qcm92aWRlcnM/P1tdKWlmKCh0eXBlb2YgZD09XCJzdHJpbmdcIj9kOmQubmFtZSk9PT1cIndlYm5uXCIpe2lmKHIuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSExLHR5cGVvZiBkIT1cInN0cmluZ1wiKXtsZXQgdj1kLEE9dj8uY29udGV4dCxEPXY/LmdwdURldmljZSxXPXY/LmRldmljZVR5cGUsWD12Py5wb3dlclByZWZlcmVuY2U7QT9yLmN1cnJlbnRDb250ZXh0PUE6RD9yLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dChEKTpyLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dCh7ZGV2aWNlVHlwZTpXLHBvd2VyUHJlZmVyZW5jZTpYfSl9ZWxzZSByLmN1cnJlbnRDb250ZXh0PWF3YWl0IHIuanNlcENyZWF0ZU1MQ29udGV4dCgpO2JyZWFrfWE9YXdhaXQgci5fT3J0Q3JlYXRlU2Vzc2lvbihvLHMsbiksYT09PTAmJmcoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKSxyLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpLHIuY3VycmVudENvbnRleHQmJihyLmpzZXBSZWdpc3Rlck1MQ29udGV4dChhLHIuY3VycmVudENvbnRleHQpLHIuY3VycmVudENvbnRleHQ9dm9pZCAwLHIuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSEwKTtsZXRbeSx1XT1DdChhKSxsPSEhdD8uZW5hYmxlR3JhcGhDYXB0dXJlLHg9W10sUz1bXSxtPVtdO2ZvcihsZXQgZD0wO2Q8eTtkKyspe2xldCB3PXIuX09ydEdldElucHV0TmFtZShhLGQpO3c9PT0wJiZnKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLGYucHVzaCh3KSx4LnB1c2goci5VVEY4VG9TdHJpbmcodykpfWZvcihsZXQgZD0wO2Q8dTtkKyspe2xldCB3PXIuX09ydEdldE91dHB1dE5hbWUoYSxkKTt3PT09MCYmZyhcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksaC5wdXNoKHcpO2xldCB2PXIuVVRGOFRvU3RyaW5nKHcpO1MucHVzaCh2KX1yZXR1cm4gVi5zZXQoYSxbYSxmLGgsbnVsbCxsLCExXSksW2EseCxTXX1jYXRjaCh5KXt0aHJvdyBmLmZvckVhY2godT0+ci5fT3J0RnJlZSh1KSksaC5mb3JFYWNoKHU9PnIuX09ydEZyZWUodSkpLGkhPT0wJiZyLl9PcnRSZWxlYXNlQmluZGluZyhpKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGEhPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbihhKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLHl9ZmluYWxseXtyLl9mcmVlKG8pLG4hPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobikhPT0wJiZnKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLGMuZm9yRWFjaCh5PT5yLl9mcmVlKHkpKSxyLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0semU9ZT0+e2xldCB0PUUoKSxvPVYuZ2V0KGUpO2lmKCFvKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W3MscixhLG4saV09bztuJiYoaSYmdC5fT3J0Q2xlYXJCb3VuZE91dHB1dHMobi5oYW5kbGUpIT09MCYmZyhcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHQuX09ydFJlbGVhc2VCaW5kaW5nKG4uaGFuZGxlKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksci5mb3JFYWNoKGM9PnQuX09ydEZyZWUoYykpLGEuZm9yRWFjaChjPT50Ll9PcnRGcmVlKGMpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihzKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLFYuZGVsZXRlKGUpfSxSZT1hc3luYyhlLHQsbyxzLHIsYT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgbj1FKCksaT1uLlBUUl9TSVpFLGM9ZVswXSxmPWVbMV0saD1lWzNdLHk9aCx1LGw7aWYoYz09PVwic3RyaW5nXCImJihoPT09XCJncHUtYnVmZmVyXCJ8fGg9PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihhJiZoIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7cn0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihoPT09XCJncHUtYnVmZmVyXCIpe2xldCBtPWVbMl0uZ3B1QnVmZmVyO2w9SChHKGMpLGYpO2xldCBiPW4uanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCFiKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7dT1iKHMscixtLGwpfWVsc2UgaWYoaD09PVwibWwtdGVuc29yXCIpe2xldCBtPWVbMl0ubWxUZW5zb3I7bD1IKEcoYyksZik7bGV0IGI9bi5qc2VwUmVnaXN0ZXJNTFRlbnNvcjtpZighYil0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTt1PWIocyxtLEcoYyksZil9ZWxzZXtsZXQgbT1lWzJdO2lmKEFycmF5LmlzQXJyYXkobSkpe2w9aSptLmxlbmd0aCx1PW4uX21hbGxvYyhsKSxvLnB1c2godSk7Zm9yKGxldCBiPTA7YjxtLmxlbmd0aDtiKyspe2lmKHR5cGVvZiBtW2JdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7Yn0gaXMgbm90IGEgc3RyaW5nYCk7bi5zZXRWYWx1ZSh1K2IqaSxPKG1bYl0sbyksXCIqXCIpfX1lbHNle2xldCBiPW4uanNlcElzR3JhcGhJbnB1dDtpZihjIT09XCJzdHJpbmdcIiYmYil7bGV0IGQ9bi5fT3J0R2V0SW5wdXROYW1lKHMsciksdz1uLlVURjhUb1N0cmluZyhkKTtpZihiKHMsdykpe2xldCB2PUcoYyk7bD1IKHYsZikseT1cIm1sLXRlbnNvclwiO2xldCBBPW4uanNlcENyZWF0ZVRlbXBvcmFyeVRlbnNvcixEPW4uanNlcFVwbG9hZFRlbnNvcjtpZighQXx8IUQpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7bGV0IFc9YXdhaXQgQShzLHYsZik7RChXLG5ldyBVaW50OEFycmF5KG0uYnVmZmVyLG0uYnl0ZU9mZnNldCxtLmJ5dGVMZW5ndGgpKSx1PVd9ZWxzZSBsPW0uYnl0ZUxlbmd0aCx1PW4uX21hbGxvYyhsKSxvLnB1c2godSksbi5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KG0uYnVmZmVyLG0uYnl0ZU9mZnNldCxsKSx1KX1lbHNlIGw9bS5ieXRlTGVuZ3RoLHU9bi5fbWFsbG9jKGwpLG8ucHVzaCh1KSxuLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkobS5idWZmZXIsbS5ieXRlT2Zmc2V0LGwpLHUpfX1sZXQgeD1uLnN0YWNrU2F2ZSgpLFM9bi5zdGFja0FsbG9jKDQqZi5sZW5ndGgpO3RyeXtmLmZvckVhY2goKGIsZCk9Pm4uc2V0VmFsdWUoUytkKmksYixpPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgbT1uLl9PcnRDcmVhdGVUZW5zb3IoRyhjKSx1LGwsUyxmLmxlbmd0aCxGZSh5KSk7bT09PTAmJmcoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3N9LCBpbmRleD0ke3J9LmApLHQucHVzaChtKX1maW5hbGx5e24uc3RhY2tSZXN0b3JlKHgpfX0sR2U9YXN5bmMoZSx0LG8scyxyLGEpPT57bGV0IG49RSgpLGk9bi5QVFJfU0laRSxjPVYuZ2V0KGUpO2lmKCFjKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldCBmPWNbMF0saD1jWzFdLHk9Y1syXSx1PWNbM10sbD1jWzRdLHg9Y1s1XSxTPXQubGVuZ3RoLG09cy5sZW5ndGgsYj0wLGQ9W10sdz1bXSx2PVtdLEE9W10sRD1uLnN0YWNrU2F2ZSgpLFc9bi5zdGFja0FsbG9jKFMqaSksWD1uLnN0YWNrQWxsb2MoUyppKSxhZT1uLnN0YWNrQWxsb2MobSppKSxTZT1uLnN0YWNrQWxsb2MobSppKTt0cnl7W2IsZF09Q2UoYSk7Zm9yKGxldCBwPTA7cDxTO3ArKylhd2FpdCBSZShvW3BdLHcsQSxlLHRbcF0sbCk7Zm9yKGxldCBwPTA7cDxtO3ArKylhd2FpdCBSZShyW3BdLHYsQSxlLFMrc1twXSxsKTtmb3IobGV0IHA9MDtwPFM7cCsrKW4uc2V0VmFsdWUoVytwKmksd1twXSxcIipcIiksbi5zZXRWYWx1ZShYK3AqaSxoW3RbcF1dLFwiKlwiKTtmb3IobGV0IHA9MDtwPG07cCsrKW4uc2V0VmFsdWUoYWUrcCppLHZbcF0sXCIqXCIpLG4uc2V0VmFsdWUoU2UrcCppLHlbc1twXV0sXCIqXCIpO24uanNlcE9uUnVuU3RhcnQ/LihmKTtsZXQgVTtVPWF3YWl0IG4uX09ydFJ1bihmLFgsVyxTLFNlLG0sYWUsYiksVSE9PTAmJmcoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IGo9W107Zm9yKGxldCBwPTA7cDxtO3ArKyl7bGV0ICQ9TnVtYmVyKG4uZ2V0VmFsdWUoYWUrcCppLFwiKlwiKSk7aWYoJD09PXZbcF0pe2oucHVzaChyW3BdKTtjb250aW51ZX1sZXQgRWU9bi5zdGFja1NhdmUoKSxCPW4uc3RhY2tBbGxvYyg0KmkpLHE9ITEsTCxJPTA7dHJ5e24uX09ydEdldFRlbnNvckRhdGEoJCxCLEIraSxCKzIqaSxCKzMqaSkhPT0wJiZnKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7cH0uYCk7bGV0IGllPWk9PT00P1wiaTMyXCI6XCJpNjRcIixaPU51bWJlcihuLmdldFZhbHVlKEIsaWUpKTtJPW4uZ2V0VmFsdWUoQitpLFwiKlwiKTtsZXQgT2U9bi5nZXRWYWx1ZShCK2kqMixcIipcIiksbHQ9TnVtYmVyKG4uZ2V0VmFsdWUoQitpKjMsaWUpKSxGPVtdO2ZvcihsZXQgUD0wO1A8bHQ7UCsrKUYucHVzaChOdW1iZXIobi5nZXRWYWx1ZShPZStQKmksaWUpKSk7bi5fT3J0RnJlZShPZSkhPT0wJiZnKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtsZXQgUj1GLnJlZHVjZSgoUCxUKT0+UCpULDEpO0w9a2UoWik7bGV0IEs9dT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW3NbcF1dO2lmKEw9PT1cInN0cmluZ1wiKXtpZihLPT09XCJncHUtYnVmZmVyXCJ8fEs9PT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCBQPVtdO2ZvcihsZXQgVD0wO1Q8UjtUKyspe2xldCBOPW4uZ2V0VmFsdWUoSStUKmksXCIqXCIpLGZ0PW4uZ2V0VmFsdWUoSSsoVCsxKSppLFwiKlwiKSxkdD1UPT09Ui0xP3ZvaWQgMDpmdC1OO1AucHVzaChuLlVURjhUb1N0cmluZyhOLGR0KSl9ai5wdXNoKFtMLEYsUCxcImNwdVwiXSl9ZWxzZSBpZihLPT09XCJncHUtYnVmZmVyXCImJlI+MCl7bGV0IFA9bi5qc2VwR2V0QnVmZmVyO2lmKCFQKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtsZXQgVD1QKEkpLE49SChaLFIpO2lmKE49PT12b2lkIDB8fCFyZShMKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtMfWApO3E9ITAsai5wdXNoKFtMLEYse2dwdUJ1ZmZlcjpULGRvd25sb2FkOm4uanNlcENyZWF0ZURvd25sb2FkZXIoVCxOLEwpLGRpc3Bvc2U6KCk9PntuLl9PcnRSZWxlYXNlVGVuc29yKCQpIT09MCYmZyhcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZSBpZihLPT09XCJtbC10ZW5zb3JcIiYmUj4wKXtsZXQgUD1uLmpzZXBFbnN1cmVUZW5zb3I7aWYoIVApdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZihIKFosUik9PT12b2lkIDB8fCFuZShMKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtMfWApO2xldCBOPWF3YWl0IFAoZSxJLFosRiwhMSk7cT0hMCxqLnB1c2goW0wsRix7bWxUZW5zb3I6Tixkb3dubG9hZDpuLmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIoSSxMKSxkaXNwb3NlOigpPT57bi5qc2VwUmVsZWFzZVRlbnNvcklkKEkpLG4uX09ydFJlbGVhc2VUZW5zb3IoJCl9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgUD1EZShMKSxUPW5ldyBQKFIpO25ldyBVaW50OEFycmF5KFQuYnVmZmVyLFQuYnl0ZU9mZnNldCxULmJ5dGVMZW5ndGgpLnNldChuLkhFQVBVOC5zdWJhcnJheShJLEkrVC5ieXRlTGVuZ3RoKSksai5wdXNoKFtMLEYsVCxcImNwdVwiXSl9fWZpbmFsbHl7bi5zdGFja1Jlc3RvcmUoRWUpLEw9PT1cInN0cmluZ1wiJiZJJiZuLl9mcmVlKEkpLHF8fG4uX09ydFJlbGVhc2VUZW5zb3IoJCksbi5qc2VwT25SdW5FbmQ/LihmKX19cmV0dXJuIHUmJiFsJiYobi5fT3J0Q2xlYXJCb3VuZE91dHB1dHModS5oYW5kbGUpIT09MCYmZyhcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLFYuc2V0KGUsW2YsaCx5LHUsbCwhMV0pKSxqfWZpbmFsbHl7bi5zdGFja1Jlc3RvcmUoRCksdy5mb3JFYWNoKFU9Pm4uX09ydFJlbGVhc2VUZW5zb3IoVSkpLHYuZm9yRWFjaChVPT5uLl9PcnRSZWxlYXNlVGVuc29yKFUpKSxBLmZvckVhY2goVT0+bi5fZnJlZShVKSksYiE9PTAmJm4uX09ydFJlbGVhc2VSdW5PcHRpb25zKGIpLGQuZm9yRWFjaChVPT5uLl9mcmVlKFUpKX19LEhlPWU9PntsZXQgdD1FKCksbz1WLmdldChlKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IHM9b1swXSxyPXQuX09ydEVuZFByb2ZpbGluZyhzKTtyPT09MCYmZyhcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShyKX19KTtpbXBvcnR7ZW52IGFzIHllfWZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO3ZhciBiZSxxZSxKZSxZZSxYZSxaZSxLZSxRZSxldCx0dCx3ZT1DKCgpPT57XCJ1c2Ugc3RyaWN0XCI7VmUoKTt6KCk7bGUoKTtiZT0hMSxxZT0hMSxKZT0hMSxZZT1hc3luYygpPT57aWYoIXFlKXtpZihiZSl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKEplKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7YmU9ITA7dHJ5e2F3YWl0IEFlKHllLndhc20pLGF3YWl0IE5lKHllKSxxZT0hMH1jYXRjaChlKXt0aHJvdyBKZT0hMCxlfWZpbmFsbHl7YmU9ITF9fX0sWGU9YXN5bmMgZT0+e2F3YWl0IGplKHllLGUpfSxaZT1hc3luYyBlPT5nZShlKSxLZT1hc3luYyhlLHQpPT4kZShlLHQpLFFlPWFzeW5jIGU9Pnt6ZShlKX0sZXQ9YXN5bmMoZSx0LG8scyxyLGEpPT5HZShlLHQsbyxzLHIsYSksdHQ9YXN5bmMgZT0+e0hlKGUpfX0pO2ltcG9ydHtUZW5zb3IgYXMgaGUsVFJBQ0VfRlVOQ19CRUdJTiBhcyBydCxUUkFDRV9GVU5DX0VORCBhcyBudH1mcm9tXCJvbm54cnVudGltZS1jb21tb25cIjt2YXIgb3QsQnQsb2Usc3Q9QygoKT0+e1widXNlIHN0cmljdFwiO3dlKCk7cGUoKTtRKCk7bWUoKTtvdD0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bZS50eXBlLGUuZGltcyxlLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHtncHVCdWZmZXI6ZS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7bWxUZW5zb3I6ZS5tbFRlbnNvcn0sXCJtbC10ZW5zb3JcIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlLmxvY2F0aW9ufSBmb3IgJHt0KCl9YCl9fSxCdD1lPT57c3dpdGNoKGVbM10pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgaGUoZVswXSxlWzJdLGVbMV0pO2Nhc2VcImdwdS1idWZmZXJcIjp7bGV0IHQ9ZVswXTtpZighcmUodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7bGV0e2dwdUJ1ZmZlcjpvLGRvd25sb2FkOnMsZGlzcG9zZTpyfT1lWzJdO3JldHVybiBoZS5mcm9tR3B1QnVmZmVyKG8se2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOnMsZGlzcG9zZTpyfSl9Y2FzZVwibWwtdGVuc29yXCI6e2xldCB0PWVbMF07aWYoIW5lKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7bGV0e21sVGVuc29yOm8sZG93bmxvYWQ6cyxkaXNwb3NlOnJ9PWVbMl07cmV0dXJuIGhlLmZyb21NTFRlbnNvcihvLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpzLGRpc3Bvc2U6cn0pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LG9lPWNsYXNze2FzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpe3JldHVybiBaZShhd2FpdCBZKHQpKX1hc3luYyBsb2FkTW9kZWwodCxvKXtydCgpO2xldCBzO3R5cGVvZiB0PT1cInN0cmluZ1wiP00/cz1hd2FpdCBZKHQpOnM9YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTpzPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBLZShzLG8pLG50KCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBRZSh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQsbyxzKXtydCgpO2xldCByPVtdLGE9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCh1PT57bGV0IGw9dVswXSx4PXVbMV0sUz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihsKTtpZihTPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke2x9J2ApO3IucHVzaCh4KSxhLnB1c2goUyl9KTtsZXQgbj1bXSxpPVtdO09iamVjdC5lbnRyaWVzKG8pLmZvckVhY2godT0+e2xldCBsPXVbMF0seD11WzFdLFM9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKGwpO2lmKFM9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke2x9J2ApO24ucHVzaCh4KSxpLnB1c2goUyl9KTtsZXQgYz1yLm1hcCgodSxsKT0+b3QodSwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbYVtsXV19XCJgKSksZj1uLm1hcCgodSxsKT0+dT9vdCh1LCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2lbbF1dfVwiYCk6bnVsbCksaD1hd2FpdCBldCh0aGlzLnNlc3Npb25JZCxhLGMsaSxmLHMpLHk9e307Zm9yKGxldCB1PTA7dTxoLmxlbmd0aDt1KyspeVt0aGlzLm91dHB1dE5hbWVzW2lbdV1dXT1uW3VdPz9CdChoW3VdKTtyZXR1cm4gbnQoKSx5fXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe3R0KHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIGl0PXt9O2J0KGl0LHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZDooKT0+c2UsaW5pdGlhbGl6ZUZsYWdzOigpPT5hdCx3YXNtQmFja2VuZDooKT0+TXR9KTtpbXBvcnR7ZW52IGFzIF99ZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7dmFyIGF0LHNlLE10LHV0PUMoKCk9PntcInVzZSBzdHJpY3RcIjt3ZSgpO3N0KCk7YXQ9KCk9PntpZigodHlwZW9mIF8ud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8Xy53YXNtLmluaXRUaW1lb3V0PDApJiYoXy53YXNtLmluaXRUaW1lb3V0PTApLF8ud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIF8ud2FzbS5wcm94eSE9XCJib29sZWFuXCImJihfLndhc20ucHJveHk9ITEpLHR5cGVvZiBfLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYoXy53YXNtLnRyYWNlPSExKSx0eXBlb2YgXy53YXNtLm51bVRocmVhZHMhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKF8ud2FzbS5udW1UaHJlYWRzKXx8Xy53YXNtLm51bVRocmVhZHM8PTApaWYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpXy53YXNtLm51bVRocmVhZHM9MTtlbHNle2xldCBlPXR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCI/Y2UoXCJub2RlOm9zXCIpLmNwdXMoKS5sZW5ndGg6bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7Xy53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LHNlPWNsYXNze2FzeW5jIGluaXQodCl7YXQoKSxhd2FpdCBZZSgpLGF3YWl0IFhlKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQsbyl7bGV0IHM9bmV3IG9lO3JldHVybiBhd2FpdCBzLmxvYWRNb2RlbCh0LG8pLFByb21pc2UucmVzb2x2ZShzKX19LE10PW5ldyBzZX0pO2V4cG9ydCpmcm9tXCJvbm54cnVudGltZS1jb21tb25cIjtpbXBvcnQqYXMga3QgZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7aW1wb3J0e3JlZ2lzdGVyQmFja2VuZCBhcyBjdCxlbnYgYXMgRHR9ZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7dmFyIFRlPVwiMS4yMS4wXCI7dmFyIENyPWt0O3tsZXQgZT0odXQoKSx3dChpdCkpLndhc21CYWNrZW5kO2N0KFwiY3B1XCIsZSwxMCksY3QoXCJ3YXNtXCIsZSwxMCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KER0LnZlcnNpb25zLFwid2ViXCIse3ZhbHVlOlRlLGVudW1lcmFibGU6ITB9KTtleHBvcnR7Q3IgYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQubm9kZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?8254\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?ee8e":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.node.min.b11d01ed.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?18ac":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.69d1be4b.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?f243":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Of),\n/* harmony export */   TRACE: () => (/* binding */ vr),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ne),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ Be),\n/* harmony export */   Tensor: () => (/* binding */ qe),\n/* harmony export */   \"default\": () => (/* binding */ lT),\n/* harmony export */   env: () => (/* binding */ we),\n/* harmony export */   registerBackend: () => (/* binding */ Ct)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Un=Object.defineProperty;var Af=Object.getOwnPropertyDescriptor;var kf=Object.getOwnPropertyNames;var Ef=Object.prototype.hasOwnProperty;var Nn=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,n)=>(typeof require<\"u\"?require:t)[n]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var G=(e,t)=>()=>(e&&(t=e(e=0)),t);var Zt=(e,t)=>{for(var n in t)Un(e,n,{get:t[n],enumerable:!0})},Pf=(e,t,n,r)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of kf(t))!Ef.call(e,o)&&o!==n&&Un(e,o,{get:()=>t[o],enumerable:!(r=Af(t,o))||r.enumerable});return e};var br=e=>Pf(Un({},\"__esModule\",{value:!0}),e);var _r,Tt,Ct,zf,Wa,Vn=G(()=>{\"use strict\";_r=new Map,Tt=[],Ct=(e,t,n)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let r=_r.get(e);if(r===void 0)_r.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${n}`)}if(n>=0){let o=Tt.indexOf(e);o!==-1&&Tt.splice(o,1);for(let a=0;a<Tt.length;a++)if(_r.get(Tt[a]).priority<=n){Tt.splice(a,0,e);return}Tt.push(e)}return}throw new TypeError(\"not a valid backend\")},zf=async e=>{let t=_r.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Wa=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l==\"string\"?l:l.name),r=n.length===0?Tt:n,o,a=[],s=new Set;for(let l of r){let p=await zf(l);typeof p==\"string\"?a.push({name:l,err:p}):(o||(o=p),o===p&&s.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${a.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of a)n.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>s.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var La=G(()=>{\"use strict\";Vn()});var Ga,Ha=G(()=>{\"use strict\";Ga=\"1.21.0\"});var Fa,Ue,Wn=G(()=>{\"use strict\";Ha();Fa=\"warning\",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:Ga},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fa=e}},get logLevel(){return Fa}};Object.defineProperty(Ue,\"logLevel\",{enumerable:!0})});var we,qa=G(()=>{\"use strict\";Wn();we=Ue});var Ka,ja,Za=G(()=>{\"use strict\";Ka=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext(\"2d\");if(r!=null){let o,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[3]):(o=e.dims[3],a=e.dims[2]);let s=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let f=a*o,h=0,y=f,_=f*2,b=-1;s===\"RGBA\"?(h=0,y=f,_=f*2,b=f*3):s===\"RGB\"?(h=0,y=f,_=f*2):s===\"RBG\"&&(h=0,_=f,y=f*2);for(let w=0;w<a;w++)for(let S=0;S<o;S++){let $=(e.data[h++]-p[0])*l[0],v=(e.data[y++]-p[1])*l[1],T=(e.data[_++]-p[2])*l[2],C=b===-1?255:(e.data[b++]-p[3])*l[3];r.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+T+\",\"+C+\")\",r.fillRect(S,w,1,1)}if(\"toDataURL\"in n)return n.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},ja=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),r;if(n!=null){let o,a,s;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[1],s=e.dims[3]):(o=e.dims[3],a=e.dims[2],s=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,f;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?f=[0,0,0,0]:typeof l.bias==\"number\"?f=[l.bias,l.bias,l.bias,l.bias]:(f=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(f[3]=l.bias[3]));let h=a*o;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!==\"RGBA\"||s===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let y=4,_=0,b=1,w=2,S=3,$=0,v=h,T=h*2,C=-1;d===\"RGBA\"?($=0,v=h,T=h*2,C=h*3):d===\"RGB\"?($=0,v=h,T=h*2):d===\"RBG\"&&($=0,T=h,v=h*2),r=n.createImageData(o,a);for(let A=0;A<a*o;_+=y,b+=y,w+=y,S+=y,A++)r.data[_]=(e.data[$++]-f[0])*p[0],r.data[b]=(e.data[v++]-f[1])*p[1],r.data[w]=(e.data[T++]-f[2])*p[2],r.data[S]=C===-1?255:(e.data[C++]-f[3])*p[3]}else throw new Error(\"Can not access image data\");return r}});var Ln,Qa,Ya,Xa,Ja,es,ts=G(()=>{\"use strict\";wr();Ln=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:n,width:r}=t,o=t.norm??{mean:255,bias:0},a,s;typeof o.mean==\"number\"?a=[o.mean,o.mean,o.mean,o.mean]:a=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=n*r,f=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),h=4,y=0,_=1,b=2,w=3,S=0,$=p,v=p*2,T=-1;d===\"RGB\"&&(h=3,y=0,_=1,b=2,w=-1),l===\"RGBA\"?T=p*3:l===\"RBG\"?(S=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,S=p*2);for(let A=0;A<p;A++,y+=h,b+=h,_+=h,w+=h)f[S++]=(e[y]+s[0])/a[0],f[$++]=(e[_]+s[1])/a[1],f[v++]=(e[b]+s[2])/a[2],T!==-1&&w!==-1&&(f[T++]=(e[w]+s[3])/a[3]);return l===\"RGBA\"?new De(\"float32\",f,[1,4,n,r]):new De(\"float32\",f,[1,3,n,r])},Qa=async(e,t)=>{let n=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,r=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,a=typeof e==\"string\",s,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=f=>typeof HTMLCanvasElement<\"u\"&&f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext(\"2d\"):null;if(n){let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(y=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=y,d.width=_}else d.tensorFormat=\"RGBA\",d.height=y,d.width=_;h.drawImage(e,0,0),s=h.getImageData(0,0,_,y).data}else throw new Error(\"Can not access image data\")}else if(r){let f,h;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(f=t.resizedHeight,h=t.resizedWidth):(f=e.height,h=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=f,d.width=h,t!==void 0){let y=l();y.width=h,y.height=f;let _=p(y);if(_!=null)_.putImageData(e,0,0),s=_.getImageData(0,0,h,f).data;else throw new Error(\"Can not access image data\")}else s=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;return h.drawImage(e,0,0,_,y),s=h.getImageData(0,0,_,y).data,d.height=y,d.width=_,Ln(s,d)}else throw new Error(\"Can not access image data\")}else{if(a)return new Promise((f,h)=>{let y=l(),_=p(y);if(!e||!_)return h();let b=new Image;b.crossOrigin=\"Anonymous\",b.src=e,b.onload=()=>{y.width=b.width,y.height=b.height,_.drawImage(b,0,0,y.width,y.height);let w=_.getImageData(0,0,y.width,y.height);d.height=y.height,d.width=y.width,f(Ln(w.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(s!==void 0)return Ln(s,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},Ya=(e,t)=>{let{width:n,height:r,download:o,dispose:a}=t,s=[1,r,n,4];return new De({location:\"texture\",type:\"float32\",texture:e,dims:s,download:o,dispose:a})},Xa=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"gpu-buffer\",type:n??\"float32\",gpuBuffer:e,dims:r,download:o,dispose:a})},Ja=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"ml-tensor\",type:n??\"float32\",mlTensor:e,dims:r,download:o,dispose:a})},es=(e,t,n)=>new De({location:\"cpu-pinned\",type:e,data:t,dims:n??[t.length]})});var It,Qt,rs,ns,os=G(()=>{\"use strict\";It=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),Qt=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),rs=!1,ns=()=>{if(!rs){rs=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<\"u\"&&n.from;e&&(It.set(\"int64\",BigInt64Array),Qt.set(BigInt64Array,\"int64\")),t&&(It.set(\"uint64\",BigUint64Array),Qt.set(BigUint64Array,\"uint64\")),r?(It.set(\"float16\",n),Qt.set(n,\"float16\")):It.set(\"float16\",Uint16Array)}}});var is,as,ss=G(()=>{\"use strict\";wr();is=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!=\"number\"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},as=(e,t)=>{switch(e.location){case\"cpu\":return new De(e.type,e.data,t);case\"cpu-pinned\":return new De({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new De({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new De({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new De({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var De,wr=G(()=>{\"use strict\";Za();ts();os();ss();De=class{constructor(t,n,r){ns();let o,a;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,a=t.dims,t.location){case\"cpu-pinned\":{let d=It.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=r,t===\"string\"){if(!Array.isArray(n))throw new TypeError(\"A string tensor's data must be a string array.\");d=n}else{let p=It.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(n,BigInt):d=p.from(n)}else if(n instanceof p)d=n;else if(n instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(n);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else if(t===\"float16\"&&n instanceof Uint16Array&&p!==Uint16Array)d=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=n,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=Qt.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");a=l,this.cpuData=d,this.dataLocation=\"cpu\"}let s=is(a);if(this.cpuData&&s!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=a,this.size=s}static async fromImage(t,n){return Qa(t,n)}static fromTexture(t,n){return Ya(t,n)}static fromGpuBuffer(t,n){return Xa(t,n)}static fromMLTensor(t,n){return Ja(t,n)}static fromPinnedBuffer(t,n,r){return es(t,n,r)}toDataURL(t){return Ka(this,t)}toImageData(t){return ja(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return as(this,t)}}});var qe,Gn=G(()=>{\"use strict\";wr();qe=De});var vr,us,Ne,Be,Hn=G(()=>{\"use strict\";Wn();vr=(e,t)=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},us=(e,t)=>{let n=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let o=0;o<n.length;o++){if(r&&!n[o].includes(\"TRACE_FUNC\")){let a=`FUNC_${e}::${n[o].trim().split(\" \")[1]}`;t&&(a+=`::${t}`),vr(\"CPU\",a);return}n[o].includes(\"TRACE_FUNC\")&&(r=!0)}},Ne=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"BEGIN\",e)},Be=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"END\",e)}});var $r,ds=G(()=>{\"use strict\";Vn();Gn();Hn();$r=class e{constructor(t){this.handler=t}async run(t,n,r){Ne();let o={},a={};if(typeof t!=\"object\"||t===null||t instanceof qe||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let s=!0;if(typeof n==\"object\"){if(n===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(n instanceof qe)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(n)){if(n.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");s=!1;for(let p of n){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,f=Object.getOwnPropertyNames(n);for(let h of this.outputNames)if(f.indexOf(h)!==-1){let y=n[h];(y===null||y instanceof qe)&&(p=!0,s=!1,o[h]=y)}if(p){if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else a=n}}else if(typeof n<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(s)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,a),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let f=d[p];f instanceof qe?l[p]=f:l[p]=new qe(f.type,f.data,f.dims)}return Be(),l}async release(){return this.handler.dispose()}static async create(t,n,r,o){Ne();let a,s={};if(typeof t==\"string\"){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let f=t,h=0,y=t.byteLength;if(typeof n==\"object\"&&n!==null)s=n;else if(typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteOffset' must be an integer.\");if(h<0||h>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(y=t.byteLength-h,typeof r==\"number\"){if(y=r,!Number.isSafeInteger(y))throw new RangeError(\"'byteLength' must be an integer.\");if(y<=0||h+y>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-h}].`);if(typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof r<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\");a=new Uint8Array(f,h,y)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Wa(s),p=await d.createInferenceSessionHandler(a,l);return Be(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Of,ls=G(()=>{\"use strict\";ds();Of=$r});var cs=G(()=>{\"use strict\"});var ps=G(()=>{\"use strict\"});var ms=G(()=>{\"use strict\"});var fs=G(()=>{\"use strict\"});var Fn={};Zt(Fn,{InferenceSession:()=>Of,TRACE:()=>vr,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>Be,Tensor:()=>qe,env:()=>we,registerBackend:()=>Ct});var Ge=G(()=>{\"use strict\";La();qa();ls();Gn();cs();ps();Hn();ms();fs()});var xr=G(()=>{\"use strict\"});var bs={};Zt(bs,{default:()=>Df});var gs,ys,Df,_s=G(()=>{\"use strict\";qn();bt();Sr();gs=\"ort-wasm-proxy-worker\",ys=globalThis.self?.name===gs;ys&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case\"init-wasm\":Tr(n.wasm).then(()=>{Cr(n).then(()=>{postMessage({type:t})},r=>{postMessage({type:t,err:r})})},r=>{postMessage({type:t,err:r})});break;case\"init-ep\":{let{epName:r,env:o}=n;Ir(o,r).then(()=>{postMessage({type:t})},a=>{postMessage({type:t,err:a})});break}case\"copy-from\":{let{buffer:r}=n,o=Yt(r);postMessage({type:t,out:o});break}case\"create\":{let{model:r,options:o}=n;Ar(r,o).then(a=>{postMessage({type:t,out:a})},a=>{postMessage({type:t,err:a})});break}case\"release\":kr(n),postMessage({type:t});break;case\"run\":{let{sessionId:r,inputIndices:o,inputs:a,outputIndices:s,options:d}=n;Er(r,o,a,s,new Array(s.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},zr([...a,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":Pr(n),postMessage({type:t});break;default:}}catch(r){postMessage({type:t,err:r})}});Df=ys?null:e=>new Worker(e??Ve,{type:\"module\",name:gs})});var vs={};Zt(vs,{default:()=>Bf});var Kn,ws,Bf,Mf,$s=G(()=>{\"use strict\";ws=(Kn=\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\",async function(e={}){var t,n,r=e,o=new Promise((i,u)=>{t=i,n=u}),a=typeof window==\"object\",s=typeof WorkerGlobalScope<\"u\",d=s&&self.name?.startsWith(\"em-pthread\");r.mountExternalData=(i,u)=>{i.startsWith(\"./\")&&(i=i.substring(2)),(r.Bd||(r.Bd=new Map)).set(i,u)},r.unmountExternalData=()=>{delete r.Bd};var l=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let p=()=>{let i=(c,m,g)=>(...x)=>{let I=Je,z=m?.();x=c(...x);let B=m?.();return z!==B&&(c=B,g(z),m=g=null),Je!=I?new Promise((L,q)=>{En={resolve:L,reject:q}}):x},u=c=>async(...m)=>{try{if(r.Cd)throw Error(\"Session already started\");let g=r.Cd={be:m[0],errors:[]},x=await c(...m);if(r.Cd!==g)throw Error(\"Session mismatch\");r.Dd?.flush();let I=g.errors;if(0<I.length){let z=await Promise.all(I);if(z=z.filter(B=>B),0<z.length)throw Error(z.join(`\n`))}return x}finally{r.Cd=null}};r._OrtCreateSession=i(r._OrtCreateSession,()=>r._OrtCreateSession,c=>r._OrtCreateSession=c),r._OrtRun=u(i(r._OrtRun,()=>r._OrtRun,c=>r._OrtRun=c)),r._OrtRunWithBinding=u(i(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,c=>r._OrtRunWithBinding=c)),r._OrtBindInput=i(r._OrtBindInput,()=>r._OrtBindInput,c=>r._OrtBindInput=c),p=void 0};r.jsepInit=(i,u)=>{if(p?.(),i===\"webgpu\"){[r.Dd,r.Rd,r.Vd,r.Hd,r.Ud,r.hc,r.Wd,r.Zd,r.Sd,r.Td,r.Xd]=u;let c=r.Dd;r.jsepRegisterBuffer=(m,g,x,I)=>c.registerBuffer(m,g,x,I),r.jsepGetBuffer=m=>c.getBuffer(m),r.jsepCreateDownloader=(m,g,x)=>c.createDownloader(m,g,x),r.jsepOnCreateSession=m=>{c.onCreateSession(m)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepOnRunStart=m=>c.onRunStart(m),r.$d=(m,g)=>{c.upload(m,g)}}else if(i===\"webnn\"){[r.Dd,r.Yd,r.Id,r.jsepEnsureTensor,r.Jd,r.jsepDownloadTensor]=u,r.jsepReleaseTensorId=r.Id,r.jsepUploadTensor=r.Jd;let c=r.Dd;r.jsepOnRunStart=m=>c.onRunStart(m),r.jsepOnRunEnd=c.onRunEnd.bind(c),r.jsepRegisterMLContext=(m,g)=>{c.registerMLContext(m,g)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepCreateMLTensorDownloader=(m,g)=>c.createMLTensorDownloader(m,g),r.jsepRegisterMLTensor=(m,g,x,I)=>c.registerMLTensor(m,g,x,I),r.jsepCreateMLContext=m=>c.createMLContext(m),r.jsepRegisterMLConstant=(m,g,x,I,z)=>c.registerMLConstant(m,g,x,I,z,r.Bd),r.jsepRegisterGraphInput=c.registerGraphInput.bind(c),r.jsepIsGraphInput=c.isGraphInput.bind(c),r.jsepCreateTemporaryTensor=c.createTemporaryTensor.bind(c)}};var f,h,y=Object.assign({},r),_=(i,u)=>{throw u},b=\"\";(a||s)&&(s?b=self.location.href:typeof document<\"u\"&&document.currentScript&&(b=document.currentScript.src),Kn&&(b=Kn),b=b.startsWith(\"blob:\")?\"\":b.slice(0,b.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),s&&(h=i=>{var u=new XMLHttpRequest;return u.open(\"GET\",i,!1),u.responseType=\"arraybuffer\",u.send(null),new Uint8Array(u.response)}),f=async i=>{if(le(i))return new Promise((c,m)=>{var g=new XMLHttpRequest;g.open(\"GET\",i,!0),g.responseType=\"arraybuffer\",g.onload=()=>{g.status==200||g.status==0&&g.response?c(g.response):m(g.status)},g.onerror=m,g.send(null)});var u=await fetch(i,{credentials:\"same-origin\"});if(u.ok)return u.arrayBuffer();throw Error(u.status+\" : \"+u.url)});var w=console.log.bind(console),S=console.error.bind(console),$=w,v=S;Object.assign(r,y),y=null;var T,C,A,k,O,M,V,F,j,ne,W,J,ve,Q=r.wasmBinary,ee=!1,le=i=>i.startsWith(\"file://\");function Z(){return T.buffer!=k.buffer&&be(),k}function pe(){return T.buffer!=k.buffer&&be(),O}function ke(){return T.buffer!=k.buffer&&be(),M}function Se(){return T.buffer!=k.buffer&&be(),V}function D(){return T.buffer!=k.buffer&&be(),F}function R(){return T.buffer!=k.buffer&&be(),j}function Y(){return T.buffer!=k.buffer&&be(),ne}function fe(){return T.buffer!=k.buffer&&be(),ve}if(d){let i=function(u){try{var c=u.data,m=c.yd;if(m===\"load\"){let g=[];self.onmessage=x=>g.push(x),self.startWorker=()=>{postMessage({yd:\"loaded\"});for(let x of g)i(x);self.onmessage=i};for(let x of c.Od)r[x]&&!r[x].proxy||(r[x]=(...I)=>{postMessage({yd:\"callHandler\",Nd:x,args:I})},x==\"print\"&&($=r[x]),x==\"printErr\"&&(v=r[x]));T=c.he,be(),Fe(c.ie)}else if(m===\"run\"){cp(c.xd),Dn(c.xd,0,0,1,0,0),Lo(),An(c.xd),xe||(Mi(),xe=!0);try{pp(c.de,c.Fd)}catch(g){if(g!=\"unwind\")throw g}}else c.target!==\"setimmediate\"&&(m===\"checkMailbox\"?xe&&ur():m&&(v(`worker: received unknown command ${m}`),v(c)))}catch(g){throw Ri(),g}};var ub=i,Fe,xe=!1;v=function(...u){u=u.join(\" \"),console.error(u)},self.alert=function(...u){postMessage({yd:\"alert\",text:u.join(\" \"),fe:gr()})},self.onunhandledrejection=u=>{throw u.reason||u},self.onmessage=i}function be(){var i=T.buffer;r.HEAP8=k=new Int8Array(i),r.HEAP16=M=new Int16Array(i),r.HEAPU8=O=new Uint8Array(i),r.HEAPU16=V=new Uint16Array(i),r.HEAP32=F=new Int32Array(i),r.HEAPU32=j=new Uint32Array(i),r.HEAPF32=ne=new Float32Array(i),r.HEAPF64=ve=new Float64Array(i),r.HEAP64=W=new BigInt64Array(i),r.HEAPU64=J=new BigUint64Array(i)}function Ye(){d?startWorker(r):U.Bb()}d||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),be());var Gt,xt=0,Ht=null;function Bo(){if(--xt==0&&Ht){var i=Ht;Ht=null,i()}}function ut(i){throw v(i=\"Aborted(\"+i+\")\"),ee=!0,i=new WebAssembly.RuntimeError(i+\". Build with -sASSERTIONS for more info.\"),n(i),i}function Mo(){return{a:{Ta:lp,Va:dp,W:mp,la:fp,b:gp,u:yp,R:bp,Za:_p,d:wp,pb:qo,g:hp,T:Zo,Ga:Qo,lb:Xo,nb:Jo,Ha:ei,Ea:ti,wb:ri,Da:ni,pa:oi,mb:ii,jb:ai,Fa:si,kb:ui,Ma:vp,za:xp,eb:Sp,cb:Cp,ya:Ap,V:kp,N:Ep,db:Pp,ma:Up,fb:Np,zb:Vp,hb:Wp,qb:Lp,ab:Gp,Aa:Hp,yb:An,Ja:Fp,S:qp,Wa:Kp,$:Qp,G:Yp,E:Jp,m:Tn,H:em,B:nm,X:om,J:im,v:am,O:sm,D:um,t:dm,A:lm,z:cm,w:pm,r:mm,tb:fm,ub:hm,vb:gm,rb:$i,sb:xi,bb:Si,Oa:bm,La:vm,y:$m,ja:xm,Ba:Sm,Ka:_m,qa:Tm,Ia:Cm,ib:Im,U:ym,fa:Am,Sa:km,gb:Em,Qa:Pm,Pa:zm,Ab:Ai,Ca:ki,ob:_n,aa:Ei,oa:Pi,xb:zi,na:Oi,$a:af,ia:_f,sa:Sf,ga:nf,da:pf,ua:$f,p:tf,e:Nm,c:Rm,ea:lf,f:Vm,n:Lm,k:Ym,Y:Hm,ka:Xm,j:rf,wa:df,Ra:If,ca:yf,Ua:Cf,P:cf,K:qm,_:gf,Q:of,Z:wf,x:Fm,l:Um,va:hf,i:Mm,h:Gm,ra:Tf,ta:xf,o:Wm,q:Km,s:Zm,I:Qm,C:ef,L:Jm,xa:uf,_a:sf,F:bf,Ya:mf,ba:vf,M:jm,Xa:ff,ha:Dm,a:T,Na:bn}}}var hn={1319426:()=>typeof wasmOffsetConverter<\"u\",1319483:(i,u,c,m,g)=>{if(r===void 0||!r.Bd)return 1;if((i=Ae(Number(i>>>0))).startsWith(\"./\")&&(i=i.substring(2)),!(i=r.Bd.get(i)))return 2;if(u=Number(u>>>0),c=Number(c>>>0),m=Number(m>>>0),u+c>i.byteLength)return 3;try{let x=i.subarray(u,u+c);switch(g){case 0:pe().set(x,m>>>0);break;case 1:r.$d(m,x);break;default:return 4}return 0}catch{return 4}},1320198:(i,u,c)=>{r.Jd(i,pe().subarray(u>>>0,u+c>>>0))},1320261:()=>r.Yd(),1320302:i=>{r.Id(i)},1320338:()=>{r.Sd()},1320369:()=>{r.Td()},1320398:()=>{r.Xd()},1320423:i=>r.Rd(i),1320456:i=>r.Vd(i),1320488:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c),!0)},1320551:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c))},1320608:i=>{r.hc(\"Abs\",i,void 0)},1320659:i=>{r.hc(\"Neg\",i,void 0)},1320710:i=>{r.hc(\"Floor\",i,void 0)},1320763:i=>{r.hc(\"Ceil\",i,void 0)},1320815:i=>{r.hc(\"Reciprocal\",i,void 0)},1320873:i=>{r.hc(\"Sqrt\",i,void 0)},1320925:i=>{r.hc(\"Exp\",i,void 0)},1320976:i=>{r.hc(\"Erf\",i,void 0)},1321027:i=>{r.hc(\"Sigmoid\",i,void 0)},1321082:(i,u,c)=>{r.hc(\"HardSigmoid\",i,{alpha:u,beta:c})},1321161:i=>{r.hc(\"Log\",i,void 0)},1321212:i=>{r.hc(\"Sin\",i,void 0)},1321263:i=>{r.hc(\"Cos\",i,void 0)},1321314:i=>{r.hc(\"Tan\",i,void 0)},1321365:i=>{r.hc(\"Asin\",i,void 0)},1321417:i=>{r.hc(\"Acos\",i,void 0)},1321469:i=>{r.hc(\"Atan\",i,void 0)},1321521:i=>{r.hc(\"Sinh\",i,void 0)},1321573:i=>{r.hc(\"Cosh\",i,void 0)},1321625:i=>{r.hc(\"Asinh\",i,void 0)},1321678:i=>{r.hc(\"Acosh\",i,void 0)},1321731:i=>{r.hc(\"Atanh\",i,void 0)},1321784:i=>{r.hc(\"Tanh\",i,void 0)},1321836:i=>{r.hc(\"Not\",i,void 0)},1321887:(i,u,c)=>{r.hc(\"Clip\",i,{min:u,max:c})},1321956:i=>{r.hc(\"Clip\",i,void 0)},1322008:(i,u)=>{r.hc(\"Elu\",i,{alpha:u})},1322066:i=>{r.hc(\"Gelu\",i,void 0)},1322118:i=>{r.hc(\"Relu\",i,void 0)},1322170:(i,u)=>{r.hc(\"LeakyRelu\",i,{alpha:u})},1322234:(i,u)=>{r.hc(\"ThresholdedRelu\",i,{alpha:u})},1322304:(i,u)=>{r.hc(\"Cast\",i,{to:u})},1322362:i=>{r.hc(\"Add\",i,void 0)},1322413:i=>{r.hc(\"Sub\",i,void 0)},1322464:i=>{r.hc(\"Mul\",i,void 0)},1322515:i=>{r.hc(\"Div\",i,void 0)},1322566:i=>{r.hc(\"Pow\",i,void 0)},1322617:i=>{r.hc(\"Equal\",i,void 0)},1322670:i=>{r.hc(\"Greater\",i,void 0)},1322725:i=>{r.hc(\"GreaterOrEqual\",i,void 0)},1322787:i=>{r.hc(\"Less\",i,void 0)},1322839:i=>{r.hc(\"LessOrEqual\",i,void 0)},1322898:(i,u,c,m,g)=>{r.hc(\"ReduceMean\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323073:(i,u,c,m,g)=>{r.hc(\"ReduceMax\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323247:(i,u,c,m,g)=>{r.hc(\"ReduceMin\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323421:(i,u,c,m,g)=>{r.hc(\"ReduceProd\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323596:(i,u,c,m,g)=>{r.hc(\"ReduceSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323770:(i,u,c,m,g)=>{r.hc(\"ReduceL1\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323943:(i,u,c,m,g)=>{r.hc(\"ReduceL2\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324116:(i,u,c,m,g)=>{r.hc(\"ReduceLogSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324293:(i,u,c,m,g)=>{r.hc(\"ReduceSumSquare\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324473:(i,u,c,m,g)=>{r.hc(\"ReduceLogSumExp\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324653:i=>{r.hc(\"Where\",i,void 0)},1324706:(i,u,c)=>{r.hc(\"Transpose\",i,{perm:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[]})},1324830:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1324963:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1325096:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1325529:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1326190:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1326623:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1327284:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327375:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1327854:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327945:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328424:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1328511:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328986:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1329073:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1329548:(i,u,c,m,g)=>{r.hc(\"Gemm\",i,{alpha:u,beta:c,transA:m,transB:g})},1329652:i=>{r.hc(\"MatMul\",i,void 0)},1329706:(i,u,c,m)=>{r.hc(\"ArgMax\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329814:(i,u,c,m)=>{r.hc(\"ArgMin\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329922:(i,u)=>{r.hc(\"Softmax\",i,{axis:u})},1329985:(i,u)=>{r.hc(\"Concat\",i,{axis:u})},1330045:(i,u,c,m,g)=>{r.hc(\"Split\",i,{axis:u,numOutputs:c,splitSizes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1330201:i=>{r.hc(\"Expand\",i,void 0)},1330255:(i,u)=>{r.hc(\"Gather\",i,{axis:Number(u)})},1330326:(i,u)=>{r.hc(\"GatherElements\",i,{axis:Number(u)})},1330405:(i,u)=>{r.hc(\"GatherND\",i,{batch_dims:Number(u)})},1330484:(i,u,c,m,g,x,I,z,B,L,q)=>{r.hc(\"Resize\",i,{antialias:u,axes:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],coordinateTransformMode:Ae(g),cubicCoeffA:x,excludeOutside:I,extrapolationValue:z,keepAspectRatioPolicy:Ae(B),mode:Ae(L),nearestMode:Ae(q)})},1330846:(i,u,c,m,g,x,I)=>{r.hc(\"Slice\",i,{starts:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[],ends:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[],axes:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[]})},1331110:i=>{r.hc(\"Tile\",i,void 0)},1331162:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331276:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331390:i=>{r.hc(\"Range\",i,void 0)},1331443:(i,u)=>{r.hc(\"Einsum\",i,{equation:Ae(u)})},1331524:(i,u,c,m,g)=>{r.hc(\"Pad\",i,{mode:u,value:c,pads:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1331667:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1331836:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1332005:(i,u,c)=>{r.hc(\"CumSum\",i,{exclusive:Number(u),reverse:Number(c)})},1332102:(i,u,c)=>{r.hc(\"DequantizeLinear\",i,{axis:u,blockSize:c})},1332192:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332362:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332532:(i,u)=>{r.hc(\"ScatterND\",i,{reduction:Ae(u)})},1332617:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"Attention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x,qkvHiddenSizes:I?Array.from(D().subarray(Number(z)>>>0,Number(z)+I>>>0)):[],pastPresentShareBuffer:!!B})},1332889:i=>{r.hc(\"BiasAdd\",i,void 0)},1332944:i=>{r.hc(\"BiasSplitGelu\",i,void 0)},1333005:i=>{r.hc(\"FastGelu\",i,void 0)},1333061:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le,jt)=>{r.hc(\"Conv\",i,{format:X?\"NHWC\":\"NCHW\",auto_pad:u,dilations:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],group:g,kernel_shape:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],pads:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],strides:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],w_is_const:()=>!!Z()[Number(ue)>>>0],activation:Ae($e),activation_params:Le?Array.from(Y().subarray(Number(Le)>>>0,Number(jt)>>>0)):[]})},1333645:i=>{r.hc(\"Gelu\",i,void 0)},1333697:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"GroupQueryAttention\",i,{numHeads:u,kvNumHeads:c,scale:m,softcap:g,doRotary:x,rotaryInterleaved:I,smoothSoftmax:z,localWindowSize:B})},1333914:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334025:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334136:(i,u,c,m,g,x)=>{r.hc(\"MatMulNBits\",i,{k:u,n:c,accuracyLevel:m,bits:g,blockSize:x})},1334263:(i,u,c,m,g,x)=>{r.hc(\"MultiHeadAttention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x})},1334422:(i,u)=>{r.hc(\"QuickGelu\",i,{alpha:u})},1334486:(i,u,c,m,g)=>{r.hc(\"RotaryEmbedding\",i,{interleaved:!!u,numHeads:c,rotaryEmbeddingDim:m,scale:g})},1334625:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334727:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334829:(i,u,c,m)=>{r.hc(\"GatherBlockQuantized\",i,{gatherAxis:u,quantizeAxis:c,blockSize:m})},1334950:i=>{r.Wd(i)},1334984:(i,u)=>r.Zd(Number(i),Number(u),r.Cd.be,r.Cd.errors)};function dp(i,u,c){return gi(async()=>{await r.Ud(Number(i),Number(u),Number(c))})}function lp(){return typeof wasmOffsetConverter<\"u\"}class gn{name=\"ExitStatus\";constructor(u){this.message=`Program terminated with exit(${u})`,this.status=u}}var Ro=i=>{i.terminate(),i.onmessage=()=>{}},yn=[],Uo=i=>{ft.length==0&&(Ho(),Go(ft[0]));var u=ft.pop();if(!u)return 6;Ft.push(u),St[i.xd]=u,u.xd=i.xd;var c={yd:\"run\",de:i.ce,Fd:i.Fd,xd:i.xd};return u.postMessage(c,i.Ld),0},mt=0,Te=(i,u,...c)=>{for(var m=2*c.length,g=ie(),x=Mn(8*m),I=x>>>3,z=0;z<c.length;z++){var B=c[z];typeof B==\"bigint\"?(W[I+2*z]=1n,W[I+2*z+1]=B):(W[I+2*z]=0n,fe()[I+2*z+1>>>0]=B)}return i=Ui(i,0,m,x,u),oe(g),i};function bn(i){if(d)return Te(0,1,i);if(A=i,!(0<mt)){for(var u of Ft)Ro(u);for(u of ft)Ro(u);ft=[],Ft=[],St={},ee=!0}_(0,new gn(i))}function No(i){if(d)return Te(1,0,i);_n(i)}var _n=i=>{if(A=i,d)throw No(i),\"unwind\";bn(i)},ft=[],Ft=[],Vo=[],St={},Wo=i=>{var u=i.xd;delete St[u],ft.push(i),Ft.splice(Ft.indexOf(i),1),i.xd=0,Ni(u)};function Lo(){Vo.forEach(i=>i())}var Go=i=>new Promise(u=>{i.onmessage=g=>{var x=(g=g.data).yd;if(g.Ed&&g.Ed!=gr()){var I=St[g.Ed];I?I.postMessage(g,g.Ld):v(`Internal error! Worker sent a message \"${x}\" to target pthread ${g.Ed}, but that thread no longer exists!`)}else x===\"checkMailbox\"?ur():x===\"spawnThread\"?Uo(g):x===\"cleanupThread\"?Wo(St[g.ee]):x===\"loaded\"?(i.loaded=!0,u(i)):x===\"alert\"?alert(`Thread ${g.fe}: ${g.text}`):g.target===\"setimmediate\"?i.postMessage(g):x===\"callHandler\"?r[g.Nd](...g.args):x&&v(`worker sent an unknown command ${x}`)},i.onerror=g=>{throw v(`worker sent an error! ${g.filename}:${g.lineno}: ${g.message}`),g};var c,m=[];for(c of[])r.propertyIsEnumerable(c)&&m.push(c);i.postMessage({yd:\"load\",Od:m,he:T,ie:C})});function Ho(){var i=new Worker(\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\")?/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?18ac\")):new URL(\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});ft.push(i)}var cp=i=>{be();var u=R()[i+52>>>2>>>0];i=R()[i+56>>>2>>>0],Li(u,u-i),oe(u)},pp=(i,u)=>{mt=0,i=Rn(i,u),0<mt?A=i:Bn(i)},sr=[];function mp(i){var u=new wn(i>>>=0);if(Z()[u.wd+12>>>0]==0){var c=1;Z()[u.wd+12>>>0]=c}return c=0,Z()[u.wd+13>>>0]=c,sr.push(u),Hi(i),qi(i)}var Dt=0,fp=()=>{se(0,0);var i=sr.pop();Gi(i.Gd),Dt=0};class wn{constructor(u){this.Gd=u,this.wd=u-24}}function hp(i){throw Dt||=i>>>0,Dt}var vn=i=>{var u=Dt;if(!u)return Kt(0),0;var c=new wn(u);R()[c.wd+16>>>2>>>0]=u;var m=R()[c.wd+4>>>2>>>0];if(!m)return Kt(0),u;for(var g of i){if(g===0||g===m)break;if(Fi(g,m,c.wd+16))return Kt(g),u}return Kt(m),u};function gp(){return vn([])}function yp(i){return vn([i>>>0])}function bp(i,u){return vn([i>>>0,u>>>0])}var _p=()=>{var i=sr.pop();i||ut(\"no exception to throw\");var u=i.Gd;if(Z()[i.wd+13>>>0]==0){sr.push(i);var c=1;Z()[i.wd+13>>>0]=c,c=0,Z()[i.wd+12>>>0]=c}throw Dt=u};function wp(i,u,c){var m=new wn(i>>>=0);throw u>>>=0,c>>>=0,R()[m.wd+16>>>2>>>0]=0,R()[m.wd+4>>>2>>>0]=u,R()[m.wd+8>>>2>>>0]=c,Dt=i}function Fo(i,u,c,m){return d?Te(2,1,i,u,c,m):qo(i,u,c,m)}function qo(i,u,c,m){if(i>>>=0,c>>>=0,m>>>=0,l===void 0)return 6;var g=[];return d&&g.length===0?Fo(i,u>>>=0,c,m):(i={ce:c,xd:i,Fd:m,Ld:g},d?(i.yd=\"spawnThread\",postMessage(i,g),0):Uo(i))}var Ko=typeof TextDecoder<\"u\"?new TextDecoder:void 0,jo=(i,u=0,c=NaN)=>{var m=(u>>>=0)+c;for(c=u;i[c]&&!(c>=m);)++c;if(16<c-u&&i.buffer&&Ko)return Ko.decode(i.buffer instanceof ArrayBuffer?i.subarray(u,c):i.slice(u,c));for(m=\"\";u<c;){var g=i[u++];if(128&g){var x=63&i[u++];if((224&g)==192)m+=String.fromCharCode((31&g)<<6|x);else{var I=63&i[u++];65536>(g=(240&g)==224?(15&g)<<12|x<<6|I:(7&g)<<18|x<<12|I<<6|63&i[u++])?m+=String.fromCharCode(g):(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g))}}else m+=String.fromCharCode(g)}return m},Ae=(i,u)=>(i>>>=0)?jo(pe(),i,u):\"\";function Zo(i,u,c){return d?Te(3,1,i,u,c):0}function Qo(i,u){if(d)return Te(4,1,i,u)}var Yo=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);127>=m?u++:2047>=m?u+=2:55296<=m&&57343>=m?(u+=4,++c):u+=3}return u},Bt=(i,u,c)=>{var m=pe();if(u>>>=0,0<c){var g=u;c=u+c-1;for(var x=0;x<i.length;++x){var I=i.charCodeAt(x);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&i.charCodeAt(++x)),127>=I){if(u>=c)break;m[u++>>>0]=I}else{if(2047>=I){if(u+1>=c)break;m[u++>>>0]=192|I>>6}else{if(65535>=I){if(u+2>=c)break;m[u++>>>0]=224|I>>12}else{if(u+3>=c)break;m[u++>>>0]=240|I>>18,m[u++>>>0]=128|I>>12&63}m[u++>>>0]=128|I>>6&63}m[u++>>>0]=128|63&I}}m[u>>>0]=0,i=u-g}else i=0;return i};function Xo(i,u){if(d)return Te(5,1,i,u)}function Jo(i,u,c){if(d)return Te(6,1,i,u,c)}function ei(i,u,c){return d?Te(7,1,i,u,c):0}function ti(i,u){if(d)return Te(8,1,i,u)}function ri(i,u,c){if(d)return Te(9,1,i,u,c)}function ni(i,u,c,m){if(d)return Te(10,1,i,u,c,m)}function oi(i,u,c,m){if(d)return Te(11,1,i,u,c,m)}function ii(i,u,c,m){if(d)return Te(12,1,i,u,c,m)}function ai(i){if(d)return Te(13,1,i)}function si(i,u){if(d)return Te(14,1,i,u)}function ui(i,u,c){if(d)return Te(15,1,i,u,c)}var di,ht,vp=()=>ut(\"\"),Xe=i=>{for(var u=\"\";pe()[i>>>0];)u+=di[pe()[i++>>>0]];return u},$n={},xn={},$p={};function dt(i,u,c={}){return function(m,g,x={}){var I=g.name;if(!m)throw new ht(`type \"${I}\" must have a positive integer typeid pointer`);if(xn.hasOwnProperty(m)){if(x.Pd)return;throw new ht(`Cannot register type '${I}' twice`)}xn[m]=g,delete $p[m],$n.hasOwnProperty(m)&&(g=$n[m],delete $n[m],g.forEach(z=>z()))}(i,u,c)}var li=(i,u,c)=>{switch(u){case 1:return c?m=>Z()[m>>>0]:m=>pe()[m>>>0];case 2:return c?m=>ke()[m>>>1>>>0]:m=>Se()[m>>>1>>>0];case 4:return c?m=>D()[m>>>2>>>0]:m=>R()[m>>>2>>>0];case 8:return c?m=>W[m>>>3]:m=>J[m>>>3];default:throw new TypeError(`invalid integer width (${u}): ${i}`)}};function xp(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:function(m,g){if(typeof g!=\"bigint\"&&typeof g!=\"number\")throw g=g===null?\"null\":(m=typeof g)==\"object\"||m===\"array\"||m===\"function\"?g.toString():\"\"+g,new TypeError(`Cannot convert \"${g}\" to ${this.name}`);return typeof g==\"number\"&&(g=BigInt(g)),g},zd:gt,readValueFromPointer:li(u,c,u.indexOf(\"u\")==-1),Ad:null})}var gt=8;function Sp(i,u,c,m){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(g){return!!g},toWireType:function(g,x){return x?c:m},zd:gt,readValueFromPointer:function(g){return this.fromWireType(pe()[g>>>0])},Ad:null})}var Sn=[],lt=[];function Tn(i){9<(i>>>=0)&&--lt[i+1]==0&&(lt[i]=void 0,Sn.push(i))}var Re=i=>{if(!i)throw new ht(\"Cannot use deleted val. handle = \"+i);return lt[i]},We=i=>{switch(i){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let u=Sn.pop()||lt.length;return lt[u]=i,lt[u+1]=1,u}};function Cn(i){return this.fromWireType(R()[i>>>2>>>0])}var Tp={name:\"emscripten::val\",fromWireType:i=>{var u=Re(i);return Tn(i),u},toWireType:(i,u)=>We(u),zd:gt,readValueFromPointer:Cn,Ad:null};function Cp(i){return dt(i>>>0,Tp)}var Ip=(i,u)=>{switch(u){case 4:return function(c){return this.fromWireType(Y()[c>>>2>>>0])};case 8:return function(c){return this.fromWireType(fe()[c>>>3>>>0])};default:throw new TypeError(`invalid float width (${u}): ${i}`)}};function Ap(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:(m,g)=>g,zd:gt,readValueFromPointer:Ip(u,c),Ad:null})}function kp(i,u,c,m,g){if(i>>>=0,c>>>=0,u=Xe(u>>>0),g===-1&&(g=4294967295),g=z=>z,m===0){var x=32-8*c;g=z=>z<<x>>>x}var I=u.includes(\"unsigned\")?function(z,B){return B>>>0}:function(z,B){return B};dt(i,{name:u,fromWireType:g,toWireType:I,zd:gt,readValueFromPointer:li(u,c,m!==0),Ad:null})}function Ep(i,u,c){function m(x){var I=R()[x>>>2>>>0];return x=R()[x+4>>>2>>>0],new g(Z().buffer,x,I)}var g=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][u];dt(i>>>=0,{name:c=Xe(c>>>0),fromWireType:m,zd:gt,readValueFromPointer:m},{Pd:!0})}function Pp(i,u){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(c){for(var m,g=R()[c>>>2>>>0],x=c+4,I=x,z=0;z<=g;++z){var B=x+z;z!=g&&pe()[B>>>0]!=0||(I=Ae(I,B-I),m===void 0?m=I:(m+=\"\\0\",m+=I),I=B+1)}return et(c),m},toWireType:function(c,m){m instanceof ArrayBuffer&&(m=new Uint8Array(m));var g=typeof m==\"string\";if(!(g||m instanceof Uint8Array||m instanceof Uint8ClampedArray||m instanceof Int8Array))throw new ht(\"Cannot pass non-string to std::string\");var x=g?Yo(m):m.length,I=yr(4+x+1),z=I+4;if(R()[I>>>2>>>0]=x,g)Bt(m,z,x+1);else if(g)for(g=0;g<x;++g){var B=m.charCodeAt(g);if(255<B)throw et(I),new ht(\"String has UTF-16 code units that do not fit in 8 bits\");pe()[z+g>>>0]=B}else for(g=0;g<x;++g)pe()[z+g>>>0]=m[g];return c!==null&&c.push(et,I),I},zd:gt,readValueFromPointer:Cn,Ad(c){et(c)}})}var ci=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,zp=(i,u)=>{for(var c=i>>1,m=c+u/2;!(c>=m)&&Se()[c>>>0];)++c;if(32<(c<<=1)-i&&ci)return ci.decode(pe().slice(i,c));for(c=\"\",m=0;!(m>=u/2);++m){var g=ke()[i+2*m>>>1>>>0];if(g==0)break;c+=String.fromCharCode(g)}return c},Op=(i,u,c)=>{if(c??=2147483647,2>c)return 0;var m=u;c=(c-=2)<2*i.length?c/2:i.length;for(var g=0;g<c;++g){var x=i.charCodeAt(g);ke()[u>>>1>>>0]=x,u+=2}return ke()[u>>>1>>>0]=0,u-m},Dp=i=>2*i.length,Bp=(i,u)=>{for(var c=0,m=\"\";!(c>=u/4);){var g=D()[i+4*c>>>2>>>0];if(g==0)break;++c,65536<=g?(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g)):m+=String.fromCharCode(g)}return m},Mp=(i,u,c)=>{if(u>>>=0,c??=2147483647,4>c)return 0;var m=u;c=m+c-4;for(var g=0;g<i.length;++g){var x=i.charCodeAt(g);if(55296<=x&&57343>=x&&(x=65536+((1023&x)<<10)|1023&i.charCodeAt(++g)),D()[u>>>2>>>0]=x,(u+=4)+4>c)break}return D()[u>>>2>>>0]=0,u-m},Rp=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);55296<=m&&57343>=m&&++c,u+=4}return u};function Up(i,u,c){if(i>>>=0,u>>>=0,c=Xe(c>>>=0),u===2)var m=zp,g=Op,x=Dp,I=z=>Se()[z>>>1>>>0];else u===4&&(m=Bp,g=Mp,x=Rp,I=z=>R()[z>>>2>>>0]);dt(i,{name:c,fromWireType:z=>{for(var B,L=R()[z>>>2>>>0],q=z+4,X=0;X<=L;++X){var ue=z+4+X*u;X!=L&&I(ue)!=0||(q=m(q,ue-q),B===void 0?B=q:(B+=\"\\0\",B+=q),q=ue+u)}return et(z),B},toWireType:(z,B)=>{if(typeof B!=\"string\")throw new ht(`Cannot pass non-string to C++ string type ${c}`);var L=x(B),q=yr(4+L+u);return R()[q>>>2>>>0]=L/u,g(B,q+4,L+u),z!==null&&z.push(et,q),q},zd:gt,readValueFromPointer:Cn,Ad(z){et(z)}})}function Np(i,u){dt(i>>>=0,{Qd:!0,name:u=Xe(u>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function Vp(i){Dn(i>>>0,!s,1,!a,131072,!1),Lo()}var In=i=>{if(!ee)try{if(i(),!(0<mt))try{d?Bn(A):_n(A)}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}};function An(i){i>>>=0,typeof Atomics.ge==\"function\"&&(Atomics.ge(D(),i>>>2,i).value.then(ur),i+=128,Atomics.store(D(),i>>>2,1))}var ur=()=>{var i=gr();i&&(An(i),In(Wi))};function Wp(i,u){(i>>>=0)==u>>>0?setTimeout(ur):d?postMessage({Ed:i,yd:\"checkMailbox\"}):(i=St[i])&&i.postMessage({yd:\"checkMailbox\"})}var kn=[];function Lp(i,u,c,m,g){for(u>>>=0,m/=2,kn.length=m,c=g>>>0>>>3,g=0;g<m;g++)kn[g]=W[c+2*g]?W[c+2*g+1]:fe()[c+2*g+1>>>0];return(u?hn[u]:Bm[i])(...kn)}var Gp=()=>{mt=0};function Hp(i){i>>>=0,d?postMessage({yd:\"cleanupThread\",ee:i}):Wo(St[i])}function Fp(i){}var dr=(i,u)=>{var c=xn[i];if(c===void 0)throw i=Bi(i),c=Xe(i),et(i),new ht(`${u} has unknown type ${c}`);return c},pi=(i,u,c)=>{var m=[];return i=i.toWireType(m,c),m.length&&(R()[u>>>2>>>0]=We(m)),i};function qp(i,u,c){return u>>>=0,c>>>=0,i=Re(i>>>0),u=dr(u,\"emval::as\"),pi(u,c,i)}function Kp(i,u){return u>>>=0,i=Re(i>>>0),(u=dr(u,\"emval::as\")).toWireType(null,i)}var lr=i=>{try{i()}catch(u){ut(u)}},yt=0,Je=null,mi=0,cr=[],fi={},hi={},jp=0,En=null,Zp=[];function gi(i){return function(u){if(!ee){if(yt===0){var c=!1,m=!1;u((g=0)=>{if(!ee&&(mi=g,c=!0,m)){yt=2,lr(()=>Na(Je)),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.resume(),g=!1;try{var x=function(){var B=D()[Je+8>>>2>>>0];return B=U[hi[B]],--mt,B()}()}catch(B){x=B,g=!0}var I=!1;if(!Je){var z=En;z&&(En=null,(g?z.reject:z.resolve)(x),I=!0)}if(g&&!I)throw x}}),m=!0,c||(yt=1,Je=function(){var g=yr(65548),x=g+12;R()[g>>>2>>>0]=x,R()[g+4>>>2>>>0]=x+65536,x=cr[0];var I=fi[x];return I===void 0&&(I=jp++,fi[x]=I,hi[I]=x),x=I,D()[g+8>>>2>>>0]=x,g}(),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.pause(),lr(()=>Ra(Je)))}else yt===2?(yt=0,lr(Va),et(Je),Je=null,Zp.forEach(In)):ut(`invalid state: ${yt}`);return mi}}(u=>{i().then(u)})}function Qp(i){return i>>>=0,gi(async()=>{var u=await Re(i);return We(u)})}var pr=[];function Yp(i,u,c,m){return c>>>=0,m>>>=0,(i=pr[i>>>0])(null,u=Re(u>>>0),c,m)}var Xp={},mr=i=>{var u=Xp[i];return u===void 0?Xe(i):u};function Jp(i,u,c,m,g){return c>>>=0,m>>>=0,g>>>=0,(i=pr[i>>>0])(u=Re(u>>>0),u[c=mr(c)],m,g)}var yi=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function em(i){return(i>>>=0)==0?We(yi()):(i=mr(i),We(yi()[i]))}var tm=i=>{var u=pr.length;return pr.push(i),u},rm=(i,u)=>{for(var c=Array(i),m=0;m<i;++m)c[m]=dr(R()[u+4*m>>>2>>>0],\"parameter \"+m);return c},bi=(i,u)=>Object.defineProperty(u,\"name\",{value:i});function nm(i,u,c){var m=(u=rm(i,u>>>0)).shift();i--;var g=`return function (obj, func, destructorsRef, args) {\n`,x=0,I=[];c===0&&I.push(\"obj\");for(var z=[\"retType\"],B=[m],L=0;L<i;++L)I.push(\"arg\"+L),z.push(\"argType\"+L),B.push(u[L]),g+=`  var arg${L} = argType${L}.readValueFromPointer(args${x?\"+\"+x:\"\"});\n`,x+=u[L].zd;return g+=`  var rv = ${c===1?\"new func\":\"func.call\"}(${I.join(\", \")});\n`,m.Qd||(z.push(\"emval_returnValue\"),B.push(pi),g+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),z.push(g+`};\n`),i=function(q){var X=Function;if(!(X instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof X} which is not a function`);var ue=bi(X.name||\"unknownFunctionName\",function(){});return ue.prototype=X.prototype,ue=new ue,(q=X.apply(ue,q))instanceof Object?q:ue}(z)(...B),c=`methodCaller<(${u.map(q=>q.name).join(\", \")}) => ${m.name}>`,tm(bi(c,i))}function om(i){return i=mr(i>>>0),We(r[i])}function im(i,u){return u>>>=0,i=Re(i>>>0),u=Re(u),We(i[u])}function am(i){9<(i>>>=0)&&(lt[i+1]+=1)}function sm(){return We([])}function um(i){i=Re(i>>>0);for(var u=Array(i.length),c=0;c<i.length;c++)u[c]=i[c];return We(u)}function dm(i){return We(mr(i>>>0))}function lm(){return We({})}function cm(i){for(var u=Re(i>>>=0);u.length;){var c=u.pop();u.pop()(c)}Tn(i)}function pm(i,u,c){u>>>=0,c>>>=0,i=Re(i>>>0),u=Re(u),c=Re(c),i[u]=c}function mm(i,u){return u>>>=0,i=(i=dr(i>>>0,\"_emval_take_value\")).readValueFromPointer(u),We(i)}function fm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getUTCSeconds(),D()[u+4>>>2>>>0]=i.getUTCMinutes(),D()[u+8>>>2>>>0]=i.getUTCHours(),D()[u+12>>>2>>>0]=i.getUTCDate(),D()[u+16>>>2>>>0]=i.getUTCMonth(),D()[u+20>>>2>>>0]=i.getUTCFullYear()-1900,D()[u+24>>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,D()[u+28>>>2>>>0]=i}var _i=i=>i%4==0&&(i%100!=0||i%400==0),wi=[0,31,60,91,121,152,182,213,244,274,305,335],vi=[0,31,59,90,120,151,181,212,243,273,304,334];function hm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getSeconds(),D()[u+4>>>2>>>0]=i.getMinutes(),D()[u+8>>>2>>>0]=i.getHours(),D()[u+12>>>2>>>0]=i.getDate(),D()[u+16>>>2>>>0]=i.getMonth(),D()[u+20>>>2>>>0]=i.getFullYear()-1900,D()[u+24>>>2>>>0]=i.getDay();var c=(_i(i.getFullYear())?wi:vi)[i.getMonth()]+i.getDate()-1|0;D()[u+28>>>2>>>0]=c,D()[u+36>>>2>>>0]=-60*i.getTimezoneOffset(),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var m=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=0|(c!=m&&i.getTimezoneOffset()==Math.min(m,c)),D()[u+32>>>2>>>0]=i}function gm(i){i>>>=0;var u=new Date(D()[i+20>>>2>>>0]+1900,D()[i+16>>>2>>>0],D()[i+12>>>2>>>0],D()[i+8>>>2>>>0],D()[i+4>>>2>>>0],D()[i>>>2>>>0],0),c=D()[i+32>>>2>>>0],m=u.getTimezoneOffset(),g=new Date(u.getFullYear(),6,1).getTimezoneOffset(),x=new Date(u.getFullYear(),0,1).getTimezoneOffset(),I=Math.min(x,g);return 0>c?D()[i+32>>>2>>>0]=+(g!=x&&I==m):0<c!=(I==m)&&(g=Math.max(x,g),u.setTime(u.getTime()+6e4*((0<c?I:g)-m))),D()[i+24>>>2>>>0]=u.getDay(),c=(_i(u.getFullYear())?wi:vi)[u.getMonth()]+u.getDate()-1|0,D()[i+28>>>2>>>0]=c,D()[i>>>2>>>0]=u.getSeconds(),D()[i+4>>>2>>>0]=u.getMinutes(),D()[i+8>>>2>>>0]=u.getHours(),D()[i+12>>>2>>>0]=u.getDate(),D()[i+16>>>2>>>0]=u.getMonth(),D()[i+20>>>2>>>0]=u.getYear(),i=u.getTime(),BigInt(isNaN(i)?-1:i/1e3)}function $i(i,u,c,m,g,x,I){return d?Te(16,1,i,u,c,m,g,x,I):-52}function xi(i,u,c,m,g,x){if(d)return Te(17,1,i,u,c,m,g,x)}var qt={},ym=()=>performance.timeOrigin+performance.now();function Si(i,u){if(d)return Te(18,1,i,u);if(qt[i]&&(clearTimeout(qt[i].id),delete qt[i]),!u)return 0;var c=setTimeout(()=>{delete qt[i],In(()=>Vi(i,performance.timeOrigin+performance.now()))},u);return qt[i]={id:c,ke:u},0}function bm(i,u,c,m){i>>>=0,u>>>=0,c>>>=0,m>>>=0;var g=new Date().getFullYear(),x=new Date(g,0,1).getTimezoneOffset();g=new Date(g,6,1).getTimezoneOffset();var I=Math.max(x,g);R()[i>>>2>>>0]=60*I,D()[u>>>2>>>0]=+(x!=g),i=(u=z=>{var B=Math.abs(z);return`UTC${0<=z?\"-\":\"+\"}${String(Math.floor(B/60)).padStart(2,\"0\")}${String(B%60).padStart(2,\"0\")}`})(x),u=u(g),g<x?(Bt(i,c,17),Bt(u,m,17)):(Bt(i,m,17),Bt(u,c,17))}var _m=()=>Date.now(),wm=1;function vm(i,u,c){if(!(0<=i&&3>=i))return 28;if(i===0)i=Date.now();else{if(!wm)return 52;i=performance.timeOrigin+performance.now()}return W[c>>>0>>>3]=BigInt(Math.round(1e6*i)),0}var Pn=[],Ti=(i,u)=>{Pn.length=0;for(var c;c=pe()[i++>>>0];){var m=c!=105;u+=(m&=c!=112)&&u%8?4:0,Pn.push(c==112?R()[u>>>2>>>0]:c==106?W[u>>>3]:c==105?D()[u>>>2>>>0]:fe()[u>>>3>>>0]),u+=m?8:4}return Pn};function $m(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}function xm(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}var Sm=()=>{};function Tm(i,u){return v(Ae(i>>>0,u>>>0))}var Cm=()=>{throw mt+=1,\"unwind\"};function Im(){return 4294901760}var Am=()=>navigator.hardwareConcurrency;function km(){return ut(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Em(i){i>>>=0;var u=pe().length;if(i<=u||4294901760<i)return!1;for(var c=1;4>=c;c*=2){var m=u*(1+.2/c);m=Math.min(m,i+100663296);e:{m=(Math.min(4294901760,65536*Math.ceil(Math.max(i,m)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(m),be();var g=1;break e}catch{}g=void 0}if(g)return!0}return!1}var fr=()=>(ut(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Mt={},Ci=i=>{i.forEach(u=>{var c=fr();c&&(Mt[c]=u)})};function Pm(){var i=Error().stack.toString().split(`\n`);return i[0]==\"Error\"&&i.shift(),Ci(i),Mt.Kd=fr(),Mt.ae=i,Mt.Kd}function zm(i,u,c){if(i>>>=0,u>>>=0,Mt.Kd==i)var m=Mt.ae;else(m=Error().stack.toString().split(`\n`))[0]==\"Error\"&&m.shift(),Ci(m);for(var g=3;m[g]&&fr()!=i;)++g;for(i=0;i<c&&m[i+g];++i)D()[u+4*i>>>2>>>0]=fr();return i}var zn,On={},Ii=()=>{if(!zn){var i,u={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:\"./this.program\"};for(i in On)On[i]===void 0?delete u[i]:u[i]=On[i];var c=[];for(i in u)c.push(`${i}=${u[i]}`);zn=c}return zn};function Ai(i,u){if(d)return Te(19,1,i,u);i>>>=0,u>>>=0;var c=0;return Ii().forEach((m,g)=>{var x=u+c;for(g=R()[i+4*g>>>2>>>0]=x,x=0;x<m.length;++x)Z()[g++>>>0]=m.charCodeAt(x);Z()[g>>>0]=0,c+=m.length+1}),0}function ki(i,u){if(d)return Te(20,1,i,u);i>>>=0,u>>>=0;var c=Ii();R()[i>>>2>>>0]=c.length;var m=0;return c.forEach(g=>m+=g.length+1),R()[u>>>2>>>0]=m,0}function Ei(i){return d?Te(21,1,i):52}function Pi(i,u,c,m){return d?Te(22,1,i,u,c,m):52}function zi(i,u,c,m){return d?Te(23,1,i,u,c,m):70}var Om=[null,[],[]];function Oi(i,u,c,m){if(d)return Te(24,1,i,u,c,m);u>>>=0,c>>>=0,m>>>=0;for(var g=0,x=0;x<c;x++){var I=R()[u>>>2>>>0],z=R()[u+4>>>2>>>0];u+=8;for(var B=0;B<z;B++){var L=pe()[I+B>>>0],q=Om[i];L===0||L===10?((i===1?$:v)(jo(q)),q.length=0):q.push(L)}g+=z}return R()[m>>>2>>>0]=g,0}function Dm(i){return i>>>0}d||function(){for(var i=r.numThreads-1;i--;)Ho();yn.unshift(()=>{xt++,function(u){d?u():Promise.all(ft.map(Go)).then(u)}(()=>Bo())})}();for(var Di=Array(256),hr=0;256>hr;++hr)Di[hr]=String.fromCharCode(hr);di=Di,ht=r.BindingError=class extends Error{constructor(i){super(i),this.name=\"BindingError\"}},r.InternalError=class extends Error{constructor(i){super(i),this.name=\"InternalError\"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>lt.length/2-5-Sn.length;var U,Bm=[bn,No,Fo,Zo,Qo,Xo,Jo,ei,ti,ri,ni,oi,ii,ai,si,ui,$i,xi,Si,Ai,ki,Ei,Pi,zi,Oi];(async function(){function i(m,g){return U=m.exports,U=function(){var x=U,I={};for(let[z,B]of Object.entries(x))I[z]=typeof B==\"function\"?(...L)=>{cr.push(z);try{return B(...L)}finally{ee||(cr.pop(),Je&&yt===1&&cr.length===0&&(yt=0,mt+=1,lr(Ua),typeof Fibers<\"u\"&&Fibers.le()))}}:B;return I}(),U=function(){var x=U,I=B=>L=>B(L)>>>0,z=B=>()=>B()>>>0;return(x=Object.assign({},x)).Cb=I(x.Cb),x.fc=z(x.fc),x.ic=I(x.ic),x.vc=I(x.vc),x.wc=z(x.wc),x.Ac=I(x.Ac),x}(),Vo.push(U.jc),C=g,Bo(),U}xt++;var u=Mo();if(r.instantiateWasm)return new Promise(m=>{r.instantiateWasm(u,(g,x)=>{i(g,x),m(g.exports)})});if(d)return new Promise(m=>{Fe=g=>{var x=new WebAssembly.Instance(g,Mo());m(i(x,g))}});Gt??=r.locateFile?r.locateFile?r.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",b):b+\"ort-wasm-simd-threaded.jsep.wasm\":/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href;try{var c=await async function(m){var g=Gt;if(!Q&&typeof WebAssembly.instantiateStreaming==\"function\"&&!le(g))try{var x=fetch(g,{credentials:\"same-origin\"});return await WebAssembly.instantiateStreaming(x,m)}catch(I){v(`wasm streaming compile failed: ${I}`),v(\"falling back to ArrayBuffer instantiation\")}return async function(I,z){try{var B=await async function(L){if(!Q)try{var q=await f(L);return new Uint8Array(q)}catch{}if(L==Gt&&Q)L=new Uint8Array(Q);else{if(!h)throw\"both async and sync fetching of the wasm failed\";L=h(L)}return L}(I);return await WebAssembly.instantiate(B,z)}catch(L){v(`failed to asynchronously prepare wasm: ${L}`),ut(L)}}(g,m)}(u);return i(c.instance,c.module)}catch(m){return n(m),Promise.reject(m)}})();var Bi=i=>(Bi=U.Cb)(i),Mi=()=>(Mi=U.Db)();r._OrtInit=(i,u)=>(r._OrtInit=U.Eb)(i,u),r._OrtGetLastError=(i,u)=>(r._OrtGetLastError=U.Fb)(i,u),r._OrtCreateSessionOptions=(i,u,c,m,g,x,I,z,B,L)=>(r._OrtCreateSessionOptions=U.Gb)(i,u,c,m,g,x,I,z,B,L),r._OrtAppendExecutionProvider=(i,u)=>(r._OrtAppendExecutionProvider=U.Hb)(i,u),r._OrtAddFreeDimensionOverride=(i,u,c)=>(r._OrtAddFreeDimensionOverride=U.Ib)(i,u,c),r._OrtAddSessionConfigEntry=(i,u,c)=>(r._OrtAddSessionConfigEntry=U.Jb)(i,u,c),r._OrtReleaseSessionOptions=i=>(r._OrtReleaseSessionOptions=U.Kb)(i),r._OrtCreateSession=(i,u,c)=>(r._OrtCreateSession=U.Lb)(i,u,c),r._OrtReleaseSession=i=>(r._OrtReleaseSession=U.Mb)(i),r._OrtGetInputOutputCount=(i,u,c)=>(r._OrtGetInputOutputCount=U.Nb)(i,u,c),r._OrtGetInputName=(i,u)=>(r._OrtGetInputName=U.Ob)(i,u),r._OrtGetOutputName=(i,u)=>(r._OrtGetOutputName=U.Pb)(i,u),r._OrtFree=i=>(r._OrtFree=U.Qb)(i),r._OrtCreateTensor=(i,u,c,m,g,x)=>(r._OrtCreateTensor=U.Rb)(i,u,c,m,g,x),r._OrtGetTensorData=(i,u,c,m,g)=>(r._OrtGetTensorData=U.Sb)(i,u,c,m,g),r._OrtReleaseTensor=i=>(r._OrtReleaseTensor=U.Tb)(i),r._OrtCreateRunOptions=(i,u,c,m)=>(r._OrtCreateRunOptions=U.Ub)(i,u,c,m),r._OrtAddRunConfigEntry=(i,u,c)=>(r._OrtAddRunConfigEntry=U.Vb)(i,u,c),r._OrtReleaseRunOptions=i=>(r._OrtReleaseRunOptions=U.Wb)(i),r._OrtCreateBinding=i=>(r._OrtCreateBinding=U.Xb)(i),r._OrtBindInput=(i,u,c)=>(r._OrtBindInput=U.Yb)(i,u,c),r._OrtBindOutput=(i,u,c,m)=>(r._OrtBindOutput=U.Zb)(i,u,c,m),r._OrtClearBoundOutputs=i=>(r._OrtClearBoundOutputs=U._b)(i),r._OrtReleaseBinding=i=>(r._OrtReleaseBinding=U.$b)(i),r._OrtRunWithBinding=(i,u,c,m,g)=>(r._OrtRunWithBinding=U.ac)(i,u,c,m,g),r._OrtRun=(i,u,c,m,g,x,I,z)=>(r._OrtRun=U.bc)(i,u,c,m,g,x,I,z),r._OrtEndProfiling=i=>(r._OrtEndProfiling=U.cc)(i),r._JsepOutput=(i,u,c)=>(r._JsepOutput=U.dc)(i,u,c),r._JsepGetNodeName=i=>(r._JsepGetNodeName=U.ec)(i);var gr=()=>(gr=U.fc)(),et=r._free=i=>(et=r._free=U.gc)(i),yr=r._malloc=i=>(yr=r._malloc=U.ic)(i),Dn=(i,u,c,m,g,x)=>(Dn=U.kc)(i,u,c,m,g,x),Ri=()=>(Ri=U.lc)(),Ui=(i,u,c,m,g)=>(Ui=U.mc)(i,u,c,m,g),Ni=i=>(Ni=U.nc)(i),Bn=i=>(Bn=U.oc)(i),Vi=(i,u)=>(Vi=U.pc)(i,u),Wi=()=>(Wi=U.qc)(),se=(i,u)=>(se=U.rc)(i,u),Kt=i=>(Kt=U.sc)(i),Li=(i,u)=>(Li=U.tc)(i,u),oe=i=>(oe=U.uc)(i),Mn=i=>(Mn=U.vc)(i),ie=()=>(ie=U.wc)(),Gi=i=>(Gi=U.xc)(i),Hi=i=>(Hi=U.yc)(i),Fi=(i,u,c)=>(Fi=U.zc)(i,u,c),qi=i=>(qi=U.Ac)(i),Ki=r.dynCall_iii=(i,u,c)=>(Ki=r.dynCall_iii=U.Bc)(i,u,c),ji=r.dynCall_vi=(i,u)=>(ji=r.dynCall_vi=U.Cc)(i,u),Rn=r.dynCall_ii=(i,u)=>(Rn=r.dynCall_ii=U.Dc)(i,u),Zi=r.dynCall_vii=(i,u,c)=>(Zi=r.dynCall_vii=U.Ec)(i,u,c),Qi=r.dynCall_iiii=(i,u,c,m)=>(Qi=r.dynCall_iiii=U.Fc)(i,u,c,m),Yi=r.dynCall_viii=(i,u,c,m)=>(Yi=r.dynCall_viii=U.Gc)(i,u,c,m),Xi=r.dynCall_iiiii=(i,u,c,m,g)=>(Xi=r.dynCall_iiiii=U.Hc)(i,u,c,m,g),Ji=r.dynCall_viiii=(i,u,c,m,g)=>(Ji=r.dynCall_viiii=U.Ic)(i,u,c,m,g),ea=r.dynCall_viiiiii=(i,u,c,m,g,x,I)=>(ea=r.dynCall_viiiiii=U.Jc)(i,u,c,m,g,x,I),ta=r.dynCall_viiiiiii=(i,u,c,m,g,x,I,z)=>(ta=r.dynCall_viiiiiii=U.Kc)(i,u,c,m,g,x,I,z),ra=r.dynCall_ji=(i,u)=>(ra=r.dynCall_ji=U.Lc)(i,u),na=r.dynCall_v=i=>(na=r.dynCall_v=U.Mc)(i),oa=r.dynCall_viiiii=(i,u,c,m,g,x)=>(oa=r.dynCall_viiiii=U.Nc)(i,u,c,m,g,x),ia=r.dynCall_i=i=>(ia=r.dynCall_i=U.Oc)(i),aa=r.dynCall_fii=(i,u,c)=>(aa=r.dynCall_fii=U.Pc)(i,u,c),sa=r.dynCall_viiiiiiii=(i,u,c,m,g,x,I,z,B)=>(sa=r.dynCall_viiiiiiii=U.Qc)(i,u,c,m,g,x,I,z,B),ua=r.dynCall_viiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ua=r.dynCall_viiiiiiiiii=U.Rc)(i,u,c,m,g,x,I,z,B,L,q),da=r.dynCall_jiii=(i,u,c,m)=>(da=r.dynCall_jiii=U.Sc)(i,u,c,m),la=r.dynCall_dii=(i,u,c)=>(la=r.dynCall_dii=U.Tc)(i,u,c),ca=r.dynCall_viiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ca=r.dynCall_viiiiiiiii=U.Uc)(i,u,c,m,g,x,I,z,B,L),pa=r.dynCall_viiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X)=>(pa=r.dynCall_viiiiiiiiiii=U.Vc)(i,u,c,m,g,x,I,z,B,L,q,X),ma=r.dynCall_iiiiii=(i,u,c,m,g,x)=>(ma=r.dynCall_iiiiii=U.Wc)(i,u,c,m,g,x),fa=r.dynCall_iij=(i,u,c)=>(fa=r.dynCall_iij=U.Xc)(i,u,c),ha=r.dynCall_iiiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ha=r.dynCall_iiiiiiiiii=U.Yc)(i,u,c,m,g,x,I,z,B,L),ga=r.dynCall_iiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ga=r.dynCall_iiiiiiiiiii=U.Zc)(i,u,c,m,g,x,I,z,B,L,q),ya=r.dynCall_vij=(i,u,c)=>(ya=r.dynCall_vij=U._c)(i,u,c),ba=r.dynCall_iiif=(i,u,c,m)=>(ba=r.dynCall_iiif=U.$c)(i,u,c,m),_a=r.dynCall_iiij=(i,u,c,m)=>(_a=r.dynCall_iiij=U.ad)(i,u,c,m),wa=r.dynCall_fiii=(i,u,c,m)=>(wa=r.dynCall_fiii=U.bd)(i,u,c,m),va=r.dynCall_viiiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>(va=r.dynCall_viiiiiiiiiiiii=U.cd)(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e),$a=r.dynCall_vjiii=(i,u,c,m,g)=>($a=r.dynCall_vjiii=U.dd)(i,u,c,m,g),xa=r.dynCall_vif=(i,u,c)=>(xa=r.dynCall_vif=U.ed)(i,u,c),Sa=r.dynCall_iiiiiii=(i,u,c,m,g,x,I)=>(Sa=r.dynCall_iiiiiii=U.fd)(i,u,c,m,g,x,I),Ta=r.dynCall_iiiij=(i,u,c,m,g)=>(Ta=r.dynCall_iiiij=U.gd)(i,u,c,m,g),Ca=r.dynCall_iiiiiiii=(i,u,c,m,g,x,I,z)=>(Ca=r.dynCall_iiiiiiii=U.hd)(i,u,c,m,g,x,I,z),Ia=r.dynCall_viiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue)=>(Ia=r.dynCall_viiiiiiiiiiii=U.id)(i,u,c,m,g,x,I,z,B,L,q,X,ue),Aa=r.dynCall_diii=(i,u,c,m)=>(Aa=r.dynCall_diii=U.jd)(i,u,c,m),ka=r.dynCall_jiiii=(i,u,c,m,g)=>(ka=r.dynCall_jiiii=U.kd)(i,u,c,m,g),Ea=r.dynCall_viiij=(i,u,c,m,g)=>(Ea=r.dynCall_viiij=U.ld)(i,u,c,m,g),Pa=r.dynCall_fiiii=(i,u,c,m,g)=>(Pa=r.dynCall_fiiii=U.md)(i,u,c,m,g),za=r.dynCall_viiif=(i,u,c,m,g)=>(za=r.dynCall_viiif=U.nd)(i,u,c,m,g),Oa=r.dynCall_diiii=(i,u,c,m,g)=>(Oa=r.dynCall_diiii=U.od)(i,u,c,m,g),Da=r.dynCall_viiid=(i,u,c,m,g)=>(Da=r.dynCall_viiid=U.pd)(i,u,c,m,g),Ba=r.dynCall_iiiijii=(i,u,c,m,g,x,I)=>(Ba=r.dynCall_iiiijii=U.qd)(i,u,c,m,g,x,I),Ma=r.dynCall_iiiiiij=(i,u,c,m,g,x,I)=>(Ma=r.dynCall_iiiiiij=U.rd)(i,u,c,m,g,x,I),Ra=i=>(Ra=U.sd)(i),Ua=()=>(Ua=U.td)(),Na=i=>(Na=U.ud)(i),Va=()=>(Va=U.vd)();function Mm(i,u,c){var m=ie();try{Zi(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Rm(i,u,c){var m=ie();try{return Ki(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Um(i,u){var c=ie();try{ji(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Nm(i,u){var c=ie();try{return Rn(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Vm(i,u,c,m){var g=ie();try{return Qi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Wm(i,u,c,m,g){var x=ie();try{Ji(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Lm(i,u,c,m,g){var x=ie();try{return Xi(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Gm(i,u,c,m){var g=ie();try{Yi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Hm(i,u,c,m,g,x,I){var z=ie();try{return Sa(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Fm(i){var u=ie();try{na(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function qm(i,u,c){var m=ie();try{return fa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Km(i,u,c,m,g,x){var I=ie();try{oa(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function jm(i,u,c){var m=ie();try{ya(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Zm(i,u,c,m,g,x,I){var z=ie();try{ea(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Qm(i,u,c,m,g,x,I,z){var B=ie();try{ta(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Ym(i,u,c,m,g,x){var I=ie();try{return ma(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function Xm(i,u,c,m,g,x,I,z){var B=ie();try{return Ca(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Jm(i,u,c,m,g,x,I,z,B,L){var q=ie();try{ca(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function ef(i,u,c,m,g,x,I,z,B){var L=ie();try{sa(i,u,c,m,g,x,I,z,B)}catch(q){if(oe(L),q!==q+0)throw q;se(1,0)}}function tf(i){var u=ie();try{return ia(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function rf(i,u,c,m,g,x,I,z,B,L){var q=ie();try{return ha(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function nf(i,u,c){var m=ie();try{return aa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function of(i,u,c,m){var g=ie();try{return da(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;return se(1,0),0n}}function af(i,u,c){var m=ie();try{return la(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function sf(i,u,c,m,g,x,I,z,B,L,q,X){var ue=ie();try{pa(i,u,c,m,g,x,I,z,B,L,q,X)}catch($e){if(oe(ue),$e!==$e+0)throw $e;se(1,0)}}function uf(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{ua(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function df(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{return ga(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function lf(i,u,c,m){var g=ie();try{return ba(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function cf(i,u,c,m){var g=ie();try{return _a(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function pf(i,u,c,m){var g=ie();try{return wa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function mf(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e){var Le=ie();try{va(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)}catch(jt){if(oe(Le),jt!==jt+0)throw jt;se(1,0)}}function ff(i,u,c,m,g){var x=ie();try{$a(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function hf(i,u,c){var m=ie();try{xa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function gf(i,u){var c=ie();try{return ra(i,u)}catch(m){if(oe(c),m!==m+0)throw m;return se(1,0),0n}}function yf(i,u,c,m,g){var x=ie();try{return Ta(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function bf(i,u,c,m,g,x,I,z,B,L,q,X,ue){var $e=ie();try{Ia(i,u,c,m,g,x,I,z,B,L,q,X,ue)}catch(Le){if(oe($e),Le!==Le+0)throw Le;se(1,0)}}function _f(i,u,c,m){var g=ie();try{return Aa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function wf(i,u,c,m,g){var x=ie();try{return ka(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;return se(1,0),0n}}function vf(i,u,c,m,g){var x=ie();try{Ea(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function $f(i,u,c,m,g){var x=ie();try{return Pa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function xf(i,u,c,m,g){var x=ie();try{za(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Sf(i,u,c,m,g){var x=ie();try{return Oa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Tf(i,u,c,m,g){var x=ie();try{Da(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Cf(i,u,c,m,g,x,I){var z=ie();try{return Ba(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function If(i,u,c,m,g,x,I){var z=ie();try{return Ma(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}return r.stackSave=()=>ie(),r.stackRestore=i=>oe(i),r.stackAlloc=i=>Mn(i),r.setValue=function(i,u,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":Z()[i>>>0]=u;break;case\"i16\":ke()[i>>>1>>>0]=u;break;case\"i32\":D()[i>>>2>>>0]=u;break;case\"i64\":W[i>>>3]=BigInt(u);break;case\"float\":Y()[i>>>2>>>0]=u;break;case\"double\":fe()[i>>>3>>>0]=u;break;case\"*\":R()[i>>>2>>>0]=u;break;default:ut(`invalid type for setValue: ${c}`)}},r.getValue=function(i,u=\"i8\"){switch(u.endsWith(\"*\")&&(u=\"*\"),u){case\"i1\":case\"i8\":return Z()[i>>>0];case\"i16\":return ke()[i>>>1>>>0];case\"i32\":return D()[i>>>2>>>0];case\"i64\":return W[i>>>3];case\"float\":return Y()[i>>>2>>>0];case\"double\":return fe()[i>>>3>>>0];case\"*\":return R()[i>>>2>>>0];default:ut(`invalid type for getValue: ${u}`)}},r.UTF8ToString=Ae,r.stringToUTF8=Bt,r.lengthBytesUTF8=Yo,function i(){if(0<xt)Ht=i;else if(d)t(r),Ye();else{for(;0<yn.length;)yn.shift()(r);0<xt?Ht=i:(r.calledRun=!0,ee||(Ye(),t(r)))}}(),r.PTR_SIZE=4,o}),Bf=ws,Mf=globalThis.self?.name?.startsWith(\"em-pthread\");Mf&&ws()});var Ts,Rf,Ve,Cs,jn,Uf,Nf,Is,Vf,xs,As,Ss,ks,Sr=G(()=>{\"use strict\";xr();Ts=typeof location>\"u\"?void 0:location.origin,Rf=()=>{if(true)return \"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?18ac\")).href,Ts).href:\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"},Ve=Rf(),Cs=()=>{if(Ve&&!Ve.startsWith(\"blob:\"))return Ve.substring(0,Ve.lastIndexOf(\"/\")+1)},jn=(e,t)=>{try{let n=t??Ve;return(n?new URL(e,n):new URL(e)).origin===Ts}catch{return!1}},Uf=(e,t)=>{let n=t??Ve;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Nf=(e,t)=>`${t??\"./\"}${e}`,Is=async e=>{let n=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(n)},Vf=async e=>(await import(/*webpackIgnore:true*/e)).default,xs=(_s(),br(bs)).default,As=async()=>{if(!Ve)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(jn(Ve))return[void 0,xs()];let e=await Is(Ve);return[e,xs(e)]},Ss=($s(),br(vs)).default,ks=async(e,t,n)=>{if(!e&&!t&&Ss&&Ve&&jn(Ve))return[void 0,Ss];{let r=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Uf(r,t),a= true&&n&&o&&!jn(o,t),s=a?await Is(o):o??Nf(r,t);return[a?s:void 0,await Vf(s)]}}});var Zn,Qn,Or,Es,Wf,Lf,Tr,Ie,bt=G(()=>{\"use strict\";Sr();Qn=!1,Or=!1,Es=!1,Wf=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lf=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Tr=async e=>{if(Qn)return Promise.resolve();if(Or)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Es)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Or=!0;let t=e.initTimeout,n=e.numThreads;if(!Lf())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let r=Wf();n>1&&!r&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+n+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=n=1);let o=e.wasmPaths,a=typeof o==\"string\"?o:void 0,s=o?.mjs,d=s?.href??s,l=o?.wasm,p=l?.href??l,f=e.wasmBinary,[h,y]=await ks(d,a,n>1),_=!1,b=[];if(t>0&&b.push(new Promise(w=>{setTimeout(()=>{_=!0,w()},t)})),b.push(new Promise((w,S)=>{let $={numThreads:n};if(f)$.wasmBinary=f;else if(p||a)$.locateFile=v=>p??a+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(h){let v=Cs();v&&($.locateFile=T=>v+T)}y($).then(v=>{Or=!1,Qn=!0,Zn=v,w(),h&&URL.revokeObjectURL(h)},v=>{Or=!1,Es=!0,S(v)})})),await Promise.race(b),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ie=()=>{if(Qn&&Zn)return Zn;throw new Error(\"WebAssembly is not initialized yet.\")}});var Pe,Xt,he,Dr=G(()=>{\"use strict\";bt();Pe=(e,t)=>{let n=Ie(),r=n.lengthBytesUTF8(e)+1,o=n._malloc(r);return n.stringToUTF8(e,o,r),t.push(o),o},Xt=(e,t,n,r)=>{if(typeof e==\"object\"&&e!==null){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach(([o,a])=>{let s=t?t+o:o;if(typeof a==\"object\")Xt(a,s+\".\",n,r);else if(typeof a==\"string\"||typeof a==\"number\")r(s,a.toString());else if(typeof a==\"boolean\")r(s,a?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},he=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetLastError(o,o+r);let a=Number(t.getValue(o,r===4?\"i32\":\"i64\")),s=t.getValue(o+r,\"*\"),d=s?t.UTF8ToString(s):\"\";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(n)}}});var Ps,zs=G(()=>{\"use strict\";bt();Dr();Ps=e=>{let t=Ie(),n=0,r=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let a=0;return e?.tag!==void 0&&(a=Pe(e.tag,r)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),n===0&&he(\"Can't create run options.\"),e?.extra!==void 0&&Xt(e.extra,\"\",new WeakSet,(s,d)=>{let l=Pe(s,r),p=Pe(d,r);t._OrtAddRunConfigEntry(n,l,p)!==0&&he(`Can't set a run config entry: ${s} - ${d}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),r.forEach(s=>t._free(s)),a}}});var Gf,Hf,Ff,qf,Os,Ds=G(()=>{\"use strict\";bt();Dr();Gf=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Hf=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ff=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(n=>(typeof n==\"string\"?n:n.name)===\"webgpu\")&&(e.enableMemPattern=!1)},qf=(e,t,n)=>{for(let r of t){let o=typeof r==\"string\"?r:r.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof r!=\"string\"){let d=r?.deviceType;if(d){let l=Pe(\"deviceType\",n),p=Pe(d,n);Ie()._OrtAddSessionConfigEntry(e,l,p)!==0&&he(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof r!=\"string\"){let s=r;if(s?.preferredLayout){if(s.preferredLayout!==\"NCHW\"&&s.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let d=Pe(\"preferredLayout\",n),l=Pe(s.preferredLayout,n);Ie()._OrtAddSessionConfigEntry(e,d,l)!==0&&he(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let a=Pe(o,n);Ie()._OrtAppendExecutionProvider(e,a)!==0&&he(`Can't append execution provider: ${o}.`)}},Os=e=>{let t=Ie(),n=0,r=[],o=e||{};Ff(o);try{let a=Gf(o.graphOptimizationLevel??\"all\"),s=Hf(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?Pe(o.logId,r):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let f=typeof o.optimizedModelFilePath==\"string\"?Pe(o.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(a,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,d,l,p,f),n===0&&he(\"Can't create session options.\"),o.executionProviders&&qf(n,o.executionProviders,r),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let h=Pe(\"enableGraphCapture\",r),y=Pe(o.enableGraphCapture.toString(),r);t._OrtAddSessionConfigEntry(n,h,y)!==0&&he(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[h,y]of Object.entries(o.freeDimensionOverrides)){if(typeof h!=\"string\")throw new Error(`free dimension override name must be a string: ${h}`);if(typeof y!=\"number\"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let _=Pe(h,r);t._OrtAddFreeDimensionOverride(n,_,y)!==0&&he(`Can't set a free dimension override: ${h} - ${y}.`)}return o.extra!==void 0&&Xt(o.extra,\"\",new WeakSet,(h,y)=>{let _=Pe(h,r),b=Pe(y,r);t._OrtAddSessionConfigEntry(n,_,b)!==0&&he(`Can't set a session config entry: ${h} - ${y}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&he(\"Can't release session options.\"),r.forEach(s=>t._free(s)),a}}});var Rt,_t,wt,Br,Jt,Mr,Rr,Yn,te=G(()=>{\"use strict\";Rt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},_t=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},wt=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r=typeof t==\"number\"?t:t.reduce((o,a)=>o*a,1);return n>0?Math.ceil(r*n):void 0},Br=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Jt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Mr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Rr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Yn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var er,Xn=G(()=>{\"use strict\";xr();er=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get(\"Content-Length\"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),a;try{a=new ArrayBuffer(r)}catch(d){if(d instanceof RangeError){let l=Math.ceil(r/65536);a=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let s=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(a,s,p).set(l),s+=p}return new Uint8Array(a,0,r)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Kf,jf,Bs,Ms,Ur,Zf,me,tt=G(()=>{\"use strict\";te();Kf=[\"V\",\"I\",\"W\",\"E\",\"F\"],jf=(e,t)=>{console.log(`[${Kf[e]},${new Date().toISOString()}]${t}`)},Ur=(e,t)=>{Bs=e,Ms=t},Zf=(e,t)=>{let n=Jt(e),r=Jt(Bs);n>=r&&jf(n,typeof t==\"function\"?t():t)},me=(...e)=>{Ms&&Zf(...e)}});var Nr,Jn=G(()=>{\"use strict\";te();Nr=(e,t)=>new(Br(t))(e)});var Vr=G(()=>{\"use strict\"});var Rs,eo,to,Qf,Yf,Us,no,ro,Vs,Ws=G(()=>{\"use strict\";tt();Vr();Rs=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),eo=[],to=e=>Math.ceil(Number(e)/16)*16,Qf=e=>{for(let t=0;t<eo.length;t++){let n=eo[t];if(e<=n)return n}return Math.ceil(e/16)*16},Yf=1,Us=()=>Yf++,no=async(e,t,n,r)=>{let o=to(n),a=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,a,0,o),e.flush(),await a.mapAsync(GPUMapMode.READ);let d=a.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(d,0,n)),l}else return new Uint8Array(d.slice(0,n))}finally{a.destroy()}},ro=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[n]of Rs)eo.push(n),this.freeBuffers.set(n,[]),this.freeUniformBuffers.set(n,[]);this.sessionCount=0}upload(t,n){let r=n.buffer,o=n.byteOffset,a=n.byteLength,s=to(a),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==a)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${a}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(r,o,a)),l.unmap();let f=this.backend.device.createCommandEncoder();f.copyBufferToBuffer(l,0,d.gpuData.buffer,0,s),this.backend.device.queue.submit([f.finish()]),l.destroy(),me(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,n){let r=this.storageCache.get(t);if(!r)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(n);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(r.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let a=to(r.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(r.gpuData.buffer,0,o.gpuData.buffer,0,a)}registerExternalBuffer(t,n,r){let o;if(r){if(o=r[0],t===r[1])return me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Us();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:n}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),me(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r=Qf(t),o,a=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||s){let p=(a?this.freeBuffers:this.freeUniformBuffers).get(r);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:r,usage:n}):o=this.backend.device.createBuffer({size:r,usage:n})}else o=this.backend.device.createBuffer({size:r,usage:n});let d={id:Us(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let n=typeof t==\"bigint\"?Number(t):t,r=this.storageCache.get(n);if(!r){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return me(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${n}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(n),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,n){let r=this.storageCache.get(Number(t));if(!r)throw new Error(\"data does not exist\");await no(this.backend,r.gpuData.buffer,r.originalSize,n)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let n=Rs.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let n of this.buffersPending)t.push(n);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let n=this.capturedPendingBuffers.get(t);n&&(n.forEach(r=>{r.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(me(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Vs=(...e)=>new ro(...e)});var oo,re,Ce=G(()=>{\"use strict\";oo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},re=e=>new oo(e)});var io,rt,E,kt,Wr,Ls,Gs,ae=G(()=>{\"use strict\";io=class{static calcMatMulShape(t,n){return t[1]!==n[0]?void 0:[t[0],n[1]]}},rt=class{static calcShape(t,n,r=!1){let o=t.length,a=n.length;if(o===0)return n;if(a===0)return t;let s=Math.max(t.length,n.length),d=new Array(s);if(r){if(o<2||a<2)return;let l=io.calcMatMulShape([t[o-2],t[o-1]],[n[a-2],n[a-1]]);if(l===void 0)return;[d[s-2],d[s-1]]=l}for(let l=r?3:1;l<=s;l++){let p=o-l<0?1:t[o-l],f=a-l<0?1:n[a-l];if(p!==f&&p>1&&f>1)return;let h=Math.max(p,f);if(p&&f)d[s-l]=Math.max(p,f);else{if(h>1)return;d[s-l]=0}}return d}static isValidBroadcast(t,n){let r=t.length,o=n.length;if(r>o)return!1;for(let a=1;a<=r;a++)if(t[r-a]!==1&&t[r-a]!==n[o-a])return!1;return!0}},E=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let r=t.length;if(r===0)return[];let o=new Array(r),a=r-1;for(;a>=0;){if(t[a]%n===0){o[a]=t[a]/n;break}if(n%t[a]!==0)throw new Error(\"cannot convert shape\");o[a]=1,n/=t[a],a--}for(a--;a>=0;a--)o[a]=t[a];return o}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,r){let o=1;for(let a=n;a<r;a++){if(t[a]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[a])}return o}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=t[n-1];for(let o=n-3;o>=0;--o)r[o]=r[o+1]*t[o+1];return r}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error(\"unsupported axis for this operation.\");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(r=>this.normalizeAxis(r,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(r=>t[r]):t.slice().reverse()}static padShape(t,n){let r=t.length;return t.map((o,a)=>o+n[a]+n[a+r])}static areEqual(t,n){return t.length!==n.length?!1:t.every((r,o)=>r===n[o])}},kt=class e{static adjustPoolAttributes(t,n,r,o,a,s){if(!t&&r.length!==n.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<n.length-2;d++)d>=r.length?r.push(n[d+2]):r[d]=n[d+2];for(let d=0;d<r.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<r.length;d++)if(d<a.length){if(a[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else a.push(1);for(let d=0;d<r.length*2;d++)if(d<s.length){if(s[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else s.push(0);for(let d=0;d<r.length;d++){if(r[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(s[d]>=r[d]||s[d+r.length]>=r[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,n,r,o,a,s,d){if(d){if(a.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(n.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(s?1:2)],n[l],r[l],o[l],a,l,l+t.length-2,d)}}static computePoolOutputShape(t,n,r,o,a,s,d){if(n.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,o,a,s,d),l}static computeConvOutputShape(t,n,r,o,a,s,d){if(t.length<=0||n.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,o,a,s,d),l}static computeShapeHelper(t,n,r,o,a,s,d,l){if(t)for(let p=0;p<n.length-2;p++)r.push(1);else for(let p=0;p<n.length-2;p++)r.push(e.adjustPadAndReturnShape(n[p+2],o[p],a[p],s[p],d,p,p+n.length-2,l))}static adjustPadAndReturnShape(t,n,r,o,a,s,d,l){let p=r*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return a[s]=0,a[d]=0,Math.floor((t-p)/n+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(r!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let h=((t+n-1)/n-1)*n+o-t;return a[s]=Math.floor(l===\"SAME_LOWER\"?(h+1)/2:h/2),a[d]=h-a[s],Math.floor((t+h-o)/n+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+a[s]+a[d]-p)/n+1)}},Wr=class{static getShapeOfGemmResult(t,n,r,o,a){if(t.length!==2||r.length!==2)throw new Error(\"shape need to be of size 2\");let s,d,l;n?(s=t[1],d=t[0]):(s=t[0],d=t[1]);let p=-1;if(o?(l=r[0],p=1):(l=r[1],p=0),r[p]!==d)throw new Error(\"dimension mismatch\");if(s<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(a&&!rt.isValidBroadcast(a,[s,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[s,l,d]}},Ls=-34028234663852886e22,Gs=34028234663852886e22});var Et,so,_e,ze,H,ge,uo,Pt,Ke,K,Lr,P,N,Hs,Gr,ao,Fs,ce=G(()=>{\"use strict\";te();ae();Et=64,so=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},_e=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[0]},ze=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[1]},H=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:E.computeStrides(n)})}),t},ge=e=>e%4===0?4:e%2===0?2:1,uo=(e=\"f32\",t,n=\"0\")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,Pt=(e,t,n)=>e===\"f32\"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,Ke=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,K=(e,t,n,r)=>e.startsWith(\"uniforms.\")&&n>4?typeof t==\"string\"?r===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:r===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Lr=(e,t,n,r,o)=>{let a=typeof n==\"number\",s=a?n:n.length,d=[...new Array(s).keys()],l=s<2?\"u32\":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,p=so(t,o),f=typeof p==\"string\"?p:p[1],h=typeof p==\"string\"?p:p[0],y={indices:l,value:f,storage:h,tensor:t},_=R=>typeof R==\"string\"?R:`${R}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=a?\"uniforms.\":\"\",S=`${w}${e}_shape`,$=`${w}${e}_strides`,v=\"\";for(let R=0;R<s-1;R++)v+=`\n    let dim${R} = current / ${K($,R,s)};\n    let rest${R} = current % ${K($,R,s)};\n    indices[${R}] = dim${R};\n    current = rest${R};\n    `;v+=`indices[${s-1}] = current;`;let T=s<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${y.indices} {\n    var indices: ${y.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,C=R=>(b.offsetToIndices=!0,s<2?R:`o2i_${e}(${R})`),A=[];if(s>=2)for(let R=s-1;R>=0;R--)A.push(`${K($,R,s)} * (indices[${R}])`);let k=s<2?\"\":`\n  fn i2o_${e}(indices: ${y.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,O=R=>(b.indicesToOffset=!0,s<2?R:`i2o_${e}(${R})`),M=(...R)=>s===0?\"0u\":`${y.indices}(${R.map(_).join(\",\")})`,V=(R,Y)=>s<2?`${R}`:`${K(R,Y,s)}`,F=(R,Y,fe)=>s<2?`${R}=${fe};`:`${K(R,Y,s)}=${fe};`,j={},ne=(R,Y)=>{b.broadcastedIndicesToOffset=!0;let fe=`${Y.name}broadcastedIndicesTo${e}Offset`;if(fe in j)return`${fe}(${R})`;let Fe=[];for(let xe=s-1;xe>=0;xe--){let be=Y.indicesGet(\"outputIndices\",xe+Y.rank-s);Fe.push(`${V($,xe)} * (${be} % ${V(S,xe)})`)}return j[fe]=`fn ${fe}(outputIndices: ${Y.type.indices}) -> u32 {\n             return ${Fe.length>0?Fe.join(\"+\"):\"0u\"};\n           }`,`${fe}(${R})`},W=(R,Y)=>(()=>{if(y.storage===y.value)return`${e}[${R}]=${Y};`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), 0u);`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`${e}[${R}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),J=R=>(()=>{if(y.storage===y.value)return`${e}[${R}]`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`i32(${e}[${R}].x)`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`u32(${e}[${R}].x)`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${R}] & 0xFFu), bool(${e}[${R}] & 0xFF00u), bool(${e}[${R}] & 0xFF0000u), bool(${e}[${R}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ve=s<2?\"\":`\n  fn get_${e}ByIndices(indices: ${y.indices}) -> ${f} {\n    return ${J(`i2o_${e}(indices)`)};\n  }`,Q=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn get_${e}(${R}) -> ${f} {\n    return get_${e}ByIndices(${M(Y)});\n  }`})(),ee=(...R)=>{if(R.length!==s)throw new Error(`indices length must be ${s}`);let Y=R.map(_).join(\",\");return s===0?J(\"0u\"):s===1?J(Y[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${Y})`)},le=R=>s<2?J(R):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${R})`),Z=s<2?\"\":`\n  fn set_${e}ByIndices(indices: ${y.indices}, value: ${f}) {\n    ${W(`i2o_${e}(indices)`,\"value\")}\n  }`,pe=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn set_${e}(${R}, value: ${f}) {\n    set_${e}ByIndices(${M(Y)}, value);\n  }`})();return{impl:()=>{let R=[],Y=!1;return b.offsetToIndices&&(R.push(T),Y=!0),b.indicesToOffset&&(R.push(k),Y=!0),b.broadcastedIndicesToOffset&&(Object.values(j).forEach(fe=>R.push(fe)),Y=!0),b.set&&(R.push(pe),Y=!0),b.setByIndices&&(R.push(Z),Y=!0),b.get&&(R.push(Q),Y=!0),b.getByIndices&&(R.push(ve),Y=!0),!a&&Y&&R.unshift(`const ${S} = ${y.indices}(${n.join(\",\")});`,`const ${$} = ${y.indices}(${E.computeStrides(n).join(\",\")});`),R.join(`\n`)},type:y,offsetToIndices:C,indicesToOffset:O,broadcastedIndicesToOffset:ne,indices:M,indicesGet:V,indicesSet:F,set:(...R)=>{if(R.length!==s+1)throw new Error(`indices length must be ${s}`);let Y=R[s];if(typeof Y!=\"string\")throw new Error(\"value must be string\");let fe=R.slice(0,s).map(_).join(\",\");return s===0?W(\"0u\",Y):s===1?W(fe[0],Y):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${fe}, ${Y})`)},setByOffset:W,setByIndices:(R,Y)=>s<2?W(R,Y):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${R}, ${Y});`),get:ee,getByOffset:J,getByIndices:le,usage:r,name:e,strides:$,shape:S,rank:s}},P=(e,t,n,r=1)=>Lr(e,t,n,\"input\",r),N=(e,t,n,r=1)=>Lr(e,t,n,\"output\",r),Hs=(e,t,n)=>Lr(e,t,n,\"atomicOutput\",1),Gr=(e,t,n,r=1)=>Lr(e,t,n,\"internal\",r),ao=class{constructor(t,n){this.normalizedDispatchGroup=t;this.limits=n;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Et){let n=typeof t==\"number\"?t:t[0],r=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(n>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(n*r*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=a?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=a?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${n*r*o}u + local_idx;`;return`@compute @workgroup_size(${n}, ${r}, ${o})\n  fn main(${s}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,n){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let r=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${n}) var<storage, ${r}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(n=>this.declareVariable(n,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(n=>this.registerInternalVariable(n)),this}registerUniform(t,n,r=1){return this.uniforms.push({name:t,type:n,length:r}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:n,type:r,length:o}of this.uniforms)if(o&&o>4)r===\"f16\"?t.push(`@align(16) ${n}:array<mat2x4<${r}>, ${Math.ceil(o/8)}>`):t.push(`${n}:array<vec4<${r}>, ${Math.ceil(o/4)}>`);else{let a=o==null||o===1?r:`vec${o}<${r}>`;t.push(`${n}:${a}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=n=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(n)];return this.uniforms.map(n=>[t(n.type),n.length??1])}},Fs=(e,t)=>new ao(e,t)});var Xf,qs,Jf,eh,th,rh,Oe,Ks,js,ct=G(()=>{\"use strict\";te();ae();Ce();ce();Xf=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},qs=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),Jf=(e,t)=>E.sortBasedOnPerm(e,qs(e.length,t)),eh=(e,t,n,r)=>{let o=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let a=0;a<t;++a)o+=`a[${e[a]}]=i[${a}];`;return o+=\"return a;}\"},th=(e,t)=>{let n=[],r=[];for(let o=0;o<e.length;++o)e[o]!==1&&n.push(e[o]),e[t[o]]!==1&&r.push(t[o]);return{newShape:n,newPerm:r}},rh=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(t[e[r]]!==1){if(e[r]<n)return!1;n=e[r]}return!0},Oe=(e,t)=>{let n=e.dataType,r=e.dims.length,o=qs(r,t),a=Jf(e.dims,o),s=e.dims,d=a,l=r<2||rh(o,e.dims),p;if(l)return p=w=>{let S=P(\"input\",n,s,4),$=N(\"output\",n,d,4);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64/4)},programUniforms:[{type:12,data:Math.ceil(w/4)}]}},getShaderSource:p};let{newShape:f,newPerm:h}=th(e.dims,o),y=E.areEqual(h,[2,3,1]),_=E.areEqual(h,[3,1,2]);if(f.length===2||y||_){s=y?[f[0],f[1]*f[2]]:_?[f[0]*f[1],f[2]]:f,d=[s[1],s[0]];let w=16;return p=S=>{let $=P(\"a\",n,s.length),v=N(\"output\",n,d.length);return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${w+1}>, ${w}>;\n  ${S.mainStart([w,w,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${w} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${w}u + local_id.x;\n    let input_row = workgroup_id_x * ${w}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${w}u + local_id.x;\n    let output_row = workgroup_id_y * ${w}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let S=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/w),y:Math.ceil(d[0]/w)},programUniforms:[{type:12,data:S},...H(s,d)]}},getShaderSource:p}}return p=w=>{let S=P(\"a\",n,s.length),$=N(\"output\",n,d.length);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n\n  ${eh(o,r,S,$)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",S.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},...H(s,d)]}},getShaderSource:p}},Ks=(e,t)=>{Xf(e.inputs,t.perm),e.compute(Oe(e.inputs[0],t.perm))},js=e=>re({perm:e.perm})});var nh,oh,ih,ah,sh,uh,dh,lh,ch,ph,nt,Zs,Qs,Ys,Xs,Js,eu,tu,ru,nu,ou,iu=G(()=>{\"use strict\";te();ae();ce();Hr();ct();nh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},oh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},ih={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},ah={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},sh=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},uh=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let o=t.map(a=>e[a]);return[n,o]},dh=(e,t)=>{let n=e.length+t.length,r=[],o=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?r.push(e[o++]):r.push(1);return r},lh=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},ch=(e,t)=>{let n=[];if(!lh(e,t)){for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);e.forEach(r=>n.push(r))}return n},ph=(e,t,n,r,o,a,s)=>{let d=n[0].dims,l=E.size(a),p=E.size(s),f=P(\"_A\",n[0].dataType,d),h=N(\"output\",o,a),y=64;l===1&&(y=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${y}>;\n       `,b=w=>`\n        ${w.registerUniform(\"reduceSize\",\"u32\").declareVariables(f,h)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${w.mainStart(y)}\n\n          let outputIndex = global_idx / ${y};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${ih[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${y}) {\n           let candidate = f32(${f.getByOffset(\"offset + k\")});\n           bestValue = ${nh[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${y}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${oh[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${h.setByOffset(\"outputIndex\",`${r===\"mean\"?`${h.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${h.type.storage}(${ah[r]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${y}`,inputDependencies:[\"type\"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},nt=(e,t,n,r)=>{let o=e.inputs.length===1?n:lo(e.inputs,n),a=o.axes;a.length===0&&!o.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((_,b)=>b));let s=E.normalizeAxes(a,e.inputs[0].dims.length),d=s,l=e.inputs[0],p=ch(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Oe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=sh(d.length,l.dims.length));let[f,h]=uh(l.dims,d),y=f;o.keepDims&&(y=dh(f,s)),e.compute(ph(t,o.cacheKey,[l],r,e.inputs[0].dataType,y,h),{inputs:[l]})},Zs=(e,t)=>{nt(e,\"ReduceMeanShared\",t,\"mean\")},Qs=(e,t)=>{nt(e,\"ReduceL1Shared\",t,\"l1\")},Ys=(e,t)=>{nt(e,\"ReduceL2Shared\",t,\"l2\")},Xs=(e,t)=>{nt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},Js=(e,t)=>{nt(e,\"ReduceMaxShared\",t,\"max\")},eu=(e,t)=>{nt(e,\"ReduceMinShared\",t,\"min\")},tu=(e,t)=>{nt(e,\"ReduceProdShared\",t,\"prod\")},ru=(e,t)=>{nt(e,\"ReduceSumShared\",t,\"sum\")},nu=(e,t)=>{nt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},ou=(e,t)=>{nt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var ot,mh,Fr,lo,it,fh,hh,gh,yh,bh,_h,wh,vh,$h,xh,at,au,su,uu,du,lu,cu,pu,mu,fu,hu,Hr=G(()=>{\"use strict\";te();ae();Ce();ce();iu();ot=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},mh=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Fr=(e,t,n,r,o,a,s=!1,d=!1)=>{let l=[],p=n[0].dims,f=p.length,h=E.normalizeAxes(o,f),y=!d&&h.length===0;p.forEach((S,$)=>{y||h.indexOf($)>=0?s&&l.push(1):l.push(S)});let _=l.length,b=E.size(l);return{name:e,shaderCache:t,getShaderSource:S=>{let $=[],v=P(\"_A\",n[0].dataType,f),T=N(\"output\",a,_),C=r(v,T,h),A=C[2];for(let k=0,O=0;k<f;k++)y||h.indexOf(k)>=0?(s&&O++,A=`for(var j${k}: u32 = 0; j${k} < ${p[k]}; j${k}++) {\n                  ${C[2].includes(\"last_index\")?`let last_index = j${k};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",k,`j${k}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",k,T.indicesGet(\"output_indices\",O))};`),O++);return`\n\n        ${S.registerUniform(\"output_size\",\"u32\").declareVariables(v,T)}\n\n        ${S.mainStart()}\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${T.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${C[0]}       // init ops for reduce max/min\n          ${C[1]}\n          ${A}\n          ${C[3]}\n          ${C.length===4?T.setByOffset(\"global_idx\",\"value\"):C.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...H(p,l)]})}},lo=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),re({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},it=(e,t,n,r)=>{let o=e.inputs,a=o.length===1?n:lo(o,n);e.compute(Fr(t,{hint:a.cacheKey,inputDependencies:[\"rank\"]},[o[0]],a.noopWithEmptyAxes&&a.axes.length===0?mh:r,a.axes,o[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},fh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},hh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL1\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${r.getByIndices(\"input_indices\")});`,\"\"])},gh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL2\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},yh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSumExp\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${r.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},bh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMax\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(r.indicesSet(\"input_indices\",d,0));return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = max(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},_h=(e,t)=>{ot(e.inputs),it(e,\"ReduceMean\",t,(r,o,a)=>{let s=1;for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&(s*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${r.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${s});`]})},wh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMin\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = min(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},vh=(e,t)=>{ot(e.inputs),it(e,\"ReduceProd\",t,(r,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${r.getByIndices(\"input_indices\")};`,\"\"])},$h=(e,t)=>{ot(e.inputs),it(e,\"ReduceSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"\"])},xh=(e,t)=>{ot(e.inputs),it(e,\"ReduceSumSquare\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},at=(e,t,n)=>{if(t.length===0)return n;let r=1,o=1;for(let a=0;a<t.length;a++)t.indexOf(a)===-1?r*=e[a]:o*=e[a];return o<32&&r>1024},au=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_h(e,t):Zs(e,t)},su=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hh(e,t):Qs(e,t)},uu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gh(e,t):Ys(e,t)},du=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yh(e,t):Xs(e,t)},lu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bh(e,t):Js(e,t)},cu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wh(e,t):eu(e,t)},pu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vh(e,t):tu(e,t)},mu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$h(e,t):ru(e,t)},fu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xh(e,t):nu(e,t)},hu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fh(e,t):ou(e,t)}});var gu,yu,bu,co,_u=G(()=>{\"use strict\";te();Ce();Hr();gu=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},yu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},bu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},co=e=>re(e)});var Sh,po,Th,Ch,Ih,Ut,Ah,wu,qr=G(()=>{\"use strict\";te();ae();Vr();ce();Sh=(e,t)=>{let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],d=e[5];if(s&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(n.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=n.dims[0],p=n.dims[1],f=n.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(r.dims[0]!==f)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==r.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let h=o.dims[0]/3,y=h,_=y;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");h=t.qkvHiddenSizes[0],y=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let b=p;if(h!==y)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==h+y+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let w=0;if(s){if(y!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(s.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(s.dims[4]!==y/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(w=s.dims[3])}let S=b+w,$=-1,v=0;if(a)throw new Error(\"Mask not supported\");if(s)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==S)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:w,kvSequenceLength:b,totalSequenceLength:S,maxSequenceLength:$,inputHiddenSize:f,hiddenSize:h,vHiddenSize:_,headSize:Math.floor(h/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},po=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Th=(e,t,n,r,o,a,s,d)=>{let l=ge(s?1:a),p=64,f=a/l;f<p&&(p=32);let h=Math.ceil(a/l/p),y=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:o},{type:12,data:f},{type:12,data:h}],_=_e(e.dataType,l),b=ze(1,l),w=[\"type\"];s&&w.push(\"type\"),d&&w.push(\"type\");let S=$=>{let v=N(\"x\",e.dataType,e.dims,l),T=[v],C=s?P(\"seq_lens\",s.dataType,s.dims):void 0;C&&T.push(C);let A=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&T.push(A);let k=ze(e.dataType),O=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(O).declareVariables(...T)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${po(C,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${s?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${b}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${b}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${b}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${b}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${k}(1.0) / ${k}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${b}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${s?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${k}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:w},getShaderSource:S,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(a/p),y:o,z:t*n},programUniforms:y})}},Ch=(e,t,n,r,o,a,s,d,l)=>{let p=s+a.kvSequenceLength,f=[a.batchSize,a.numHeads,a.sequenceLength,p],h=e>1&&r,y=a.kvNumHeads?a.kvNumHeads:a.numHeads,_=h?[a.batchSize,y,p,a.headSize]:void 0,b=a.nReps?a.nReps:1,w=a.scale===0?1/Math.sqrt(a.headSize):a.scale,S=ge(a.headSize),$=a.headSize/S,v=12,T={x:Math.ceil(p/v),y:Math.ceil(a.sequenceLength/v),z:a.batchSize*a.numHeads},C=[{type:12,data:a.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:w},{type:12,data:s},{type:12,data:a.kvSequenceLength},{type:12,data:b}],A=h&&r&&E.size(r.dims)>0,k=[\"type\",\"type\"];A&&k.push(\"type\"),o&&k.push(\"type\"),d&&k.push(\"type\"),l&&k.push(\"type\");let O=[{dims:f,dataType:t.dataType,gpuDataType:0}];h&&O.push({dims:_,dataType:t.dataType,gpuDataType:0});let M=V=>{let F=P(\"q\",t.dataType,t.dims,S),j=P(\"key\",n.dataType,n.dims,S),ne=[F,j];if(A){let Z=P(\"past_key\",r.dataType,r.dims,S);ne.push(Z)}o&&ne.push(P(\"attention_bias\",o.dataType,o.dims));let W=d?P(\"seq_lens\",d.dataType,d.dims):void 0;W&&ne.push(W);let J=l?P(\"total_sequence_length_input\",l.dataType,l.dims):void 0;J&&ne.push(J);let ve=N(\"output\",t.dataType,f),Q=[ve];h&&Q.push(N(\"present_key\",t.dataType,_,S));let ee=ze(1,S),le=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${F.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${F.type.storage}, ${v*v}>;\n  ${V.registerUniforms(le).declareVariables(...ne,...Q)}\n  ${V.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${b===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${b===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${po(W,J,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&h?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${h?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${ee}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${A&&h?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`}\n      ${h?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(S){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${S}`)}})()};\n        output[outputIdx] = ${ve.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${S};${o!==void 0};${r!==void 0};${e}`,inputDependencies:k},getRunData:()=>({outputs:O,dispatchGroup:T,programUniforms:C}),getShaderSource:M}},Ih=(e,t,n,r,o,a,s=void 0,d=void 0)=>{let l=a+o.kvSequenceLength,p=o.nReps?o.nReps:1,f=o.vHiddenSize*p,h=e>1&&r,y=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=h?[o.batchSize,y,l,o.headSize]:void 0,b=[o.batchSize,o.sequenceLength,f],w=12,S={x:Math.ceil(o.vHeadSize/w),y:Math.ceil(o.sequenceLength/w),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:f},{type:12,data:a},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=h&&r&&E.size(r.dims)>0,T=[\"type\",\"type\"];v&&T.push(\"type\"),s&&T.push(\"type\"),d&&T.push(\"type\");let C=[{dims:b,dataType:t.dataType,gpuDataType:0}];h&&C.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=k=>{let O=P(\"probs\",t.dataType,t.dims),M=P(\"v\",n.dataType,n.dims),V=[O,M];v&&V.push(P(\"past_value\",r.dataType,r.dims));let F=s?P(\"seq_lens\",s.dataType,s.dims):void 0;s&&V.push(F);let j=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&V.push(j);let W=[N(\"output\",t.dataType,b)];h&&W.push(N(\"present_value\",t.dataType,_));let J=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${w}u;\n  var<workgroup> tileQ: array<${O.type.value}, ${w*w}>;\n  var<workgroup> tileV: array<${O.type.value}, ${w*w}>;\n  ${k.registerUniforms(J).declareVariables(...V,...W)}\n  ${k.mainStart([w,w,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${po(F,j,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&h?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${h?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${O.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${v&&h?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`}\n        ${h?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${r!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:C,dispatchGroup:S,programUniforms:$}),getShaderSource:A}},Ut=(e,t,n,r,o,a,s,d,l,p,f=void 0,h=void 0)=>{let y=Math.min(e.outputCount,1+(s?1:0)+(d?1:0)),_=y>1?p.pastSequenceLength:0,b=_+p.kvSequenceLength,w=l&&E.size(l.dims)>0?l:void 0,S=[t,n];y>1&&s&&E.size(s.dims)>0&&S.push(s),w&&S.push(w),f&&S.push(f),h&&S.push(h);let $=e.compute(Ch(y,t,n,s,w,p,_,f,h),{inputs:S,outputs:y>1?[-1,1]:[-1]})[0];e.compute(Th($,p.batchSize,p.numHeads,_,p.sequenceLength,b,f,h),{inputs:f&&h?[$,f,h]:[$],outputs:[]});let v=[$,r];y>1&&d&&E.size(d.dims)>0&&v.push(d),f&&v.push(f),h&&v.push(h),e.compute(Ih(y,$,r,d,p,_,f,h),{inputs:v,outputs:y>1?[0,2]:[0]})},Ah=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,o=t.inputHiddenSize,a=t.headSize,s=12,d={x:Math.ceil(t.headSize/s),y:Math.ceil(t.sequenceLength/s),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:r},{type:12,data:o},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],f=h=>{let y=N(\"output_q\",l[0].dataType,n),_=N(\"output_k\",l[0].dataType,n),b=N(\"output_v\",l[0].dataType,n),w=P(\"input\",l[0].dataType,l[0].dims),S=P(\"weight\",l[1].dataType,l[1].dims),$=P(\"bias\",l[2].dataType,l[2].dims),v=w.type.storage,T=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileInput: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightQ: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightK: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightV: array<${v}, ${s*s}>;\n  ${h.registerUniforms(T).declareVariables(w,S,$,y,_,b)}\n  ${h.mainStart([s,s,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:f},{inputs:l,outputs:[-1,-1,-1]})},wu=(e,t)=>{let n=Sh(e.inputs,t),[r,o,a]=Ah(e,n);return Ut(e,r,o,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}});var kh,Eh,Ph,vu,$u=G(()=>{\"use strict\";Ge();te();ae();Ce();ce();kh=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let n=(r,o,a)=>{let s=o.length;if(s!==r.length)throw new Error(`${a}: num dimensions != ${s}`);o.forEach((d,l)=>{if(d!==r[l])throw new Error(`${a}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let r=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,\"Invalid input scale\"),n(e[2].dims,r,\"Invalid input B\"),n(e[3].dims,r,\"Invalid input mean\"),n(e[4].dims,r,\"Invalid input var\")}else n(e[1].dims,[1],\"Invalid input scale\"),n(e[2].dims,[1],\"Invalid input B\"),n(e[3].dims,[1],\"Invalid input mean\"),n(e[4].dims,[1],\"Invalid input var\")},Eh=(e,t)=>{let{epsilon:n,spatial:r,format:o}=t,a=e[0].dims,s=r?ge(a[a.length-1]):1,d=o===\"NHWC\"&&a.length>1?s:1,l=E.size(a)/s,p=r,f=p?a.length:a,h=P(\"x\",e[0].dataType,e[0].dims,s),y=P(\"scale\",e[1].dataType,e[1].dims,d),_=P(\"bias\",e[2].dataType,e[2].dims,d),b=P(\"inputMean\",e[3].dataType,e[3].dims,d),w=P(\"inputVar\",e[4].dataType,e[4].dims,d),S=N(\"y\",e[0].dataType,f,s),$=()=>{let T=\"\";if(r)T=`let cOffset = ${a.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${a.length-1}] / ${s}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")T=`\n            ${S.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${S.indicesToOffset(\"outputIndices\")};`;else{T=`var cIndices = ${y.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let C=1;C<y.rank;C++)T+=`cIndices[${C}] = outputIndices[${C}];`;T+=`let cOffset = ${y.indicesToOffset(\"cIndices\")};`}return T},v=T=>`\n  const epsilon = ${n};\n  ${T.registerUniform(\"outputSize\",\"u32\").declareVariables(h,y,_,b,w,S)}\n  ${T.mainStart()}\n  ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${S.offsetToIndices(`global_idx * ${s}`)};\n    ${$()}\n    let scale = ${y.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${b.getByOffset(\"cOffset\")};\n    let inputVar = ${w.getByOffset(\"cOffset\")};\n    let x = ${h.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${S.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${s}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...H(a)]:[{type:12,data:l}]})}},Ph=e=>re(e),vu=(e,t)=>{let{inputs:n,outputCount:r}=e,o=Ph({...t,outputCount:r});if(we.webgpu.validateInputContent&&kh(n,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Eh(n,o))}});var zh,Oh,xu,Su=G(()=>{\"use strict\";ae();ce();zh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Oh=e=>{let t=e[0].dims,n=e[0].dims[2],r=E.size(t)/4,o=e[0].dataType,a=P(\"input\",o,t,4),s=P(\"bias\",o,[n],4),d=P(\"residual\",o,t,4),l=N(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:f=>`\n  const channels = ${n}u / 4;\n  ${f.declareVariables(a,s,d,l)}\n\n  ${f.mainStart()}\n    ${f.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${a.getByOffset(\"global_idx\")}\n      + ${s.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},xu=e=>{zh(e.inputs),e.compute(Oh(e.inputs))}});var Dh,ye,Tu,Cu,Iu,Au,ku,Eu,Pu,zu,Ou,Bh,Du,Bu,Mu,Ru,tr,Uu,Kr,Nu,Vu,Wu,Lu,Gu,Hu,Fu,qu,Ku,ju,Zu,Qu,Yu,Xu,Ju,ed,td,rd,mo,fo,nd,od,id,Mh,Rh,ad,jr=G(()=>{\"use strict\";te();ae();Ce();ce();Dh=(e,t,n,r,o,a,s)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=P(\"inputData\",n,[d],4),f=N(\"outputData\",r,[d],4),h=[{name:\"vec_size\",type:\"u32\"}];return s&&h.push(...s),`\n      ${e.registerUniforms(h).declareVariables(p,f)}\n\n  ${a??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${f.setByOffset(\"global_idx\",l)}\n  }`},ye=(e,t,n,r,o,a=e.dataType,s,d)=>{let l=[{type:12,data:Math.ceil(E.size(e.dims)/4)}];return s&&l.push(...s),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Dh(p,E.size(e.dims),e.dataType,a,n,r,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(E.size(p[0].dims)/64/4)},programUniforms:l})}},Tu=e=>{e.compute(ye(e.inputs[0],\"Abs\",\"abs\"))},Cu=e=>{e.compute(ye(e.inputs[0],\"Acos\",\"acos\"))},Iu=e=>{e.compute(ye(e.inputs[0],\"Acosh\",\"acosh\"))},Au=e=>{e.compute(ye(e.inputs[0],\"Asin\",\"asin\"))},ku=e=>{e.compute(ye(e.inputs[0],\"Asinh\",\"asinh\"))},Eu=e=>{e.compute(ye(e.inputs[0],\"Atan\",\"atan\"))},Pu=e=>{e.compute(ye(e.inputs[0],\"Atanh\",\"atanh\"))},zu=e=>re(e),Ou=(e,t)=>{let n;switch(t.to){case 10:n=\"vec4<f16>\";break;case 1:n=\"vec4<f32>\";break;case 12:n=\"vec4<u32>\";break;case 6:n=\"vec4<i32>\";break;case 9:n=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(ye(e.inputs[0],\"Cast\",n,void 0,t.cacheKey,t.to))},Bh=e=>{let t,n,r=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return re({min:t,max:n})},Du=(e,t)=>{let n=t||Bh(e.inputs),r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:\"min\",type:r},{name:\"max\",type:r}]),{inputs:[0]})},Bu=e=>{e.compute(ye(e.inputs[0],\"Ceil\",\"ceil\"))},Mu=e=>{e.compute(ye(e.inputs[0],\"Cos\",\"cos\"))},Ru=e=>{e.compute(ye(e.inputs[0],\"Cosh\",\"cosh\"))},tr=e=>re(e),Uu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Elu\",r=>`elu_vf32(${r})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Kr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Nu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Erf\",n=>`erf_vf32(${n})`,Kr(t)))},Vu=e=>{e.compute(ye(e.inputs[0],\"Exp\",\"exp\"))},Wu=e=>{e.compute(ye(e.inputs[0],\"Floor\",\"floor\"))},Lu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Gelu\",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Kr(t)))},Gu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"LeakyRelu\",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Hu=e=>{e.compute(ye(e.inputs[0],\"Not\",t=>`!${t}`))},Fu=e=>{e.compute(ye(e.inputs[0],\"Neg\",t=>`-${t}`))},qu=e=>{e.compute(ye(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},Ku=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Relu\",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},ju=e=>{e.compute(ye(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},Zu=e=>re(e),Qu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"HardSigmoid\",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${r} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},Yu=e=>{e.compute(ye(e.inputs[0],\"Sin\",\"sin\"))},Xu=e=>{e.compute(ye(e.inputs[0],\"Sinh\",\"sinh\"))},Ju=e=>{e.compute(ye(e.inputs[0],\"Sqrt\",\"sqrt\"))},ed=e=>{e.compute(ye(e.inputs[0],\"Tan\",\"tan\"))},td=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,rd=e=>{e.compute(ye(e.inputs[0],\"Tanh\",td))},mo=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${td(\"v\")};\n}\n`,fo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,nd=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"FastGelu\",fo,mo(t),void 0,e.inputs[0].dataType))},od=(e,t)=>{let n=ze(e.inputs[0].dataType);return e.compute(ye(e.inputs[0],\"ThresholdedRelu\",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},id=e=>{e.compute(ye(e.inputs[0],\"Log\",\"log\"))},Mh=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Rh=e=>`quick_gelu_impl(${e})`,ad=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"QuickGelu\",Rh,Mh(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Uh,Nh,ud,dd=G(()=>{\"use strict\";ae();ce();jr();Uh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Nh=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=P(\"input\",e[0].dataType,e[0].dims,4),r=P(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=N(\"output\",e[0].dataType,t,4),a=E.size(t)/4,s=_e(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(n,r,o)}\n\n  ${Kr(s)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},ud=e=>{Uh(e.inputs),e.compute(Nh(e.inputs))}});var Vh,Wh,st,ld,cd,pd,md,fd,hd,gd,yd,bd,_d,wd=G(()=>{\"use strict\";te();ae();ce();Vh=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y,_;typeof d==\"string\"?y=_=(v,T)=>`${d}((${v}),(${T}))`:typeof d==\"function\"?y=_=d:(y=d.scalar,_=d.vector);let b=N(\"outputData\",f,r.length,4),w=P(\"aData\",l,t.length,4),S=P(\"bData\",p,n.length,4),$;if(o)if(a){let v=E.size(t)===1,T=E.size(n)===1,C=t.length>0&&t[t.length-1]%4===0,A=n.length>0&&n[n.length-1]%4===0;v||T?$=b.setByOffset(\"global_idx\",_(v?`${w.type.value}(${w.getByOffset(\"0\")}.x)`:w.getByOffset(\"global_idx\"),T?`${S.type.value}(${S.getByOffset(\"0\")}.x)`:S.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${b.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${w.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            let offsetB = ${S.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            ${b.setByOffset(\"global_idx\",_(s||C?w.getByOffset(\"offsetA / 4u\"):`${w.type.value}(${w.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,s||A?S.getByOffset(\"offsetB / 4u\"):`${S.type.value}(${S.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=b.setByOffset(\"global_idx\",_(w.getByOffset(\"global_idx\"),S.getByOffset(\"global_idx\")));else{if(!a)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(T,C,A=\"\")=>{let k=`aData[indexA${C}][componentA${C}]`,O=`bData[indexB${C}][componentB${C}]`;return`\n            let outputIndices${C} = ${b.offsetToIndices(`global_idx * 4u + ${C}u`)};\n            let offsetA${C} = ${w.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let offsetB${C} = ${S.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let indexA${C} = offsetA${C} / 4u;\n            let indexB${C} = offsetB${C} / 4u;\n            let componentA${C} = offsetA${C} % 4u;\n            let componentB${C} = offsetB${C} % 4u;\n            ${T}[${C}] = ${A}(${y(k,O)});\n          `};f===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(w,S,b)}\n\n        ${h??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Wh=(e,t,n,r,o,a,s=n.dataType)=>{let d=n.dims.map(w=>Number(w)??1),l=r.dims.map(w=>Number(w)??1),p=!E.areEqual(d,l),f=d,h=E.size(d),y=!1,_=!1,b=[p];if(p){let w=rt.calcShape(d,l,!1);if(!w)throw new Error(\"Can't perform binary op on the given tensors\");f=w.slice(),h=E.size(f);let S=E.size(d)===1,$=E.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;b.push(S),b.push($),b.push(v),b.push(T);let C=1;for(let A=1;A<f.length;A++){let k=d[d.length-A],O=l[l.length-A];if(k===O)C*=k;else break}C%4===0?(_=!0,y=!0):(S||$||v||T)&&(y=!0)}else y=!0;return b.push(y),{name:e,shaderCache:{hint:t+b.map(w=>w.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:w=>Vh(w,d,l,f,y,p,_,o,n.dataType,r.dataType,s,a),getRunData:()=>({outputs:[{dims:f,dataType:s}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(E.size(f)/4)},...H(d,l,f)]})}},st=(e,t,n,r,o,a)=>{e.compute(Wh(t,o??\"\",e.inputs[0],e.inputs[1],n,r,a))},ld=e=>{st(e,\"Add\",(t,n)=>`${t}+${n}`)},cd=e=>{st(e,\"Div\",(t,n)=>`${t}/${n}`)},pd=e=>{st(e,\"Equal\",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},md=e=>{st(e,\"Mul\",(t,n)=>`${t}*${n}`)},fd=e=>{let t=P(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;st(e,\"Pow\",{scalar:(r,o)=>`pow_custom(${r},${o})`,vector:(r,o)=>`pow_vector_custom(${r},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},hd=e=>{st(e,\"Sub\",(t,n)=>`${t}-${n}`)},gd=e=>{st(e,\"Greater\",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},yd=e=>{st(e,\"Less\",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},bd=e=>{st(e,\"GreaterOrEqual\",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},_d=e=>{st(e,\"LessOrEqual\",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}});var Gh,Hh,Fh,qh,vd,$d,xd=G(()=>{\"use strict\";te();ae();Ce();ce();Gh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let n=0,r=e[n],o=r.dataType,a=r.dims.length;e.forEach((s,d)=>{if(d!==n){if(s.dataType!==o)throw new Error(\"input tensors should be one type\");if(s.dims.length!==a)throw new Error(\"input tensors should have the same shape\");s.dims.forEach((l,p)=>{if(p!==t&&l!==r.dims[p])throw new Error(\"non concat dimensions must match\")})}})},Hh=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Fh=(e,t)=>{let n=e.length,r=[];for(let o=0;o<n;++o){let a=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));n===1?r.push(a):o===0?r.push(`if (inputIndex == ${o}u) { ${a} }`):o===n-1?r.push(`else { ${a} }`):r.push(`else if (inputIndex == ${o}) { ${a} }`)}return r.join(`\n`)},qh=(e,t,n,r)=>{let o=E.size(n),a=new Array(e.length),s=new Array(e.length),d=0,l=[],p=[],f=[{type:12,data:o}];for(let w=0;w<e.length;++w)d+=e[w].dims[t],a[w]=d,p.push(e[w].dims.length),s[w]=P(`input${w}`,r,p[w]),l.push(\"rank\"),f.push({type:12,data:a[w]});for(let w=0;w<e.length;++w)f.push(...H(e[w].dims));f.push(...H(n));let h=N(\"output\",r,n.length),y=h.indicesGet(\"indices\",t),_=Array.from(Array(a.length).keys()).map(w=>`uniforms.sizeInConcatAxis${w}`).join(\",\"),b=w=>`\n\n  ${(()=>{w.registerUniform(\"outputSize\",\"u32\");for(let S=0;S<e.length;S++)w.registerUniform(`sizeInConcatAxis${S}`,\"u32\");return w.declareVariables(...s,h)})()}\n\n  ${Hh(a.length,_)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${h.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${y});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${_});\n      ${y} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Fh(s,h)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:b}},vd=(e,t)=>{let n=e.inputs,r=n[0].dims,o=E.normalizeAxis(t.axis,r.length);Gh(n,o);let a=r.slice();a[o]=n.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let s=n.filter(d=>E.size(d.dims)>0);e.compute(qh(s,o,a,n[0].dataType),{inputs:s})},$d=e=>re({axis:e.axis})});var je,Ze,Qe,Zr,vt=G(()=>{\"use strict\";te();ae();je=(e,t,n=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ze=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Qe=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},Zr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}else if(t===\"Clip\"){let[n,r]=e?.activation_params||[Ls,Gs];return{activation:t,clipMax:r,clipMin:n}}else if(t===\"LeakyRelu\"){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}});var Ee,Sd,Qr=G(()=>{\"use strict\";Ee=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Sd=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Td,Cd=G(()=>{\"use strict\";Td=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var rr,Yr,Xr=G(()=>{\"use strict\";te();ae();ce();vt();rr=(e,t,n,r,o)=>{let a=r-n;return`\n      ${Array.from({length:n}).map((s,d)=>`\n      if (${K(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,K(o,d+a,r))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Yr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s[s.length-2],p=d[d.length-1],f=s[s.length-1],h=ge(p),y=ge(f),_=ge(l),b=E.size(n)/h/_,w=e.length>2,S=r?r.slice(0,-2):n.slice(0,-2),v=[E.size(S),l,p],T=[{type:12,data:b},{type:12,data:l},{type:12,data:p},{type:12,data:f}];Ze(t,T),T.push(...H(S,s,d)),w&&T.push(...H(e[2].dims)),T.push(...H(v));let C=A=>{let k=Gr(\"batch_dims\",e[0].dataType,S.length),O=P(\"a\",e[0].dataType,s.length,y),M=P(\"b\",e[1].dataType,d.length,h),V=N(\"output\",e[0].dataType,v.length,h),F=_e(V.type.tensor),j=je(t,V.type.value,F),ne=[O,M],W=\"\";if(w){let Q=o?h:1;ne.push(P(\"bias\",e[2].dataType,e[2].dims.length,Q)),W=`${o?`value += bias[col / ${Q}];`:`value += ${V.type.value}(bias[row + i]);`}`}let J=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Qe(t,J);let ve=()=>{let Q=`var a_data: ${O.type.value};`;for(let ee=0;ee<y;ee++)Q+=`\n              let b_data${ee} = b[(b_offset + (k + ${ee}) * uniforms.N + col) / ${h}];`;for(let ee=0;ee<_;ee++){Q+=`a_data = a[(a_offset + (row + ${ee}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)Q+=`\n            values[${ee}] = fma(${M.type.value}(a_data${y===1?\"\":`[${le}]`}), b_data${le}, values[${ee}]);\n`}return Q};return`\n  ${A.registerUniforms(J).registerInternalVariables(k).declareVariables(...ne,V)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${n.length===2?\"\":`let batch_indices = ${k.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${O.type.indices};\n    ${rr(\"a_indices\",O,O.rank-2,k.rank,\"batch_indices\")}\n    ${O.indicesSet(\"a_indices\",O.rank-2,0)}\n    ${O.indicesSet(\"a_indices\",O.rank-1,0)}\n    let a_offset = ${O.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${M.type.indices};\n    ${rr(\"b_indices\",M,M.rank-2,k.rank,\"batch_indices\")}\n    ${M.indicesSet(\"b_indices\",M.rank-2,0)}\n    ${M.indicesSet(\"b_indices\",M.rank-1,0)}\n    let b_offset = ${M.indicesToOffset(\"b_indices\")};\n    var values: array<${V.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${ve()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${W}\n      ${j}\n      let cur_indices = ${V.type.indices}(batch, row + i, col);\n      let offset = ${V.indicesToOffset(\"cur_indices\")};\n      ${V.setByOffset(`offset / ${h}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${h};${y};${_};${o}`,inputDependencies:w?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:T}),getShaderSource:C}}});var Kh,jh,ho,Id,Zh,go,Qh,nr,Jr=G(()=>{\"use strict\";te();ae();ce();vt();Xr();Qr();Kh=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,jh=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,ho=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],f=o?l:a,h=o?a:l,y=f/t[0],_=a/t[1];if(!((o&&y===4&&e[1]===4||!o&&(y===3||y===4))&&f%t[0]===0&&a%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${y} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${y} must be 3 or 4.\n  tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${y}<${n}>, ${f/y}>, ${h}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${p/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${y};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?\"0\":\"i32(globalId.z)\"};\n  ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Kh(o,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${y===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${jh(o,y)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Id=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,Zh=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",go=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32,l=!1)=>{let p=e[1]*t[1],f=e[0]*t[0],h=o?p:a,y=o?a:p;if(!(y%t[1]===0&&h%t[0]===0&&a%t[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let _=y/t[1],b=h/t[0],w=a/t[1],S=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${f};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          ${Id(o,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${b};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Id(o,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Zh(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${h}>, ${y}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${f}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?\"0\":\"i32(globalId.z)\"};\n    ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${S}\n  }\n`},Qh=(e,t,n,r,o=!1)=>{let[a,s,d,l]=r,p=_e(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${s.type.indices};\n        ${rr(\"aIndices\",s,s.rank-2,a.rank,\"batchIndices\")}\n        ${s.indicesSet(\"aIndices\",s.rank-2,\"u32(row)\")}\n        ${s.indicesSet(\"aIndices\",s.rank-1,\"u32(colIn)\")}\n        value = ${s.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${rr(\"bIndices\",d,d.rank-2,a.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ee(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ee(e,p)}(bias[row])`};`:\"\"}\n        ${n}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},nr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s.slice(0,-2),p=d.slice(0,-2),f=r?r.slice(0,-2):n.slice(0,-2),h=E.size(f),y=s[s.length-2],_=s[s.length-1],b=d[d.length-1],w=_%4===0&&b%4===0,S=y<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(b/$[0]/S[0]),Math.ceil(y/$[1]/S[1]),Math.ceil(h/$[2]/S[2])],T=w?4:1,C=[...l,y,_/T],A=C.length,k=[...p,_,b/T],O=k.length,M=[h,y,b/T],V=[{type:6,data:y},{type:6,data:b},{type:6,data:_}];Ze(t,V),V.push(...H(f,C,k));let F=[\"rank\",\"rank\"],j=e.length>2;j&&(V.push(...H(e[2].dims)),F.push(\"rank\")),V.push(...H(M));let ne=W=>{let J=f.length,ve=Gr(\"batchDims\",e[0].dataType,J,1),Q=_e(e[0].dataType),ee=P(\"a\",e[0].dataType,A,T),le=P(\"b\",e[1].dataType,O,T),Z=N(\"result\",e[0].dataType,M.length,T),pe=[ee,le];if(j){let Y=o?T:1;pe.push(P(\"bias\",e[2].dataType,e[2].dims.length,Y))}let ke=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Qe(t,ke);let Se=_e(Z.type.tensor),D=je(t,Z.type.value,Se),R=Qh(T,j,D,[ve,ee,le,Z],o);return`\n  ${W.registerUniforms(ke).registerInternalVariables(ve).declareVariables(...pe,Z)}\n  ${R}\n  ${w?ho(S,$,Q,ve):go(S,$,Q,ve)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${S};${t.activation};${w};${o}`,inputDependencies:F},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:V}),getShaderSource:ne}}});var Yh,Ad,kd=G(()=>{\"use strict\";te();tt();ce();vt();Qr();Cd();Jr();Yh=(e,t,n,r,o=!1,a,s=4,d=4,l=4,p=\"f32\")=>{let f=F=>{switch(F){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},h=F=>{switch(F){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},y=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,b=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",w=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",S=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${S} / outWidth;\n    let outCol = ${S} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ee(s,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${w}) {\n      ${y}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${f(s)}\n    }\n    return resData;`,T=e?t&&r?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`,C=e?r&&n?h(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`,A=Ee(l,p),k=e?Ee(s,p):Ee(d,p),O=e?Ee(d,p):Ee(s,p),M=je(a,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?T:C}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${O} {\n      ${e?C:T}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Sd(o)}\n      ${M}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ad=(e,t,n,r,o,a,s,d,l)=>{let p=t.format===\"NHWC\",f=p?e[0].dims[3]:e[0].dims[1],h=n[0],y=p?n[2]:n[3],_=p?n[1]:n[2],b=p?n[3]:n[1],w=p&&(f%4===0||f%3===0)&&b%4===0,S=p?b:y*_,$=p?y*_:b,v=[8,8,1],T=r<=8?[4,1,1]:[4,4,1],C=[Math.ceil(S/v[0]/T[0]),Math.ceil($/v[1]/T[1]),Math.ceil(h/v[2]/T[2])];me(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let A=w?p&&f%4!==0?3:4:1,k=v[1]*T[1],O=v[0]*T[0],M=Math.max(v[0]*A,v[1]),V=r%k===0,F=o%O===0,j=a%M===0,ne=w?[A,4,4]:[1,1,1],W=[{type:6,data:r},{type:6,data:o},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ze(t,W),W.push(...H(e[0].dims,e[1].dims));let J=[\"rank\",\"rank\"];s&&(W.push(...H(e[2].dims)),J.push(\"rank\")),W.push(...H(n));let ve=Q=>{let ee=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Qe(t,ee);let le=w?4:1,Z=_e(e[0].dataType),pe=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        result[flatIndex] = ${w?`vec4<${Z}>`:Z}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${w?\"/ 4\":\"\"}, value);\n      }`,ke=P(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),Se=P(\"w\",e[1].dataType,e[1].dims.length,le),D=[ke,Se],R=N(\"result\",e[0].dataType,n.length,le);if(s){let Y=P(\"bias\",e[2].dataType,e[2].dims.length,le);D.push(Y),pe+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${Z}>`:Z} {\n          return bias[coords.${p?\"w\":\"y\"}${w?\"/ 4\":\"\"}];\n        }`}return`\n        ${Td(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Q.registerUniforms(ee).declareVariables(...D,R)}\n        ${pe}\n        ${Yh(p,V,F,j,s,t,ne[0],ne[1],ne[2],Z)}\n        ${w?ho(T,v,Z,void 0,!p,M):go(T,v,Z,void 0,!p,M,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${w};${V};${F};${j};${k};${O};${M}`,inputDependencies:J},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:W}),getShaderSource:ve}}});var Xh,Ed,en,Jh,Pd,eg,zd,Od,Dd=G(()=>{\"use strict\";te();tt();ae();ce();vt();Qr();Xh=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Ed=e=>typeof e==\"number\"?[e,e,e]:e,en=(e,t)=>t<=1?e:e+(e-1)*(t-1),Jh=(e,t,n,r=1)=>{let o=en(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)},Pd=(e,t,n,r,o)=>{o==null&&(o=Jh(e,t[0],r[0]));let a=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*o>=t[s]&&(a[s]=Math.trunc((e[s]-t[s]+2*o)/r[s]+1));return a},eg=(e,t,n,r,o,a,s,d,l,p)=>{let f,h,y,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){f={top:e,bottom:e,left:e,right:e,front:e,back:e};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e);h=b[0],y=b[1],_=b[2]}else if(Array.isArray(e)){if(!e.every((w,S,$)=>w===$[0]))throw Error(`Unsupported padding parameter: ${e}`);f={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e[0]);h=b[0],y=b[1],_=b[2]}else if(e===\"SAME_UPPER\"){h=Math.ceil(t/o),y=Math.ceil(n/a),_=Math.ceil(r/s);let b=(h-1)*o+d-t,w=(y-1)*a+l-n,S=(_-1)*s+p-r,$=Math.floor(b/2),v=b-$,T=Math.floor(w/2),C=w-T,A=Math.floor(S/2),k=S-A;f={top:T,bottom:C,left:A,right:k,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:h,outHeight:y,outWidth:_}},zd=(e,t,n,r,o,a=!1,s=\"channelsLast\")=>{let d,l,p,f,h;if(s===\"channelsLast\")[d,l,p,f,h]=e;else if(s===\"channelsFirst\")[d,h,l,p,f]=e;else throw new Error(`Unknown dataFormat ${s}`);let[y,,_,b,w]=t,[S,$,v]=Ed(n),[T,C,A]=Ed(r),k=en(_,T),O=en(b,C),M=en(w,A),{padInfo:V,outDepth:F,outHeight:j,outWidth:ne}=eg(o,l,p,f,S,$,v,k,O,M),W=a?y*h:y,J=[0,0,0,0,0];return s===\"channelsFirst\"?J=[d,W,F,j,ne]:s===\"channelsLast\"&&(J=[d,F,j,ne,W]),{batchSize:d,dataFormat:s,inDepth:l,inHeight:p,inWidth:f,inChannels:h,outDepth:F,outHeight:j,outWidth:ne,outChannels:W,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:b,filterWidth:w,effectiveFilterDepth:k,effectiveFilterHeight:O,effectiveFilterWidth:M,dilationDepth:T,dilationHeight:C,dilationWidth:A,inShape:e,outShape:J,filterShape:t}},Od=(e,t,n,r,o,a)=>{let s=a===\"channelsLast\",d=s?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],f={x:n.map((v,T)=>T)},h=[Math.ceil(Xh(f.x.map(v=>n[v]))/p[0]),1,1];me(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${h}`);let y=l?s&&d%4!==0?3:4:1,_=E.size(n),b=[{type:12,data:_},{type:12,data:r},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];Ze(t,b),b.push(...H(e[0].dims,e[1].dims));let w=[\"rank\",\"rank\"],S=e.length===3;S&&(b.push(...H(e[2].dims)),w.push(\"rank\")),b.push(...H(n));let $=v=>{let T=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:r.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];Qe(t,T);let C=l?4:1,A=_e(e[0].dataType),k=P(\"x\",e[0].dataType,e[0].dims.length,y===3?1:y),O=P(\"W\",e[1].dataType,e[1].dims.length,C),M=[k,O],V=N(\"result\",e[0].dataType,n.length,C),F=\"\";if(S){let W=P(\"bias\",e[2].dataType,e[2].dims.length,C);M.push(W),F+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${s?K(\"coords\",4,5):K(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let j=Ee(y,A),ne=je(t,j,A);return`\n            ${F}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${k.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${O.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(T).declareVariables(...M,V)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${V.offsetToIndices(\"global_idx\")};\n              let batch = ${K(\"coords\",0,k.rank)};\n              let d2 = ${s?K(\"coords\",k.rank-1,k.rank):K(\"coords\",1,k.rank)};\n              let xFRCCorner = vec3<u32>(${s?K(\"coords\",1,k.rank):K(\"coords\",2,k.rank)},\n              ${s?K(\"coords\",2,k.rank):K(\"coords\",3,k.rank)},\n              ${s?K(\"coords\",3,k.rank):K(\"coords\",4,k.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${s?K(\"uniforms.x_shape\",1,k.rank):K(\"uniforms.x_shape\",2,k.rank)};\n              let xShapeZ = ${s?K(\"uniforms.x_shape\",2,k.rank):K(\"uniforms.x_shape\",3,k.rank)};\n              let xShapeW = ${s?K(\"uniforms.x_shape\",3,k.rank):K(\"uniforms.x_shape\",4,k.rank)};\n              let xShapeU = ${s?K(\"uniforms.x_shape\",4,k.rank):K(\"uniforms.x_shape\",1,k.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${s?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${s?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${s?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${s?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${S?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${ne}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${s};${y};${S}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:b}),getShaderSource:$}}});var Bd,Md,Rd=G(()=>{\"use strict\";te();ae();ce();vt();Bd=(e,t,n,r)=>{let o=e.length>2,a=o?\"value += b[output_channel];\":\"\",s=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?n[3]:n[1],f=p/t.group,h=l&&f>=4?ge(p):1,y=E.size(n)/h,_=[{type:12,data:y},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:f}];Ze(t,_),_.push(...H(s,[d[0],d[1],d[2],d[3]/h]));let b=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...H([n[0],n[1],n[2],n[3]/h]));let w=S=>{let $=N(\"output\",e[0].dataType,n.length,h),v=_e($.type.tensor),T=je(t,$.type.value,v),C=P(\"x\",e[0].dataType,s.length),A=P(\"w\",e[1].dataType,d.length,h),k=[C,A];o&&k.push(P(\"b\",e[2].dataType,e[2].dims,h));let O=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];Qe(t,O);let M=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${C.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${C.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${S.registerUniforms(O).declareVariables(...k,$)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${h} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${M}\n    ${a}\n    ${T}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${h}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},Md=(e,t,n,r)=>{let o=e.length>2,a=ge(n[3]),s=ge(n[2]),d=E.size(n)/a/s,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],f=[n[0],n[1],n[2],n[3]/a],h=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ze(t,h),h.push(...H(l,p,f));let y=(s-1)*t.strides[1]+p[1],_=b=>{let w=N(\"output\",e[0].dataType,f.length,a),S=_e(w.type.tensor),$=je(t,w.type.value,S),v=P(\"x\",e[0].dataType,l.length,a),T=P(\"w\",e[1].dataType,p.length,a),C=[v,T];o&&C.push(P(\"b\",e[2].dataType,e[2].dims,a));let A=o?\"value += b[output_channel];\":\"\",k=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Qe(t,k),`\n  ${b.registerUniforms(k).declareVariables(...C,w)}\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${y}>;\n    var values: array<${w.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${T.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${w.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${a};${s};${y};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:_}}});var tg,yo,rg,bo,_o,Ud,ng,og,wo,Nd=G(()=>{\"use strict\";ae();kd();Dd();Jr();Rd();vt();Xr();ct();tg=(e,t,n,r,o,a)=>{let s=e[0],d=e.slice(a?1:2,a?3:4),l=d.length,p=t[0],h=t.slice(2).map((b,w)=>b+(b-1)*(n[w]-1)),_=d.map((b,w)=>b+r[w]+r[w+l]).map((b,w)=>Math.floor((b-h[w]+o[w])/o[w]));return _.splice(0,0,s),_.splice(a?3:1,0,p),_},yo=[2,3,1,0],rg=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[1]*t.group;if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},bo=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let a=2;a<t[1].dims.length;++a)n[a-2]===0&&(n[a-2]=t[1].dims[a]);let r=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:n,pads:r}),o},_o=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,a=e.group,s=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Ud=(e,t,n,r)=>{let o=n.format===\"NHWC\",a=tg(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,o);if(n.group!==1){let k=[t[0]];if(o){let M=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),k.push(M)}else k.push(t[1]);t.length===3&&k.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(Md(k,n,a,r),{inputs:k}):e.compute(Bd(k,n,a,r),{inputs:k});return}let s=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],f=t[1].dims[2],h=t[1].dims[3],y=a[o?1:2],_=a[o?2:3],b=a[o?3:1],w=o&&f===d&&h===l&&n.pads[0]===0&&n.pads[1]===0;if(w||f===1&&h===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let k=a[0],O,M,V,F=[];if(o){let W=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=W),w){let J=d*l*p;O=t[0].reshape([1,k,J]),M=W.reshape([1,J,b]),V=[1,k,b]}else O=t[0].reshape([k,d*l,p]),M=W.reshape([1,p,b]),V=[k,y*_,b];F.push(O),F.push(M)}else O=t[0].reshape([k,p,d*l]),M=t[1].reshape([1,b,p]),V=[k,b,y*_],F.push(M),F.push(O);s&&F.push(t[2]);let j=V[2],ne=F[0].dims[F[0].dims.length-1];j<8&&ne<8?e.compute(Yr(F,n,a,V,o,r),{inputs:F}):e.compute(nr(F,n,a,V,o,r),{inputs:F});return}let S=!0,$=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];s&&v.push(t[2]);let T=o?y*_:b,C=o?b:y*_,A=f*h*p;e.compute(Ad(v,n,a,T,C,A,s,S,r),{inputs:v})},ng=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=bo({...t,pads:o,strides:a,dilations:s,kernelShape:d},r);Ud(e,r,l,p=>n?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},og=(e,t,n)=>{let r=n.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=bo(n,t),a=n.autoPad===\"NOTSET\"?n.pads:n.autoPad,s=zd(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,r);e.compute(Od(t,o,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],r))},wo=(e,t)=>{if(rg(e.inputs,t),e.inputs[0].dims.length===3)ng(e,t);else if(e.inputs[0].dims.length===5)og(e,e.inputs,t);else{let n=bo(t,e.inputs);Ud(e,e.inputs,n)}}});var Vd,Wd=G(()=>{\"use strict\";te();tt();ae();ce();Vd=(e,t,n)=>{let r=e.length>2,o=t.outputShape,a=t.format===\"NHWC\",s=t.group,d=e[1].dims,l=d[2]/s,p=d[3],f=a?ge(l):1,h=a?ge(p):1,y=a?p===1?f:h:1,_=E.size(o)/h,b=[Math.ceil(_/64),1,1];me(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let w=[\"rank\",\"rank\"],S=[t.strides[0],t.strides[1]],$=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],v=[t.dilations[0],t.dilations[1]],T=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],C=[T[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),T[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:S},{type:12,data:$},{type:12,data:v},{type:12,data:T},{type:6,data:C},{type:12,data:l},{type:12,data:p},...H(e[0].dims,e[1].dims)];r&&(A.push(...H(e[2].dims)),w.push(\"rank\")),A.push(...H(o));let k=O=>{let M=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:S.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:T.length},{name:\"pads\",type:\"i32\",length:C.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],V=_e(e[0].dataType),F=a?1:2,j=a?2:3,ne=a?3:1,W=P(\"W\",e[1].dataType,e[1].dims.length,y),J=P(\"Dy\",e[0].dataType,e[0].dims.length,f),ve=[J,W];r&&ve.push(P(\"bias\",e[2].dataType,[o[ne]].length,h));let Q=N(\"result\",e[0].dataType,o.length,h),ee=()=>{let Z=\"\";if(f===1)Z+=`\n        let w_offset = ${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${W.getByOffset(`w_offset / ${y}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)Z+=`\n          let wValue = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${y}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let pe=0;pe<f;pe++)Z+=`\n            let wValue${pe} = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${pe}, wOutChannel)`)} / ${y}`)};\n            dotProd = dotProd + xValue[${pe}] * wValue${pe};`;return Z},le=`\n            let outputIndices = ${Q.offsetToIndices(`global_idx * ${h}`)};\n            let batch = ${Q.indicesGet(\"outputIndices\",0)};\n            let d1 = ${Q.indicesGet(\"outputIndices\",ne)};\n            let r = ${Q.indicesGet(\"outputIndices\",F)};\n            let c = ${Q.indicesGet(\"outputIndices\",j)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${Q.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${V}(dyRCorner) + ${V}(wR)) / ${V}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${V}(uniforms.Dy_shape[${F}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${V}(dyCCorner) + ${V}(wC)) / ${V}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${V}(uniforms.Dy_shape[${j}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${f}) {\n                  let xValue = ${a?J.getByOffset(`${J.indicesToOffset(`${J.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${f}`):J.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${ee()}\n                  inputChannel = inputChannel + ${f};\n                }\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${r?` + bias[d1 / ${h}]`:\"\"};\n            ${Q.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${O.registerUniforms(M).declareVariables(...ve,Q)}\n      ${O.mainStart()}\n      ${O.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${le}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${f}${y}${h}${p===1}`,inputDependencies:w},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:n?n(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:k}}});var ig,ag,sg,Ld,Gd,ug,Hd,dg,Fd,qd=G(()=>{\"use strict\";Wd();vt();ct();ig=(e,t,n,r,o,a)=>(e-1)*t+n+(r-1)*o+1-a,ag=(e,t,n,r,o)=>{let a=Math.floor(e/2);t===\"SAME_UPPER\"?(n[r]=a,n[o]=e-a):t===\"SAME_LOWER\"&&(n[r]=e-a,n[o]=a)},sg=(e,t,n,r,o,a,s,d,l,p)=>{let f=e.length-2,h=p.length===0;l.length<f&&l.push(...Array(f-l.length).fill(0));let y=e[0],_=t[d?3:1]*o;for(let b=0,w=e.length-f-(d?1:0);b<f;++b,++w){let S=e[w],$=h?S*s[b]:p[b],v=ig(S,s[b],a[b],t[w],n[b],$);ag(v,r,a,b,b+f),h&&p.push(s[b]*(S-1)+l[b]+(t[w]-1)*n[b]+1-a[b]-a[b+f])}p.splice(0,0,y),p.splice(d?3:1,0,_)},Ld=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((h,y)=>h*y,1)===0){n.length=0;for(let h=2;h<t[1].dims.length;++h)n.push(t[1].dims[h])}let r=e.format===\"NHWC\";n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let o=e.pads.slice(),a=e.outputShape.slice(),s=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;l=new Array(h).fill(1)}let p=e.strides.slice();if(p.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;p=new Array(h).fill(1)}sg(d,n,l,e.autoPad,e.group,o,p,r,s,a);let f=Object.assign({},e);return Object.assign(f,{kernelShape:n,pads:o,outputPadding:s,outputShape:a,dilations:l,strides:p}),f},Gd=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,a=e.group,s=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),f=e.outputPadding,h=e.outputShape;return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,outputPadding:f,outputShape:h,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},ug=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[0];if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let a=e[0].dims.length-2;if(t.dilations.reduce((f,h)=>f+h,0)>0&&t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.reduce((f,h)=>f+h,0)>0&&t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.reduce((f,h)=>f+h,0)>0&&t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.outputPadding.length!==a&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${a}D`);if(t.kernelShape.reduce((f,h)=>f+h,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},Hd=(e,t,n,r)=>{let o=e.kernelCustomData.wT??e.compute(Oe(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let a=[t[0],o];t.length===3&&a.push(t[2]),e.compute(Vd(a,n,r),{inputs:a})},dg=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let a=t.dilations;(a.length===0||a[0]===0)&&(a=[1]);let s=t.strides;(s.length===0||s[0]===0)&&(s=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],s=[1].concat(s),a=[1].concat(a),o=[1].concat(o);let l=t.outputPadding;l=[0].concat(l);let p=Ld({...t,pads:d,strides:s,dilations:a,kernelShape:o,outputPadding:l},r);Hd(e,r,p,f=>n?[f[0],f[2],f[3]]:[f[0],f[1],f[3]])},Fd=(e,t)=>{if(ug(e.inputs,t),e.inputs[0].dims.length===3)dg(e,t);else{let n=Ld(t,e.inputs);Hd(e,e.inputs,n)}}});var lg,Kd,jd,Zd=G(()=>{\"use strict\";te();ae();Ce();ce();lg=(e,t,n,r)=>{let o=E.size(t),a=t.length,s=P(\"input\",e,a),d=N(\"output\",e,a),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),p=E.normalizeAxis(l,a),f=h=>{let y=` i32(${s.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=K(\"uniforms.input_shape\",\"uniforms.axis\",a),b=r.reverse?y+(r.exclusive?\" + 1\":\"\"):\"0\",w=r.reverse?_:y+(r.exclusive?\"\":\" + 1\");return`\n                ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(s,d)}\n                ${h.mainStart()}\n                  ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${b};\n                  let last : i32 = ${w};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${s.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:r.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...H(t,t)]}),getShaderSource:f}},Kd=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,o=e.inputs[1];e.compute(lg(r,n,o,t),{inputs:[0]})},jd=e=>{let t=e.exclusive===1,n=e.reverse===1;return re({exclusive:t,reverse:n})}});var cg,pg,mg,Qd,Yd,Xd=G(()=>{\"use strict\";te();ae();Ce();ce();cg=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},pg=(e,t,n,r)=>{let o=[];o.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let a=0;a<t;++a)o.push(n.indicesSet(\"a\",e[a],`i[${a}]`));return o.push(\"return a;}\"),o.join(`\n`)},mg=(e,t)=>{let n,r,o,a,s,d,l=t.format===\"NHWC\",p=t.blocksize,f=t.mode===\"DCR\";l?([n,r,o,a]=e.dims,s=f?[n,r,o,p,p,a/p**2]:[n,r,o,a/p**2,p,p],d=f?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,o,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=f?[n,p,p,a/p**2,r,o]:[n,a/p**2,p,p,r,o],d=f?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let h=e.reshape(s),y=h.dims.length,_=e.dataType,b=P(\"a\",_,y),w=N(\"output\",_,y),S=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(b,w)}\n\n  ${pg(d,y,b,w)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${w.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${w.setByOffset(\"global_idx\",b.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[n,r*p,o*p,a/p**2]:[n,a/p**2,r*p,o*p],T=E.size(v),C=h.dims,A=E.sortBasedOnPerm(C,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...H(C,A)]}},getShaderSource:S}},Qd=(e,t)=>{cg(e.inputs),e.compute(mg(e.inputs[0],t))},Yd=e=>re({blocksize:e.blocksize,mode:e.mode,format:e.format})});var vo,tn,Jd,fg,hg,$o,xo,el,gg,tl,rl,nl=G(()=>{\"use strict\";te();ae();Ce();ce();vo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",tn=\"(\"+vo+\")+\",Jd=\"^\"+tn+\"$\",fg=\"(\"+tn+\",)*\"+tn,hg=\"^\"+fg+\"$\",$o=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,n){let r=this.symbolToIndices.get(t);r===void 0?r=[n]:r.push(n),this.symbolToIndices.set(t,r)}},xo=class{constructor(t,n){this.equation=n;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[r,o]=n.includes(\"->\")?n.split(\"->\",2):[n,\"\"];if(!r.match(RegExp(hg)))throw new Error(\"Invalid LHS term\");if(r.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(Jd)))throw new Error(\"Invalid LHS term\");let f=this.processTerm(d,!0,p,l);this.lhs.push(f)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(tn)))throw new Error(\"Invalid RHS\");o.match(RegExp(vo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,n,r){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==n&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(r)}else o={count:1,dimValue:n,inputIndices:[r]};this.symbolToInfo.set(t,o)}processTerm(t,n,r,o=-1){let a=r.length,s=!1,d=[],l=0;if(!t.match(RegExp(Jd))&&!n&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(vo,\"g\")),f=new $o(o);return p?.forEach((h,y)=>{if(h===\"...\"){if(s)throw new Error(\"Only one ellipsis is allowed per input term\");s=!0;let _=a-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=r.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let b=0;b<d.length;b++){let w=String.fromCharCode(48+b);f.addSymbol(w,y+b),this.addSymbol(w,r[l++],o)}}else f.addSymbol(h,y+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(h,r[l++],o)}),f}},el=e=>e+\"_max\",gg=(e,t,n,r)=>{let a=e.map(f=>f.length).map((f,h)=>P(`input${h}`,t,f)),s=E.size(r),d=N(\"output\",t,r.length),l=[...n.symbolToInfo.keys()].filter(f=>!n.rhs.symbolToIndices.has(f)),p=f=>{let h=[],y=\"var prod = 1.0;\",_=\"var sum = 0.0;\",b=\"sum += prod;\",w=[],S=[],$=[],v=[],T=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((A,k)=>{if(n.rhs.symbolToIndices.has(k)){let O=n.rhs.symbolToIndices.get(k)?.[0];O!==void 0&&n.lhs.forEach((M,V)=>{if(A.inputIndices.includes(V)){let F=M.symbolToIndices.get(k);if(F===void 0)throw new Error(\"Invalid symbol error\");F.forEach(j=>{h.push(`${a[V].indicesSet(`input${V}Indices`,j,d.indicesGet(\"outputIndices\",O))}`)})}})}else n.lhs.forEach((O,M)=>{if(A.inputIndices.includes(M)){let V=O.symbolToIndices.get(k);if(V===void 0)throw new Error(\"Invalid symbol error\");V.forEach(F=>{w.push(`${a[M].indicesSet(`input${M}Indices`,F,`${k}`)}`)}),v.push(`prod *= ${a[M].getByIndices(`input${M}Indices`)};`)}}),S.push(`for(var ${k}: u32 = 0; ${k} < uniforms.${el(k)}; ${k}++) {`),$.push(\"}\")});let C=T?[...h,`let sum = ${a.map((A,k)=>A.getByIndices(`input${k}Indices`)).join(\" * \")};`]:[...h,_,...S,...w,y,...v,b,...$];return`\n            ${f.registerUniforms(l.map(A=>({name:`${el(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...a,d)}\n\n            ${f.mainStart()}\n            ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${a.map((A,k)=>`var input${k}Indices: ${a[k].type.indices};`).join(`\n`)}\n            ${C.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let f=l.filter(y=>n.symbolToInfo.has(y)).map(y=>({type:12,data:n.symbolToInfo.get(y)?.dimValue||0}));f.push({type:12,data:s});let h=e.map((y,_)=>[...H(y)]).reduce((y,_)=>y.concat(_),f);return h.push(...H(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:h}},getShaderSource:p}},tl=(e,t)=>{let n=new xo(e.inputs,t.equation),r=n.outputDims,o=e.inputs.map((a,s)=>a.dims);e.compute(gg(o,e.inputs[0].dataType,n,r))},rl=e=>{let t=e.equation.replace(/\\s+/g,\"\");return re({equation:t})}});var yg,ol,bg,_g,il,al=G(()=>{\"use strict\";te();ae();ce();yg=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,o=t.length<n.length?0:t.length-n.length;for(;r<n.length&&o<t.length;++r,++o)if(n[r]!==t[o]&&n[r]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},ol=(e,t)=>{let n=e.length-t.length,r=[];for(let o=0;o<n;++o)r.push(e[o]);for(let o=0;o<t.length;++o)r.push(t[o]===1?e[o+n]:t[o]);return r},bg=(e,t)=>e.length>t.length?ol(e,t):ol(t,e),_g=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=bg(t,n),o=e[0].dataType,a=o===9||E.size(t)===1,s=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=a||r.length>0&&r[r.length-1]%4===0?4:1,l=Math.ceil(E.size(r)/d),p=h=>{let y=P(\"input\",o,t.length,s),_=N(\"output\",o,r.length,d),b;if(o===9){let w=(S,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${y.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${S}[${$}] = ${v}(${y.getByOffset(`index${$}`)}[component${$}]);\n        `;b=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${w(\"data\",0,\"u32\")}\n        ${w(\"data\",1,\"u32\")}\n        ${w(\"data\",2,\"u32\")}\n        ${w(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else b=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${y.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${y.getByOffset(`inputOffset / ${s}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${h.registerUniform(\"vec_size\",\"u32\").declareVariables(y,_)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${b}`},f=[{type:12,data:l},...H(t,r)];return{name:\"Expand\",shaderCache:{hint:`${r.length};${s}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:f})}},il=e=>{yg(e.inputs),e.compute(_g(e.inputs),{inputs:[0]})}});var wg,sl,ul=G(()=>{\"use strict\";te();ae();ce();jr();wg=e=>{let t=e[0].dataType,n=E.size(e[0].dims),r=E.size(e[1].dims),o=r%4===0,a=s=>{let d=P(\"x\",t,[1],4),l=P(\"bias\",t,[1],4),p=N(\"y\",t,[1],4),f=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],h=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,y=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${h(0)}${h(1)}${h(2)}${h(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${s.registerUniforms(f).declareVariables(d,l,p)}\n\n    ${mo(ze(t))}\n\n    ${s.mainStart(Et)}\n      ${s.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${y}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",fo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:a,getRunData:s=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Et/4)}})}},sl=e=>{e.inputs.length<2||E.size(e.inputs[1].dims)===0?nd(e):e.compute(wg(e.inputs))}});var vg,$g,dl,ll,cl=G(()=>{\"use strict\";te();ae();Ce();ce();vg=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},$g=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.axis,o),s=n.slice(0);s.splice(a,1,...r);let d=n[a],l=e[0].dataType===9?4:1,p=Math.ceil(E.size(s)/l),f=[{type:12,data:p},{type:6,data:d},{type:12,data:a},...H(e[0].dims,e[1].dims,s)],h=y=>{let _=P(\"data\",e[0].dataType,e[0].dims.length,l),b=P(\"inputIndices\",e[1].dataType,e[1].dims.length),w=N(\"output\",e[0].dataType,s.length,l),S=v=>{let T=r.length,C=`var indicesIndices${v}  = ${b.type.indices}(0);`;for(let A=0;A<T;A++)C+=`${T>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${s.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;C+=`\n          var idx${v} = ${b.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,k=0;A<o;A++)A===a?(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,k+=T):(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${s.length>1?`outputIndices${v}[${k}]`:`outputIndices${v}`};`,k++);return C},$;if(e[0].dataType===9){let v=(T,C,A=\"\")=>`\n          let outputIndices${C} = ${w.offsetToIndices(`outputOffset + ${C}u`)};\n          ${S(C)};\n          let offset${C} = ${_.indicesToOffset(`dataIndices${C}`)};\n          let index${C} = offset${C} / 4u;\n          let component${C} = offset${C} % 4u;\n          ${T}[${C}] = ${A}(${_.getByOffset(`index${C}`)}[component${C}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${w.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${w.offsetToIndices(\"global_idx\")};\n      ${S(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${w.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${y.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,b,w)}\n      ${y.mainStart()}\n        ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:h}},dl=e=>re({axis:e.axis}),ll=(e,t)=>{let n=e.inputs;vg(n),e.compute($g(e.inputs,t))}});var xg,pl,ml,fl=G(()=>{\"use strict\";te();ae();ce();xg=(e,t,n,r,o,a,s,d,l)=>{let p=[{type:12,data:a},{type:12,data:r},{type:12,data:o},{type:12,data:n},{type:12,data:s},{type:12,data:d},{type:12,data:l}],f=[a];p.push(...H(t.dims,f));let h=y=>{let _=P(\"indices_data\",t.dataType,t.dims.length),b=N(\"input_slice_offsets_data\",12,1,1),w=[_,b],S=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:n.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${y.registerUniforms(S).declareVariables(...w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${n.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${n.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:f,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:h},{inputs:[t],outputs:[-1]})[0]},pl=(e,t)=>{let n=e.inputs,r=n[0].dims,o=n[0].dataType,a=n[1].dims,s=a[a.length-1],d=E.sizeToDimension(a,a.length-1),l=E.sizeFromDimension(r,t.batchDims+s),p=E.sizeToDimension(r,t.batchDims),f=E.sizeFromDimension(r,t.batchDims),h=d/p,y=new Array(s),_=l;for(let C=0;C<s;++C)y[s-1-C]=_,_*=r[t.batchDims+s-1-C];let b=xg(e,n[1],y,t.batchDims,r,d,h,f,s),w=t.batchDims+s;if(w>r.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let S=a.slice(0,-1).concat(r.slice(w)),$=E.size(S),v=[{type:12,data:$},{type:12,data:l},...H(n[0].dims,b.dims,S)],T=C=>{let A=P(\"data\",n[0].dataType,n[0].dims.length),k=P(\"slice_offsets\",12,b.dims.length),O=N(\"output\",n[0].dataType,S.length);return`\n          ${C.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,k,O)}\n            ${C.mainStart()}\n            ${C.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:S,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:T},{inputs:[n[0],b]})},ml=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Sg,Tg,hl,gl,yl=G(()=>{\"use strict\";te();ae();Ce();ce();Sg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let n=E.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,o=e[0],a=e[2],s=e.length===4?e[3]:void 0;if(a.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===n?Math.ceil(d/r)===a.dims[l]:d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(s){if(s.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(s.dims.length!==a.dims.length||!s.dims.map((d,l)=>d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Tg=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.gatherAxis,o),s=E.normalizeAxis(t.quantizeAxis,o),d=n.slice(0);d.splice(a,1,...r);let l=E.size(d),p=e[2].dataType,h=e[0].dataType===22,y=[{type:12,data:l},{type:12,data:s},{type:12,data:a},{type:12,data:t.blockSize},...H(...e.map((b,w)=>b.dims),d)],_=b=>{let w=P(\"data\",e[0].dataType,e[0].dims.length),S=P(\"inputIndices\",e[1].dataType,e[1].dims.length),$=P(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?P(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,T=N(\"output\",p,d.length),C=[w,S,$];v&&C.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${b.registerUniforms(A).declareVariables(...C,T)}\n        ${b.mainStart()}\n        let output_indices = ${T.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${S.type.indices}(0);\n        ${r.length>1?`\n          for (var i: u32 = 0; i < ${r.length}; i++) {\n            let index = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${S.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`};\n        var data_indices = ${w.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${T.indicesGet(\"output_indices\",\"i\")};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${S.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${w.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${T.indicesGet(\"output_indices\",`i + ${r.length} - 1`)};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${w.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${w.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\"};\n        let dequantized_data = ${ze(p)}(quantized_data - zero_point) * scale;\n        ${T.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((b,w)=>w!==1).map(b=>b.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(b,w)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:y}),getShaderSource:_}},hl=(e,t)=>{let n=e.inputs;Sg(n,t),e.compute(Tg(e.inputs,t))},gl=e=>re({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Cg,Ig,bl,_l,wl=G(()=>{\"use strict\";te();ae();Ce();ce();Cg=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Ig=(e,t)=>{let n=e[0].dims,r=e[0].dataType,o=n.length,a=e[1].dims,s=e[1].dataType,d=E.normalizeAxis(t.axis,o),l=n[d],p=a.slice(0),f=E.size(p),h=P(\"input\",r,o),y=P(\"indicesInput\",s,a.length),_=N(\"output\",r,p.length),b=[{type:12,data:f},{type:6,data:l},{type:12,data:d}];return b.push(...H(n,a,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(h,y,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${y.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${h.type.indices}(outputIndices);\n      ${h.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${h.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},bl=e=>re({axis:e.axis}),_l=(e,t)=>{let n=e.inputs;Cg(n),e.compute(Ig(e.inputs,t))}});var Ag,kg,vl,$l,xl=G(()=>{\"use strict\";te();ae();ce();Ag=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},kg=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[o,a,s]=Wr.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),d=[o,a];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(a/l),f=Math.ceil(o/l),h=!0,y=E.size(d),_=[{type:12,data:h?p:y},{type:12,data:o},{type:12,data:a},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}],b=[\"type\",\"type\"];e.length===3&&(_.push(...H(e[2].dims)),b.push(\"rank\")),_.push(...H(d));let w=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let T=t.alpha===1?\"\":\"value *= uniforms.alpha;\",C=P(\"a\",e[0].dataType,e[0].dims),A=P(\"b\",e[1].dataType,e[1].dims),k=C.type.value,O=null,M=[C,A];e.length===3&&(O=P(\"c\",e[2].dataType,e[2].dims.length),M.push(O));let V=N(\"output\",e[0].dataType,d.length);M.push(V);let F=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(F).declareVariables(...M)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${k}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${T}\n    ${O!=null?`let cOffset = ${O.broadcastedIndicesToOffset(\"vec2(m, n)\",V)}; value += ${k}(uniforms.beta) * ${O.getByOffset(\"cOffset\")};`:\"\"}\n    output[global_idx] = value;\n  }`},S=$=>{let v=P(\"a\",e[0].dataType,e[0].dims),T=P(\"b\",e[1].dataType,e[1].dims),C=null,A=[v,T];e.length===3&&(C=P(\"c\",e[2].dataType,e[2].dims.length),A.push(C));let k=N(\"output\",e[0].dataType,d.length);A.push(k);let O=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],M=\"\",V=\"\";t.transA&&t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let F=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(O).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${k.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${V}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${M}\n      }\n      workgroupBarrier();\n    }\n\n    ${F}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset(\"vec2(m, n)\",k)}; value += ${k.type.value}(uniforms.beta) * ${C.getByOffset(\"cOffset\")};`:\"\"}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return h?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*f},programUniforms:_}),getShaderSource:S}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},vl=e=>{let t=e.transA,n=e.transB,r=e.alpha,o=e.beta;return{transA:t,transB:n,alpha:r,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},$l=(e,t)=>{Ag(e.inputs),e.compute(kg(e.inputs,t))}});var pt,$t,Nt,Vt,Eg,Pg,zg,Og,Dg,Bg,Mg,Rg,Sl,Tl,Cl=G(()=>{\"use strict\";te();ae();Ce();ce();[pt,$t,Nt,Vt]=[0,1,2,3],Eg=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Pg=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,zg=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Og=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,Dg=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Bg=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${pt}] = batch;\n     indices[${$t}] = channel;`+(()=>{switch(n.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,Mg=(e,t,n)=>(()=>{switch(n.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${pt}], indices[${$t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${pt}], indices[${$t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Rg=(e,t)=>{let n=P(\"x\",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=P(\"grid\",e[1].dataType,r.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[pt,$t,Nt,Vt]=[0,3,1,2]);let s=N(\"output\",e[0].dataType,a.length),d=n.type.value,l=E.size(a),p=[{type:12,data:l},...H(e[0].dims,r,a)],f=h=>`\n  ${h.registerUniform(\"output_size\",\"u32\").declareVariables(n,o,s)}\n  ${Pg}\n  ${zg(d)}\n  ${Og(t)}\n  ${Dg(t)}\n  ${Bg(n,d,t)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${s.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${pt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Mg(s,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:h=>{let y=E.size(a);return{outputs:[{dims:a,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:p}},getShaderSource:f}},Sl=(e,t)=>{Eg(e.inputs),e.compute(Rg(e.inputs,t))},Tl=e=>re({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Me,Vg,Al,Il,Wg,or,kl,So=G(()=>{\"use strict\";te();ae();Ce();Vr();qr();ce();ct();Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Vg=(e,t)=>{let n=e[0],r=Me(e,1),o=Me(e,2),a=Me(e,3),s=Me(e,4),d=Me(e,5),l=Me(e,6),p=Me(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let f=n.dims[0],h=n.dims[1],y=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],_=h,b=0,w=0,S=Math.floor(y/t.numHeads);if(l&&p&&E.size(l.dims)&&E.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==f||l.dims[1]!==t.numHeads||l.dims[3]!==S)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==f||p.dims[1]!==t.numHeads||p.dims[3]!==S)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');b=l.dims[2],w=l.dims[2]}else if(l&&E.size(l.dims)||p&&E.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(r&&E.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==S)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==S)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(a&&E.size(a.dims)>0){if(a.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=b+_,T=0;if(s&&E.size(s.dims)>0){T=8;let O=s.dims;throw O.length===1?O[0]===f?T=1:O[0]===3*f+2&&(T=3):O.length===2&&O[0]===f&&O[1]===v&&(T=5),T===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let C=!1,A=y;if(o&&E.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=!1;if(s&&E.size(s.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&E.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==f||d.dims[1]!==t.numHeads||d.dims[2]!==h||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:f,sequenceLength:h,pastSequenceLength:b,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:w,inputHiddenSize:0,hiddenSize:y,vHiddenSize:A,headSize:S,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:k,passPastInKv:C,qkvFormat:$}},Al=e=>re({...e}),Il=re({perm:[0,2,1,3]}),Wg=(e,t,n,r,o,a,s)=>{let d=[r,o,a],l=E.size(d),p=[{type:12,data:l},{type:12,data:s},{type:12,data:a}],f=h=>{let y=N(\"qkv_with_bias\",t.dataType,d),_=P(\"qkv\",t.dataType,d),b=P(\"bias\",n.dataType,d),w=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${h.registerUniforms(w).declareVariables(_,b,y)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:f},{inputs:[t,n],outputs:[-1]})[0]},or=(e,t,n,r,o,a,s,d)=>{let l=a;if(s&&E.size(s.dims)>0){if(r===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Wg(e,a,s,t,r,n*o,d),l=l.reshape([t,r,n,o]),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]}else return a.dims.length===3&&(l=a.reshape([t,r,n,o])),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]},kl=(e,t)=>{let n=Vg(e.inputs,t),r=e.inputs[0],o=Me(e.inputs,1),a=Me(e.inputs,2),s=Me(e.inputs,3),d=Me(e.inputs,4),l=Me(e.inputs,5),p=Me(e.inputs,6),f=Me(e.inputs,7);if(r.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let h=o&&a&&o.dims.length===4&&a.dims.length===4,y=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,s,0);if(h)return Ut(e,y,o,a,d,void 0,p,f,l,n);if(!o||!a)throw new Error(\"key and value must be provided\");let _=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,o,s,n.hiddenSize),b=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,s,2*n.hiddenSize);Ut(e,y,_,b,d,void 0,p,f,l,n)}});var Lg,Gg,Hg,Fg,To,El,Pl,Co=G(()=>{\"use strict\";te();ae();Ce();ce();Lg=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},Gg=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>n.push(Number(o))),r=n.length),re({numOutputs:r,axis:t.axis,splitSizes:n})},Hg=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${K(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Fg=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let o=e[r].setByIndices(\"indices\",\"input[global_idx]\");t===1?n.push(o):r===0?n.push(`if (output_number == ${r}u) { ${o} }`):r===t-1?n.push(`else { ${o} }`):n.push(`else if (output_number == ${r}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join(`\n`)}\n      }`},To=(e,t)=>{let n=e[0].dims,r=E.size(n),o=e[0].dataType,a=E.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),d=P(\"input\",o,n.length),l=new Array(t.numOutputs),p=[],f=[],h=0,y=[{type:12,data:r}];for(let b=0;b<t.numOutputs;b++){h+=t.splitSizes[b],l[b]=h;let w=n.slice();w[a]=t.splitSizes[b],f.push(w),s[b]=N(`output${b}`,o,w.length),p.push({dims:f[b],dataType:e[0].dataType})}y.push({type:12,data:l},...H(n,...f));let _=b=>`\n  ${b.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...s)}\n  ${Hg(l.length)}\n  ${Fg(s)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${K(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",a,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:y})}},El=(e,t)=>{Lg(e.inputs);let n=e.inputs.length===1?t:Gg(e.inputs,t);e.compute(To(e.inputs,n),{inputs:[0]})},Pl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return re({axis:t,numOutputs:r,splitSizes:n})}});var qg,Kg,zl,Ol,Dl=G(()=>{\"use strict\";Ce();qr();So();Co();ct();qg=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=n.dims[0],p=n.dims[1],f=n.dims.length===3?d?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],h=p,y=0,_=!r||r.dims.length===0,b=Math.floor(_?f/(t.numHeads+2*t.kvNumHeads):f/t.numHeads);_&&(f=b*t.numHeads);let w=a&&a.dims.length!==0,S=s&&s.dims.length!==0;if(w&&a.dims.length===4&&a.dims[0]===l&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===b)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(w&&S){if(a.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(s.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=a.dims[2]}else if(w||S)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');h=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==b)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');h=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==b)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');h=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let T=0,C=!1,A=t.kvNumHeads?b*t.kvNumHeads:f;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(h!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(h!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=e.length>4?e[5]:void 0;if(k&&k.dims.length!==1&&k.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:h,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:f,vHiddenSize:A,headSize:b,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:T,scale:t.scale,broadcastResPosBias:!1,passPastInKv:C,qkvFormat:v}},Kg=re({perm:[0,2,1,3]}),zl=(e,t,n)=>{let r=t,o=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(r=t.reshape([n.batchSize,n.kvSequenceLength,o,n.headSize]),r=e.compute(Oe(r,Kg.perm),{inputs:[r],outputs:[-1]})[0]),r},Ol=(e,t)=>{let n=qg(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let r=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,a=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,s=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,f=n.kvNumHeads?n.kvNumHeads:n.numHeads,h=re({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,f*n.headSize,f*n.headSize]}),[y,_,b]=!o&&!a?e.compute(To([r],h),{inputs:[r],outputs:[-1,-1,-1]}):[r,o,a],w=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,y,void 0,0);Ut(e,w,zl(e,_,n),zl(e,b,n),void 0,void 0,s,d,void 0,n,l,p)}});var Bl,jg,Zg,Ml,Rl=G(()=>{\"use strict\";te();ae();ct();ce();Bl=(e,t,n,r,o,a,s,d)=>{let l=ge(a),p=l===1?\"f32\":`vec${l}f`,f=l===1?\"vec2f\":`mat2x${l}f`,h=o*s,y=64;h===1&&(y=256);let _=[o,s,a/l],b=[o,s,2],w=[\"rank\",\"type\",\"type\"],S=[];S.push(...H(_,b));let $=v=>{let T=P(\"x\",t.dataType,3,l),C=P(\"scale\",n.dataType,n.dims),A=P(\"bias\",r.dataType,r.dims),k=N(\"output\",1,3,2),O=[T,C,A,k];return`\n  var<workgroup> workgroup_shared : array<${f}, ${y}>;\n  const workgroup_size = ${y}u;\n  ${v.declareVariables(...O)}\n  ${v.mainStart(y)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${T.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${f}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Ke(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${Ke(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${y}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:b,dataType:1}],dispatchGroup:{x:h},programUniforms:S}),getShaderSource:$},{inputs:[t,n,r],outputs:[-1]})[0]},jg=(e,t,n)=>{let r=t[0].dims,o=r,a=2,s=r[0],d=r[1],l=E.sizeFromDimension(r,a),p=ge(l),f=E.size(o)/p,h=Bl(e,t[0],t[1],t[2],s,l,d,n.epsilon),y=[s,d,l/p],_=[s,d],b=[\"type\",\"none\"],w=S=>{let $=P(\"x\",t[0].dataType,y.length,p),v=P(\"scale_shift\",1,_.length,2),T=N(\"output\",t[0].dataType,y.length,p),C=[$,v,T];return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables(...C)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${T.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);\n      ${T.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...H(y,_,y)]}),getShaderSource:w},{inputs:[t[0],h]})},Zg=(e,t,n)=>{let r=t[0].dims,o=r,a=r[0],s=r[r.length-1],d=E.sizeFromDimension(r,1)/s,l=ge(s),p=E.size(o)/l,f=[{type:12,data:d},{type:12,data:Math.floor(s/l)}],h=[\"type\",\"type\"],y=!1,_=[0,r.length-1];for(let $=0;$<r.length-2;$++)y=y||r[$+1]!==1,_.push($+1);y=y&&r[r.length-1]!==1;let b=y?e.compute(Oe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},($,v)=>r[_[v]])),w=Bl(e,b,t[1],t[2],a,d,s,n.epsilon),S=$=>{let v=_e(t[0].dataType),T=l===1?\"vec2f\":`mat${l}x2f`,C=O=>{let M=O===0?\"x\":\"y\",V=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${V}(scale.${M}))`;case 2:return`vec2<${v}>(${V}(scale[0].${M}, scale[1].${M}))`;case 4:return`vec4<${v}>(${V}(scale[0].${M}, scale[1].${M}, scale[2].${M}, scale[3].${M}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=P(\"input\",t[0].dataType,t[0].dims,l),k=N(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:S},{inputs:[t[0],w]})},Ml=(e,t)=>{t.format===\"NHWC\"?Zg(e,e.inputs,t):jg(e,e.inputs,t)}});var Qg,Yg,Ul,Nl=G(()=>{\"use strict\";te();ae();ce();Qg=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},Yg=(e,t,n)=>{let r=t.simplified,o=e[0].dims,a=e[1],s=!r&&e[2],d=o,l=E.normalizeAxis(t.axis,o.length),p=E.sizeToDimension(o,l),f=E.sizeFromDimension(o,l),h=E.size(a.dims),y=s?E.size(s.dims):0;if(h!==f||s&&y!==f)throw new Error(`Size of X.shape()[axis:] == ${f}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${y}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let b=ge(f),w=[\"type\",\"type\"],S=[{type:12,data:p},{type:1,data:f},{type:12,data:Math.floor(f/b)},{type:1,data:t.epsilon}];s&&w.push(\"type\");let $=n>1,v=n>2,T=A=>{let k=_e(e[0].dataType),O=[P(\"x\",e[0].dataType,e[0].dims,b),P(\"scale\",a.dataType,a.dims,b)];s&&O.push(P(\"bias\",s.dataType,s.dims,b)),O.push(N(\"output\",e[0].dataType,d,b)),$&&O.push(N(\"mean_data_output\",1,_)),v&&O.push(N(\"inv_std_output\",1,_));let M=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(M).declareVariables(...O)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${uo(\"f32\",b)};\n    var mean_square_vector = ${uo(\"f32\",b)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(k,b,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Ke(\"mean_vector\",b)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Ke(\"mean_square_vector\",b)} / uniforms.norm_size ${r?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(k,b,\"x[j + offset]\")};\n      let f32scale = ${Pt(k,b,\"scale[j]\")};\n      output[j + offset] = ${O[0].type.value}((f32input ${r?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${s?`+ ${Pt(k,b,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},C=[{dims:d,dataType:e[0].dataType}];return $&&C.push({dims:_,dataType:1}),v&&C.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${b};${n};${r}`,inputDependencies:w},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:S}),getShaderSource:T}},Ul=(e,t)=>{Qg(e.inputs),e.compute(Yg(e.inputs,t,e.outputCount))}});var Xg,Vl,Wl=G(()=>{\"use strict\";ae();Xr();Jr();Xg=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Vl=e=>{Xg(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(Yr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],a=E.size(e.inputs[0].dims.slice(0,-2)),s=E.size(e.inputs[1].dims.slice(0,-2));if(a!==1&&o===1&&s===1){let d=e.inputs[0].reshape([1,a,r]),l=e.inputs[1].reshape([1,r,n]),p=[1,a,n],f=[d,l];e.compute(nr(f,{activation:\"\"},t,p),{inputs:f})}else e.compute(nr(e.inputs,{activation:\"\"},t))}}});var Jg,ey,ty,Ll,Gl,Hl=G(()=>{\"use strict\";te();ae();Ce();ce();Jg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,s=e[1];if(!E.areEqual(s.dims,[t.n,o,a]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(E.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let f=e[3].dims,h=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(E.size(f)!==h)throw new Error(\"zeroPoints input size error.\")}},ey=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=ge(s),w=d.concat([o,s]),S=o>1&&s/b%2===0?2:1,$=E.size(w)/b/S,v=64,T=[],C=[l,o,a/y],A=E.convertShape(e[1].dims).slice();A.splice(-1,1,f/_),T.push(...H(C)),T.push(...H(A)),T.push(...H(e[2].dims)),e.length===4&&T.push(...H(E.convertShape(e[3].dims)));let k=[l,o,s/b];T.push(...H(k));let O=M=>{let V=C.length,F=P(\"a\",e[0].dataType,V,y),j=P(\"b\",12,A.length,_),ne=P(\"scales\",e[2].dataType,e[2].dims.length),W=[F,j,ne],J=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;J&&W.push(J);let ve=k.length,Q=N(\"output\",e[0].dataType,ve,b),ee=_e(e[0].dataType),le=(()=>{switch(y){case 1:return`array<${ee}, 8>`;case 2:return`mat4x2<${ee}>`;case 4:return`mat2x4<${ee}>`;default:throw new Error(`${y}-component is not supported.`)}})(),Z=()=>{let Se=`\n          // reuse a data\n            var input_offset = ${F.indicesToOffset(`${F.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${le};\n            for (var j: u32 = 0; j < ${8/y}; j++) {\n              a_data[j] = ${F.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let D=0;D<b*S;D++)Se+=`\n            b_value = ${_===1?`b${D}_data`:`b${D}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${le}(${Array.from({length:4},(R,Y)=>`${ee}(b_value_lower[${Y}]), ${ee}(b_value_upper[${Y}])`).join(\", \")});\n            b_dequantized_values = ${y===1?`${le}(${Array.from({length:8},(R,Y)=>`(b_quantized_values[${Y}] - ${J?`zero_point${D}`:\"zero_point\"}) * scale${D}`).join(\", \")});`:`(b_quantized_values - ${le}(${Array(8).fill(`${J?`zero_point${D}`:\"zero_point\"}`).join(\",\")})) * scale${D};`};\n            workgroup_shared[local_id.x * ${S} + ${Math.floor(D/b)}]${b>1?`[${D%b}]`:\"\"} += ${Array.from({length:8/y},(R,Y)=>`${y===1?`a_data[${Y}] * b_dequantized_values[${Y}]`:`dot(a_data[${Y}], b_dequantized_values[${Y}])`}`).join(\" + \")};\n          `;return Se},pe=()=>{let Se=`\n            var col_index = col * ${b};\n            ${J?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${ee}(8);`}\n            `;for(let D=0;D<b*S;D++)Se+=`\n            let scale${D} = ${ne.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${J?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${J.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${D} = ${ee}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return Se},ke=()=>{let Se=`col_index = col * ${b};`;for(let D=0;D<b*S;D++)Se+=`\n            let b${D}_data = ${j.getByIndices(`${j.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return Se+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${le};\n            var b_dequantized_values: ${le};`,Se};return`\n        var<workgroup> workgroup_shared: array<${Q.type.value}, ${S*v}>;\n        ${M.declareVariables(...W,Q)}\n        ${M.mainStart([v,1,1])}\n          let output_indices = ${Q.offsetToIndices(`(global_idx / ${v}) * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/y};\n            ${pe()}\n            for (var word: u32 = 0; word < ${f}; word += ${_}) {\n              ${ke()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${Z()}\n                word_offset += ${8/y};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${S}) {\n            var output_value: ${Q.type.value} = ${Q.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${S};\n            }\n            ${Q.setByIndices(`${Q.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${y};${_};${b};${S};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:w,dataType:h}],dispatchGroup:{x:$},programUniforms:T}),getShaderSource:O}},ty=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=d.concat([o,s]),w=128,S=s%8===0?8:s%4===0?4:1,$=w/S,v=$*_*8,T=v/y,C=v/t.blockSize,A=E.size(b)/S,k=[],O=[l,o,a/y],M=E.convertShape(e[1].dims).slice();M.splice(-1,1,f/_),k.push(...H(O)),k.push(...H(M)),k.push(...H(e[2].dims)),e.length===4&&k.push(...H(E.convertShape(e[3].dims)));let V=[l,o,s];k.push(...H(V));let F=j=>{let ne=O.length,W=P(\"a\",e[0].dataType,ne,y),J=P(\"b\",12,M.length,_),ve=P(\"scales\",e[2].dataType,e[2].dims.length),Q=[W,J,ve],ee=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;ee&&Q.push(ee);let le=V.length,Z=N(\"output\",e[0].dataType,le),pe=_e(e[0].dataType),ke=()=>{switch(y){case 1:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${y}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${W.type.value}, ${T}>;\n        var<workgroup> inter_results: array<array<${Z.type.value}, ${$}>, ${S}>;\n        ${j.declareVariables(...Q,Z)}\n        ${j.mainStart([$,S,1])}\n          let output_indices = ${Z.offsetToIndices(`workgroup_index * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${C} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${T};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${w})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${W.getByIndices(`${W.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${W.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${C} + local_id.x;\n            ${ee?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${ee.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${pe}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${pe}(8);`}\n            let scale = ${ve.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${J.getByIndices(`${J.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/y};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${ke()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${pe}>(${Array.from({length:4},(Se,D)=>`${pe}(b_value_lower[${D}]), ${pe}(b_value_upper[${D}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${pe}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Se,D)=>`${`dot(a_data${D}, b_dequantized_values[${D}])`}`).join(\" + \")};\n              word_offset += ${8/y};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${S}) {\n            var output_value: ${Z.type.value} = ${Z.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${Z.setByIndices(`${Z.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${y};${_};${$};${S}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:b,dataType:h}],dispatchGroup:{x:A},programUniforms:k}),getShaderSource:F}},Ll=(e,t)=>{Jg(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(ty(e.inputs,t)):e.compute(ey(e.inputs,t))},Gl=e=>re(e)});var ry,ny,oy,iy,ay,sy,uy,dy,Fl,ql=G(()=>{\"use strict\";te();ae();ce();ry=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},ny=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},oy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${K(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},iy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${K(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},ay=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0)  {\n                  k += i32(${K(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${K(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},sy=(e,t,n)=>{switch(n.mode){case 0:return ny(e,t,n.pads.length);case 1:return oy(e,t,n.pads.length);case 2:return iy(e,t,n.pads.length);case 3:return ay(e,t,n.pads.length);default:throw new Error(\"Invalid mode\")}},uy=(e,t)=>{let n=E.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,o=E.size(n),a=[{type:12,data:o},{type:6,data:t.pads}],s=e.length>=3&&e[2].data;t.mode===0&&a.push({type:s?e[2].dataType:1,data:t.value}),a.push(...H(e[0].dims,n));let d=[\"rank\"],l=p=>{let f=N(\"output\",e[0].dataType,n.length),h=P(\"x\",e[0].dataType,r.length),y=h.type.value,_=sy(f,r.length,t),b=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&b.push({name:\"constant_value\",type:s?y:\"f32\"}),`\n            ${p.registerUniforms(b).declareVariables(h,f)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${f.offsetToIndices(\"global_idx\")};\n\n            var value = ${y}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${s}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(n)/64)},programUniforms:a}),getShaderSource:l}},dy=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,a=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)a[Number(d[l])]=Number(n[l]),a[Number(d[l])+o]=Number(n[l+d.length])}else n.forEach((d,l)=>a[Number(l)]=Number(d));let s=[];return a.forEach(d=>s.push(d)),{mode:t.mode,value:r,pads:s}}else return t},Fl=(e,t)=>{ry(e.inputs);let n=dy(e.inputs,t);e.compute(uy(e.inputs,n),{inputs:[0]})}});var rn,Kl,jl,Zl,Ql,ly,cy,Yl,Xl,Jl,ec,tc,rc,nc,oc,ic,ac,sc,uc,dc=G(()=>{\"use strict\";Ge();te();ae();ce();rn=e=>{if(we.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},Kl=(e,t,n)=>{let r=t.format===\"NHWC\",o=e.dims.slice();r&&o.splice(1,0,o.pop());let a=Object.hasOwnProperty.call(t,\"dilations\"),s=t.kernelShape.slice(),d=t.strides.slice(),l=a?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(n,o,s,d,l,p);let f=kt.computePoolOutputShape(n,o,d,l,s,p,t.autoPad),h=Object.assign({},t);a?Object.assign(h,{kernelShape:s,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(h,{kernelShape:s,strides:d,pads:p,cacheKey:t.cacheKey});let y=f.slice();return y.push(y.splice(1,1)[0]),[h,r?y:f]},jl=(e,t)=>{let n=t.format===\"NHWC\",r=E.size(e),o=E.size(t.kernelShape),a=[{type:12,data:r},{type:12,data:o}],s=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],f=t.pads[t.pads.length-1],h=!!(p+f);a.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:f}),s.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let y=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],b=t.strides[t.strides.length-2],w=t.pads[t.pads.length/2-2],S=t.pads[t.pads.length-2];y=!!(w+S),a.push({type:12,data:_},{type:12,data:b},{type:12,data:w},{type:12,data:S}),s.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[a,s,!0,h,y]}else{if(n)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=E.computeStrides(t.kernelShape);a.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,f)=>p+f);return[a,s,!!l,!1,!1]}},Zl=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y=o.format===\"NHWC\",_=t.type.value,b=N(\"output\",t.type.tensor,r);if(o.kernelShape.length<=2){let w=\"\",S=\"\",$=\"\",v=n-(y?2:1);if(f?w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`:w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`,o.kernelShape.length===2){let C=n-(y?3:2);h?S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${C}] < 0 || xIndices[${C}] >= uniforms.x_shape[${C}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${S}\n              ${w}\n              ${$}\n              ${s}\n\n              output[global_idx] = value;\n            }`}else{if(y)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let w=o.kernelShape.length,S=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${a}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${w}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${w-1}u; j++) {\n                  offsets[j] = offset / ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                  offset -= offsets[j] * ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                }\n                offsets[${w-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-w}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${K(\"uniforms.strides\",`j - ${n-w}u`,w)}\n                    + offsets[j - ${n-w}u] - ${K(\"uniforms.pads\",\"j - 2u\",S)};\n                  ${$}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Ql=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,ly=e=>`${Ql(e)};${e.countIncludePad}`,cy=e=>`${Ql(e)};${e.storageOrder};${e.dilations}`,Yl=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xl=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=P(\"x\",t.dataType,t.dims.length),d=s.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[f,h,y,_,b]=jl(a,o);f.push(...H(t.dims,a));let w=[\"rank\"];return{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:S=>Zl(S,s,t.dims.length,a.length,o,l,p,0,h,y,_,b)}},Jl=e=>{let t=e.count_include_pad!==0,n=Yl(e);if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let r={countIncludePad:t,...n,cacheKey:\"\"};return{...r,cacheKey:ly(r)}},ec=(e,t)=>{rn(e.inputs),e.compute(Xl(\"AveragePool\",e.inputs[0],!1,t))},tc={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},rc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},nc=(e,t)=>{rn(e.inputs),e.compute(Xl(\"GlobalAveragePool\",e.inputs[0],!0,t))},oc=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=`\n      value = max(x_val, value);\n    `,d=\"\",l=P(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[f,h,y,_,b]=jl(a,o);return f.push(...H(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:w=>Zl(w,l,t.dims.length,a.length,o,s,d,t.dataType===10?-65504:-1e5,h,y,_,b)}},ic=(e,t)=>{rn(e.inputs),e.compute(oc(\"MaxPool\",e.inputs[0],!1,t))},ac=e=>{let t=e.storage_order,n=e.dilations,r=Yl(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:n,...r,cacheKey:\"\"};return{...o,cacheKey:cy(o)}},sc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},uc=(e,t)=>{rn(e.inputs),e.compute(oc(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var my,fy,lc,cc,pc=G(()=>{\"use strict\";te();ae();Ce();ce();my=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((n,r)=>n===e[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,a)=>a===t.axis||o===e[0].dims[a]).reduce((o,a)=>o&&a,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},fy=(e,t)=>{let n=E.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,o=r===3,a=e[0].dims,s=e[1].dataType,d=E.size(a),l=r===3||r===2,p=l?[Math.ceil(E.size(e[0].dims)/4)]:e[0].dims,f=e[1].dims,h=e.length>2?e[2]:void 0,y=h?l?[Math.ceil(E.size(h.dims)/4)]:h.dims:void 0,_=f.length===0||f.length===1&&f[0]===1,b=_===!1&&f.length===1,w=ge(d),S=_&&(!l||w===4),$=S?w:1,v=S&&!l?w:1,T=P(\"input\",l?12:r,p.length,v),C=P(\"scale\",s,f.length),A=h?P(\"zero_point\",l?12:r,y.length):void 0,k=N(\"output\",s,a.length,$),O=[T,C];A&&O.push(A);let M=[p,f];h&&M.push(y);let V=[{type:12,data:d/$},{type:12,data:n},{type:12,data:t.blockSize},...H(...M,a)],F=j=>{let ne=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${j.registerUniforms(ne).declareVariables(...O,k)}\n      ${j.mainStart()}\n          ${j.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${k.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${l?`\n            let input = ${T.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${T.getByOffset(\"global_idx\")};`};\n\n          // Set scale input\n          ${_?`let scale_value= ${C.getByOffset(\"0\")}`:b?`\n            let scale_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${C.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${C.type.indices} = output_indices;\n            let index = ${C.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${C.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${C.getByIndices(\"scale_indices\")};`};\n\n          // Set zero-point input\n          ${A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:b?l?`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${C.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":T.type.value}(0);`};\n      // Compute and write output\n      ${k.setByOffset(\"global_idx\",`${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:F,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:V})}},lc=(e,t)=>{my(e.inputs,t),e.compute(fy(e.inputs,t))},cc=e=>re({axis:e.axis,blockSize:e.blockSize})});var hy,gy,mc,fc=G(()=>{\"use strict\";Ge();te();ce();hy=(e,t,n)=>{let r=e===t,o=e<t&&n<0,a=e>t&&n>0;if(r||o||a)throw new Error(\"Range these inputs' contents are invalid.\")},gy=(e,t,n,r)=>{let o=Math.abs(Math.ceil((t-e)/n)),a=[o],s=o,d=[{type:12,data:s},{type:r,data:e},{type:r,data:n},...H(a)],l=p=>{let f=N(\"output\",r,a.length),h=f.type.value,y=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:h},{name:\"delta\",type:h}];return`\n        ${p.registerUniforms(y).declareVariables(f)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${h}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${r}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d})}},mc=e=>{let t=0,n=0,r=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),we.webgpu.validateInputContent&&hy(t,n,r),e.compute(gy(t,n,r,e.inputs[0].dataType),{inputs:[]})}});var yy,by,hc,gc,yc=G(()=>{\"use strict\";te();ae();Ce();ce();yy=(e,t,n,r)=>{if(e!==\"none\"&&r!==\"i32\"&&r!==\"u32\"&&r!==\"f32\")throw new Error(`Input ${r} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${n};`;case\"add\":return r===\"i32\"||r===\"u32\"?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\n              ${o}bitcast<${r}>(oldValue) + (${n})${a}`;case\"max\":return r===\"i32\"||r===\"u32\"?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${n}))${a}`;case\"min\":return r===\"i32\"||r===\"u32\"?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${o}min(bitcast<${r}>(oldValue), (${n}))${a}`;case\"mul\":return`${o}(bitcast<${r}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},by=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n,a=1,s=Math.ceil(E.size(r)/a),d=r[r.length-1],l=E.sizeFromDimension(n,d),p=[{type:12,data:s},{type:12,data:d},{type:12,data:l},...H(e[1].dims,e[2].dims,o)],f=h=>{let y=P(\"indices\",e[1].dataType,e[1].dims.length),_=P(\"updates\",e[2].dataType,e[2].dims.length,a),b=t.reduction!==\"none\"&&t.reduction!==\"\"?Hs(\"output\",e[0].dataType,o.length):N(\"output\",e[0].dataType,o.length,a);return`\n      ${h.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(y,_,b)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var hasDuplicates = false;\n  if (${t.reduction===\"none\"}) {\n    let n = ${E.size(r)};\n    for (var i = 0; i < n; i = i + 1) {\n      for (var j = i + 1; j < n; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  if (${t.reduction===\"none\"} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    indices_start = 0u;\n  }\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${yy(t.reduction,\"output[data_offset + i]\",\"value\",b.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:p}),getShaderSource:f}},hc=e=>re({reduction:e.reduction}),gc=(e,t)=>{e.compute(by(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var _y,wy,vy,bc,$y,xy,Sy,Ty,Cy,Iy,Ay,ky,_c,Ey,Py,zy,Oy,Dy,wc,vc,$c=G(()=>{\"use strict\";te();ae();Ce();ce();_y=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},wy=(e,t,n)=>{t.every(o=>o>=0&&o<n||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let r=new Array(n).fill(1);return t.forEach((o,a)=>r[o]=e[a]),r},vy=(e,t,n,r,o,a)=>{let[s,d,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(f=>a.push(f));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(f=>r.push(f)),r.length!==0&&r.length!==p&&n>=18&&r.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");_y(r,t),t.axes.length>0&&wy(r,t.axes,p).forEach((f,h)=>r[h]=f)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(f=>o.push(Number(f))),o.length!==0&&o.length!==p&&n>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<\"u\"&&typeof o<\"u\"&&r.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},bc=(e,t,n,r)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${r}(big / (${n}));\n  let fract = ${r}(big % (${n})) / ${r}(${n});\n  return whole + fract;\n`,$y=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${bc(\"xResized\",\"lengthOriginal\",\"lengthResized\",t)}\n          }\n        `;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${bc(\"xResized\",\"lengthOriginal - 1\",\"lengthResized - 1\",t)}\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",xy=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Sy=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),o=e.length===0?r:e.slice();return t.length>0?(t.forEach((a,s)=>{r[a]=o[s],r[s+n]=o[t.length+s]}),r):o},Ty=(e,t,n,r)=>{let o=[];if(n.length>0)if(r.length>0){if(e.forEach(a=>o.push(a)),Math.max(...r)>e.length)throw new Error(\"axes is out of bound\");r.forEach((a,s)=>o[a]=n[s])}else n.forEach(a=>o.push(a));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((a,s)=>Math.round(a*t[s]))}return o},Cy=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case\"not_larger\":return n.axes.length>0?Math.min(...n.axes.map(a=>t[a]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return n.axes.length>0?Math.max(...n.axes.map(a=>t[a]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return n.axes.length>0?(n.axes.forEach(a=>t[a]=r),n.axes.forEach(a=>o[a]=Math.round(e[a]*t[a]))):(t.fill(r,0,t.length),o.forEach((a,s)=>o[s]=Math.round(a*t[s]))),o},Iy=(e,t,n,r,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${K(\"uniforms.scales\",\"i\",r)};\n        var roi_low = ${K(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${K(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ay=(e,t,n,r,o,a,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${K(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${K(\"uniforms.roi\",\"i\",a)};\n          var roi_hi = ${K(\"uniforms.roi\",`i + ${n.length}`,a)};\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")}\n      }\n      return input_indices;\n    }`,ky=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${K(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,_c=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",n,\"batch\")};\n`:\"\",Ey=(e,t,n,r,o)=>{let[s,d,l,p]=n.length===2?[-1,0,1,-1]:[0,2,3,1],f=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${f} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${n[l]} - 1))`)};\n      ${_c(e,p,s,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${f} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${f} = originalIndices[${d}];\n      var col:${f} = originalIndices[${l}];\n      ${r?`if (row < 0 || row > (${n[d]} - 1) || col < 0 || col > (${n[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${n[d]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${s}])`:\"0\"};\n      var x11: ${f} = getInputValue(batch, channel, row1, col1);\n      var x12: ${f} = getInputValue(batch, channel, row1, col2);\n      var x21: ${f} = getInputValue(batch, channel, row2, col1);\n      var x22: ${f} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${f} = abs(row - ${f}(row1));\n      var dx2: ${f} = abs(${f}(row2) - row);\n      var dy1: ${f} = abs(col - ${f}(col1));\n      var dy2: ${f} = abs(${f}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Py=(e,t,n,r,o,a,s,d,l,p)=>{let f=n.length===2,h=!0,[y,_]=f?[0,1]:h?[2,3]:[1,2],b=e.type.value,w=S=>{let $=S===y?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${b} {\n        var output_index = ${t.indicesGet(\"output_indices\",S)};\n        var originalIdx: ${b} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[S]},\n        ${r[S]}, ${n[S]}, ${a[S]}, ${a[S]} + ${n.length});\n        var fractOriginalIdx: ${b} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${n[S]} - 1))) {\n          return ${l};\n        }\n        var data: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${b} = originalIdx + ${b}(i);\n          if (${$} < 0 || ${$} >= ${n[S]}) {\n            ${p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${n[S]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",S,`u32(${$})`)};\n          data[i + 1] = ${S===y?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${w(y)};\n    ${w(_)};\n  fn getCubicInterpolationCoefs(s: ${b}) -> array<${b}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${b} = 1.0 - absS;\n    var twoMinusAbsS: ${b} = 2.0 - absS;\n    var onePlusAbsS: ${b} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${b}, 4>, coefs: array<${b}, 4>) -> ${b} {\n    var coefsSum: ${b} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${b} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},zy=(e,t,n,r,o)=>{let[s,d,l,p,f]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${n[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${n[p]} - 1))`)};\n      ${_c(e,f,s,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${h} = originalIndices[${d}];\n      var height:${h} = originalIndices[${l}];\n      var width:${h} = originalIndices[${p}];\n      ${r?`if (depth < 0 || depth > (${n[d]} - 1) || height < 0 || height > (${n[l]} - 1) || width < 0 || (width > ${n[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${n[d]} - 1));\n      height = max(0, min(height, ${n[l]} - 1));\n      width = max(0, min(width, ${n[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${f}])`:\"0\"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${s}])`:\"0\"};\n\n      var x111: ${h} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${h} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${h} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${h} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${h} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${h} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${h} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${h} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${h} = abs(depth - ${h}(depth1));\n      var dx2: ${h} = abs(${h}(depth2) - depth);\n      var dy1: ${h} = abs(height - ${h}(height1));\n      var dy2: ${h} = abs(${h}(height2) - height);\n      var dz1: ${h} = abs(width - ${h}(width1));\n      var dz2: ${h} = abs(${h}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Oy=(e,t,n,r,o,a)=>{let s=e.dims,d=Sy(a,t.axes,s.length),l=Ty(s,r,o,t.axes),p=r.slice();r.length===0&&(p=s.map((v,T)=>v===0?1:l[T]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Cy(s,p,t)));let f=N(\"output\",e.dataType,l.length),h=P(\"input\",e.dataType,s.length),y=E.size(l),_=s.length===l.length&&s.every((v,T)=>v===l[T]),b=t.coordinateTransformMode===\"tf_crop_and_resize\",w=t.extrapolationValue,S=h.type.value,$=v=>`\n      ${_?\"\":`\n      ${$y(t.coordinateTransformMode,S)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${ky(h,s)};\n              ${xy(t.nearestMode,n,S)};\n              ${Ay(h,f,s,l,p.length,d.length,b)};\n              `;case\"linear\":return`\n              ${Iy(f,s,l,p.length,d.length)};\n              ${(()=>{if(s.length===2||s.length===4)return`${Ey(h,f,s,b,w)}`;if(s.length===3||s.length===5)return`${zy(h,f,s,b,w)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(s.length===2||s.length===4)return`${Py(h,f,s,l,p,d,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(h,f)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${f.offsetToIndices(\"global_idx\")};\n        var input_indices: ${h.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${h.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${s.length===2||s.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${n}|${p.length>0?t.mode===\"cubic\"?p:p.length:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${t.mode===\"nearest\"?s.length:s}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},{type:1,data:p},{type:1,data:d},...H(s,l)]})}},Dy=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},wc=(e,t)=>{let n=[],r=[],o=[],a=Dy(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");vy(e.inputs,t,a,n,r,o),e.compute(Oy(e.inputs[0],t,a,n,r,o),{inputs:[0]})},vc=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,o=e.cubicCoeffA,a=e.excludeOutside!==0,s=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return re({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:o,excludeOutside:a,extrapolationValue:s,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var By,My,xc,Sc=G(()=>{\"use strict\";te();ae();Ce();ce();By=(e,t)=>{let[n,r,o,a]=e,{numHeads:s,rotaryEmbeddingDim:d}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!E.areEqual(r.dims,[])&&!E.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!E.areEqual(o.dims,a.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&s===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=n.dims[0],p=n.dims[n.dims.length-2],f=o.dims[0],h=E.sizeFromDimension(n.dims,1)/p,y=d===0?o.dims[1]*2:h/s;if(d>y)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(r.dims.length===2){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(p!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(y/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>f)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},My=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:o,scale:a}=t,s=e[0].dims[0],d=E.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,f=e[2].dims[1],h=o===0?f*2:p/r,y=new Array(s,l,p/h,h-f),_=E.computeStrides(y),b=[{type:1,data:a},{type:12,data:y},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,h,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,h,l*h,1]}):[],...H(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],w=S=>{let $=P(\"input\",e[0].dataType,e[0].dims.length),v=P(\"position_ids\",e[1].dataType,e[1].dims.length),T=P(\"cos_cache\",e[2].dataType,e[2].dims.length),C=P(\"sin_cache\",e[3].dataType,e[3].dims.length),A=N(\"output\",e[0].dataType,e[0].dims.length);return S.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:y.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${S.declareVariables($,v,T,C,A)}\n\n        ${S.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",N(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${C.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${C.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:re({interleaved:n}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(y)/Et)},programUniforms:b})}},xc=(e,t)=>{By(e.inputs,t),e.compute(My(e.inputs,t))}});var Ry,Uy,Tc,Cc=G(()=>{\"use strict\";te();ae();ce();Ry=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(n.dims.length!==3&&n.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(n.dims[n.dims.length-2]!==a)throw new Error(\"Skip must have the same sequence length as input\");if(r.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(r.dims[r.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let s=e[3];if(s.dims.length!==1)throw new Error(\"Beta must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let s=e[4];if(s.dims.length!==1)throw new Error(\"Bias must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Uy=(e,t,n,r)=>{let o=t.simplified,a=e[0].dims,s=E.size(a),d=a,l=s,p=a.slice(-1)[0],f=r?a.slice(0,-1).concat(1):[],h=!o&&e.length>3,y=e.length>4,_=r&&n>1,b=r&&n>2,w=n>3,S=64,$=ge(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],T=A=>{let k=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],O=[P(\"x\",e[0].dataType,e[0].dims,$),P(\"skip\",e[1].dataType,e[1].dims,$),P(\"gamma\",e[2].dataType,e[2].dims,$)];h&&O.push(P(\"beta\",e[3].dataType,e[3].dims,$)),y&&O.push(P(\"bias\",e[4].dataType,e[4].dims,$)),O.push(N(\"output\",e[0].dataType,d,$)),_&&O.push(N(\"mean_output\",1,f)),b&&O.push(N(\"inv_std_output\",1,f)),w&&O.push(N(\"input_skip_bias_sum\",e[0].dataType,d,$));let M=_e(e[0].dataType),V=_e(1,$);return`\n\n      ${A.registerUniforms(k).declareVariables(...O)}\n      var<workgroup> sum_shared : array<${V}, ${S}>;\n      var<workgroup> sum_squared_shared : array<${V}, ${S}>;\n\n      ${A.mainStart([S,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${S};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${S};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${S-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${y?\"bias[offset1d + i]\":M+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${w?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Pt(M,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${S};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Ke(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Ke(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${b?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${M}(mean)`}) *\n            ${M}(inv_std_dev) * gamma[offset1d + i]\n            ${h?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},C=[{dims:d,dataType:e[0].dataType}];return n>1&&C.push({dims:f,dataType:1}),n>2&&C.push({dims:f,dataType:1}),n>3&&C.push({dims:a,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${b};${w}`,inputDependencies:e.map((A,k)=>\"type\")},getShaderSource:T,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Tc=(e,t)=>{Ry(e.inputs);let r=[0];e.outputCount>1&&r.push(-3),e.outputCount>2&&r.push(-3),e.outputCount>3&&r.push(3),e.compute(Uy(e.inputs,t,e.outputCount,!1),{outputs:r})}});var Ny,nn,Vy,Ic,Wy,Ly,Ac,kc,Ec=G(()=>{\"use strict\";te();ae();Ce();ce();Ny=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((n,r)=>{if(e[r+1].dataType!==6&&e[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},nn=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},Vy=(e,t)=>{if(e.length>1){let n=nn(e,1),r=nn(e,2),o=nn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),re({starts:n,ends:r,axes:o})}else return t},Ic=(e,t,n,r,o)=>{let a=e;return e<0&&(a+=n[r[t]]),o[t]<0?Math.max(0,Math.min(a,n[r[t]]-1)):Math.max(0,Math.min(a,n[r[t]]))},Wy=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n            let steps_i = ${K(\"uniforms.steps\",\"i\",n.length)};\n            let signs_i = ${K(\"uniforms.signs\",\"i\",n.length)};\n            let starts_i = ${K(\"uniforms.starts\",\"i\",n.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,Ly=(e,t)=>{let n=e[0].dims,r=E.size(n),o=t.axes.length>0?E.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=nn(e,4);a.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),a.length===0&&(a=Array(o.length).fill(1));let s=t.starts.map(($,v)=>Ic($,v,n,o,a)),d=t.ends.map(($,v)=>Ic($,v,n,o,a));if(o.length!==s.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==n.length)for(let $=0;$<n.length;++$)o.includes($)||(s.splice($,0,0),d.splice($,0,n[$]),a.splice($,0,1));let l=a.map($=>Math.sign($));a.forEach(($,v,T)=>{if($<0){let C=(d[v]-s[v])/$,A=s[v],k=A+C*a[v];s[v]=k,d[v]=A,T[v]=-$}});let p=n.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-s[$])/a[$])});let f={dims:p,dataType:e[0].dataType},h=N(\"output\",e[0].dataType,p.length),y=P(\"input\",e[0].dataType,e[0].dims.length),_=E.size(p),b=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:s.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:a.length}],w=[{type:12,data:_},{type:12,data:s},{type:6,data:l},{type:12,data:a},...H(e[0].dims,p)],S=$=>`\n      ${$.registerUniforms(b).declareVariables(y,h)}\n        ${Wy(y,h,n)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${h.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${h.setByOffset(\"global_idx\",y.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${s.length}_${a.length}`,inputDependencies:[\"rank\"]},getShaderSource:S,getRunData:()=>({outputs:[f],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:w})}},Ac=(e,t)=>{Ny(e.inputs,t);let n=Vy(e.inputs,t);e.compute(Ly(e.inputs,n),{inputs:[0]})},kc=e=>{let t=e.starts,n=e.ends,r=e.axes;return re({starts:t,ends:n,axes:r})}});var Gy,Hy,Pc,zc,Oc=G(()=>{\"use strict\";te();ae();Ce();ct();ce();Gy=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},Hy=(e,t)=>{let n=e.inputs[0],r=n.dims,o=E.size(r),a=r.length,s=E.normalizeAxis(t.axis,a),d=s<r.length-1,l,p=[];d?(p=Array.from({length:a},(O,M)=>M),p[s]=a-1,p[a-1]=s,l=e.compute(Oe(n,p),{inputs:[n],outputs:[-1]})[0]):l=n;let f=l.dims,h=f[a-1],y=o/h,_=ge(h),b=h/_,w=64;y===1&&(w=256);let S=(O,M)=>M===4?`max(max(${O}.x, ${O}.y), max(${O}.z, ${O}.w))`:M===2?`max(${O}.x, ${O}.y)`:M===3?`max(max(${O}.x, ${O}.y), ${O}.z)`:O,$=P(\"x\",l.dataType,l.dims,_),v=N(\"result\",l.dataType,l.dims,_),T=$.type.value,C=_e(l.dataType)===\"f32\"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,A=O=>`\n      var<workgroup> rowMaxShared : ${T};\n      var<workgroup> rowSumShared : ${T};\n      var<workgroup> threadShared : array<${T}, ${w}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${O.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${O.mainStart(w)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${w};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${C}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${T}(${S(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${T}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${T}(${Ke(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,k=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${w}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:f,dataType:l.dataType}],dispatchGroup:{x:y},programUniforms:[{type:6,data:b}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Oe(k,p),{inputs:[k]})},Pc=(e,t)=>{Gy(e.inputs),Hy(e,t)},zc=e=>re({axis:e.axis})});var Dc,Fy,qy,Ky,Bc,Mc=G(()=>{\"use strict\";te();ae();ce();Dc=e=>Array.from(e.getBigInt64Array(),Number),Fy=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Dc(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},qy=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Ky=(e,t)=>{let n=e[0].dims,r=t??Dc(e[1]),o=qy(n,r),a=E.size(o),s=e[0].dataType,d=P(\"input\",s,n.length),l=N(\"output\",s,o.length),p=f=>`\n      const inputShape = ${d.indices(...n)};\n      ${f.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${f.mainStart()}\n      ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${r}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...H(e[0].dims,o)]}),getShaderSource:p}},Bc=e=>{Fy(e.inputs),e.compute(Ky(e.inputs),{inputs:[0]})}});var jy,Zy,Rc,Uc=G(()=>{\"use strict\";te();ae();ce();jy=(e,t,n,r,o)=>{let a=N(\"output_data\",o,n.length,4),s=P(\"a_data\",t[1].dataType,t[1].dims.length,4),d=P(\"b_data\",t[2].dataType,t[2].dims.length,4),l=P(\"c_data\",t[0].dataType,t[0].dims.length,4),p,f=(h,y,_)=>`select(${y}, ${h}, ${_})`;if(!r)p=a.setByOffset(\"global_idx\",f(s.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let h=(y,_,b=\"\")=>{let w=`a_data[index_a${_}][component_a${_}]`,S=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${a.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${s.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${y}[${_}] = ${b}(${f(w,S,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${h(\"data\",0,\"u32\")}\n            ${h(\"data\",1,\"u32\")}\n            ${h(\"data\",2,\"u32\")}\n            ${h(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${h(\"output_data[global_idx]\",0)}\n            ${h(\"output_data[global_idx]\",1)}\n            ${h(\"output_data[global_idx]\",2)}\n            ${h(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,s,d,a)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},Zy=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,o=e[1].dataType,a=!(E.areEqual(t,n)&&E.areEqual(n,r)),s=t,d=E.size(t);if(a){let p=rt.calcShape(rt.calcShape(t,n,!1),r,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");s=p,d=E.size(s)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>jy(p,e,s,a,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...H(r,t,n,s)]})}},Rc=e=>{e.compute(Zy(e.inputs))}});var Nc,Vc=G(()=>{\"use strict\";_u();qr();$u();Su();dd();wd();xd();Nd();qd();Zd();Xd();nl();al();ul();cl();fl();yl();wl();xl();Cl();Dl();Rl();Nl();Wl();Hl();So();ql();dc();pc();fc();yc();Hr();$c();Sc();Cc();Ec();Oc();Co();Mc();ct();jr();Uc();Nc=new Map([[\"Abs\",[Tu]],[\"Acos\",[Cu]],[\"Acosh\",[Iu]],[\"Add\",[ld]],[\"ArgMax\",[bu,co]],[\"ArgMin\",[yu,co]],[\"Asin\",[Au]],[\"Asinh\",[ku]],[\"Atan\",[Eu]],[\"Atanh\",[Pu]],[\"Attention\",[wu]],[\"AveragePool\",[ec,Jl]],[\"BatchNormalization\",[vu]],[\"BiasAdd\",[xu]],[\"BiasSplitGelu\",[ud]],[\"Cast\",[Ou,zu]],[\"Ceil\",[Bu]],[\"Clip\",[Du]],[\"Concat\",[vd,$d]],[\"Conv\",[wo,_o]],[\"ConvTranspose\",[Fd,Gd]],[\"Cos\",[Mu]],[\"Cosh\",[Ru]],[\"CumSum\",[Kd,jd]],[\"DepthToSpace\",[Qd,Yd]],[\"DequantizeLinear\",[lc,cc]],[\"Div\",[cd]],[\"Einsum\",[tl,rl]],[\"Elu\",[Uu,tr]],[\"Equal\",[pd]],[\"Erf\",[Nu]],[\"Exp\",[Vu]],[\"Expand\",[il]],[\"FastGelu\",[sl]],[\"Floor\",[Wu]],[\"FusedConv\",[wo,_o]],[\"Gather\",[ll,dl]],[\"GatherElements\",[_l,bl]],[\"GatherBlockQuantized\",[hl,gl]],[\"GatherND\",[pl,ml]],[\"Gelu\",[Lu]],[\"Gemm\",[$l,vl]],[\"GlobalAveragePool\",[nc,rc]],[\"GlobalMaxPool\",[uc,sc]],[\"Greater\",[gd]],[\"GreaterOrEqual\",[bd]],[\"GridSample\",[Sl,Tl]],[\"GroupQueryAttention\",[Ol]],[\"HardSigmoid\",[Qu,Zu]],[\"InstanceNormalization\",[Ml]],[\"LayerNormalization\",[Ul]],[\"LeakyRelu\",[Gu,tr]],[\"Less\",[yd]],[\"LessOrEqual\",[_d]],[\"Log\",[id]],[\"MatMul\",[Vl]],[\"MatMulNBits\",[Ll,Gl]],[\"MaxPool\",[ic,ac]],[\"Mul\",[md]],[\"MultiHeadAttention\",[kl,Al]],[\"Neg\",[Fu]],[\"Not\",[Hu]],[\"Pad\",[Fl]],[\"Pow\",[fd]],[\"QuickGelu\",[ad,tr]],[\"Range\",[mc]],[\"Reciprocal\",[qu]],[\"ReduceMin\",[cu]],[\"ReduceMean\",[au]],[\"ReduceMax\",[lu]],[\"ReduceSum\",[mu]],[\"ReduceProd\",[pu]],[\"ReduceL1\",[su]],[\"ReduceL2\",[uu]],[\"ReduceLogSum\",[hu]],[\"ReduceLogSumExp\",[du]],[\"ReduceSumSquare\",[fu]],[\"Relu\",[Ku]],[\"Resize\",[wc,vc]],[\"RotaryEmbedding\",[xc]],[\"ScatterND\",[gc,hc]],[\"Sigmoid\",[ju]],[\"Sin\",[Yu]],[\"Sinh\",[Xu]],[\"Slice\",[Ac,kc]],[\"SkipLayerNormalization\",[Tc]],[\"Split\",[El,Pl]],[\"Sqrt\",[Ju]],[\"Softmax\",[Pc,zc]],[\"Sub\",[hd]],[\"Tan\",[ed]],[\"Tanh\",[rd]],[\"ThresholdedRelu\",[od,tr]],[\"Tile\",[Bc]],[\"Transpose\",[Ks,js]],[\"Where\",[Rc]]])});var on,Wc=G(()=>{\"use strict\";Ge();tt();ce();on=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,n){this.repo.set(t,n)}run(t,n,r,o,a){Ne(t.programInfo.name);let s=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let f of n)l.push({binding:l.length,resource:{buffer:f.buffer}});for(let f of r)l.push({binding:l.length,resource:{buffer:f.buffer}});a&&l.push({binding:l.length,resource:a});let p=s.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let f={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(f)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Be(t.programInfo.name)}dispose(){}build(t,n){Ne(t.name);let r=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(h=>{r.features.has(h.feature)&&o.push(`enable ${h.extension};`)});let s=Fs(n,this.backend.device.limits),d=t.getShaderSource(s),l=`${o.join(`\n`)}\n${s.additionalImplementations}\n${d}`,p=r.createShaderModule({code:l,label:t.name});me(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let f=r.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return Be(t.name),{programInfo:t,computePipeline:f,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(t){let n=typeof t==\"number\"?t:t.x,r=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=a&&r<=a&&o<=a)return[n,r,o];let s=n*r*o,d=Math.ceil(Math.sqrt(s));if(d>a){if(d=Math.ceil(Math.cbrt(s)),d>a)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var Qy,Yy,Io,Ao,an,Lc=G(()=>{\"use strict\";Ge();te();tt();Jn();Ws();Vc();Wc();Qy=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let o=e[r].dataType;switch(t[r]){case\"none\":{n.push(\"\");break}case\"type\":{n.push(`${o}`);break}case\"rank\":{let a=e[r].dims.length;n.push(`${o};${a}`);break}case\"dims\":{let a=e[r].dims.join(\",\");n.push(`${o};${a}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join(\"|\")},Yy=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+=\"[\"+e.shaderCache.hint+\"]\"),r+=\":\"+n+`:${Qy(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,r},Io=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ao=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let n=t.limits;!this.subgroupsSupported||!n.minSubgroupSize||!n.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[n.minSubgroupSize,n.maxSubgroupSize]}},an=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,n){this.env=t;let r=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r},a=s=>n.features.has(s)&&r.push(s)&&!0;a(\"chromium-experimental-timestamp-query-inside-passes\")||a(\"timestamp-query\"),a(\"shader-f16\"),a(\"subgroups\")&&a(\"subgroups-f16\"),this.device=await n.requestDevice(o),this.deviceInfo=new Ao(this.device),this.adapterInfo=new Io(n.info||await n.requestAdapterInfo()),this.gpuDataManager=Vs(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ur(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:n,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),n={};this.queryType===\"at-passes\"&&(n.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(n)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ne(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let n=new BigUint64Array(t.getMappedRange()),r=this.pendingQueries.get(t);for(let o=0;o<n.length/2;o++){let a=r[o],s=a.kernelId,d=this.kernels.get(s),l=d.kernelType,p=d.kernelName,f=a.programName,h=a.inputTensorViews,y=a.outputTensorViews,_=n[o*2],b=n[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let w=Number(_-this.queryTimeBase),S=Number(b-this.queryTimeBase);if(!Number.isSafeInteger(w)||!Number.isSafeInteger(S))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:h.map($=>({dims:$.dims,dataType:_t($.dataType)})),outputsMetadata:y.map($=>({dims:$.dims,dataType:_t($.dataType)})),kernelId:s,kernelType:l,kernelName:p,programName:f,startTime:w,endTime:S});else{let $=\"\";h.forEach((T,C)=>{$+=`input[${C}]: [${T.dims}] | ${_t(T.dataType)}, `});let v=\"\";y.forEach((T,C)=>{v+=`output[${C}]: [${T.dims}] | ${_t(T.dataType)}, `}),console.log(`[profiling] kernel \"${s}|${l}|${p}|${f}\" ${$}${v}execution time: ${S-w} ns`)}vr(\"GPU\",`${f}::${_}::${b}`)}t.unmap(),this.pendingQueries.delete(t)}),Be()}run(t,n,r,o,a,s){Ne(t.name);let d=[];for(let T=0;T<n.length;++T){let C=n[T].data;if(C===0)continue;let A=this.gpuDataManager.get(C);if(!A)throw new Error(`no GPU data for input: ${C}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:f}=t.getRunData(n),h=r.length===0?l.map((T,C)=>C):r;if(h.length!==l.length)throw new Error(`Output size ${h.length} must be equal to ${l.length}.`);let y=[],_=[];for(let T=0;T<l.length;++T){if(!Number.isInteger(h[T])||h[T]<-3||h[T]>=s)throw new Error(`Invalid output index: ${h[T]}`);if(h[T]===-3)continue;let C=h[T]===-1,A=h[T]===-2,k=C||A?a(l[T].dataType,l[T].dims):o(h[T],l[T].dataType,l[T].dims);if(y.push(k),k.data===0)continue;let O=this.gpuDataManager.get(k.data);if(!O)throw new Error(`no GPU data for output: ${k.data}`);if(C&&this.temporaryData.push(O),A){let M=this.kernelPersistentData.get(this.currentKernelId);M||(M=[],this.kernelPersistentData.set(this.currentKernelId,M)),M.push(O)}_.push(O)}if(d.length!==n.length||_.length!==y.length){if(_.length===0)return Be(t.name),y;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let b;if(f){let T=0,C=[];f.forEach(M=>{let V=typeof M.data==\"number\"?[M.data]:M.data;if(V.length===0)return;let F=M.type===10?2:4,j,ne;M.type===10?(ne=V.length>4?16:V.length>2?8:V.length*F,j=V.length>4?16:F*V.length):(ne=V.length<=2?V.length*F:16,j=16),T=Math.ceil(T/ne)*ne,C.push(T);let W=M.type===10?8:4;T+=V.length>4?Math.ceil(V.length/W)*j:V.length*F});let A=16;T=Math.ceil(T/A)*A;let k=new ArrayBuffer(T);f.forEach((M,V)=>{let F=C[V],j=typeof M.data==\"number\"?[M.data]:M.data;if(M.type===6)new Int32Array(k,F,j.length).set(j);else if(M.type===12)new Uint32Array(k,F,j.length).set(j);else if(M.type===10)new Uint16Array(k,F,j.length).set(j);else if(M.type===1)new Float32Array(k,F,j.length).set(j);else throw new Error(`Unsupported uniform type: ${_t(M.type)}`)});let O=this.gpuDataManager.create(T,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(O.buffer,0,k,0,T),this.gpuDataManager.release(O.id),b={offset:0,size:T,buffer:O.buffer}}let w=this.programManager.normalizeDispatchGroupSize(p),S=w[1]===1&&w[2]===1,$=Yy(t,n,S),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,w),this.programManager.setArtifact($,v),me(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),f&&v.uniformVariablesInfo){if(f.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${f.length} in program \"${v.programInfo.name}\".`);for(let T=0;T<f.length;T++){let C=f[T],A=C.type,k=typeof C.data==\"number\"?1:C.data.length,[O,M]=v.uniformVariablesInfo[T];if(A!==O||k!==M)throw new Error(`Uniform variable ${T} mismatch: expect type ${O} with size ${M}, got type ${A} with size ${k} in program \"${v.programInfo.name}\".`)}}if(me(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${w[0]}x${w[1]}x${w[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let T={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:n,outputTensorViews:y};this.pendingKernels.push(T),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(T)}return this.programManager.run(v,d,_,w,b),Be(t.name),y}upload(t,n){this.gpuDataManager.upload(t,n)}memcpy(t,n){this.gpuDataManager.memcpy(t,n)}async download(t,n){await this.gpuDataManager.download(t,n)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,n,r,o){let a=Nc.get(t);if(!a)throw new Error(`kernel not implemented: ${t}`);let s={kernelType:t,kernelName:o,kernelEntry:a[0],attributes:[a[1],r]};this.kernels.set(n,s)}releaseKernel(t){let n=this.kernelPersistentData.get(t);if(n){for(let r of n)this.gpuDataManager.release(r.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,n,r){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let a=o.kernelType,s=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${a}] ${s}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),me(\"info\",()=>`[WebGPU] Start to run kernel \"[${a}] ${s}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(n,l[1]),0}catch(f){return r.push(Promise.resolve(`[WebGPU] Kernel \"[${a}] ${s}\" failed. ${f}`)),1}finally{p&&r.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel \"[${a}] ${s}\": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,n,r,o){let a=this.sessionExternalDataMapping.get(t);a||(a=new Map,this.sessionExternalDataMapping.set(t,a));let s=a.get(n),d=this.gpuDataManager.registerExternalBuffer(r,o,s);return a.set(n,[d,r]),d}unregisterBuffers(t){let n=this.sessionExternalDataMapping.get(t);n&&(n.forEach(r=>this.gpuDataManager.unregisterExternalBuffer(r[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let n=this.gpuDataManager.get(t);if(!n)throw new Error(`no GPU data for buffer: ${t}`);return n.buffer}createDownloader(t,n,r){return async()=>{let o=await no(this,t,n);return Nr(o.buffer,r)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){me(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){me(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){me(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),n=this.capturedPendingKernels.get(this.currentSessionId),r=t.length;this.pendingKernels=[];for(let o=0;o<r;o++){let a=this.getComputePassEncoder(),s=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),a.setPipeline(s.computePipeline),a.setBindGroup(0,s.bindGroup),a.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(n[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Xy,Gc,Jy,Hc,sn,un,ko,Fc,qc=G(()=>{\"use strict\";tt();Xy=1,Gc=()=>Xy++,Jy=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),Hc=(e,t)=>{let n=Jy.get(e);if(!n)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((r,o)=>r*o)*n/8):0},sn=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Hc(this.dataType,this.tensorShape)}destroy(){me(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,n,r){return this.mlContext===t&&this.dataType===n&&this.tensorShape.length===r.length&&this.tensorShape.every((o,a)=>o===r[a])}},un=class{constructor(t,n){this.tensorManager=t;this.wrapper=n}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,n,r,o){let a=this.tensorManager.getMLContext(t);if(this.wrapper){if(this.wrapper.canReuseTensor(a,n,r))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==Hc(n,r))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let s=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,n,r,s,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else me(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},ko=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(t){let n=this.backend.getMLContext(t);if(!n)throw new Error(\"MLContext not found for session.\");return n}reserveTensorId(){let t=Gc();return this.tensorTrackersById.set(t,new un(this)),t}releaseTensorId(t){let n=this.tensorTrackersById.get(t);n&&(this.tensorTrackersById.delete(t),n.tensorWrapper&&this.releaseTensor(n.tensorWrapper))}async ensureTensor(t,n,r,o,a){me(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${n}, dataType: ${r}, shape: ${o}, copyOld: ${a}}`);let s=this.tensorTrackersById.get(n);if(!s)throw new Error(\"Tensor not found.\");return s.ensureTensor(t,r,o,a)}upload(t,n){let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");r.upload(n)}async download(t,n){me(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${n?.byteLength}}`);let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");return r.download(n)}releaseTensorsForSession(t){for(let n of this.freeTensors)n.sessionId===t&&n.destroy();this.freeTensors=this.freeTensors.filter(n=>n.sessionId!==t)}registerTensor(t,n,r,o){let a=this.getMLContext(t),s=Gc(),d=new sn({sessionId:t,context:a,tensor:n,dataType:r,shape:o});return this.tensorTrackersById.set(s,new un(this,d)),this.externalTensors.add(d),s}async getCachedTensor(t,n,r,o,a,s){let d=this.getMLContext(t);for(let[p,f]of this.freeTensors.entries())if(f.canReuseTensor(d,n,r)){me(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${n}, shape: ${r}}`);let h=this.freeTensors.splice(p,1)[0];return h.sessionId=t,h}me(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${n}, shape: ${r}}`);let l=await d.createTensor({dataType:n,shape:r,dimensions:r,usage:o,writable:a,readable:s});return new sn({sessionId:t,context:d,tensor:l,dataType:n,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},Fc=(...e)=>new ko(...e)});var Eo,eb,dn,Kc=G(()=>{\"use strict\";te();bt();Jn();qc();tt();Eo=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),eb=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((o,a)=>o===r[a]&&e[o]===t[o])},dn=class{constructor(t){this.tensorManager=Fc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.temporaryGraphInputs=[];this.temporarySessionTensorIds=new Map;Ur(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){me(\"verbose\",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){me(\"verbose\",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let n=this.temporarySessionTensorIds.get(t);if(n){for(let r of n)me(\"verbose\",()=>`[WebNN] releasing temporary tensor {tensorId: ${r}}`),this.tensorManager.releaseTensorId(r);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let r=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let r=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let n=this.mlContextCache.findIndex(r=>eb(r.options,t));if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:r}),r}}registerMLContext(t,n){this.mlContextBySessionId.set(t,n);let r=this.sessionIdsByMLContext.get(n);r||(r=new Set,this.sessionIdsByMLContext.set(n,r)),r.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t);let n=this.mlContextBySessionId.get(t);if(!n)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let r=this.sessionIdsByMLContext.get(n);if(r.delete(t),r.size===0){this.sessionIdsByMLContext.delete(n);let o=this.mlContextCache.findIndex(a=>a.mlContext===n);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){me(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,n,r,o,a){let s=Eo.get(r);if(!s)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,n,s,o,a)}async createTemporaryTensor(t,n,r){me(\"verbose\",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${n}, shape: ${r}}`);let o=Eo.get(n);if(!o)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,a,o,r,!1);let s=this.temporarySessionTensorIds.get(t);return s?s.push(a):this.temporarySessionTensorIds.set(t,[a]),a}uploadTensor(t,n){if(!Ie().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");me(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${n.byteLength}}`),this.tensorManager.upload(t,n)}async downloadTensor(t,n){return this.tensorManager.download(t,n)}createMLTensorDownloader(t,n){return async()=>{let r=await this.tensorManager.download(t);return Nr(r,n)}}registerMLTensor(t,n,r,o){let a=Eo.get(r);if(!a)throw new Error(`Unsupported ONNX data type: ${r}`);let s=this.tensorManager.registerTensor(t,n,a,o);return me(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${n}, dataType: ${a}, dimensions: ${o}} -> {tensorId: ${s}}`),s}registerMLConstant(t,n,r,o,a,s){if(!s)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=s.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(n+r>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(n,n+r).buffer,f;switch(a.dataType){case\"float32\":f=new Float32Array(p);break;case\"float16\":f=new Uint16Array(p);break;case\"int32\":f=new Int32Array(p);break;case\"uint32\":f=new Uint32Array(p);break;case\"int64\":f=new BigInt64Array(p);break;case\"uint64\":f=new BigUint64Array(p);break;case\"int8\":f=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":f=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return me(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}}`),o.constant(a,f)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}isGraphInput(t,n){let r=this.sessionGraphInputs.get(t);return r?r.includes(n):!1}flush(){}}});var jc={};Zt(jc,{init:()=>tb});var ir,Po,tb,Zc=G(()=>{\"use strict\";te();Lc();tt();ae();Kc();ir=class e{constructor(t,n,r,o){this.module=t;this.dataType=n;this.data=r;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(E.size(t)!==E.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},Po=class{constructor(t,n,r){this.module=t;this.backend=n;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=n.adapterInfo,this.deviceInfo=n.deviceInfo;let o=t.PTR_SIZE,a=r/t.PTR_SIZE,s=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*a++,s));let d=Number(t.getValue(o*a++,s));this.outputCount=Number(t.getValue(o*a++,s)),this.customDataOffset=Number(t.getValue(o*a++,\"*\")),this.customDataSize=Number(t.getValue(o*a++,s));let l=[];for(let p=0;p<d;p++){let f=Number(t.getValue(o*a++,s)),h=Number(t.getValue(o*a++,\"*\")),y=Number(t.getValue(o*a++,s)),_=[];for(let b=0;b<y;b++)_.push(Number(t.getValue(o*a++,s)));l.push(new ir(t,f,h,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,n){let r=n?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=n?.outputs??[],a=(d,l,p)=>new ir(this.module,l,this.output(d,p),p),s=(d,l)=>{let p=wt(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let f=p>0?this.backend.gpuDataManager.create(p).id:0;return new ir(this.module,d,f,l)};return this.backend.run(t,r,o,a,s,this.outputCount)}output(t,n){let r=this.module.stackSave();try{let o=this.module.PTR_SIZE,a=o===4?\"i32\":\"i64\",s=this.module.stackAlloc((1+n.length)*o);this.module.setValue(s,n.length,a);for(let d=0;d<n.length;d++)this.module.setValue(s+o*(d+1),n[d],a);return this.module._JsepOutput(this.opKernelContext,t,s)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(r)}}},tb=async(e,t,n,r)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let a=new an;await a.initialize(n,r),o(\"webgpu\",[a,s=>a.alloc(Number(s)),s=>a.free(s),(s,d,l,p=!1)=>{if(p)me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(s)}, dst=${Number(d)}, size=${Number(l)}`),a.memcpy(Number(s),Number(d));else{me(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(s)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let f=t.HEAPU8.subarray(Number(s>>>0),Number(s>>>0)+Number(l));a.upload(Number(d),f)}},async(s,d,l)=>{me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${d}, size=${l}`),await a.download(Number(s),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(s,d,l)=>a.createKernel(s,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),s=>a.releaseKernel(s),(s,d,l,p)=>{me(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${s}, contextDataOffset=${d}`);let f=new Po(t,a,Number(d));return a.computeKernel(Number(s),f,p)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let a=new dn(n);o(\"webnn\",[a,()=>a.reserveTensorId(),s=>a.releaseTensorId(s),async(s,d,l,p,f)=>a.ensureTensor(s,d,l,p,f),(s,d)=>{a.uploadTensor(s,d)},async(s,d)=>a.downloadTensor(s,d)])}}});var rb,Cr,Ir,zt,nb,Yt,Ar,kr,Qc,Er,Pr,zr,qn=G(()=>{\"use strict\";zs();Ds();te();bt();Dr();Xn();rb=(e,t)=>{Ie()._OrtInit(e,t)!==0&&he(\"Can't initialize onnxruntime.\")},Cr=async e=>{rb(e.wasm.numThreads,Jt(e.logLevel))},Ir=async(e,t)=>{{let n=(Zc(),br(jc)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let r=e.webgpu.adapter;if(r){if(typeof r.limits!=\"object\"||typeof r.features!=\"object\"||typeof r.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let a=e.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${a}\"`);if(r=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:a}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await n(\"webgpu\",Ie(),e,r)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await n(\"webnn\",Ie(),e)}}},zt=new Map,nb=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetInputOutputCount(e,o,o+r)!==0&&he(\"Can't get session input/output count.\");let s=r===4?\"i32\":\"i64\";return[Number(t.getValue(o,s)),Number(t.getValue(o+r,s))]}finally{t.stackRestore(n)}},Yt=e=>{let t=Ie(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Ar=async(e,t)=>{let n,r,o=Ie();Array.isArray(e)?[n,r]=e:e.buffer===o.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Yt(e);let a=0,s=0,d=0,l=[],p=[],f=[];try{if([s,l]=Os(t),t?.externalData&&o.mountExternalData){let v=[];for(let T of t.externalData){let C=typeof T==\"string\"?T:T.path;v.push(er(typeof T==\"string\"?T:T.data).then(A=>{o.mountExternalData(C,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let C=v,A=C?.context,k=C?.gpuDevice,O=C?.deviceType,M=C?.powerPreference;A?o.currentContext=A:k?o.currentContext=await o.jsepCreateMLContext(k):o.currentContext=await o.jsepCreateMLContext({deviceType:O,powerPreference:M})}else o.currentContext=await o.jsepCreateMLContext();break}a=await o._OrtCreateSession(n,r,s),a===0&&he(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(a,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[h,y]=nb(a),_=!!t?.enableGraphCapture,b=[],w=[],S=[];for(let v=0;v<h;v++){let T=o._OrtGetInputName(a,v);T===0&&he(\"Can't get an input name.\"),p.push(T),b.push(o.UTF8ToString(T))}for(let v=0;v<y;v++){let T=o._OrtGetOutputName(a,v);T===0&&he(\"Can't get an output name.\"),f.push(T);let C=o.UTF8ToString(T);w.push(C);{if(_&&t?.preferredOutputLocation===void 0){S.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[C]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);S.push(A)}}let $=null;return S.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(a),d===0&&he(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:S,outputPreferredLocationsEncoded:S.map(v=>Yn(v))}),zt.set(a,[a,p,f,$,_,!1]),[a,b,w]}catch(h){throw p.forEach(y=>o._OrtFree(y)),f.forEach(y=>o._OrtFree(y)),d!==0&&o._OrtReleaseBinding(d)!==0&&he(\"Can't release IO binding.\"),a!==0&&o._OrtReleaseSession(a)!==0&&he(\"Can't release session.\"),h}finally{o._free(n),s!==0&&o._OrtReleaseSessionOptions(s)!==0&&he(\"Can't release session options.\"),l.forEach(h=>o._free(h)),o.unmountExternalData?.()}},kr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,o,a,s,d]=n;s&&(d&&t._OrtClearBoundOutputs(s.handle)!==0&&he(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(s.handle)!==0&&he(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),a.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(r)!==0&&he(\"Can't release session.\"),zt.delete(e)},Qc=async(e,t,n,r,o,a=!1)=>{if(!e){t.push(0);return}let s=Ie(),d=s.PTR_SIZE,l=e[0],p=e[1],f=e[3],h=f,y,_;if(l===\"string\"&&(f===\"gpu-buffer\"||f===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(a&&f!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(f===\"gpu-buffer\"){let S=e[2].gpuBuffer;_=wt(Rt(l),p);let $=s.jsepRegisterBuffer;if(!$)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');y=$(r,o,S,_)}else if(f===\"ml-tensor\"){let S=e[2].mlTensor;_=wt(Rt(l),p);let $=s.jsepRegisterMLTensor;if(!$)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');y=$(r,S,Rt(l),p)}else{let S=e[2];if(Array.isArray(S)){_=d*S.length,y=s._malloc(_),n.push(y);for(let $=0;$<S.length;$++){if(typeof S[$]!=\"string\")throw new TypeError(`tensor data at index ${$} is not a string`);s.setValue(y+$*d,Pe(S[$],n),\"*\")}}else{let $=s.jsepIsGraphInput;if(l!==\"string\"&&$){let v=s._OrtGetInputName(r,o),T=s.UTF8ToString(v);if($(r,T)){let C=Rt(l);_=wt(C,p),h=\"ml-tensor\";let A=s.jsepCreateTemporaryTensor,k=s.jsepUploadTensor;if(!A||!k)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');let O=await A(r,C,p);k(O,new Uint8Array(S.buffer,S.byteOffset,S.byteLength)),y=O}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}}let b=s.stackSave(),w=s.stackAlloc(4*p.length);try{p.forEach(($,v)=>s.setValue(w+v*d,$,d===4?\"i32\":\"i64\"));let S=s._OrtCreateTensor(Rt(l),y,_,w,p.length,Yn(h));S===0&&he(`Can't create tensor for input/output. session=${r}, index=${o}.`),t.push(S)}finally{s.stackRestore(b)}},Er=async(e,t,n,r,o,a)=>{let s=Ie(),d=s.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],f=l[1],h=l[2],y=l[3],_=l[4],b=l[5],w=t.length,S=r.length,$=0,v=[],T=[],C=[],A=[],k=s.stackSave(),O=s.stackAlloc(w*d),M=s.stackAlloc(w*d),V=s.stackAlloc(S*d),F=s.stackAlloc(S*d);try{[$,v]=Ps(a);for(let W=0;W<w;W++)await Qc(n[W],T,A,e,t[W],_);for(let W=0;W<S;W++)await Qc(o[W],C,A,e,w+r[W],_);for(let W=0;W<w;W++)s.setValue(O+W*d,T[W],\"*\"),s.setValue(M+W*d,f[t[W]],\"*\");for(let W=0;W<S;W++)s.setValue(V+W*d,C[W],\"*\"),s.setValue(F+W*d,h[r[W]],\"*\");if(y&&!b){let{handle:W,outputPreferredLocations:J,outputPreferredLocationsEncoded:ve}=y;if(f.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${f.length}).`);for(let Q=0;Q<w;Q++){let ee=t[Q];await s._OrtBindInput(W,f[ee],T[Q])!==0&&he(`Can't bind input[${Q}] for session=${e}.`)}for(let Q=0;Q<S;Q++){let ee=r[Q];o[Q]?.[3]?s._OrtBindOutput(W,h[ee],C[Q],0)!==0&&he(`Can't bind pre-allocated output[${Q}] for session=${e}.`):s._OrtBindOutput(W,h[ee],0,ve[ee])!==0&&he(`Can't bind output[${Q}] to ${J[Q]} for session=${e}.`)}zt.set(e,[p,f,h,y,_,!0])}s.jsepOnRunStart?.(p);let j;y?j=await s._OrtRunWithBinding(p,y.handle,S,V,$):j=await s._OrtRun(p,M,O,w,F,S,V,$),j!==0&&he(\"failed to call OrtRun().\");let ne=[];for(let W=0;W<S;W++){let J=Number(s.getValue(V+W*d,\"*\"));if(J===C[W]){ne.push(o[W]);continue}let ve=s.stackSave(),Q=s.stackAlloc(4*d),ee=!1,le,Z=0;try{s._OrtGetTensorData(J,Q,Q+d,Q+2*d,Q+3*d)!==0&&he(`Can't access output tensor data on index ${W}.`);let ke=d===4?\"i32\":\"i64\",Se=Number(s.getValue(Q,ke));Z=s.getValue(Q+d,\"*\");let D=s.getValue(Q+d*2,\"*\"),R=Number(s.getValue(Q+d*3,ke)),Y=[];for(let xe=0;xe<R;xe++)Y.push(Number(s.getValue(D+xe*d,ke)));s._OrtFree(D)!==0&&he(\"Can't free memory for tensor dims.\");let fe=Y.reduce((xe,be)=>xe*be,1);le=_t(Se);let Fe=y?.outputPreferredLocations[r[W]];if(le===\"string\"){if(Fe===\"gpu-buffer\"||Fe===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let xe=[];for(let be=0;be<fe;be++){let Ye=s.getValue(Z+be*d,\"*\"),Gt=s.getValue(Z+(be+1)*d,\"*\"),xt=be===fe-1?void 0:Gt-Ye;xe.push(s.UTF8ToString(Ye,xt))}ne.push([le,Y,xe,\"cpu\"])}else if(Fe===\"gpu-buffer\"&&fe>0){let xe=s.jsepGetBuffer;if(!xe)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let be=xe(Z),Ye=wt(Se,fe);if(Ye===void 0||!Mr(le))throw new Error(`Unsupported data type: ${le}`);ee=!0,ne.push([le,Y,{gpuBuffer:be,download:s.jsepCreateDownloader(be,Ye,le),dispose:()=>{s._OrtReleaseTensor(J)!==0&&he(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(Fe===\"ml-tensor\"&&fe>0){let xe=s.jsepEnsureTensor;if(!xe)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(wt(Se,fe)===void 0||!Rr(le))throw new Error(`Unsupported data type: ${le}`);let Ye=await xe(e,Z,Se,Y,!1);ee=!0,ne.push([le,Y,{mlTensor:Ye,download:s.jsepCreateMLTensorDownloader(Z,le),dispose:()=>{s.jsepReleaseTensorId(Z),s._OrtReleaseTensor(J)}},\"ml-tensor\"])}else{let xe=Br(le),be=new xe(fe);new Uint8Array(be.buffer,be.byteOffset,be.byteLength).set(s.HEAPU8.subarray(Z,Z+be.byteLength)),ne.push([le,Y,be,\"cpu\"])}}finally{s.stackRestore(ve),le===\"string\"&&Z&&s._free(Z),ee||s._OrtReleaseTensor(J),s.jsepOnRunEnd?.(p)}}return y&&!_&&(s._OrtClearBoundOutputs(y.handle)!==0&&he(\"Can't clear bound outputs.\"),zt.set(e,[p,f,h,y,_,!1])),ne}finally{s.stackRestore(k),T.forEach(j=>s._OrtReleaseTensor(j)),C.forEach(j=>s._OrtReleaseTensor(j)),A.forEach(j=>s._free(j)),$!==0&&s._OrtReleaseRunOptions($),v.forEach(j=>s._free(j))}},Pr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(\"invalid session id\");let r=n[0],o=t._OrtEndProfiling(r);o===0&&he(\"Can't get an profile file name.\"),t._OrtFree(o)},zr=e=>{let t=[];for(let n of e){let r=n[2];!Array.isArray(r)&&\"buffer\"in r&&t.push(r.buffer)}return t}});var Ot,He,ar,cn,pn,ln,zo,Oo,Wt,Lt,ib,Yc,Xc,Jc,ep,tp,rp,np,Do=G(()=>{\"use strict\";Ge();qn();bt();Sr();Ot=()=>!!we.wasm.proxy&&typeof document<\"u\",ar=!1,cn=!1,pn=!1,Oo=new Map,Wt=(e,t)=>{let n=Oo.get(e);n?n.push(t):Oo.set(e,[t])},Lt=()=>{if(ar||!cn||pn||!He)throw new Error(\"worker not ready\")},ib=e=>{switch(e.data.type){case\"init-wasm\":ar=!1,e.data.err?(pn=!0,zo[1](e.data.err)):(cn=!0,zo[0]()),ln&&(URL.revokeObjectURL(ln),ln=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=Oo.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},Yc=async()=>{if(!cn){if(ar)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(pn)throw new Error(\"previous call to 'initWasm()' failed.\");if(ar=!0,Ot())return new Promise((e,t)=>{He?.terminate(),As().then(([n,r])=>{try{He=r,He.onerror=a=>t(a),He.onmessage=ib,zo=[e,t];let o={type:\"init-wasm\",in:we};!o.in.wasm.wasmPaths&&(n||\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href}),He.postMessage(o),ln=n}catch(o){t(o)}},t)});try{await Tr(we.wasm),await Cr(we),cn=!0}catch(e){throw pn=!0,e}finally{ar=!1}}},Xc=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"init-ep\",[t,n]);let r={type:\"init-ep\",in:{epName:e,env:we}};He.postMessage(r)});await Ir(we,e)},Jc=async e=>Ot()?(Lt(),new Promise((t,n)=>{Wt(\"copy-from\",[t,n]);let r={type:\"copy-from\",in:{buffer:e}};He.postMessage(r,[e.buffer])})):Yt(e),ep=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Lt(),new Promise((n,r)=>{Wt(\"create\",[n,r]);let o={type:\"create\",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),He.postMessage(o,a)})}else return Ar(e,t)},tp=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"release\",[t,n]);let r={type:\"release\",in:e};He.postMessage(r)});kr(e)},rp=async(e,t,n,r,o,a)=>{if(Ot()){if(n.some(s=>s[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(s=>s))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Lt(),new Promise((s,d)=>{Wt(\"run\",[s,d]);let l=n,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:r,options:a}};He.postMessage(p,zr(l))})}else return Er(e,t,n,r,o,a)},np=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"end-profiling\",[t,n]);let r={type:\"end-profiling\",in:e};He.postMessage(r)});Pr(e)}});var op,ab,mn,ip=G(()=>{\"use strict\";Ge();Do();te();xr();Xn();op=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ab=e=>{switch(e[3]){case\"cpu\":return new qe(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Mr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:o}=e[2];return qe.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Rr(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:o}=e[2];return qe.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},mn=class{async fetchModelAndCopyToWasmMemory(t){return Jc(await er(t))}async loadModel(t,n){Ne();let r;typeof t==\"string\"?r=await this.fetchModelAndCopyToWasmMemory(t):r=t,[this.sessionId,this.inputNames,this.outputNames]=await ep(r,n),Be()}async dispose(){return tp(this.sessionId)}async run(t,n,r){Ne();let o=[],a=[];Object.entries(t).forEach(y=>{let _=y[0],b=y[1],w=this.inputNames.indexOf(_);if(w===-1)throw new Error(`invalid input '${_}'`);o.push(b),a.push(w)});let s=[],d=[];Object.entries(n).forEach(y=>{let _=y[0],b=y[1],w=this.outputNames.indexOf(_);if(w===-1)throw new Error(`invalid output '${_}'`);s.push(b),d.push(w)});let l=o.map((y,_)=>op(y,()=>`input \"${this.inputNames[a[_]]}\"`)),p=s.map((y,_)=>y?op(y,()=>`output \"${this.outputNames[d[_]]}\"`):null),f=await rp(this.sessionId,a,l,d,p,r),h={};for(let y=0;y<f.length;y++)h[this.outputNames[d[y]]]=s[y]??ab(f[y]);return Be(),h}startProfiling(){}endProfiling(){np(this.sessionId)}}});var sp={};Zt(sp,{OnnxruntimeWebAssemblyBackend:()=>fn,initializeFlags:()=>ap,wasmBackend:()=>sb});var ap,fn,sb,up=G(()=>{\"use strict\";Ge();Do();ip();ap=()=>{if((typeof we.wasm.initTimeout!=\"number\"||we.wasm.initTimeout<0)&&(we.wasm.initTimeout=0),we.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof we.wasm.proxy!=\"boolean\"&&(we.wasm.proxy=!1),typeof we.wasm.trace!=\"boolean\"&&(we.wasm.trace=!1),typeof we.wasm.numThreads!=\"number\"||!Number.isInteger(we.wasm.numThreads)||we.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)we.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Nn(\"node:os\").cpus().length:navigator.hardwareConcurrency;we.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},fn=class{async init(t){ap(),await Yc(),await Xc(t)}async createInferenceSessionHandler(t,n){let r=new mn;return await r.loadModel(t,n),Promise.resolve(r)}},sb=new fn});Ge();Ge();Ge();var hs=\"1.21.0\";var lT=Fn;{let e=(up(),br(sp)).wasmBackend;Ct(\"webgpu\",e,5),Ct(\"webnn\",e,5),Ct(\"cpu\",e,10),Ct(\"wasm\",e,10)}Object.defineProperty(we.versions,\"web\",{value:hs,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz9mMjQzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1Q0FBdUMsa0NBQWtDLHVDQUF1QyxvRUFBb0UsNkNBQTZDLGlCQUFpQiwyREFBMkQsMkRBQTJELEVBQUUsbUNBQW1DLGVBQWUsdUJBQXVCLHVCQUF1QixFQUFFLGdCQUFnQixnR0FBZ0csbURBQW1ELEVBQUUsVUFBVSxrQkFBa0IsZUFBZSxTQUFTLEtBQUssNkJBQTZCLGFBQWEsOEJBQThCLHFGQUFxRixnQkFBZ0Isd0JBQXdCLHFCQUFxQixFQUFFLEtBQUssdUJBQXVCLDZFQUE2RSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsU0FBUyxvQkFBb0IsdUJBQXVCLFlBQVksWUFBWSxrQ0FBa0MsaUJBQWlCLE9BQU8sV0FBVyxPQUFPLDJDQUEyQyxjQUFjLGdCQUFnQixpQ0FBaUMsa0NBQWtDLDZCQUE2QixzQkFBc0IsSUFBSSwyRkFBMkYsU0FBUyxzQkFBc0IsRUFBRSx3QkFBd0IsUUFBUSx1QkFBdUIsY0FBYyw0R0FBNEcsZ0JBQWdCLGtCQUFrQiwyQkFBMkIsYUFBYSw2QkFBNkIsMERBQTBELGFBQWEsT0FBTyxJQUFJLE1BQU0sY0FBYyxHQUFHLFFBQVEsYUFBYSwyRUFBMkUsRUFBRSxzREFBc0QsRUFBRSxHQUFHLHNEQUFzRCxzQkFBc0IsdURBQXVELElBQUksRUFBRSxjQUFjLGFBQWEsS0FBSyxFQUFFLGlCQUFpQixhQUFhLFlBQVksRUFBRSxvQkFBb0IsYUFBYSxLQUFLLGlCQUFpQixPQUFPLFNBQVMsVUFBVSxXQUFXLFVBQVUsaUJBQWlCLGVBQWUsa0lBQWtJLEVBQUUsR0FBRyxNQUFNLGdCQUFnQixZQUFZLHFDQUFxQyxjQUFjLEVBQUUsRUFBRSxpQkFBaUIsYUFBYSxLQUFLLE1BQU0sRUFBRSxvQkFBb0IsYUFBYSxXQUFX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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMFxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBVbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIEFmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIGtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBFZj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBObj0oZT0+dHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0eXBlb2YgUHJveHk8XCJ1XCI/bmV3IFByb3h5KGUse2dldDoodCxuKT0+KHR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dClbbl19KTplKShmdW5jdGlvbihlKXtpZih0eXBlb2YgcmVxdWlyZTxcInVcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrZSsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyIEc9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgWnQ9KGUsdCk9Pntmb3IodmFyIG4gaW4gdClVbihlLG4se2dldDp0W25dLGVudW1lcmFibGU6ITB9KX0sUGY9KGUsdCxuLHIpPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBvIG9mIGtmKHQpKSFFZi5jYWxsKGUsbykmJm8hPT1uJiZVbihlLG8se2dldDooKT0+dFtvXSxlbnVtZXJhYmxlOiEocj1BZih0LG8pKXx8ci5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciBicj1lPT5QZihVbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgX3IsVHQsQ3QsemYsV2EsVm49RygoKT0+e1widXNlIHN0cmljdFwiO19yPW5ldyBNYXAsVHQ9W10sQ3Q9KGUsdCxuKT0+e2lmKHQmJnR5cGVvZiB0LmluaXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIil7bGV0IHI9X3IuZ2V0KGUpO2lmKHI9PT12b2lkIDApX3Iuc2V0KGUse2JhY2tlbmQ6dCxwcmlvcml0eTpufSk7ZWxzZXtpZihyLnByaW9yaXR5Pm4pcmV0dXJuO2lmKHIucHJpb3JpdHk9PT1uJiZyLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtufWApfWlmKG4+PTApe2xldCBvPVR0LmluZGV4T2YoZSk7byE9PS0xJiZUdC5zcGxpY2UobywxKTtmb3IobGV0IGE9MDthPFR0Lmxlbmd0aDthKyspaWYoX3IuZ2V0KFR0W2FdKS5wcmlvcml0eTw9bil7VHQuc3BsaWNlKGEsMCxlKTtyZXR1cm59VHQucHVzaChlKX1yZXR1cm59dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIil9LHpmPWFzeW5jIGU9PntsZXQgdD1fci5nZXQoZSk7aWYoIXQpcmV0dXJuXCJiYWNrZW5kIG5vdCBmb3VuZC5cIjtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKXJldHVybiB0LmVycm9yO3tsZXQgbj0hIXQuaW5pdFByb21pc2U7dHJ5e3JldHVybiBufHwodC5pbml0UHJvbWlzZT10LmJhY2tlbmQuaW5pdChlKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChyKXtyZXR1cm4gbnx8KHQuZXJyb3I9YCR7cn1gLHQuYWJvcnRlZD0hMCksdC5lcnJvcn1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19LFdhPWFzeW5jIGU9PntsZXQgdD1lLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10sbj10Lm1hcChsPT50eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkscj1uLmxlbmd0aD09PTA/VHQ6bixvLGE9W10scz1uZXcgU2V0O2ZvcihsZXQgbCBvZiByKXtsZXQgcD1hd2FpdCB6ZihsKTt0eXBlb2YgcD09XCJzdHJpbmdcIj9hLnB1c2goe25hbWU6bCxlcnI6cH0pOihvfHwobz1wKSxvPT09cCYmcy5hZGQobCkpfWlmKCFvKXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHthLm1hcChsPT5gWyR7bC5uYW1lfV0gJHtsLmVycn1gKS5qb2luKFwiLCBcIil9YCk7Zm9yKGxldHtuYW1lOmwsZXJyOnB9b2YgYSluLmluY2x1ZGVzKGwpJiZjb25zb2xlLndhcm4oYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke2x9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke3B9YCk7bGV0IGQ9dC5maWx0ZXIobD0+cy5oYXModHlwZW9mIGw9PVwic3RyaW5nXCI/bDpsLm5hbWUpKTtyZXR1cm5bbyxuZXcgUHJveHkoZSx7Z2V0OihsLHApPT5wPT09XCJleGVjdXRpb25Qcm92aWRlcnNcIj9kOlJlZmxlY3QuZ2V0KGwscCl9KV19fSk7dmFyIExhPUcoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpfSk7dmFyIEdhLEhhPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHYT1cIjEuMjEuMFwifSk7dmFyIEZhLFVlLFduPUcoKCk9PntcInVzZSBzdHJpY3RcIjtIYSgpO0ZhPVwid2FybmluZ1wiLFVlPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOkdhfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7RmE9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiBGYX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShVZSxcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciB3ZSxxYT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt3ZT1VZX0pO3ZhciBLYSxqYSxaYT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7S2E9KGUsdCk9PntsZXQgbj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7bi53aWR0aD1lLmRpbXNbM10sbi5oZWlnaHQ9ZS5kaW1zWzJdO2xldCByPW4uZ2V0Q29udGV4dChcIjJkXCIpO2lmKHIhPW51bGwpe2xldCBvLGE7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxhPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGE9ZS5kaW1zWzJdKTtsZXQgcz10Py5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixkPXQ/Lm5vcm0sbCxwO2Q9PT12b2lkIDB8fGQubWVhbj09PXZvaWQgMD9sPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBkLm1lYW49PVwibnVtYmVyXCI/bD1bZC5tZWFuLGQubWVhbixkLm1lYW4sZC5tZWFuXToobD1bZC5tZWFuWzBdLGQubWVhblsxXSxkLm1lYW5bMl0sMF0sZC5tZWFuWzNdIT09dm9pZCAwJiYobFszXT1kLm1lYW5bM10pKSxkPT09dm9pZCAwfHxkLmJpYXM9PT12b2lkIDA/cD1bMCwwLDAsMF06dHlwZW9mIGQuYmlhcz09XCJudW1iZXJcIj9wPVtkLmJpYXMsZC5iaWFzLGQuYmlhcyxkLmJpYXNdOihwPVtkLmJpYXNbMF0sZC5iaWFzWzFdLGQuYmlhc1syXSwwXSxkLmJpYXNbM10hPT12b2lkIDAmJihwWzNdPWQuYmlhc1szXSkpO2xldCBmPWEqbyxoPTAseT1mLF89ZioyLGI9LTE7cz09PVwiUkdCQVwiPyhoPTAseT1mLF89ZioyLGI9ZiozKTpzPT09XCJSR0JcIj8oaD0wLHk9ZixfPWYqMik6cz09PVwiUkJHXCImJihoPTAsXz1mLHk9ZioyKTtmb3IobGV0IHc9MDt3PGE7dysrKWZvcihsZXQgUz0wO1M8bztTKyspe2xldCAkPShlLmRhdGFbaCsrXS1wWzBdKSpsWzBdLHY9KGUuZGF0YVt5KytdLXBbMV0pKmxbMV0sVD0oZS5kYXRhW18rK10tcFsyXSkqbFsyXSxDPWI9PT0tMT8yNTU6KGUuZGF0YVtiKytdLXBbM10pKmxbM107ci5maWxsU3R5bGU9XCJyZ2JhKFwiKyQrXCIsXCIrditcIixcIitUK1wiLFwiK0MrXCIpXCIsci5maWxsUmVjdChTLHcsMSwxKX1pZihcInRvRGF0YVVSTFwiaW4gbilyZXR1cm4gbi50b0RhdGFVUkwoKTt0aHJvdyBuZXcgRXJyb3IoXCJ0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9LGphPShlLHQpPT57bGV0IG49dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KFwiMmRcIikscjtpZihuIT1udWxsKXtsZXQgbyxhLHM7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxhPWUuZGltc1sxXSxzPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGE9ZS5kaW1zWzJdLHM9ZS5kaW1zWzFdKTtsZXQgZD10IT09dm9pZCAwJiZ0LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGw9dD8ubm9ybSxwLGY7bD09PXZvaWQgMHx8bC5tZWFuPT09dm9pZCAwP3A9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGwubWVhbj09XCJudW1iZXJcIj9wPVtsLm1lYW4sbC5tZWFuLGwubWVhbixsLm1lYW5dOihwPVtsLm1lYW5bMF0sbC5tZWFuWzFdLGwubWVhblsyXSwyNTVdLGwubWVhblszXSE9PXZvaWQgMCYmKHBbM109bC5tZWFuWzNdKSksbD09PXZvaWQgMHx8bC5iaWFzPT09dm9pZCAwP2Y9WzAsMCwwLDBdOnR5cGVvZiBsLmJpYXM9PVwibnVtYmVyXCI/Zj1bbC5iaWFzLGwuYmlhcyxsLmJpYXMsbC5iaWFzXTooZj1bbC5iaWFzWzBdLGwuYmlhc1sxXSxsLmJpYXNbMl0sMF0sbC5iaWFzWzNdIT09dm9pZCAwJiYoZlszXT1sLmJpYXNbM10pKTtsZXQgaD1hKm87aWYodCE9PXZvaWQgMCYmKHQuZm9ybWF0IT09dm9pZCAwJiZzPT09NCYmdC5mb3JtYXQhPT1cIlJHQkFcInx8cz09PTMmJnQuZm9ybWF0IT09XCJSR0JcIiYmdC5mb3JtYXQhPT1cIkJHUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIik7bGV0IHk9NCxfPTAsYj0xLHc9MixTPTMsJD0wLHY9aCxUPWgqMixDPS0xO2Q9PT1cIlJHQkFcIj8oJD0wLHY9aCxUPWgqMixDPWgqMyk6ZD09PVwiUkdCXCI/KCQ9MCx2PWgsVD1oKjIpOmQ9PT1cIlJCR1wiJiYoJD0wLFQ9aCx2PWgqMikscj1uLmNyZWF0ZUltYWdlRGF0YShvLGEpO2ZvcihsZXQgQT0wO0E8YSpvO18rPXksYis9eSx3Kz15LFMrPXksQSsrKXIuZGF0YVtfXT0oZS5kYXRhWyQrK10tZlswXSkqcFswXSxyLmRhdGFbYl09KGUuZGF0YVt2KytdLWZbMV0pKnBbMV0sci5kYXRhW3ddPShlLmRhdGFbVCsrXS1mWzJdKSpwWzJdLHIuZGF0YVtTXT1DPT09LTE/MjU1OihlLmRhdGFbQysrXS1mWzNdKSpwWzNdfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTtyZXR1cm4gcn19KTt2YXIgTG4sUWEsWWEsWGEsSmEsZXMsdHM9RygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7TG49KGUsdCk9PntpZihlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodC5oZWlnaHQ9PT12b2lkIDB8fHQud2lkdGg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7bGV0e2hlaWdodDpuLHdpZHRoOnJ9PXQsbz10Lm5vcm0/P3ttZWFuOjI1NSxiaWFzOjB9LGEsczt0eXBlb2Ygby5tZWFuPT1cIm51bWJlclwiP2E9W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06YT1bby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sby5tZWFuWzNdPz8yNTVdLHR5cGVvZiBvLmJpYXM9PVwibnVtYmVyXCI/cz1bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXTpzPVtvLmJpYXNbMF0sby5iaWFzWzFdLG8uYmlhc1syXSxvLmJpYXNbM10/PzBdO2xldCBkPXQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCQVwiLGw9dC50ZW5zb3JGb3JtYXQhPT12b2lkIDAmJnQudGVuc29yRm9ybWF0IT09dm9pZCAwP3QudGVuc29yRm9ybWF0OlwiUkdCXCIscD1uKnIsZj1sPT09XCJSR0JBXCI/bmV3IEZsb2F0MzJBcnJheShwKjQpOm5ldyBGbG9hdDMyQXJyYXkocCozKSxoPTQseT0wLF89MSxiPTIsdz0zLFM9MCwkPXAsdj1wKjIsVD0tMTtkPT09XCJSR0JcIiYmKGg9Myx5PTAsXz0xLGI9Mix3PS0xKSxsPT09XCJSR0JBXCI/VD1wKjM6bD09PVwiUkJHXCI/KFM9MCx2PXAsJD1wKjIpOmw9PT1cIkJHUlwiJiYodj0wLCQ9cCxTPXAqMik7Zm9yKGxldCBBPTA7QTxwO0ErKyx5Kz1oLGIrPWgsXys9aCx3Kz1oKWZbUysrXT0oZVt5XStzWzBdKS9hWzBdLGZbJCsrXT0oZVtfXStzWzFdKS9hWzFdLGZbdisrXT0oZVtiXStzWzJdKS9hWzJdLFQhPT0tMSYmdyE9PS0xJiYoZltUKytdPShlW3ddK3NbM10pL2FbM10pO3JldHVybiBsPT09XCJSR0JBXCI/bmV3IERlKFwiZmxvYXQzMlwiLGYsWzEsNCxuLHJdKTpuZXcgRGUoXCJmbG9hdDMyXCIsZixbMSwzLG4scl0pfSxRYT1hc3luYyhlLHQpPT57bGV0IG49dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8XCJ1XCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LHI9dHlwZW9mIEltYWdlRGF0YTxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPXR5cGVvZiBJbWFnZUJpdG1hcDxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGE9dHlwZW9mIGU9PVwic3RyaW5nXCIscyxkPXQ/P3t9LGw9KCk9PntpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhczxcInVcIilyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO3Rocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwPWY9PnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDxcInVcIiYmZiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHxmIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzP2YuZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7aWYobil7bGV0IGY9bCgpO2Yud2lkdGg9ZS53aWR0aCxmLmhlaWdodD1lLmhlaWdodDtsZXQgaD1wKGYpO2lmKGghPW51bGwpe2xldCB5PWUuaGVpZ2h0LF89ZS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYoeT10LnJlc2l6ZWRIZWlnaHQsXz10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYoZD10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2QudGVuc29yRm9ybWF0PVwiUkdCQVwiLGQuaGVpZ2h0PXksZC53aWR0aD1ffWVsc2UgZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9eSxkLndpZHRoPV87aC5kcmF3SW1hZ2UoZSwwLDApLHM9aC5nZXRJbWFnZURhdGEoMCwwLF8seSkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihyKXtsZXQgZixoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KGY9dC5yZXNpemVkSGVpZ2h0LGg9dC5yZXNpemVkV2lkdGgpOihmPWUuaGVpZ2h0LGg9ZS53aWR0aCksdCE9PXZvaWQgMCYmKGQ9dCksZC5mb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9ZixkLndpZHRoPWgsdCE9PXZvaWQgMCl7bGV0IHk9bCgpO3kud2lkdGg9aCx5LmhlaWdodD1mO2xldCBfPXAoeSk7aWYoXyE9bnVsbClfLnB1dEltYWdlRGF0YShlLDAsMCkscz1fLmdldEltYWdlRGF0YSgwLDAsaCxmKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIHM9ZS5kYXRhfWVsc2UgaWYobyl7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBmPWwoKTtmLndpZHRoPWUud2lkdGgsZi5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IGg9cChmKTtpZihoIT1udWxsKXtsZXQgeT1lLmhlaWdodCxfPWUud2lkdGg7cmV0dXJuIGguZHJhd0ltYWdlKGUsMCwwLF8seSkscz1oLmdldEltYWdlRGF0YSgwLDAsXyx5KS5kYXRhLGQuaGVpZ2h0PXksZC53aWR0aD1fLExuKHMsZCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYoYSlyZXR1cm4gbmV3IFByb21pc2UoKGYsaCk9PntsZXQgeT1sKCksXz1wKHkpO2lmKCFlfHwhXylyZXR1cm4gaCgpO2xldCBiPW5ldyBJbWFnZTtiLmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIsYi5zcmM9ZSxiLm9ubG9hZD0oKT0+e3kud2lkdGg9Yi53aWR0aCx5LmhlaWdodD1iLmhlaWdodCxfLmRyYXdJbWFnZShiLDAsMCx5LndpZHRoLHkuaGVpZ2h0KTtsZXQgdz1fLmdldEltYWdlRGF0YSgwLDAseS53aWR0aCx5LmhlaWdodCk7ZC5oZWlnaHQ9eS5oZWlnaHQsZC53aWR0aD15LndpZHRoLGYoTG4ody5kYXRhLGQpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZihzIT09dm9pZCAwKXJldHVybiBMbihzLGQpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSxZYT0oZSx0KT0+e2xldHt3aWR0aDpuLGhlaWdodDpyLGRvd25sb2FkOm8sZGlzcG9zZTphfT10LHM9WzEscixuLDRdO3JldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTplLGRpbXM6cyxkb3dubG9hZDpvLGRpc3Bvc2U6YX0pfSxYYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpuLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX09dDtyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOm4/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjplLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX0pfSxKYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpuLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX09dDtyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLHR5cGU6bj8/XCJmbG9hdDMyXCIsbWxUZW5zb3I6ZSxkaW1zOnIsZG93bmxvYWQ6byxkaXNwb3NlOmF9KX0sZXM9KGUsdCxuKT0+bmV3IERlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIix0eXBlOmUsZGF0YTp0LGRpbXM6bj8/W3QubGVuZ3RoXX0pfSk7dmFyIEl0LFF0LHJzLG5zLG9zPUcoKCk9PntcInVzZSBzdHJpY3RcIjtJdD1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XSxbXCJpbnQ0XCIsVWludDhBcnJheV0sW1widWludDRcIixVaW50OEFycmF5XV0pLFF0PW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxycz0hMSxucz0oKT0+e2lmKCFycyl7cnM9ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJkJpZ0ludDY0QXJyYXkuZnJvbSx0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmQmlnVWludDY0QXJyYXkuZnJvbSxuPWdsb2JhbFRoaXMuRmxvYXQxNkFycmF5LHI9dHlwZW9mIG48XCJ1XCImJm4uZnJvbTtlJiYoSXQuc2V0KFwiaW50NjRcIixCaWdJbnQ2NEFycmF5KSxRdC5zZXQoQmlnSW50NjRBcnJheSxcImludDY0XCIpKSx0JiYoSXQuc2V0KFwidWludDY0XCIsQmlnVWludDY0QXJyYXkpLFF0LnNldChCaWdVaW50NjRBcnJheSxcInVpbnQ2NFwiKSkscj8oSXQuc2V0KFwiZmxvYXQxNlwiLG4pLFF0LnNldChuLFwiZmxvYXQxNlwiKSk6SXQuc2V0KFwiZmxvYXQxNlwiLFVpbnQxNkFycmF5KX19fSk7dmFyIGlzLGFzLHNzPUcoKCk9PntcInVzZSBzdHJpY3RcIjt3cigpO2lzPWU9PntsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtsZXQgcj1lW25dO2lmKHR5cGVvZiByIT1cIm51bWJlclwifHwhTnVtYmVyLmlzU2FmZUludGVnZXIocikpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtyfWApO2lmKHI8MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske259XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtyfWApO3QqPXJ9cmV0dXJuIHR9LGFzPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgRGUoZS50eXBlLGUuZGF0YSx0KTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsZGF0YTplLmRhdGEsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwidGV4dHVyZVwiOnJldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHRleHR1cmU6ZS50ZXh0dXJlLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIixncHVCdWZmZXI6ZS5ncHVCdWZmZXIsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJtbC10ZW5zb3JcIixtbFRlbnNvcjplLm1sVGVuc29yLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciBEZSx3cj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WmEoKTt0cygpO29zKCk7c3MoKTtEZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4scil7bnMoKTtsZXQgbyxhO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLG89dC50eXBlLGE9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGQ9SXQuZ2V0KG8pO2lmKCFkKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGQpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2QubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYobyE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKG8hPT1cImZsb2F0MzJcIiYmbyE9PVwiZmxvYXQxNlwiJiZvIT09XCJpbnQzMlwiJiZvIT09XCJpbnQ2NFwiJiZvIT09XCJ1aW50MzJcIiYmbyE9PVwidWludDhcIiYmbyE9PVwiYm9vbFwiJiZvIT09XCJ1aW50NFwiJiZvIT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO3RoaXMuZ3B1QnVmZmVyRGF0YT10LmdwdUJ1ZmZlcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJtbC10ZW5zb3JcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50NjRcIiYmbyE9PVwiaW50OFwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBNTFRlbnNvcmApO3RoaXMubWxUZW5zb3JEYXRhPXQubWxUZW5zb3IsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGQsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihvPXQsbD1yLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtkPW59ZWxzZXtsZXQgcD1JdC5nZXQodCk7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZih0PT09XCJmbG9hdDE2XCImJnA9PT1VaW50MTZBcnJheXx8dD09PVwidWludDRcInx8dD09PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYENyZWF0aW5nIGEgJHt0fSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3AubmFtZX0gYXMgZGF0YS5gKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9kPXAuZnJvbShuLEJpZ0ludCk6ZD1wLmZyb20obil9ZWxzZSBpZihuIGluc3RhbmNlb2YgcClkPW47ZWxzZSBpZihuIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpaWYodD09PVwidWludDhcIilkPVVpbnQ4QXJyYXkuZnJvbShuKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIFVpbnQ4Q2xhbXBlZEFycmF5IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mIHVpbnQ4XCIpO2Vsc2UgaWYodD09PVwiZmxvYXQxNlwiJiZuIGluc3RhbmNlb2YgVWludDE2QXJyYXkmJnAhPT1VaW50MTZBcnJheSlkPW5ldyBnbG9iYWxUaGlzLkZsb2F0MTZBcnJheShuLmJ1ZmZlcixuLmJ5dGVPZmZzZXQsbi5sZW5ndGgpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke299IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cH1gKX1lbHNlIGlmKGw9bixBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtsZXQgcD10eXBlb2YgdFswXTtpZihwPT09XCJzdHJpbmdcIilvPVwic3RyaW5nXCIsZD10O2Vsc2UgaWYocD09PVwiYm9vbGVhblwiKW89XCJib29sXCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3B9LmApfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KW89XCJ1aW50OFwiLGQ9VWludDhBcnJheS5mcm9tKHQpO2Vsc2V7bGV0IHA9UXQuZ2V0KHQuY29uc3RydWN0b3IpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7dC5jb25zdHJ1Y3Rvcn0uYCk7bz1wLGQ9dH1pZihsPT09dm9pZCAwKWw9W2QubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTthPWwsdGhpcy5jcHVEYXRhPWQsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIn1sZXQgcz1pcyhhKTtpZih0aGlzLmNwdURhdGEmJnMhPT10aGlzLmNwdURhdGEubGVuZ3RoJiYhKChvPT09XCJ1aW50NFwifHxvPT09XCJpbnQ0XCIpJiZNYXRoLmNlaWwocy8yKT09PXRoaXMuY3B1RGF0YS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3N9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTt0aGlzLnR5cGU9byx0aGlzLmRpbXM9YSx0aGlzLnNpemU9c31zdGF0aWMgYXN5bmMgZnJvbUltYWdlKHQsbil7cmV0dXJuIFFhKHQsbil9c3RhdGljIGZyb21UZXh0dXJlKHQsbil7cmV0dXJuIFlhKHQsbil9c3RhdGljIGZyb21HcHVCdWZmZXIodCxuKXtyZXR1cm4gWGEodCxuKX1zdGF0aWMgZnJvbU1MVGVuc29yKHQsbil7cmV0dXJuIEphKHQsbil9c3RhdGljIGZyb21QaW5uZWRCdWZmZXIodCxuLHIpe3JldHVybiBlcyh0LG4scil9dG9EYXRhVVJMKHQpe3JldHVybiBLYSh0aGlzLHQpfXRvSW1hZ2VEYXRhKHQpe3JldHVybiBqYSh0aGlzLHQpfWdldCBkYXRhKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmNwdURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LlwiKTtyZXR1cm4gdGhpcy5jcHVEYXRhfWdldCBsb2NhdGlvbigpe3JldHVybiB0aGlzLmRhdGFMb2NhdGlvbn1nZXQgdGV4dHVyZSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVUZXh0dXJlRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS5cIik7cmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGF9Z2V0IGdwdUJ1ZmZlcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVCdWZmZXJEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLlwiKTtyZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhfWdldCBtbFRlbnNvcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5tbFRlbnNvckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLlwiKTtyZXR1cm4gdGhpcy5tbFRlbnNvckRhdGF9YXN5bmMgZ2V0RGF0YSh0KXtzd2l0Y2godGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZGF0YUxvY2F0aW9uKXtjYXNlXCJjcHVcIjpjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIHRoaXMuZGF0YTtjYXNlXCJ0ZXh0dXJlXCI6Y2FzZVwiZ3B1LWJ1ZmZlclwiOmNhc2VcIm1sLXRlbnNvclwiOntpZighdGhpcy5kb3dubG9hZGVyKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci5cIik7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0cnl7dGhpcy5pc0Rvd25sb2FkaW5nPSEwO2xldCBuPWF3YWl0IHRoaXMuZG93bmxvYWRlcigpO3JldHVybiB0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCIsdGhpcy5jcHVEYXRhPW4sdCYmdGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCksbn1maW5hbGx5e3RoaXMuaXNEb3dubG9hZGluZz0hMX19ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApfX1kaXNwb3NlKCl7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSx0aGlzLmNwdURhdGE9dm9pZCAwLHRoaXMuZ3B1VGV4dHVyZURhdGE9dm9pZCAwLHRoaXMuZ3B1QnVmZmVyRGF0YT12b2lkIDAsdGhpcy5tbFRlbnNvckRhdGE9dm9pZCAwLHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5pc0Rvd25sb2FkaW5nPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cIm5vbmVcIn1lbnN1cmVWYWxpZCgpe2lmKHRoaXMuZGF0YUxvY2F0aW9uPT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cIil9cmVzaGFwZSh0KXtpZih0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kb3dubG9hZGVyfHx0aGlzLmRpc3Bvc2VyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuXCIpO3JldHVybiBhcyh0aGlzLHQpfX19KTt2YXIgcWUsR249RygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7cWU9RGV9KTt2YXIgdnIsdXMsTmUsQmUsSG49RygoKT0+e1widXNlIHN0cmljdFwiO1duKCk7dnI9KGUsdCk9PnsodHlwZW9mIFVlLnRyYWNlPlwidVwiPyFVZS53YXNtLnRyYWNlOiFVZS50cmFjZSl8fGNvbnNvbGUudGltZVN0YW1wKGAke2V9OjpPUlQ6OiR7dH1gKX0sdXM9KGUsdCk9PntsZXQgbj1uZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpfHxbXSxyPSExO2ZvcihsZXQgbz0wO288bi5sZW5ndGg7bysrKXtpZihyJiYhbltvXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikpe2xldCBhPWBGVU5DXyR7ZX06OiR7bltvXS50cmltKCkuc3BsaXQoXCIgXCIpWzFdfWA7dCYmKGErPWA6OiR7dH1gKSx2cihcIkNQVVwiLGEpO3JldHVybn1uW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSYmKHI9ITApfX0sTmU9ZT0+eyh0eXBlb2YgVWUudHJhY2U+XCJ1XCI/IVVlLndhc20udHJhY2U6IVVlLnRyYWNlKXx8dXMoXCJCRUdJTlwiLGUpfSxCZT1lPT57KHR5cGVvZiBVZS50cmFjZT5cInVcIj8hVWUud2FzbS50cmFjZTohVWUudHJhY2UpfHx1cyhcIkVORFwiLGUpfX0pO3ZhciAkcixkcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm4oKTtHbigpO0huKCk7JHI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1hc3luYyBydW4odCxuLHIpe05lKCk7bGV0IG89e30sYT17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBxZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBzPSEwO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiKXtpZihuPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKG4gaW5zdGFuY2VvZiBxZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KG4pKXtpZihuLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO3M9ITE7Zm9yKGxldCBwIG9mIG4pe2lmKHR5cGVvZiBwIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihwKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtwfS5gKTtvW3BdPW51bGx9aWYodHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWE9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IHA9ITEsZj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKTtmb3IobGV0IGggb2YgdGhpcy5vdXRwdXROYW1lcylpZihmLmluZGV4T2YoaCkhPT0tMSl7bGV0IHk9bltoXTsoeT09PW51bGx8fHkgaW5zdGFuY2VvZiBxZSkmJihwPSEwLHM9ITEsb1toXT15KX1pZihwKXtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBhPW59fWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBwIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtwXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3B9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYocylmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcylvW3BdPW51bGw7bGV0IGQ9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG8sYSksbD17fTtmb3IobGV0IHAgaW4gZClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChkLHApKXtsZXQgZj1kW3BdO2YgaW5zdGFuY2VvZiBxZT9sW3BdPWY6bFtwXT1uZXcgcWUoZi50eXBlLGYuZGF0YSxmLmRpbXMpfXJldHVybiBCZSgpLGx9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxuLHIsbyl7TmUoKTtsZXQgYSxzPXt9O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihhPXQsdHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKXM9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGE9dCx0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmdCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKXtsZXQgZj10LGg9MCx5PXQuYnl0ZUxlbmd0aDtpZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPDB8fGg+PWYuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHtmLmJ5dGVMZW5ndGh9KS5gKTtpZih5PXQuYnl0ZUxlbmd0aC1oLHR5cGVvZiByPT1cIm51bWJlclwiKXtpZih5PXIsIU51bWJlci5pc1NhZmVJbnRlZ2VyKHkpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoeTw9MHx8aCt5PmYuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHtmLmJ5dGVMZW5ndGgtaH1dLmApO2lmKHR5cGVvZiBvPT1cIm9iamVjdFwiJiZvIT09bnVsbClzPW87ZWxzZSBpZih0eXBlb2YgbzxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTthPW5ldyBVaW50OEFycmF5KGYsaCx5KX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7bGV0W2QsbF09YXdhaXQgV2EocykscD1hd2FpdCBkLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGEsbCk7cmV0dXJuIEJlKCksbmV3IGUocCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319fSk7dmFyIE9mLGxzPUcoKCk9PntcInVzZSBzdHJpY3RcIjtkcygpO09mPSRyfSk7dmFyIGNzPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBwcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgbXM9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGZzPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBGbj17fTtadChGbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+T2YsVFJBQ0U6KCk9PnZyLFRSQUNFX0ZVTkNfQkVHSU46KCk9Pk5lLFRSQUNFX0ZVTkNfRU5EOigpPT5CZSxUZW5zb3I6KCk9PnFlLGVudjooKT0+d2UscmVnaXN0ZXJCYWNrZW5kOigpPT5DdH0pO3ZhciBHZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7TGEoKTtxYSgpO2xzKCk7R24oKTtjcygpO3BzKCk7SG4oKTttcygpO2ZzKCl9KTt2YXIgeHI9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIGJzPXt9O1p0KGJzLHtkZWZhdWx0OigpPT5EZn0pO3ZhciBncyx5cyxEZixfcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cW4oKTtidCgpO1NyKCk7Z3M9XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIix5cz1nbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1nczt5cyYmKHNlbGYub25tZXNzYWdlPWU9PntsZXR7dHlwZTp0LGluOm59PWUuZGF0YTt0cnl7c3dpdGNoKHQpe2Nhc2VcImluaXQtd2FzbVwiOlRyKG4ud2FzbSkudGhlbigoKT0+e0NyKG4pLnRoZW4oKCk9Pntwb3N0TWVzc2FnZSh7dHlwZTp0fSl9LHI9Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpyfSl9KX0scj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX0pO2JyZWFrO2Nhc2VcImluaXQtZXBcIjp7bGV0e2VwTmFtZTpyLGVudjpvfT1uO0lyKG8scikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmF9KX0pO2JyZWFrfWNhc2VcImNvcHktZnJvbVwiOntsZXR7YnVmZmVyOnJ9PW4sbz1ZdChyKTtwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpvfSk7YnJlYWt9Y2FzZVwiY3JlYXRlXCI6e2xldHttb2RlbDpyLG9wdGlvbnM6b309bjtBcihyLG8pLnRoZW4oYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0OmF9KX0sYT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmF9KX0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjprcihuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7Y2FzZVwicnVuXCI6e2xldHtzZXNzaW9uSWQ6cixpbnB1dEluZGljZXM6byxpbnB1dHM6YSxvdXRwdXRJbmRpY2VzOnMsb3B0aW9uczpkfT1uO0VyKHIsbyxhLHMsbmV3IEFycmF5KHMubGVuZ3RoKS5maWxsKG51bGwpLGQpLnRoZW4obD0+e2wuc29tZShwPT5wWzNdIT09XCJjcHVcIik/cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6XCJQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLlwifSk6cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6bH0senIoWy4uLmEsLi4ubF0pKX0sbD0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmx9KX0pO2JyZWFrfWNhc2VcImVuZC1wcm9maWxpbmdcIjpQcihuKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7ZGVmYXVsdDp9fWNhdGNoKHIpe3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX19KTtEZj15cz9udWxsOmU9Pm5ldyBXb3JrZXIoZT8/VmUse3R5cGU6XCJtb2R1bGVcIixuYW1lOmdzfSl9KTt2YXIgdnM9e307WnQodnMse2RlZmF1bHQ6KCk9PkJmfSk7dmFyIEtuLHdzLEJmLE1mLCRzPUcoKCk9PntcInVzZSBzdHJpY3RcIjt3cz0oS249aW1wb3J0Lm1ldGEudXJsLGFzeW5jIGZ1bmN0aW9uKGU9e30pe3ZhciB0LG4scj1lLG89bmV3IFByb21pc2UoKGksdSk9Pnt0PWksbj11fSksYT10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLHM9dHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlPFwidVwiLGQ9cyYmc2VsZi5uYW1lPy5zdGFydHNXaXRoKFwiZW0tcHRocmVhZFwiKTtyLm1vdW50RXh0ZXJuYWxEYXRhPShpLHUpPT57aS5zdGFydHNXaXRoKFwiLi9cIikmJihpPWkuc3Vic3RyaW5nKDIpKSwoci5CZHx8KHIuQmQ9bmV3IE1hcCkpLnNldChpLHUpfSxyLnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgci5CZH07dmFyIGw9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0IHA9KCk9PntsZXQgaT0oYyxtLGcpPT4oLi4ueCk9PntsZXQgST1KZSx6PW0/LigpO3g9YyguLi54KTtsZXQgQj1tPy4oKTtyZXR1cm4geiE9PUImJihjPUIsZyh6KSxtPWc9bnVsbCksSmUhPUk/bmV3IFByb21pc2UoKEwscSk9PntFbj17cmVzb2x2ZTpMLHJlamVjdDpxfX0pOnh9LHU9Yz0+YXN5bmMoLi4ubSk9Pnt0cnl7aWYoci5DZCl0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCBnPXIuQ2Q9e2JlOm1bMF0sZXJyb3JzOltdfSx4PWF3YWl0IGMoLi4ubSk7aWYoci5DZCE9PWcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3IuRGQ/LmZsdXNoKCk7bGV0IEk9Zy5lcnJvcnM7aWYoMDxJLmxlbmd0aCl7bGV0IHo9YXdhaXQgUHJvbWlzZS5hbGwoSSk7aWYoej16LmZpbHRlcihCPT5CKSwwPHoubGVuZ3RoKXRocm93IEVycm9yKHouam9pbihgXG5gKSl9cmV0dXJuIHh9ZmluYWxseXtyLkNkPW51bGx9fTtyLl9PcnRDcmVhdGVTZXNzaW9uPWkoci5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+ci5fT3J0Q3JlYXRlU2Vzc2lvbixjPT5yLl9PcnRDcmVhdGVTZXNzaW9uPWMpLHIuX09ydFJ1bj11KGkoci5fT3J0UnVuLCgpPT5yLl9PcnRSdW4sYz0+ci5fT3J0UnVuPWMpKSxyLl9PcnRSdW5XaXRoQmluZGluZz11KGkoci5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnIuX09ydFJ1bldpdGhCaW5kaW5nLGM9PnIuX09ydFJ1bldpdGhCaW5kaW5nPWMpKSxyLl9PcnRCaW5kSW5wdXQ9aShyLl9PcnRCaW5kSW5wdXQsKCk9PnIuX09ydEJpbmRJbnB1dCxjPT5yLl9PcnRCaW5kSW5wdXQ9YykscD12b2lkIDB9O3IuanNlcEluaXQ9KGksdSk9PntpZihwPy4oKSxpPT09XCJ3ZWJncHVcIil7W3IuRGQsci5SZCxyLlZkLHIuSGQsci5VZCxyLmhjLHIuV2Qsci5aZCxyLlNkLHIuVGQsci5YZF09dTtsZXQgYz1yLkRkO3IuanNlcFJlZ2lzdGVyQnVmZmVyPShtLGcseCxJKT0+Yy5yZWdpc3RlckJ1ZmZlcihtLGcseCxJKSxyLmpzZXBHZXRCdWZmZXI9bT0+Yy5nZXRCdWZmZXIobSksci5qc2VwQ3JlYXRlRG93bmxvYWRlcj0obSxnLHgpPT5jLmNyZWF0ZURvd25sb2FkZXIobSxnLHgpLHIuanNlcE9uQ3JlYXRlU2Vzc2lvbj1tPT57Yy5vbkNyZWF0ZVNlc3Npb24obSl9LHIuanNlcE9uUmVsZWFzZVNlc3Npb249bT0+e2Mub25SZWxlYXNlU2Vzc2lvbihtKX0sci5qc2VwT25SdW5TdGFydD1tPT5jLm9uUnVuU3RhcnQobSksci4kZD0obSxnKT0+e2MudXBsb2FkKG0sZyl9fWVsc2UgaWYoaT09PVwid2Vibm5cIil7W3IuRGQsci5ZZCxyLklkLHIuanNlcEVuc3VyZVRlbnNvcixyLkpkLHIuanNlcERvd25sb2FkVGVuc29yXT11LHIuanNlcFJlbGVhc2VUZW5zb3JJZD1yLklkLHIuanNlcFVwbG9hZFRlbnNvcj1yLkpkO2xldCBjPXIuRGQ7ci5qc2VwT25SdW5TdGFydD1tPT5jLm9uUnVuU3RhcnQobSksci5qc2VwT25SdW5FbmQ9Yy5vblJ1bkVuZC5iaW5kKGMpLHIuanNlcFJlZ2lzdGVyTUxDb250ZXh0PShtLGcpPT57Yy5yZWdpc3Rlck1MQ29udGV4dChtLGcpfSxyLmpzZXBPblJlbGVhc2VTZXNzaW9uPW09PntjLm9uUmVsZWFzZVNlc3Npb24obSl9LHIuanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlcj0obSxnKT0+Yy5jcmVhdGVNTFRlbnNvckRvd25sb2FkZXIobSxnKSxyLmpzZXBSZWdpc3Rlck1MVGVuc29yPShtLGcseCxJKT0+Yy5yZWdpc3Rlck1MVGVuc29yKG0sZyx4LEkpLHIuanNlcENyZWF0ZU1MQ29udGV4dD1tPT5jLmNyZWF0ZU1MQ29udGV4dChtKSxyLmpzZXBSZWdpc3Rlck1MQ29uc3RhbnQ9KG0sZyx4LEkseik9PmMucmVnaXN0ZXJNTENvbnN0YW50KG0sZyx4LEkseixyLkJkKSxyLmpzZXBSZWdpc3RlckdyYXBoSW5wdXQ9Yy5yZWdpc3RlckdyYXBoSW5wdXQuYmluZChjKSxyLmpzZXBJc0dyYXBoSW5wdXQ9Yy5pc0dyYXBoSW5wdXQuYmluZChjKSxyLmpzZXBDcmVhdGVUZW1wb3JhcnlUZW5zb3I9Yy5jcmVhdGVUZW1wb3JhcnlUZW5zb3IuYmluZChjKX19O3ZhciBmLGgseT1PYmplY3QuYXNzaWduKHt9LHIpLF89KGksdSk9Pnt0aHJvdyB1fSxiPVwiXCI7KGF8fHMpJiYocz9iPXNlbGYubG9jYXRpb24uaHJlZjp0eXBlb2YgZG9jdW1lbnQ8XCJ1XCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihiPWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjKSxLbiYmKGI9S24pLGI9Yi5zdGFydHNXaXRoKFwiYmxvYjpcIik/XCJcIjpiLnNsaWNlKDAsYi5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKSxzJiYoaD1pPT57dmFyIHU9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiB1Lm9wZW4oXCJHRVRcIixpLCExKSx1LnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsdS5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KHUucmVzcG9uc2UpfSksZj1hc3luYyBpPT57aWYobGUoaSkpcmV0dXJuIG5ldyBQcm9taXNlKChjLG0pPT57dmFyIGc9bmV3IFhNTEh0dHBSZXF1ZXN0O2cub3BlbihcIkdFVFwiLGksITApLGcucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixnLm9ubG9hZD0oKT0+e2cuc3RhdHVzPT0yMDB8fGcuc3RhdHVzPT0wJiZnLnJlc3BvbnNlP2MoZy5yZXNwb25zZSk6bShnLnN0YXR1cyl9LGcub25lcnJvcj1tLGcuc2VuZChudWxsKX0pO3ZhciB1PWF3YWl0IGZldGNoKGkse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pO2lmKHUub2spcmV0dXJuIHUuYXJyYXlCdWZmZXIoKTt0aHJvdyBFcnJvcih1LnN0YXR1cytcIiA6IFwiK3UudXJsKX0pO3ZhciB3PWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksUz1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksJD13LHY9UztPYmplY3QuYXNzaWduKHIseSkseT1udWxsO3ZhciBULEMsQSxrLE8sTSxWLEYsaixuZSxXLEosdmUsUT1yLndhc21CaW5hcnksZWU9ITEsbGU9aT0+aS5zdGFydHNXaXRoKFwiZmlsZTovL1wiKTtmdW5jdGlvbiBaKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxrfWZ1bmN0aW9uIHBlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxPfWZ1bmN0aW9uIGtlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxNfWZ1bmN0aW9uIFNlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxWfWZ1bmN0aW9uIEQoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLEZ9ZnVuY3Rpb24gUigpe3JldHVybiBULmJ1ZmZlciE9ay5idWZmZXImJmJlKCksan1mdW5jdGlvbiBZKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxuZX1mdW5jdGlvbiBmZSgpe3JldHVybiBULmJ1ZmZlciE9ay5idWZmZXImJmJlKCksdmV9aWYoZCl7bGV0IGk9ZnVuY3Rpb24odSl7dHJ5e3ZhciBjPXUuZGF0YSxtPWMueWQ7aWYobT09PVwibG9hZFwiKXtsZXQgZz1bXTtzZWxmLm9ubWVzc2FnZT14PT5nLnB1c2goeCksc2VsZi5zdGFydFdvcmtlcj0oKT0+e3Bvc3RNZXNzYWdlKHt5ZDpcImxvYWRlZFwifSk7Zm9yKGxldCB4IG9mIGcpaSh4KTtzZWxmLm9ubWVzc2FnZT1pfTtmb3IobGV0IHggb2YgYy5PZClyW3hdJiYhclt4XS5wcm94eXx8KHJbeF09KC4uLkkpPT57cG9zdE1lc3NhZ2Uoe3lkOlwiY2FsbEhhbmRsZXJcIixOZDp4LGFyZ3M6SX0pfSx4PT1cInByaW50XCImJigkPXJbeF0pLHg9PVwicHJpbnRFcnJcIiYmKHY9clt4XSkpO1Q9Yy5oZSxiZSgpLEZlKGMuaWUpfWVsc2UgaWYobT09PVwicnVuXCIpe2NwKGMueGQpLERuKGMueGQsMCwwLDEsMCwwKSxMbygpLEFuKGMueGQpLHhlfHwoTWkoKSx4ZT0hMCk7dHJ5e3BwKGMuZGUsYy5GZCl9Y2F0Y2goZyl7aWYoZyE9XCJ1bndpbmRcIil0aHJvdyBnfX1lbHNlIGMudGFyZ2V0IT09XCJzZXRpbW1lZGlhdGVcIiYmKG09PT1cImNoZWNrTWFpbGJveFwiP3hlJiZ1cigpOm0mJih2KGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke219YCksdihjKSkpfWNhdGNoKGcpe3Rocm93IFJpKCksZ319O3ZhciB1Yj1pLEZlLHhlPSExO3Y9ZnVuY3Rpb24oLi4udSl7dT11LmpvaW4oXCIgXCIpLGNvbnNvbGUuZXJyb3IodSl9LHNlbGYuYWxlcnQ9ZnVuY3Rpb24oLi4udSl7cG9zdE1lc3NhZ2Uoe3lkOlwiYWxlcnRcIix0ZXh0OnUuam9pbihcIiBcIiksZmU6Z3IoKX0pfSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPXU9Pnt0aHJvdyB1LnJlYXNvbnx8dX0sc2VsZi5vbm1lc3NhZ2U9aX1mdW5jdGlvbiBiZSgpe3ZhciBpPVQuYnVmZmVyO3IuSEVBUDg9az1uZXcgSW50OEFycmF5KGkpLHIuSEVBUDE2PU09bmV3IEludDE2QXJyYXkoaSksci5IRUFQVTg9Tz1uZXcgVWludDhBcnJheShpKSxyLkhFQVBVMTY9Vj1uZXcgVWludDE2QXJyYXkoaSksci5IRUFQMzI9Rj1uZXcgSW50MzJBcnJheShpKSxyLkhFQVBVMzI9aj1uZXcgVWludDMyQXJyYXkoaSksci5IRUFQRjMyPW5lPW5ldyBGbG9hdDMyQXJyYXkoaSksci5IRUFQRjY0PXZlPW5ldyBGbG9hdDY0QXJyYXkoaSksci5IRUFQNjQ9Vz1uZXcgQmlnSW50NjRBcnJheShpKSxyLkhFQVBVNjQ9Sj1uZXcgQmlnVWludDY0QXJyYXkoaSl9ZnVuY3Rpb24gWWUoKXtkP3N0YXJ0V29ya2VyKHIpOlUuQmIoKX1kfHwoVD1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjI1NixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pLGJlKCkpO3ZhciBHdCx4dD0wLEh0PW51bGw7ZnVuY3Rpb24gQm8oKXtpZigtLXh0PT0wJiZIdCl7dmFyIGk9SHQ7SHQ9bnVsbCxpKCl9fWZ1bmN0aW9uIHV0KGkpe3Rocm93IHYoaT1cIkFib3J0ZWQoXCIraStcIilcIiksZWU9ITAsaT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGkrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG4oaSksaX1mdW5jdGlvbiBNbygpe3JldHVybnthOntUYTpscCxWYTpkcCxXOm1wLGxhOmZwLGI6Z3AsdTp5cCxSOmJwLFphOl9wLGQ6d3AscGI6cW8sZzpocCxUOlpvLEdhOlFvLGxiOlhvLG5iOkpvLEhhOmVpLEVhOnRpLHdiOnJpLERhOm5pLHBhOm9pLG1iOmlpLGpiOmFpLEZhOnNpLGtiOnVpLE1hOnZwLHphOnhwLGViOlNwLGNiOkNwLHlhOkFwLFY6a3AsTjpFcCxkYjpQcCxtYTpVcCxmYjpOcCx6YjpWcCxoYjpXcCxxYjpMcCxhYjpHcCxBYTpIcCx5YjpBbixKYTpGcCxTOnFwLFdhOktwLCQ6UXAsRzpZcCxFOkpwLG06VG4sSDplbSxCOm5tLFg6b20sSjppbSx2OmFtLE86c20sRDp1bSx0OmRtLEE6bG0sejpjbSx3OnBtLHI6bW0sdGI6Zm0sdWI6aG0sdmI6Z20scmI6JGksc2I6eGksYmI6U2ksT2E6Ym0sTGE6dm0seTokbSxqYTp4bSxCYTpTbSxLYTpfbSxxYTpUbSxJYTpDbSxpYjpJbSxVOnltLGZhOkFtLFNhOmttLGdiOkVtLFFhOlBtLFBhOnptLEFiOkFpLENhOmtpLG9iOl9uLGFhOkVpLG9hOlBpLHhiOnppLG5hOk9pLCRhOmFmLGlhOl9mLHNhOlNmLGdhOm5mLGRhOnBmLHVhOiRmLHA6dGYsZTpObSxjOlJtLGVhOmxmLGY6Vm0sbjpMbSxrOlltLFk6SG0sa2E6WG0sajpyZix3YTpkZixSYTpJZixjYTp5ZixVYTpDZixQOmNmLEs6cW0sXzpnZixROm9mLFo6d2YseDpGbSxsOlVtLHZhOmhmLGk6TW0saDpHbSxyYTpUZix0YTp4ZixvOldtLHE6S20sczpabSxJOlFtLEM6ZWYsTDpKbSx4YTp1ZixfYTpzZixGOmJmLFlhOm1mLGJhOnZmLE06am0sWGE6ZmYsaGE6RG0sYTpULE5hOmJufX19dmFyIGhuPXsxMzE5NDI2OigpPT50eXBlb2Ygd2FzbU9mZnNldENvbnZlcnRlcjxcInVcIiwxMzE5NDgzOihpLHUsYyxtLGcpPT57aWYocj09PXZvaWQgMHx8IXIuQmQpcmV0dXJuIDE7aWYoKGk9QWUoTnVtYmVyKGk+Pj4wKSkpLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGk9aS5zdWJzdHJpbmcoMikpLCEoaT1yLkJkLmdldChpKSkpcmV0dXJuIDI7aWYodT1OdW1iZXIodT4+PjApLGM9TnVtYmVyKGM+Pj4wKSxtPU51bWJlcihtPj4+MCksdStjPmkuYnl0ZUxlbmd0aClyZXR1cm4gMzt0cnl7bGV0IHg9aS5zdWJhcnJheSh1LHUrYyk7c3dpdGNoKGcpe2Nhc2UgMDpwZSgpLnNldCh4LG0+Pj4wKTticmVhaztjYXNlIDE6ci4kZChtLHgpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSwxMzIwMTk4OihpLHUsYyk9PntyLkpkKGkscGUoKS5zdWJhcnJheSh1Pj4+MCx1K2M+Pj4wKSl9LDEzMjAyNjE6KCk9PnIuWWQoKSwxMzIwMzAyOmk9PntyLklkKGkpfSwxMzIwMzM4OigpPT57ci5TZCgpfSwxMzIwMzY5OigpPT57ci5UZCgpfSwxMzIwMzk4OigpPT57ci5YZCgpfSwxMzIwNDIzOmk9PnIuUmQoaSksMTMyMDQ1NjppPT5yLlZkKGkpLDEzMjA0ODg6KGksdSxjKT0+e3IuSGQoTnVtYmVyKGkpLE51bWJlcih1KSxOdW1iZXIoYyksITApfSwxMzIwNTUxOihpLHUsYyk9PntyLkhkKE51bWJlcihpKSxOdW1iZXIodSksTnVtYmVyKGMpKX0sMTMyMDYwODppPT57ci5oYyhcIkFic1wiLGksdm9pZCAwKX0sMTMyMDY1OTppPT57ci5oYyhcIk5lZ1wiLGksdm9pZCAwKX0sMTMyMDcxMDppPT57ci5oYyhcIkZsb29yXCIsaSx2b2lkIDApfSwxMzIwNzYzOmk9PntyLmhjKFwiQ2VpbFwiLGksdm9pZCAwKX0sMTMyMDgxNTppPT57ci5oYyhcIlJlY2lwcm9jYWxcIixpLHZvaWQgMCl9LDEzMjA4NzM6aT0+e3IuaGMoXCJTcXJ0XCIsaSx2b2lkIDApfSwxMzIwOTI1Omk9PntyLmhjKFwiRXhwXCIsaSx2b2lkIDApfSwxMzIwOTc2Omk9PntyLmhjKFwiRXJmXCIsaSx2b2lkIDApfSwxMzIxMDI3Omk9PntyLmhjKFwiU2lnbW9pZFwiLGksdm9pZCAwKX0sMTMyMTA4MjooaSx1LGMpPT57ci5oYyhcIkhhcmRTaWdtb2lkXCIsaSx7YWxwaGE6dSxiZXRhOmN9KX0sMTMyMTE2MTppPT57ci5oYyhcIkxvZ1wiLGksdm9pZCAwKX0sMTMyMTIxMjppPT57ci5oYyhcIlNpblwiLGksdm9pZCAwKX0sMTMyMTI2MzppPT57ci5oYyhcIkNvc1wiLGksdm9pZCAwKX0sMTMyMTMxNDppPT57ci5oYyhcIlRhblwiLGksdm9pZCAwKX0sMTMyMTM2NTppPT57ci5oYyhcIkFzaW5cIixpLHZvaWQgMCl9LDEzMjE0MTc6aT0+e3IuaGMoXCJBY29zXCIsaSx2b2lkIDApfSwxMzIxNDY5Omk9PntyLmhjKFwiQXRhblwiLGksdm9pZCAwKX0sMTMyMTUyMTppPT57ci5oYyhcIlNpbmhcIixpLHZvaWQgMCl9LDEzMjE1NzM6aT0+e3IuaGMoXCJDb3NoXCIsaSx2b2lkIDApfSwxMzIxNjI1Omk9PntyLmhjKFwiQXNpbmhcIixpLHZvaWQgMCl9LDEzMjE2Nzg6aT0+e3IuaGMoXCJBY29zaFwiLGksdm9pZCAwKX0sMTMyMTczMTppPT57ci5oYyhcIkF0YW5oXCIsaSx2b2lkIDApfSwxMzIxNzg0Omk9PntyLmhjKFwiVGFuaFwiLGksdm9pZCAwKX0sMTMyMTgzNjppPT57ci5oYyhcIk5vdFwiLGksdm9pZCAwKX0sMTMyMTg4NzooaSx1LGMpPT57ci5oYyhcIkNsaXBcIixpLHttaW46dSxtYXg6Y30pfSwxMzIxOTU2Omk9PntyLmhjKFwiQ2xpcFwiLGksdm9pZCAwKX0sMTMyMjAwODooaSx1KT0+e3IuaGMoXCJFbHVcIixpLHthbHBoYTp1fSl9LDEzMjIwNjY6aT0+e3IuaGMoXCJHZWx1XCIsaSx2b2lkIDApfSwxMzIyMTE4Omk9PntyLmhjKFwiUmVsdVwiLGksdm9pZCAwKX0sMTMyMjE3MDooaSx1KT0+e3IuaGMoXCJMZWFreVJlbHVcIixpLHthbHBoYTp1fSl9LDEzMjIyMzQ6KGksdSk9PntyLmhjKFwiVGhyZXNob2xkZWRSZWx1XCIsaSx7YWxwaGE6dX0pfSwxMzIyMzA0OihpLHUpPT57ci5oYyhcIkNhc3RcIixpLHt0bzp1fSl9LDEzMjIzNjI6aT0+e3IuaGMoXCJBZGRcIixpLHZvaWQgMCl9LDEzMjI0MTM6aT0+e3IuaGMoXCJTdWJcIixpLHZvaWQgMCl9LDEzMjI0NjQ6aT0+e3IuaGMoXCJNdWxcIixpLHZvaWQgMCl9LDEzMjI1MTU6aT0+e3IuaGMoXCJEaXZcIixpLHZvaWQgMCl9LDEzMjI1NjY6aT0+e3IuaGMoXCJQb3dcIixpLHZvaWQgMCl9LDEzMjI2MTc6aT0+e3IuaGMoXCJFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjY3MDppPT57ci5oYyhcIkdyZWF0ZXJcIixpLHZvaWQgMCl9LDEzMjI3MjU6aT0+e3IuaGMoXCJHcmVhdGVyT3JFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjc4NzppPT57ci5oYyhcIkxlc3NcIixpLHZvaWQgMCl9LDEzMjI4Mzk6aT0+e3IuaGMoXCJMZXNzT3JFcXVhbFwiLGksdm9pZCAwKX0sMTMyMjg5ODooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VNZWFuXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzA3MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VNYXhcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzIzMjQ3OihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZU1pblwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM0MjE6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlUHJvZFwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM1OTY6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlU3VtXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzc3MDooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VMMVwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjM5NDM6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlTDJcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzI0MTE2OihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZUxvZ1N1bVwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjQyOTM6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlU3VtU3F1YXJlXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyNDQ3MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VMb2dTdW1FeHBcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzI0NjUzOmk9PntyLmhjKFwiV2hlcmVcIixpLHZvaWQgMCl9LDEzMjQ3MDY6KGksdSxjKT0+e3IuaGMoXCJUcmFuc3Bvc2VcIixpLHtwZXJtOnU/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHUpPj4+MCxOdW1iZXIoYyk+Pj4wKSk6W119KX0sMTMyNDgzMDooaSx1LGMsbSk9PntyLmhjKFwiRGVwdGhUb1NwYWNlXCIsaSx7YmxvY2tzaXplOnUsbW9kZTpBZShjKSxmb3JtYXQ6bT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI0OTYzOihpLHUsYyxtKT0+e3IuaGMoXCJEZXB0aFRvU3BhY2VcIixpLHtibG9ja3NpemU6dSxtb2RlOkFlKGMpLGZvcm1hdDptP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMjUwOTY6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlLExlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpbY10sZ3JvdXA6bSxrZXJuZWxTaGFwZTpbZ10scGFkczpbeCxJXSxzdHJpZGVzOlt6XSx3SXNDb25zdDooKT0+ISFaKClbTD4+PjBdLG91dHB1dFBhZGRpbmc6cT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIocSk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTp1ZT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodWUpPj4+MCxOdW1iZXIoJGUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoTGUpfSl9LDEzMjU1Mjk6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLDIrKE51bWJlcihjKT4+PjApPj4+MCkpLGdyb3VwOm0sa2VybmVsU2hhcGU6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGcpPj4+MCwyKyhOdW1iZXIoZyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsNCsoTnVtYmVyKHgpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDIrKE51bWJlcihJKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIVooKVtCPj4+MF0sb3V0cHV0UGFkZGluZzpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLG91dHB1dFNoYXBlOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoJGUpfSl9LDEzMjYxOTA6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlLExlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpbY10sZ3JvdXA6bSxrZXJuZWxTaGFwZTpbZ10scGFkczpbeCxJXSxzdHJpZGVzOlt6XSx3SXNDb25zdDooKT0+ISFaKClbTD4+PjBdLG91dHB1dFBhZGRpbmc6cT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIocSk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTp1ZT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodWUpPj4+MCxOdW1iZXIoJGUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoTGUpfSl9LDEzMjY2MjM6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJDb252VHJhbnNwb3NlXCIsaSx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDp1LGRpbGF0aW9uczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLDIrKE51bWJlcihjKT4+PjApPj4+MCkpLGdyb3VwOm0sa2VybmVsU2hhcGU6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGcpPj4+MCwyKyhOdW1iZXIoZyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsNCsoTnVtYmVyKHgpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDIrKE51bWJlcihJKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIVooKVtCPj4+MF0sb3V0cHV0UGFkZGluZzpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLG91dHB1dFNoYXBlOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdLGFjdGl2YXRpb246QWUoJGUpfSl9LDEzMjcyODQ6KGksdSk9PntyLmhjKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI3Mzc1OihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6JGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDptLHN0b3JhZ2Vfb3JkZXI6ZyxkaWxhdGlvbnM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxwYWRzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sc3RyaWRlczpYP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKHVlKT4+PjApKTpbXX0pfSwxMzI3ODU0OihpLHUpPT57ci5oYyhcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OnU/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMyNzk0NTooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIkF2ZXJhZ2VQb29sXCIsaSx7Zm9ybWF0OiRlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnUsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6bSxzdG9yYWdlX29yZGVyOmcsZGlsYXRpb25zOng/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHgpPj4+MCxOdW1iZXIoSSk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOno/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHopPj4+MCxOdW1iZXIoQik+Pj4wKSk6W10scGFkczpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLHN0cmlkZXM6WD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcih1ZSk+Pj4wKSk6W119KX0sMTMyODQyNDooaSx1KT0+e3IuaGMoXCJHbG9iYWxNYXhQb29sXCIsaSx7Zm9ybWF0OnU/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMyODUxMTooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIk1heFBvb2xcIixpLHtmb3JtYXQ6JGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDptLHN0b3JhZ2Vfb3JkZXI6ZyxkaWxhdGlvbnM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxwYWRzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sc3RyaWRlczpYP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKHVlKT4+PjApKTpbXX0pfSwxMzI4OTg2OihpLHUpPT57ci5oYyhcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI5MDczOihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDokZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDp1LGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOm0sc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdLGtlcm5lbF9zaGFwZTp6P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih6KT4+PjAsTnVtYmVyKEIpPj4+MCkpOltdLHBhZHM6TD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoTCk+Pj4wLE51bWJlcihxKT4+PjApKTpbXSxzdHJpZGVzOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdfSl9LDEzMjk1NDg6KGksdSxjLG0sZyk9PntyLmhjKFwiR2VtbVwiLGkse2FscGhhOnUsYmV0YTpjLHRyYW5zQTptLHRyYW5zQjpnfSl9LDEzMjk2NTI6aT0+e3IuaGMoXCJNYXRNdWxcIixpLHZvaWQgMCl9LDEzMjk3MDY6KGksdSxjLG0pPT57ci5oYyhcIkFyZ01heFwiLGkse2tlZXBEaW1zOiEhdSxzZWxlY3RMYXN0SW5kZXg6ISFjLGF4aXM6bX0pfSwxMzI5ODE0OihpLHUsYyxtKT0+e3IuaGMoXCJBcmdNaW5cIixpLHtrZWVwRGltczohIXUsc2VsZWN0TGFzdEluZGV4OiEhYyxheGlzOm19KX0sMTMyOTkyMjooaSx1KT0+e3IuaGMoXCJTb2Z0bWF4XCIsaSx7YXhpczp1fSl9LDEzMjk5ODU6KGksdSk9PntyLmhjKFwiQ29uY2F0XCIsaSx7YXhpczp1fSl9LDEzMzAwNDU6KGksdSxjLG0sZyk9PntyLmhjKFwiU3BsaXRcIixpLHtheGlzOnUsbnVtT3V0cHV0czpjLHNwbGl0U2l6ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzMwMjAxOmk9PntyLmhjKFwiRXhwYW5kXCIsaSx2b2lkIDApfSwxMzMwMjU1OihpLHUpPT57ci5oYyhcIkdhdGhlclwiLGkse2F4aXM6TnVtYmVyKHUpfSl9LDEzMzAzMjY6KGksdSk9PntyLmhjKFwiR2F0aGVyRWxlbWVudHNcIixpLHtheGlzOk51bWJlcih1KX0pfSwxMzMwNDA1OihpLHUpPT57ci5oYyhcIkdhdGhlck5EXCIsaSx7YmF0Y2hfZGltczpOdW1iZXIodSl9KX0sMTMzMDQ4NDooaSx1LGMsbSxnLHgsSSx6LEIsTCxxKT0+e3IuaGMoXCJSZXNpemVcIixpLHthbnRpYWxpYXM6dSxheGVzOmM/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIobSk+Pj4wKSk6W10sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6QWUoZyksY3ViaWNDb2VmZkE6eCxleGNsdWRlT3V0c2lkZTpJLGV4dHJhcG9sYXRpb25WYWx1ZTp6LGtlZXBBc3BlY3RSYXRpb1BvbGljeTpBZShCKSxtb2RlOkFlKEwpLG5lYXJlc3RNb2RlOkFlKHEpfSl9LDEzMzA4NDY6KGksdSxjLG0sZyx4LEkpPT57ci5oYyhcIlNsaWNlXCIsaSx7c3RhcnRzOnU/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHUpPj4+MCxOdW1iZXIoYyk+Pj4wKSk6W10sZW5kczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdLGF4ZXM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXX0pfSwxMzMxMTEwOmk9PntyLmhjKFwiVGlsZVwiLGksdm9pZCAwKX0sMTMzMTE2MjooaSx1LGMpPT57ci5oYyhcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246dSxmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMxMjc2OihpLHUsYyk9PntyLmhjKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LGZvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzEzOTA6aT0+e3IuaGMoXCJSYW5nZVwiLGksdm9pZCAwKX0sMTMzMTQ0MzooaSx1KT0+e3IuaGMoXCJFaW5zdW1cIixpLHtlcXVhdGlvbjpBZSh1KX0pfSwxMzMxNTI0OihpLHUsYyxtLGcpPT57ci5oYyhcIlBhZFwiLGkse21vZGU6dSx2YWx1ZTpjLHBhZHM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzMxNjY3OihpLHUsYyxtLGcseCk9PntyLmhjKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LG1vbWVudHVtOmMsc3BhdGlhbDohIWcsdHJhaW5pbmdNb2RlOiEhbSxmb3JtYXQ6eD9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMxODM2OihpLHUsYyxtLGcseCk9PntyLmhjKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LG1vbWVudHVtOmMsc3BhdGlhbDohIWcsdHJhaW5pbmdNb2RlOiEhbSxmb3JtYXQ6eD9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMyMDA1OihpLHUsYyk9PntyLmhjKFwiQ3VtU3VtXCIsaSx7ZXhjbHVzaXZlOk51bWJlcih1KSxyZXZlcnNlOk51bWJlcihjKX0pfSwxMzMyMTAyOihpLHUsYyk9PntyLmhjKFwiRGVxdWFudGl6ZUxpbmVhclwiLGkse2F4aXM6dSxibG9ja1NpemU6Y30pfSwxMzMyMTkyOihpLHUsYyxtLGcpPT57ci5oYyhcIkdyaWRTYW1wbGVcIixpLHthbGlnbl9jb3JuZXJzOnUsbW9kZTpBZShjKSxwYWRkaW5nX21vZGU6QWUobSksZm9ybWF0Omc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMzMjM2MjooaSx1LGMsbSxnKT0+e3IuaGMoXCJHcmlkU2FtcGxlXCIsaSx7YWxpZ25fY29ybmVyczp1LG1vZGU6QWUoYykscGFkZGluZ19tb2RlOkFlKG0pLGZvcm1hdDpnP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzI1MzI6KGksdSk9PntyLmhjKFwiU2NhdHRlck5EXCIsaSx7cmVkdWN0aW9uOkFlKHUpfSl9LDEzMzI2MTc6KGksdSxjLG0sZyx4LEkseixCKT0+e3IuaGMoXCJBdHRlbnRpb25cIixpLHtudW1IZWFkczp1LGlzVW5pZGlyZWN0aW9uYWw6YyxtYXNrRmlsdGVyVmFsdWU6bSxzY2FsZTpnLGRvUm90YXJ5OngscWt2SGlkZGVuU2l6ZXM6ST9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcih6KStJPj4+MCkpOltdLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ISFCfSl9LDEzMzI4ODk6aT0+e3IuaGMoXCJCaWFzQWRkXCIsaSx2b2lkIDApfSwxMzMyOTQ0Omk9PntyLmhjKFwiQmlhc1NwbGl0R2VsdVwiLGksdm9pZCAwKX0sMTMzMzAwNTppPT57ci5oYyhcIkZhc3RHZWx1XCIsaSx2b2lkIDApfSwxMzMzMDYxOihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSxMZSxqdCk9PntyLmhjKFwiQ29udlwiLGkse2Zvcm1hdDpYP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnUsZGlsYXRpb25zOmM/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIobSk+Pj4wKSk6W10sZ3JvdXA6ZyxrZXJuZWxfc2hhcGU6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxwYWRzOno/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHopPj4+MCxOdW1iZXIoQik+Pj4wKSk6W10sc3RyaWRlczpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLHdfaXNfY29uc3Q6KCk9PiEhWigpW051bWJlcih1ZSk+Pj4wXSxhY3RpdmF0aW9uOkFlKCRlKSxhY3RpdmF0aW9uX3BhcmFtczpMZT9BcnJheS5mcm9tKFkoKS5zdWJhcnJheShOdW1iZXIoTGUpPj4+MCxOdW1iZXIoanQpPj4+MCkpOltdfSl9LDEzMzM2NDU6aT0+e3IuaGMoXCJHZWx1XCIsaSx2b2lkIDApfSwxMzMzNjk3OihpLHUsYyxtLGcseCxJLHosQik9PntyLmhjKFwiR3JvdXBRdWVyeUF0dGVudGlvblwiLGkse251bUhlYWRzOnUsa3ZOdW1IZWFkczpjLHNjYWxlOm0sc29mdGNhcDpnLGRvUm90YXJ5Ongscm90YXJ5SW50ZXJsZWF2ZWQ6SSxzbW9vdGhTb2Z0bWF4OnosbG9jYWxXaW5kb3dTaXplOkJ9KX0sMTMzMzkxNDooaSx1LGMsbSk9PntyLmhjKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsaSx7YXhpczp1LGVwc2lsb246YyxzaW1wbGlmaWVkOiEhbX0pfSwxMzM0MDI1OihpLHUsYyxtKT0+e3IuaGMoXCJMYXllck5vcm1hbGl6YXRpb25cIixpLHtheGlzOnUsZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFtfSl9LDEzMzQxMzY6KGksdSxjLG0sZyx4KT0+e3IuaGMoXCJNYXRNdWxOQml0c1wiLGkse2s6dSxuOmMsYWNjdXJhY3lMZXZlbDptLGJpdHM6ZyxibG9ja1NpemU6eH0pfSwxMzM0MjYzOihpLHUsYyxtLGcseCk9PntyLmhjKFwiTXVsdGlIZWFkQXR0ZW50aW9uXCIsaSx7bnVtSGVhZHM6dSxpc1VuaWRpcmVjdGlvbmFsOmMsbWFza0ZpbHRlclZhbHVlOm0sc2NhbGU6Zyxkb1JvdGFyeTp4fSl9LDEzMzQ0MjI6KGksdSk9PntyLmhjKFwiUXVpY2tHZWx1XCIsaSx7YWxwaGE6dX0pfSwxMzM0NDg2OihpLHUsYyxtLGcpPT57ci5oYyhcIlJvdGFyeUVtYmVkZGluZ1wiLGkse2ludGVybGVhdmVkOiEhdSxudW1IZWFkczpjLHJvdGFyeUVtYmVkZGluZ0RpbTptLHNjYWxlOmd9KX0sMTMzNDYyNTooaSx1LGMpPT57ci5oYyhcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsc2ltcGxpZmllZDohIWN9KX0sMTMzNDcyNzooaSx1LGMpPT57ci5oYyhcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsc2ltcGxpZmllZDohIWN9KX0sMTMzNDgyOTooaSx1LGMsbSk9PntyLmhjKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixpLHtnYXRoZXJBeGlzOnUscXVhbnRpemVBeGlzOmMsYmxvY2tTaXplOm19KX0sMTMzNDk1MDppPT57ci5XZChpKX0sMTMzNDk4NDooaSx1KT0+ci5aZChOdW1iZXIoaSksTnVtYmVyKHUpLHIuQ2QuYmUsci5DZC5lcnJvcnMpfTtmdW5jdGlvbiBkcChpLHUsYyl7cmV0dXJuIGdpKGFzeW5jKCk9Pnthd2FpdCByLlVkKE51bWJlcihpKSxOdW1iZXIodSksTnVtYmVyKGMpKX0pfWZ1bmN0aW9uIGxwKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWNsYXNzIGdue25hbWU9XCJFeGl0U3RhdHVzXCI7Y29uc3RydWN0b3IodSl7dGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7dX0pYCx0aGlzLnN0YXR1cz11fX12YXIgUm89aT0+e2kudGVybWluYXRlKCksaS5vbm1lc3NhZ2U9KCk9Pnt9fSx5bj1bXSxVbz1pPT57ZnQubGVuZ3RoPT0wJiYoSG8oKSxHbyhmdFswXSkpO3ZhciB1PWZ0LnBvcCgpO2lmKCF1KXJldHVybiA2O0Z0LnB1c2godSksU3RbaS54ZF09dSx1LnhkPWkueGQ7dmFyIGM9e3lkOlwicnVuXCIsZGU6aS5jZSxGZDppLkZkLHhkOmkueGR9O3JldHVybiB1LnBvc3RNZXNzYWdlKGMsaS5MZCksMH0sbXQ9MCxUZT0oaSx1LC4uLmMpPT57Zm9yKHZhciBtPTIqYy5sZW5ndGgsZz1pZSgpLHg9TW4oOCptKSxJPXg+Pj4zLHo9MDt6PGMubGVuZ3RoO3orKyl7dmFyIEI9Y1t6XTt0eXBlb2YgQj09XCJiaWdpbnRcIj8oV1tJKzIqel09MW4sV1tJKzIqeisxXT1CKTooV1tJKzIqel09MG4sZmUoKVtJKzIqeisxPj4+MF09Qil9cmV0dXJuIGk9VWkoaSwwLG0seCx1KSxvZShnKSxpfTtmdW5jdGlvbiBibihpKXtpZihkKXJldHVybiBUZSgwLDEsaSk7aWYoQT1pLCEoMDxtdCkpe2Zvcih2YXIgdSBvZiBGdClSbyh1KTtmb3IodSBvZiBmdClSbyh1KTtmdD1bXSxGdD1bXSxTdD17fSxlZT0hMH1fKDAsbmV3IGduKGkpKX1mdW5jdGlvbiBObyhpKXtpZihkKXJldHVybiBUZSgxLDAsaSk7X24oaSl9dmFyIF9uPWk9PntpZihBPWksZCl0aHJvdyBObyhpKSxcInVud2luZFwiO2JuKGkpfSxmdD1bXSxGdD1bXSxWbz1bXSxTdD17fSxXbz1pPT57dmFyIHU9aS54ZDtkZWxldGUgU3RbdV0sZnQucHVzaChpKSxGdC5zcGxpY2UoRnQuaW5kZXhPZihpKSwxKSxpLnhkPTAsTmkodSl9O2Z1bmN0aW9uIExvKCl7Vm8uZm9yRWFjaChpPT5pKCkpfXZhciBHbz1pPT5uZXcgUHJvbWlzZSh1PT57aS5vbm1lc3NhZ2U9Zz0+e3ZhciB4PShnPWcuZGF0YSkueWQ7aWYoZy5FZCYmZy5FZCE9Z3IoKSl7dmFyIEk9U3RbZy5FZF07ST9JLnBvc3RNZXNzYWdlKGcsZy5MZCk6dihgSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIiR7eH1cIiB0byB0YXJnZXQgcHRocmVhZCAke2cuRWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIHg9PT1cImNoZWNrTWFpbGJveFwiP3VyKCk6eD09PVwic3Bhd25UaHJlYWRcIj9VbyhnKTp4PT09XCJjbGVhbnVwVGhyZWFkXCI/V28oU3RbZy5lZV0pOng9PT1cImxvYWRlZFwiPyhpLmxvYWRlZD0hMCx1KGkpKTp4PT09XCJhbGVydFwiP2FsZXJ0KGBUaHJlYWQgJHtnLmZlfTogJHtnLnRleHR9YCk6Zy50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP2kucG9zdE1lc3NhZ2UoZyk6eD09PVwiY2FsbEhhbmRsZXJcIj9yW2cuTmRdKC4uLmcuYXJncyk6eCYmdihgd29ya2VyIHNlbnQgYW4gdW5rbm93biBjb21tYW5kICR7eH1gKX0saS5vbmVycm9yPWc9Pnt0aHJvdyB2KGB3b3JrZXIgc2VudCBhbiBlcnJvciEgJHtnLmZpbGVuYW1lfToke2cubGluZW5vfTogJHtnLm1lc3NhZ2V9YCksZ307dmFyIGMsbT1bXTtmb3IoYyBvZltdKXIucHJvcGVydHlJc0VudW1lcmFibGUoYykmJm0ucHVzaChjKTtpLnBvc3RNZXNzYWdlKHt5ZDpcImxvYWRcIixPZDptLGhlOlQsaWU6Q30pfSk7ZnVuY3Rpb24gSG8oKXt2YXIgaT1uZXcgV29ya2VyKGltcG9ydC5tZXRhLnVybC5zdGFydHNXaXRoKFwiZmlsZTpcIik/bmV3IFVSTChcIm9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpOm5ldyBVUkwoaW1wb3J0Lm1ldGEudXJsKSx7dHlwZTpcIm1vZHVsZVwiLHdvcmtlckRhdGE6XCJlbS1wdGhyZWFkXCIsbmFtZTpcImVtLXB0aHJlYWRcIn0pO2Z0LnB1c2goaSl9dmFyIGNwPWk9PntiZSgpO3ZhciB1PVIoKVtpKzUyPj4+Mj4+PjBdO2k9UigpW2krNTY+Pj4yPj4+MF0sTGkodSx1LWkpLG9lKHUpfSxwcD0oaSx1KT0+e210PTAsaT1SbihpLHUpLDA8bXQ/QT1pOkJuKGkpfSxzcj1bXTtmdW5jdGlvbiBtcChpKXt2YXIgdT1uZXcgd24oaT4+Pj0wKTtpZihaKClbdS53ZCsxMj4+PjBdPT0wKXt2YXIgYz0xO1ooKVt1LndkKzEyPj4+MF09Y31yZXR1cm4gYz0wLFooKVt1LndkKzEzPj4+MF09Yyxzci5wdXNoKHUpLEhpKGkpLHFpKGkpfXZhciBEdD0wLGZwPSgpPT57c2UoMCwwKTt2YXIgaT1zci5wb3AoKTtHaShpLkdkKSxEdD0wfTtjbGFzcyB3bntjb25zdHJ1Y3Rvcih1KXt0aGlzLkdkPXUsdGhpcy53ZD11LTI0fX1mdW5jdGlvbiBocChpKXt0aHJvdyBEdHx8PWk+Pj4wLER0fXZhciB2bj1pPT57dmFyIHU9RHQ7aWYoIXUpcmV0dXJuIEt0KDApLDA7dmFyIGM9bmV3IHduKHUpO1IoKVtjLndkKzE2Pj4+Mj4+PjBdPXU7dmFyIG09UigpW2Mud2QrND4+PjI+Pj4wXTtpZighbSlyZXR1cm4gS3QoMCksdTtmb3IodmFyIGcgb2YgaSl7aWYoZz09PTB8fGc9PT1tKWJyZWFrO2lmKEZpKGcsbSxjLndkKzE2KSlyZXR1cm4gS3QoZyksdX1yZXR1cm4gS3QobSksdX07ZnVuY3Rpb24gZ3AoKXtyZXR1cm4gdm4oW10pfWZ1bmN0aW9uIHlwKGkpe3JldHVybiB2bihbaT4+PjBdKX1mdW5jdGlvbiBicChpLHUpe3JldHVybiB2bihbaT4+PjAsdT4+PjBdKX12YXIgX3A9KCk9Pnt2YXIgaT1zci5wb3AoKTtpfHx1dChcIm5vIGV4Y2VwdGlvbiB0byB0aHJvd1wiKTt2YXIgdT1pLkdkO2lmKFooKVtpLndkKzEzPj4+MF09PTApe3NyLnB1c2goaSk7dmFyIGM9MTtaKClbaS53ZCsxMz4+PjBdPWMsYz0wLFooKVtpLndkKzEyPj4+MF09Y310aHJvdyBEdD11fTtmdW5jdGlvbiB3cChpLHUsYyl7dmFyIG09bmV3IHduKGk+Pj49MCk7dGhyb3cgdT4+Pj0wLGM+Pj49MCxSKClbbS53ZCsxNj4+PjI+Pj4wXT0wLFIoKVttLndkKzQ+Pj4yPj4+MF09dSxSKClbbS53ZCs4Pj4+Mj4+PjBdPWMsRHQ9aX1mdW5jdGlvbiBGbyhpLHUsYyxtKXtyZXR1cm4gZD9UZSgyLDEsaSx1LGMsbSk6cW8oaSx1LGMsbSl9ZnVuY3Rpb24gcW8oaSx1LGMsbSl7aWYoaT4+Pj0wLGM+Pj49MCxtPj4+PTAsbD09PXZvaWQgMClyZXR1cm4gNjt2YXIgZz1bXTtyZXR1cm4gZCYmZy5sZW5ndGg9PT0wP0ZvKGksdT4+Pj0wLGMsbSk6KGk9e2NlOmMseGQ6aSxGZDptLExkOmd9LGQ/KGkueWQ9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKGksZyksMCk6VW8oaSkpfXZhciBLbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyOnZvaWQgMCxqbz0oaSx1PTAsYz1OYU4pPT57dmFyIG09KHU+Pj49MCkrYztmb3IoYz11O2lbY10mJiEoYz49bSk7KSsrYztpZigxNjxjLXUmJmkuYnVmZmVyJiZLbylyZXR1cm4gS28uZGVjb2RlKGkuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/aS5zdWJhcnJheSh1LGMpOmkuc2xpY2UodSxjKSk7Zm9yKG09XCJcIjt1PGM7KXt2YXIgZz1pW3UrK107aWYoMTI4Jmcpe3ZhciB4PTYzJmlbdSsrXTtpZigoMjI0JmcpPT0xOTIpbSs9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmZyk8PDZ8eCk7ZWxzZXt2YXIgST02MyZpW3UrK107NjU1MzY+KGc9KDI0MCZnKT09MjI0PygxNSZnKTw8MTJ8eDw8NnxJOig3JmcpPDwxOHx4PDwxMnxJPDw2fDYzJmlbdSsrXSk/bSs9U3RyaW5nLmZyb21DaGFyQ29kZShnKTooZy09NjU1MzYsbSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxnPj4xMCw1NjMyMHwxMDIzJmcpKX19ZWxzZSBtKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfXJldHVybiBtfSxBZT0oaSx1KT0+KGk+Pj49MCk/am8ocGUoKSxpLHUpOlwiXCI7ZnVuY3Rpb24gWm8oaSx1LGMpe3JldHVybiBkP1RlKDMsMSxpLHUsYyk6MH1mdW5jdGlvbiBRbyhpLHUpe2lmKGQpcmV0dXJuIFRlKDQsMSxpLHUpfXZhciBZbz1pPT57Zm9yKHZhciB1PTAsYz0wO2M8aS5sZW5ndGg7KytjKXt2YXIgbT1pLmNoYXJDb2RlQXQoYyk7MTI3Pj1tP3UrKzoyMDQ3Pj1tP3UrPTI6NTUyOTY8PW0mJjU3MzQzPj1tPyh1Kz00LCsrYyk6dSs9M31yZXR1cm4gdX0sQnQ9KGksdSxjKT0+e3ZhciBtPXBlKCk7aWYodT4+Pj0wLDA8Yyl7dmFyIGc9dTtjPXUrYy0xO2Zvcih2YXIgeD0wO3g8aS5sZW5ndGg7Kyt4KXt2YXIgST1pLmNoYXJDb2RlQXQoeCk7aWYoNTUyOTY8PUkmJjU3MzQzPj1JJiYoST02NTUzNisoKDEwMjMmSSk8PDEwKXwxMDIzJmkuY2hhckNvZGVBdCgrK3gpKSwxMjc+PUkpe2lmKHU+PWMpYnJlYWs7bVt1Kys+Pj4wXT1JfWVsc2V7aWYoMjA0Nz49SSl7aWYodSsxPj1jKWJyZWFrO21bdSsrPj4+MF09MTkyfEk+PjZ9ZWxzZXtpZig2NTUzNT49SSl7aWYodSsyPj1jKWJyZWFrO21bdSsrPj4+MF09MjI0fEk+PjEyfWVsc2V7aWYodSszPj1jKWJyZWFrO21bdSsrPj4+MF09MjQwfEk+PjE4LG1bdSsrPj4+MF09MTI4fEk+PjEyJjYzfW1bdSsrPj4+MF09MTI4fEk+PjYmNjN9bVt1Kys+Pj4wXT0xMjh8NjMmSX19bVt1Pj4+MF09MCxpPXUtZ31lbHNlIGk9MDtyZXR1cm4gaX07ZnVuY3Rpb24gWG8oaSx1KXtpZihkKXJldHVybiBUZSg1LDEsaSx1KX1mdW5jdGlvbiBKbyhpLHUsYyl7aWYoZClyZXR1cm4gVGUoNiwxLGksdSxjKX1mdW5jdGlvbiBlaShpLHUsYyl7cmV0dXJuIGQ/VGUoNywxLGksdSxjKTowfWZ1bmN0aW9uIHRpKGksdSl7aWYoZClyZXR1cm4gVGUoOCwxLGksdSl9ZnVuY3Rpb24gcmkoaSx1LGMpe2lmKGQpcmV0dXJuIFRlKDksMSxpLHUsYyl9ZnVuY3Rpb24gbmkoaSx1LGMsbSl7aWYoZClyZXR1cm4gVGUoMTAsMSxpLHUsYyxtKX1mdW5jdGlvbiBvaShpLHUsYyxtKXtpZihkKXJldHVybiBUZSgxMSwxLGksdSxjLG0pfWZ1bmN0aW9uIGlpKGksdSxjLG0pe2lmKGQpcmV0dXJuIFRlKDEyLDEsaSx1LGMsbSl9ZnVuY3Rpb24gYWkoaSl7aWYoZClyZXR1cm4gVGUoMTMsMSxpKX1mdW5jdGlvbiBzaShpLHUpe2lmKGQpcmV0dXJuIFRlKDE0LDEsaSx1KX1mdW5jdGlvbiB1aShpLHUsYyl7aWYoZClyZXR1cm4gVGUoMTUsMSxpLHUsYyl9dmFyIGRpLGh0LHZwPSgpPT51dChcIlwiKSxYZT1pPT57Zm9yKHZhciB1PVwiXCI7cGUoKVtpPj4+MF07KXUrPWRpW3BlKClbaSsrPj4+MF1dO3JldHVybiB1fSwkbj17fSx4bj17fSwkcD17fTtmdW5jdGlvbiBkdChpLHUsYz17fSl7cmV0dXJuIGZ1bmN0aW9uKG0sZyx4PXt9KXt2YXIgST1nLm5hbWU7aWYoIW0pdGhyb3cgbmV3IGh0KGB0eXBlIFwiJHtJfVwiIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXJgKTtpZih4bi5oYXNPd25Qcm9wZXJ0eShtKSl7aWYoeC5QZClyZXR1cm47dGhyb3cgbmV3IGh0KGBDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnJHtJfScgdHdpY2VgKX14blttXT1nLGRlbGV0ZSAkcFttXSwkbi5oYXNPd25Qcm9wZXJ0eShtKSYmKGc9JG5bbV0sZGVsZXRlICRuW21dLGcuZm9yRWFjaCh6PT56KCkpKX0oaSx1LGMpfXZhciBsaT0oaSx1LGMpPT57c3dpdGNoKHUpe2Nhc2UgMTpyZXR1cm4gYz9tPT5aKClbbT4+PjBdOm09PnBlKClbbT4+PjBdO2Nhc2UgMjpyZXR1cm4gYz9tPT5rZSgpW20+Pj4xPj4+MF06bT0+U2UoKVttPj4+MT4+PjBdO2Nhc2UgNDpyZXR1cm4gYz9tPT5EKClbbT4+PjI+Pj4wXTptPT5SKClbbT4+PjI+Pj4wXTtjYXNlIDg6cmV0dXJuIGM/bT0+V1ttPj4+M106bT0+SlttPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7dX0pOiAke2l9YCl9fTtmdW5jdGlvbiB4cChpLHUsYyl7Yz4+Pj0wLGR0KGk+Pj49MCx7bmFtZTp1PVhlKHU+Pj4wKSxmcm9tV2lyZVR5cGU6bT0+bSx0b1dpcmVUeXBlOmZ1bmN0aW9uKG0sZyl7aWYodHlwZW9mIGchPVwiYmlnaW50XCImJnR5cGVvZiBnIT1cIm51bWJlclwiKXRocm93IGc9Zz09PW51bGw/XCJudWxsXCI6KG09dHlwZW9mIGcpPT1cIm9iamVjdFwifHxtPT09XCJhcnJheVwifHxtPT09XCJmdW5jdGlvblwiP2cudG9TdHJpbmcoKTpcIlwiK2csbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke2d9XCIgdG8gJHt0aGlzLm5hbWV9YCk7cmV0dXJuIHR5cGVvZiBnPT1cIm51bWJlclwiJiYoZz1CaWdJbnQoZykpLGd9LHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxpKHUsYyx1LmluZGV4T2YoXCJ1XCIpPT0tMSksQWQ6bnVsbH0pfXZhciBndD04O2Z1bmN0aW9uIFNwKGksdSxjLG0pe2R0KGk+Pj49MCx7bmFtZTp1PVhlKHU+Pj4wKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZyl7cmV0dXJuISFnfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKGcseCl7cmV0dXJuIHg/YzptfSx6ZDpndCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbihnKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUocGUoKVtnPj4+MF0pfSxBZDpudWxsfSl9dmFyIFNuPVtdLGx0PVtdO2Z1bmN0aW9uIFRuKGkpezk8KGk+Pj49MCkmJi0tbHRbaSsxXT09MCYmKGx0W2ldPXZvaWQgMCxTbi5wdXNoKGkpKX12YXIgUmU9aT0+e2lmKCFpKXRocm93IG5ldyBodChcIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9IFwiK2kpO3JldHVybiBsdFtpXX0sV2U9aT0+e3N3aXRjaChpKXtjYXNlIHZvaWQgMDpyZXR1cm4gMjtjYXNlIG51bGw6cmV0dXJuIDQ7Y2FzZSEwOnJldHVybiA2O2Nhc2UhMTpyZXR1cm4gODtkZWZhdWx0OmxldCB1PVNuLnBvcCgpfHxsdC5sZW5ndGg7cmV0dXJuIGx0W3VdPWksbHRbdSsxXT0xLHV9fTtmdW5jdGlvbiBDbihpKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoUigpW2k+Pj4yPj4+MF0pfXZhciBUcD17bmFtZTpcImVtc2NyaXB0ZW46OnZhbFwiLGZyb21XaXJlVHlwZTppPT57dmFyIHU9UmUoaSk7cmV0dXJuIFRuKGkpLHV9LHRvV2lyZVR5cGU6KGksdSk9PldlKHUpLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkNuLEFkOm51bGx9O2Z1bmN0aW9uIENwKGkpe3JldHVybiBkdChpPj4+MCxUcCl9dmFyIElwPShpLHUpPT57c3dpdGNoKHUpe2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuZnJvbVdpcmVUeXBlKFkoKVtjPj4+Mj4+PjBdKX07Y2FzZSA4OnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoZmUoKVtjPj4+Mz4+PjBdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGZsb2F0IHdpZHRoICgke3V9KTogJHtpfWApfX07ZnVuY3Rpb24gQXAoaSx1LGMpe2M+Pj49MCxkdChpPj4+PTAse25hbWU6dT1YZSh1Pj4+MCksZnJvbVdpcmVUeXBlOm09Pm0sdG9XaXJlVHlwZToobSxnKT0+Zyx6ZDpndCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpJcCh1LGMpLEFkOm51bGx9KX1mdW5jdGlvbiBrcChpLHUsYyxtLGcpe2lmKGk+Pj49MCxjPj4+PTAsdT1YZSh1Pj4+MCksZz09PS0xJiYoZz00Mjk0OTY3Mjk1KSxnPXo9PnosbT09PTApe3ZhciB4PTMyLTgqYztnPXo9Pno8PHg+Pj54fXZhciBJPXUuaW5jbHVkZXMoXCJ1bnNpZ25lZFwiKT9mdW5jdGlvbih6LEIpe3JldHVybiBCPj4+MH06ZnVuY3Rpb24oeixCKXtyZXR1cm4gQn07ZHQoaSx7bmFtZTp1LGZyb21XaXJlVHlwZTpnLHRvV2lyZVR5cGU6SSx6ZDpndCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpsaSh1LGMsbSE9PTApLEFkOm51bGx9KX1mdW5jdGlvbiBFcChpLHUsYyl7ZnVuY3Rpb24gbSh4KXt2YXIgST1SKClbeD4+PjI+Pj4wXTtyZXR1cm4geD1SKClbeCs0Pj4+Mj4+PjBdLG5ldyBnKFooKS5idWZmZXIseCxJKX12YXIgZz1bSW50OEFycmF5LFVpbnQ4QXJyYXksSW50MTZBcnJheSxVaW50MTZBcnJheSxJbnQzMkFycmF5LFVpbnQzMkFycmF5LEZsb2F0MzJBcnJheSxGbG9hdDY0QXJyYXksQmlnSW50NjRBcnJheSxCaWdVaW50NjRBcnJheV1bdV07ZHQoaT4+Pj0wLHtuYW1lOmM9WGUoYz4+PjApLGZyb21XaXJlVHlwZTptLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOm19LHtQZDohMH0pfWZ1bmN0aW9uIFBwKGksdSl7ZHQoaT4+Pj0wLHtuYW1lOnU9WGUodT4+PjApLGZyb21XaXJlVHlwZTpmdW5jdGlvbihjKXtmb3IodmFyIG0sZz1SKClbYz4+PjI+Pj4wXSx4PWMrNCxJPXgsej0wO3o8PWc7Kyt6KXt2YXIgQj14K3o7eiE9ZyYmcGUoKVtCPj4+MF0hPTB8fChJPUFlKEksQi1JKSxtPT09dm9pZCAwP209SToobSs9XCJcXDBcIixtKz1JKSxJPUIrMSl9cmV0dXJuIGV0KGMpLG19LHRvV2lyZVR5cGU6ZnVuY3Rpb24oYyxtKXttIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihtPW5ldyBVaW50OEFycmF5KG0pKTt2YXIgZz10eXBlb2YgbT09XCJzdHJpbmdcIjtpZighKGd8fG0gaW5zdGFuY2VvZiBVaW50OEFycmF5fHxtIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fG0gaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBodChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIHg9Zz9ZbyhtKTptLmxlbmd0aCxJPXlyKDQreCsxKSx6PUkrNDtpZihSKClbST4+PjI+Pj4wXT14LGcpQnQobSx6LHgrMSk7ZWxzZSBpZihnKWZvcihnPTA7Zzx4OysrZyl7dmFyIEI9bS5jaGFyQ29kZUF0KGcpO2lmKDI1NTxCKXRocm93IGV0KEkpLG5ldyBodChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKTtwZSgpW3orZz4+PjBdPUJ9ZWxzZSBmb3IoZz0wO2c8eDsrK2cpcGUoKVt6K2c+Pj4wXT1tW2ddO3JldHVybiBjIT09bnVsbCYmYy5wdXNoKGV0LEkpLEl9LHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOkNuLEFkKGMpe2V0KGMpfX0pfXZhciBjaT10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIik6dm9pZCAwLHpwPShpLHUpPT57Zm9yKHZhciBjPWk+PjEsbT1jK3UvMjshKGM+PW0pJiZTZSgpW2M+Pj4wXTspKytjO2lmKDMyPChjPDw9MSktaSYmY2kpcmV0dXJuIGNpLmRlY29kZShwZSgpLnNsaWNlKGksYykpO2ZvcihjPVwiXCIsbT0wOyEobT49dS8yKTsrK20pe3ZhciBnPWtlKClbaSsyKm0+Pj4xPj4+MF07aWYoZz09MClicmVhaztjKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfXJldHVybiBjfSxPcD0oaSx1LGMpPT57aWYoYz8/PTIxNDc0ODM2NDcsMj5jKXJldHVybiAwO3ZhciBtPXU7Yz0oYy09Mik8MippLmxlbmd0aD9jLzI6aS5sZW5ndGg7Zm9yKHZhciBnPTA7ZzxjOysrZyl7dmFyIHg9aS5jaGFyQ29kZUF0KGcpO2tlKClbdT4+PjE+Pj4wXT14LHUrPTJ9cmV0dXJuIGtlKClbdT4+PjE+Pj4wXT0wLHUtbX0sRHA9aT0+MippLmxlbmd0aCxCcD0oaSx1KT0+e2Zvcih2YXIgYz0wLG09XCJcIjshKGM+PXUvNCk7KXt2YXIgZz1EKClbaSs0KmM+Pj4yPj4+MF07aWYoZz09MClicmVhazsrK2MsNjU1MzY8PWc/KGctPTY1NTM2LG0rPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Zz4+MTAsNTYzMjB8MTAyMyZnKSk6bSs9U3RyaW5nLmZyb21DaGFyQ29kZShnKX1yZXR1cm4gbX0sTXA9KGksdSxjKT0+e2lmKHU+Pj49MCxjPz89MjE0NzQ4MzY0Nyw0PmMpcmV0dXJuIDA7dmFyIG09dTtjPW0rYy00O2Zvcih2YXIgZz0wO2c8aS5sZW5ndGg7KytnKXt2YXIgeD1pLmNoYXJDb2RlQXQoZyk7aWYoNTUyOTY8PXgmJjU3MzQzPj14JiYoeD02NTUzNisoKDEwMjMmeCk8PDEwKXwxMDIzJmkuY2hhckNvZGVBdCgrK2cpKSxEKClbdT4+PjI+Pj4wXT14LCh1Kz00KSs0PmMpYnJlYWt9cmV0dXJuIEQoKVt1Pj4+Mj4+PjBdPTAsdS1tfSxScD1pPT57Zm9yKHZhciB1PTAsYz0wO2M8aS5sZW5ndGg7KytjKXt2YXIgbT1pLmNoYXJDb2RlQXQoYyk7NTUyOTY8PW0mJjU3MzQzPj1tJiYrK2MsdSs9NH1yZXR1cm4gdX07ZnVuY3Rpb24gVXAoaSx1LGMpe2lmKGk+Pj49MCx1Pj4+PTAsYz1YZShjPj4+PTApLHU9PT0yKXZhciBtPXpwLGc9T3AseD1EcCxJPXo9PlNlKClbej4+PjE+Pj4wXTtlbHNlIHU9PT00JiYobT1CcCxnPU1wLHg9UnAsST16PT5SKClbej4+PjI+Pj4wXSk7ZHQoaSx7bmFtZTpjLGZyb21XaXJlVHlwZTp6PT57Zm9yKHZhciBCLEw9UigpW3o+Pj4yPj4+MF0scT16KzQsWD0wO1g8PUw7KytYKXt2YXIgdWU9eis0K1gqdTtYIT1MJiZJKHVlKSE9MHx8KHE9bShxLHVlLXEpLEI9PT12b2lkIDA/Qj1xOihCKz1cIlxcMFwiLEIrPXEpLHE9dWUrdSl9cmV0dXJuIGV0KHopLEJ9LHRvV2lyZVR5cGU6KHosQik9PntpZih0eXBlb2YgQiE9XCJzdHJpbmdcIil0aHJvdyBuZXcgaHQoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Y31gKTt2YXIgTD14KEIpLHE9eXIoNCtMK3UpO3JldHVybiBSKClbcT4+PjI+Pj4wXT1ML3UsZyhCLHErNCxMK3UpLHohPT1udWxsJiZ6LnB1c2goZXQscSkscX0semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sQWQoeil7ZXQoeil9fSl9ZnVuY3Rpb24gTnAoaSx1KXtkdChpPj4+PTAse1FkOiEwLG5hbWU6dT1YZSh1Pj4+MCksemQ6MCxmcm9tV2lyZVR5cGU6KCk9Pnt9LHRvV2lyZVR5cGU6KCk9Pnt9fSl9ZnVuY3Rpb24gVnAoaSl7RG4oaT4+PjAsIXMsMSwhYSwxMzEwNzIsITEpLExvKCl9dmFyIEluPWk9PntpZighZWUpdHJ5e2lmKGkoKSwhKDA8bXQpKXRyeXtkP0JuKEEpOl9uKEEpfWNhdGNoKHUpe3UgaW5zdGFuY2VvZiBnbnx8dT09XCJ1bndpbmRcInx8XygwLHUpfX1jYXRjaCh1KXt1IGluc3RhbmNlb2YgZ258fHU9PVwidW53aW5kXCJ8fF8oMCx1KX19O2Z1bmN0aW9uIEFuKGkpe2k+Pj49MCx0eXBlb2YgQXRvbWljcy5nZT09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5nZShEKCksaT4+PjIsaSkudmFsdWUudGhlbih1ciksaSs9MTI4LEF0b21pY3Muc3RvcmUoRCgpLGk+Pj4yLDEpKX12YXIgdXI9KCk9Pnt2YXIgaT1ncigpO2kmJihBbihpKSxJbihXaSkpfTtmdW5jdGlvbiBXcChpLHUpeyhpPj4+PTApPT11Pj4+MD9zZXRUaW1lb3V0KHVyKTpkP3Bvc3RNZXNzYWdlKHtFZDppLHlkOlwiY2hlY2tNYWlsYm94XCJ9KTooaT1TdFtpXSkmJmkucG9zdE1lc3NhZ2Uoe3lkOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIga249W107ZnVuY3Rpb24gTHAoaSx1LGMsbSxnKXtmb3IodT4+Pj0wLG0vPTIsa24ubGVuZ3RoPW0sYz1nPj4+MD4+PjMsZz0wO2c8bTtnKyspa25bZ109V1tjKzIqZ10/V1tjKzIqZysxXTpmZSgpW2MrMipnKzE+Pj4wXTtyZXR1cm4odT9oblt1XTpCbVtpXSkoLi4ua24pfXZhciBHcD0oKT0+e210PTB9O2Z1bmN0aW9uIEhwKGkpe2k+Pj49MCxkP3Bvc3RNZXNzYWdlKHt5ZDpcImNsZWFudXBUaHJlYWRcIixlZTppfSk6V28oU3RbaV0pfWZ1bmN0aW9uIEZwKGkpe312YXIgZHI9KGksdSk9Pnt2YXIgYz14bltpXTtpZihjPT09dm9pZCAwKXRocm93IGk9QmkoaSksYz1YZShpKSxldChpKSxuZXcgaHQoYCR7dX0gaGFzIHVua25vd24gdHlwZSAke2N9YCk7cmV0dXJuIGN9LHBpPShpLHUsYyk9Pnt2YXIgbT1bXTtyZXR1cm4gaT1pLnRvV2lyZVR5cGUobSxjKSxtLmxlbmd0aCYmKFIoKVt1Pj4+Mj4+PjBdPVdlKG0pKSxpfTtmdW5jdGlvbiBxcChpLHUsYyl7cmV0dXJuIHU+Pj49MCxjPj4+PTAsaT1SZShpPj4+MCksdT1kcih1LFwiZW12YWw6OmFzXCIpLHBpKHUsYyxpKX1mdW5jdGlvbiBLcChpLHUpe3JldHVybiB1Pj4+PTAsaT1SZShpPj4+MCksKHU9ZHIodSxcImVtdmFsOjphc1wiKSkudG9XaXJlVHlwZShudWxsLGkpfXZhciBscj1pPT57dHJ5e2koKX1jYXRjaCh1KXt1dCh1KX19LHl0PTAsSmU9bnVsbCxtaT0wLGNyPVtdLGZpPXt9LGhpPXt9LGpwPTAsRW49bnVsbCxacD1bXTtmdW5jdGlvbiBnaShpKXtyZXR1cm4gZnVuY3Rpb24odSl7aWYoIWVlKXtpZih5dD09PTApe3ZhciBjPSExLG09ITE7dSgoZz0wKT0+e2lmKCFlZSYmKG1pPWcsYz0hMCxtKSl7eXQ9MixscigoKT0+TmEoSmUpKSx0eXBlb2YgTWFpbkxvb3A8XCJ1XCImJk1haW5Mb29wLk1kJiZNYWluTG9vcC5yZXN1bWUoKSxnPSExO3RyeXt2YXIgeD1mdW5jdGlvbigpe3ZhciBCPUQoKVtKZSs4Pj4+Mj4+PjBdO3JldHVybiBCPVVbaGlbQl1dLC0tbXQsQigpfSgpfWNhdGNoKEIpe3g9QixnPSEwfXZhciBJPSExO2lmKCFKZSl7dmFyIHo9RW47eiYmKEVuPW51bGwsKGc/ei5yZWplY3Q6ei5yZXNvbHZlKSh4KSxJPSEwKX1pZihnJiYhSSl0aHJvdyB4fX0pLG09ITAsY3x8KHl0PTEsSmU9ZnVuY3Rpb24oKXt2YXIgZz15cig2NTU0OCkseD1nKzEyO1IoKVtnPj4+Mj4+PjBdPXgsUigpW2crND4+PjI+Pj4wXT14KzY1NTM2LHg9Y3JbMF07dmFyIEk9ZmlbeF07cmV0dXJuIEk9PT12b2lkIDAmJihJPWpwKyssZmlbeF09SSxoaVtJXT14KSx4PUksRCgpW2crOD4+PjI+Pj4wXT14LGd9KCksdHlwZW9mIE1haW5Mb29wPFwidVwiJiZNYWluTG9vcC5NZCYmTWFpbkxvb3AucGF1c2UoKSxscigoKT0+UmEoSmUpKSl9ZWxzZSB5dD09PTI/KHl0PTAsbHIoVmEpLGV0KEplKSxKZT1udWxsLFpwLmZvckVhY2goSW4pKTp1dChgaW52YWxpZCBzdGF0ZTogJHt5dH1gKTtyZXR1cm4gbWl9fSh1PT57aSgpLnRoZW4odSl9KX1mdW5jdGlvbiBRcChpKXtyZXR1cm4gaT4+Pj0wLGdpKGFzeW5jKCk9Pnt2YXIgdT1hd2FpdCBSZShpKTtyZXR1cm4gV2UodSl9KX12YXIgcHI9W107ZnVuY3Rpb24gWXAoaSx1LGMsbSl7cmV0dXJuIGM+Pj49MCxtPj4+PTAsKGk9cHJbaT4+PjBdKShudWxsLHU9UmUodT4+PjApLGMsbSl9dmFyIFhwPXt9LG1yPWk9Pnt2YXIgdT1YcFtpXTtyZXR1cm4gdT09PXZvaWQgMD9YZShpKTp1fTtmdW5jdGlvbiBKcChpLHUsYyxtLGcpe3JldHVybiBjPj4+PTAsbT4+Pj0wLGc+Pj49MCwoaT1wcltpPj4+MF0pKHU9UmUodT4+PjApLHVbYz1tcihjKV0sbSxnKX12YXIgeWk9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGVtKGkpe3JldHVybihpPj4+PTApPT0wP1dlKHlpKCkpOihpPW1yKGkpLFdlKHlpKClbaV0pKX12YXIgdG09aT0+e3ZhciB1PXByLmxlbmd0aDtyZXR1cm4gcHIucHVzaChpKSx1fSxybT0oaSx1KT0+e2Zvcih2YXIgYz1BcnJheShpKSxtPTA7bTxpOysrbSljW21dPWRyKFIoKVt1KzQqbT4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIittKTtyZXR1cm4gY30sYmk9KGksdSk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LFwibmFtZVwiLHt2YWx1ZTppfSk7ZnVuY3Rpb24gbm0oaSx1LGMpe3ZhciBtPSh1PXJtKGksdT4+PjApKS5zaGlmdCgpO2ktLTt2YXIgZz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLHg9MCxJPVtdO2M9PT0wJiZJLnB1c2goXCJvYmpcIik7Zm9yKHZhciB6PVtcInJldFR5cGVcIl0sQj1bbV0sTD0wO0w8aTsrK0wpSS5wdXNoKFwiYXJnXCIrTCksei5wdXNoKFwiYXJnVHlwZVwiK0wpLEIucHVzaCh1W0xdKSxnKz1gICB2YXIgYXJnJHtMfSA9IGFyZ1R5cGUke0x9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke3g/XCIrXCIreDpcIlwifSk7XG5gLHgrPXVbTF0uemQ7cmV0dXJuIGcrPWAgIHZhciBydiA9ICR7Yz09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7SS5qb2luKFwiLCBcIil9KTtcbmAsbS5RZHx8KHoucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEIucHVzaChwaSksZys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSx6LnB1c2goZytgfTtcbmApLGk9ZnVuY3Rpb24ocSl7dmFyIFg9RnVuY3Rpb247aWYoIShYIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoYG5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAke3R5cGVvZiBYfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciB1ZT1iaShYLm5hbWV8fFwidW5rbm93bkZ1bmN0aW9uTmFtZVwiLGZ1bmN0aW9uKCl7fSk7cmV0dXJuIHVlLnByb3RvdHlwZT1YLnByb3RvdHlwZSx1ZT1uZXcgdWUsKHE9WC5hcHBseSh1ZSxxKSlpbnN0YW5jZW9mIE9iamVjdD9xOnVlfSh6KSguLi5CKSxjPWBtZXRob2RDYWxsZXI8KCR7dS5tYXAocT0+cS5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke20ubmFtZX0+YCx0bShiaShjLGkpKX1mdW5jdGlvbiBvbShpKXtyZXR1cm4gaT1tcihpPj4+MCksV2UocltpXSl9ZnVuY3Rpb24gaW0oaSx1KXtyZXR1cm4gdT4+Pj0wLGk9UmUoaT4+PjApLHU9UmUodSksV2UoaVt1XSl9ZnVuY3Rpb24gYW0oaSl7OTwoaT4+Pj0wKSYmKGx0W2krMV0rPTEpfWZ1bmN0aW9uIHNtKCl7cmV0dXJuIFdlKFtdKX1mdW5jdGlvbiB1bShpKXtpPVJlKGk+Pj4wKTtmb3IodmFyIHU9QXJyYXkoaS5sZW5ndGgpLGM9MDtjPGkubGVuZ3RoO2MrKyl1W2NdPWlbY107cmV0dXJuIFdlKHUpfWZ1bmN0aW9uIGRtKGkpe3JldHVybiBXZShtcihpPj4+MCkpfWZ1bmN0aW9uIGxtKCl7cmV0dXJuIFdlKHt9KX1mdW5jdGlvbiBjbShpKXtmb3IodmFyIHU9UmUoaT4+Pj0wKTt1Lmxlbmd0aDspe3ZhciBjPXUucG9wKCk7dS5wb3AoKShjKX1UbihpKX1mdW5jdGlvbiBwbShpLHUsYyl7dT4+Pj0wLGM+Pj49MCxpPVJlKGk+Pj4wKSx1PVJlKHUpLGM9UmUoYyksaVt1XT1jfWZ1bmN0aW9uIG1tKGksdSl7cmV0dXJuIHU+Pj49MCxpPShpPWRyKGk+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKHUpLFdlKGkpfWZ1bmN0aW9uIGZtKGksdSl7aT0tOTAwNzE5OTI1NDc0MDk5Mj5pfHw5MDA3MTk5MjU0NzQwOTkyPGk/TmFOOk51bWJlcihpKSx1Pj4+PTAsaT1uZXcgRGF0ZSgxZTMqaSksRCgpW3U+Pj4yPj4+MF09aS5nZXRVVENTZWNvbmRzKCksRCgpW3UrND4+PjI+Pj4wXT1pLmdldFVUQ01pbnV0ZXMoKSxEKClbdSs4Pj4+Mj4+PjBdPWkuZ2V0VVRDSG91cnMoKSxEKClbdSsxMj4+PjI+Pj4wXT1pLmdldFVUQ0RhdGUoKSxEKClbdSsxNj4+PjI+Pj4wXT1pLmdldFVUQ01vbnRoKCksRCgpW3UrMjA+Pj4yPj4+MF09aS5nZXRVVENGdWxsWWVhcigpLTE5MDAsRCgpW3UrMjQ+Pj4yPj4+MF09aS5nZXRVVENEYXkoKSxpPShpLmdldFRpbWUoKS1EYXRlLlVUQyhpLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLEQoKVt1KzI4Pj4+Mj4+PjBdPWl9dmFyIF9pPWk9PmklND09MCYmKGklMTAwIT0wfHxpJTQwMD09MCksd2k9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0sdmk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gaG0oaSx1KXtpPS05MDA3MTk5MjU0NzQwOTkyPml8fDkwMDcxOTkyNTQ3NDA5OTI8aT9OYU46TnVtYmVyKGkpLHU+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxEKClbdT4+PjI+Pj4wXT1pLmdldFNlY29uZHMoKSxEKClbdSs0Pj4+Mj4+PjBdPWkuZ2V0TWludXRlcygpLEQoKVt1Kzg+Pj4yPj4+MF09aS5nZXRIb3VycygpLEQoKVt1KzEyPj4+Mj4+PjBdPWkuZ2V0RGF0ZSgpLEQoKVt1KzE2Pj4+Mj4+PjBdPWkuZ2V0TW9udGgoKSxEKClbdSsyMD4+PjI+Pj4wXT1pLmdldEZ1bGxZZWFyKCktMTkwMCxEKClbdSsyND4+PjI+Pj4wXT1pLmdldERheSgpO3ZhciBjPShfaShpLmdldEZ1bGxZZWFyKCkpP3dpOnZpKVtpLmdldE1vbnRoKCldK2kuZ2V0RGF0ZSgpLTF8MDtEKClbdSsyOD4+PjI+Pj4wXT1jLEQoKVt1KzM2Pj4+Mj4+PjBdPS02MCppLmdldFRpbWV6b25lT2Zmc2V0KCksYz1uZXcgRGF0ZShpLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBtPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7aT0wfChjIT1tJiZpLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKG0sYykpLEQoKVt1KzMyPj4+Mj4+PjBdPWl9ZnVuY3Rpb24gZ20oaSl7aT4+Pj0wO3ZhciB1PW5ldyBEYXRlKEQoKVtpKzIwPj4+Mj4+PjBdKzE5MDAsRCgpW2krMTY+Pj4yPj4+MF0sRCgpW2krMTI+Pj4yPj4+MF0sRCgpW2krOD4+PjI+Pj4wXSxEKClbaSs0Pj4+Mj4+PjBdLEQoKVtpPj4+Mj4+PjBdLDApLGM9RCgpW2krMzI+Pj4yPj4+MF0sbT11LmdldFRpbWV6b25lT2Zmc2V0KCksZz1uZXcgRGF0ZSh1LmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLHg9bmV3IERhdGUodS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxJPU1hdGgubWluKHgsZyk7cmV0dXJuIDA+Yz9EKClbaSszMj4+PjI+Pj4wXT0rKGchPXgmJkk9PW0pOjA8YyE9KEk9PW0pJiYoZz1NYXRoLm1heCh4LGcpLHUuc2V0VGltZSh1LmdldFRpbWUoKSs2ZTQqKCgwPGM/STpnKS1tKSkpLEQoKVtpKzI0Pj4+Mj4+PjBdPXUuZ2V0RGF5KCksYz0oX2kodS5nZXRGdWxsWWVhcigpKT93aTp2aSlbdS5nZXRNb250aCgpXSt1LmdldERhdGUoKS0xfDAsRCgpW2krMjg+Pj4yPj4+MF09YyxEKClbaT4+PjI+Pj4wXT11LmdldFNlY29uZHMoKSxEKClbaSs0Pj4+Mj4+PjBdPXUuZ2V0TWludXRlcygpLEQoKVtpKzg+Pj4yPj4+MF09dS5nZXRIb3VycygpLEQoKVtpKzEyPj4+Mj4+PjBdPXUuZ2V0RGF0ZSgpLEQoKVtpKzE2Pj4+Mj4+PjBdPXUuZ2V0TW9udGgoKSxEKClbaSsyMD4+PjI+Pj4wXT11LmdldFllYXIoKSxpPXUuZ2V0VGltZSgpLEJpZ0ludChpc05hTihpKT8tMTppLzFlMyl9ZnVuY3Rpb24gJGkoaSx1LGMsbSxnLHgsSSl7cmV0dXJuIGQ/VGUoMTYsMSxpLHUsYyxtLGcseCxJKTotNTJ9ZnVuY3Rpb24geGkoaSx1LGMsbSxnLHgpe2lmKGQpcmV0dXJuIFRlKDE3LDEsaSx1LGMsbSxnLHgpfXZhciBxdD17fSx5bT0oKT0+cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKTtmdW5jdGlvbiBTaShpLHUpe2lmKGQpcmV0dXJuIFRlKDE4LDEsaSx1KTtpZihxdFtpXSYmKGNsZWFyVGltZW91dChxdFtpXS5pZCksZGVsZXRlIHF0W2ldKSwhdSlyZXR1cm4gMDt2YXIgYz1zZXRUaW1lb3V0KCgpPT57ZGVsZXRlIHF0W2ldLEluKCgpPT5WaShpLHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCkpKX0sdSk7cmV0dXJuIHF0W2ldPXtpZDpjLGtlOnV9LDB9ZnVuY3Rpb24gYm0oaSx1LGMsbSl7aT4+Pj0wLHU+Pj49MCxjPj4+PTAsbT4+Pj0wO3ZhciBnPW5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSx4PW5ldyBEYXRlKGcsMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpO2c9bmV3IERhdGUoZyw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEk9TWF0aC5tYXgoeCxnKTtSKClbaT4+PjI+Pj4wXT02MCpJLEQoKVt1Pj4+Mj4+PjBdPSsoeCE9ZyksaT0odT16PT57dmFyIEI9TWF0aC5hYnMoeik7cmV0dXJuYFVUQyR7MDw9ej9cIi1cIjpcIitcIn0ke1N0cmluZyhNYXRoLmZsb29yKEIvNjApKS5wYWRTdGFydCgyLFwiMFwiKX0ke1N0cmluZyhCJTYwKS5wYWRTdGFydCgyLFwiMFwiKX1gfSkoeCksdT11KGcpLGc8eD8oQnQoaSxjLDE3KSxCdCh1LG0sMTcpKTooQnQoaSxtLDE3KSxCdCh1LGMsMTcpKX12YXIgX209KCk9PkRhdGUubm93KCksd209MTtmdW5jdGlvbiB2bShpLHUsYyl7aWYoISgwPD1pJiYzPj1pKSlyZXR1cm4gMjg7aWYoaT09PTApaT1EYXRlLm5vdygpO2Vsc2V7aWYoIXdtKXJldHVybiA1MjtpPXBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCl9cmV0dXJuIFdbYz4+PjA+Pj4zXT1CaWdJbnQoTWF0aC5yb3VuZCgxZTYqaSkpLDB9dmFyIFBuPVtdLFRpPShpLHUpPT57UG4ubGVuZ3RoPTA7Zm9yKHZhciBjO2M9cGUoKVtpKys+Pj4wXTspe3ZhciBtPWMhPTEwNTt1Kz0obSY9YyE9MTEyKSYmdSU4PzQ6MCxQbi5wdXNoKGM9PTExMj9SKClbdT4+PjI+Pj4wXTpjPT0xMDY/V1t1Pj4+M106Yz09MTA1P0QoKVt1Pj4+Mj4+PjBdOmZlKClbdT4+PjM+Pj4wXSksdSs9bT84OjR9cmV0dXJuIFBufTtmdW5jdGlvbiAkbShpLHUsYyl7cmV0dXJuIGk+Pj49MCx1PVRpKHU+Pj4wLGM+Pj4wKSxobltpXSguLi51KX1mdW5jdGlvbiB4bShpLHUsYyl7cmV0dXJuIGk+Pj49MCx1PVRpKHU+Pj4wLGM+Pj4wKSxobltpXSguLi51KX12YXIgU209KCk9Pnt9O2Z1bmN0aW9uIFRtKGksdSl7cmV0dXJuIHYoQWUoaT4+PjAsdT4+PjApKX12YXIgQ209KCk9Pnt0aHJvdyBtdCs9MSxcInVud2luZFwifTtmdW5jdGlvbiBJbSgpe3JldHVybiA0Mjk0OTAxNzYwfXZhciBBbT0oKT0+bmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3k7ZnVuY3Rpb24ga20oKXtyZXR1cm4gdXQoXCJDYW5ub3QgdXNlIGVtc2NyaXB0ZW5fcGNfZ2V0X2Z1bmN0aW9uIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwfWZ1bmN0aW9uIEVtKGkpe2k+Pj49MDt2YXIgdT1wZSgpLmxlbmd0aDtpZihpPD11fHw0Mjk0OTAxNzYwPGkpcmV0dXJuITE7Zm9yKHZhciBjPTE7ND49YztjKj0yKXt2YXIgbT11KigxKy4yL2MpO209TWF0aC5taW4obSxpKzEwMDY2MzI5Nik7ZTp7bT0oTWF0aC5taW4oNDI5NDkwMTc2MCw2NTUzNipNYXRoLmNlaWwoTWF0aC5tYXgoaSxtKS82NTUzNikpLVQuYnVmZmVyLmJ5dGVMZW5ndGgrNjU1MzUpLzY1NTM2fDA7dHJ5e1QuZ3JvdyhtKSxiZSgpO3ZhciBnPTE7YnJlYWsgZX1jYXRjaHt9Zz12b2lkIDB9aWYoZylyZXR1cm4hMH1yZXR1cm4hMX12YXIgZnI9KCk9Pih1dChcIkNhbm5vdCB1c2UgY29udmVydEZyYW1lVG9QQyAobmVlZGVkIGJ5IF9fYnVpbHRpbl9yZXR1cm5fYWRkcmVzcykgd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDApLE10PXt9LENpPWk9PntpLmZvckVhY2godT0+e3ZhciBjPWZyKCk7YyYmKE10W2NdPXUpfSl9O2Z1bmN0aW9uIFBtKCl7dmFyIGk9RXJyb3IoKS5zdGFjay50b1N0cmluZygpLnNwbGl0KGBcbmApO3JldHVybiBpWzBdPT1cIkVycm9yXCImJmkuc2hpZnQoKSxDaShpKSxNdC5LZD1mcigpLE10LmFlPWksTXQuS2R9ZnVuY3Rpb24gem0oaSx1LGMpe2lmKGk+Pj49MCx1Pj4+PTAsTXQuS2Q9PWkpdmFyIG09TXQuYWU7ZWxzZShtPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKSlbMF09PVwiRXJyb3JcIiYmbS5zaGlmdCgpLENpKG0pO2Zvcih2YXIgZz0zO21bZ10mJmZyKCkhPWk7KSsrZztmb3IoaT0wO2k8YyYmbVtpK2ddOysraSlEKClbdSs0Kmk+Pj4yPj4+MF09ZnIoKTtyZXR1cm4gaX12YXIgem4sT249e30sSWk9KCk9PntpZighem4pe3ZhciBpLHU9e1VTRVI6XCJ3ZWJfdXNlclwiLExPR05BTUU6XCJ3ZWJfdXNlclwiLFBBVEg6XCIvXCIsUFdEOlwiL1wiLEhPTUU6XCIvaG9tZS93ZWJfdXNlclwiLExBTkc6KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiLF86XCIuL3RoaXMucHJvZ3JhbVwifTtmb3IoaSBpbiBPbilPbltpXT09PXZvaWQgMD9kZWxldGUgdVtpXTp1W2ldPU9uW2ldO3ZhciBjPVtdO2ZvcihpIGluIHUpYy5wdXNoKGAke2l9PSR7dVtpXX1gKTt6bj1jfXJldHVybiB6bn07ZnVuY3Rpb24gQWkoaSx1KXtpZihkKXJldHVybiBUZSgxOSwxLGksdSk7aT4+Pj0wLHU+Pj49MDt2YXIgYz0wO3JldHVybiBJaSgpLmZvckVhY2goKG0sZyk9Pnt2YXIgeD11K2M7Zm9yKGc9UigpW2krNCpnPj4+Mj4+PjBdPXgseD0wO3g8bS5sZW5ndGg7Kyt4KVooKVtnKys+Pj4wXT1tLmNoYXJDb2RlQXQoeCk7WigpW2c+Pj4wXT0wLGMrPW0ubGVuZ3RoKzF9KSwwfWZ1bmN0aW9uIGtpKGksdSl7aWYoZClyZXR1cm4gVGUoMjAsMSxpLHUpO2k+Pj49MCx1Pj4+PTA7dmFyIGM9SWkoKTtSKClbaT4+PjI+Pj4wXT1jLmxlbmd0aDt2YXIgbT0wO3JldHVybiBjLmZvckVhY2goZz0+bSs9Zy5sZW5ndGgrMSksUigpW3U+Pj4yPj4+MF09bSwwfWZ1bmN0aW9uIEVpKGkpe3JldHVybiBkP1RlKDIxLDEsaSk6NTJ9ZnVuY3Rpb24gUGkoaSx1LGMsbSl7cmV0dXJuIGQ/VGUoMjIsMSxpLHUsYyxtKTo1Mn1mdW5jdGlvbiB6aShpLHUsYyxtKXtyZXR1cm4gZD9UZSgyMywxLGksdSxjLG0pOjcwfXZhciBPbT1bbnVsbCxbXSxbXV07ZnVuY3Rpb24gT2koaSx1LGMsbSl7aWYoZClyZXR1cm4gVGUoMjQsMSxpLHUsYyxtKTt1Pj4+PTAsYz4+Pj0wLG0+Pj49MDtmb3IodmFyIGc9MCx4PTA7eDxjO3grKyl7dmFyIEk9UigpW3U+Pj4yPj4+MF0sej1SKClbdSs0Pj4+Mj4+PjBdO3UrPTg7Zm9yKHZhciBCPTA7Qjx6O0IrKyl7dmFyIEw9cGUoKVtJK0I+Pj4wXSxxPU9tW2ldO0w9PT0wfHxMPT09MTA/KChpPT09MT8kOnYpKGpvKHEpKSxxLmxlbmd0aD0wKTpxLnB1c2goTCl9Zys9en1yZXR1cm4gUigpW20+Pj4yPj4+MF09ZywwfWZ1bmN0aW9uIERtKGkpe3JldHVybiBpPj4+MH1kfHxmdW5jdGlvbigpe2Zvcih2YXIgaT1yLm51bVRocmVhZHMtMTtpLS07KUhvKCk7eW4udW5zaGlmdCgoKT0+e3h0KyssZnVuY3Rpb24odSl7ZD91KCk6UHJvbWlzZS5hbGwoZnQubWFwKEdvKSkudGhlbih1KX0oKCk9PkJvKCkpfSl9KCk7Zm9yKHZhciBEaT1BcnJheSgyNTYpLGhyPTA7MjU2PmhyOysraHIpRGlbaHJdPVN0cmluZy5mcm9tQ2hhckNvZGUoaHIpO2RpPURpLGh0PXIuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IoaSl7c3VwZXIoaSksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSxyLkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihpKXtzdXBlcihpKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSxsdC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSxyLmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9Pmx0Lmxlbmd0aC8yLTUtU24ubGVuZ3RoO3ZhciBVLEJtPVtibixObyxGbyxabyxRbyxYbyxKbyxlaSx0aSxyaSxuaSxvaSxpaSxhaSxzaSx1aSwkaSx4aSxTaSxBaSxraSxFaSxQaSx6aSxPaV07KGFzeW5jIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaShtLGcpe3JldHVybiBVPW0uZXhwb3J0cyxVPWZ1bmN0aW9uKCl7dmFyIHg9VSxJPXt9O2ZvcihsZXRbeixCXW9mIE9iamVjdC5lbnRyaWVzKHgpKUlbel09dHlwZW9mIEI9PVwiZnVuY3Rpb25cIj8oLi4uTCk9Pntjci5wdXNoKHopO3RyeXtyZXR1cm4gQiguLi5MKX1maW5hbGx5e2VlfHwoY3IucG9wKCksSmUmJnl0PT09MSYmY3IubGVuZ3RoPT09MCYmKHl0PTAsbXQrPTEsbHIoVWEpLHR5cGVvZiBGaWJlcnM8XCJ1XCImJkZpYmVycy5sZSgpKSl9fTpCO3JldHVybiBJfSgpLFU9ZnVuY3Rpb24oKXt2YXIgeD1VLEk9Qj0+TD0+QihMKT4+PjAsej1CPT4oKT0+QigpPj4+MDtyZXR1cm4oeD1PYmplY3QuYXNzaWduKHt9LHgpKS5DYj1JKHguQ2IpLHguZmM9eih4LmZjKSx4LmljPUkoeC5pYykseC52Yz1JKHgudmMpLHgud2M9eih4LndjKSx4LkFjPUkoeC5BYykseH0oKSxWby5wdXNoKFUuamMpLEM9ZyxCbygpLFV9eHQrKzt2YXIgdT1NbygpO2lmKHIuaW5zdGFudGlhdGVXYXNtKXJldHVybiBuZXcgUHJvbWlzZShtPT57ci5pbnN0YW50aWF0ZVdhc20odSwoZyx4KT0+e2koZyx4KSxtKGcuZXhwb3J0cyl9KX0pO2lmKGQpcmV0dXJuIG5ldyBQcm9taXNlKG09PntGZT1nPT57dmFyIHg9bmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKGcsTW8oKSk7bShpKHgsZykpfX0pO0d0Pz89ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZT9yLmxvY2F0ZUZpbGUoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLGIpOmIrXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiOm5ldyBVUkwoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLGltcG9ydC5tZXRhLnVybCkuaHJlZjt0cnl7dmFyIGM9YXdhaXQgYXN5bmMgZnVuY3Rpb24obSl7dmFyIGc9R3Q7aWYoIVEmJnR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZz09XCJmdW5jdGlvblwiJiYhbGUoZykpdHJ5e3ZhciB4PWZldGNoKGcse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pO3JldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyh4LG0pfWNhdGNoKEkpe3YoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke0l9YCksdihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpfXJldHVybiBhc3luYyBmdW5jdGlvbihJLHope3RyeXt2YXIgQj1hd2FpdCBhc3luYyBmdW5jdGlvbihMKXtpZighUSl0cnl7dmFyIHE9YXdhaXQgZihMKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkocSl9Y2F0Y2h7fWlmKEw9PUd0JiZRKUw9bmV3IFVpbnQ4QXJyYXkoUSk7ZWxzZXtpZighaCl0aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIjtMPWgoTCl9cmV0dXJuIEx9KEkpO3JldHVybiBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShCLHopfWNhdGNoKEwpe3YoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7TH1gKSx1dChMKX19KGcsbSl9KHUpO3JldHVybiBpKGMuaW5zdGFuY2UsYy5tb2R1bGUpfWNhdGNoKG0pe3JldHVybiBuKG0pLFByb21pc2UucmVqZWN0KG0pfX0pKCk7dmFyIEJpPWk9PihCaT1VLkNiKShpKSxNaT0oKT0+KE1pPVUuRGIpKCk7ci5fT3J0SW5pdD0oaSx1KT0+KHIuX09ydEluaXQ9VS5FYikoaSx1KSxyLl9PcnRHZXRMYXN0RXJyb3I9KGksdSk9PihyLl9PcnRHZXRMYXN0RXJyb3I9VS5GYikoaSx1KSxyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0oaSx1LGMsbSxnLHgsSSx6LEIsTCk9PihyLl9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1VLkdiKShpLHUsYyxtLGcseCxJLHosQixMKSxyLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0oaSx1KT0+KHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVUuSGIpKGksdSksci5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShpLHUsYyk9PihyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9VS5JYikoaSx1LGMpLHIuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0oaSx1LGMpPT4oci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVUuSmIpKGksdSxjKSxyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9aT0+KHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1VLktiKShpKSxyLl9PcnRDcmVhdGVTZXNzaW9uPShpLHUsYyk9PihyLl9PcnRDcmVhdGVTZXNzaW9uPVUuTGIpKGksdSxjKSxyLl9PcnRSZWxlYXNlU2Vzc2lvbj1pPT4oci5fT3J0UmVsZWFzZVNlc3Npb249VS5NYikoaSksci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0oaSx1LGMpPT4oci5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1VLk5iKShpLHUsYyksci5fT3J0R2V0SW5wdXROYW1lPShpLHUpPT4oci5fT3J0R2V0SW5wdXROYW1lPVUuT2IpKGksdSksci5fT3J0R2V0T3V0cHV0TmFtZT0oaSx1KT0+KHIuX09ydEdldE91dHB1dE5hbWU9VS5QYikoaSx1KSxyLl9PcnRGcmVlPWk9PihyLl9PcnRGcmVlPVUuUWIpKGkpLHIuX09ydENyZWF0ZVRlbnNvcj0oaSx1LGMsbSxnLHgpPT4oci5fT3J0Q3JlYXRlVGVuc29yPVUuUmIpKGksdSxjLG0sZyx4KSxyLl9PcnRHZXRUZW5zb3JEYXRhPShpLHUsYyxtLGcpPT4oci5fT3J0R2V0VGVuc29yRGF0YT1VLlNiKShpLHUsYyxtLGcpLHIuX09ydFJlbGVhc2VUZW5zb3I9aT0+KHIuX09ydFJlbGVhc2VUZW5zb3I9VS5UYikoaSksci5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0oaSx1LGMsbSk9PihyLl9PcnRDcmVhdGVSdW5PcHRpb25zPVUuVWIpKGksdSxjLG0pLHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShpLHUsYyk9PihyLl9PcnRBZGRSdW5Db25maWdFbnRyeT1VLlZiKShpLHUsYyksci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9aT0+KHIuX09ydFJlbGVhc2VSdW5PcHRpb25zPVUuV2IpKGkpLHIuX09ydENyZWF0ZUJpbmRpbmc9aT0+KHIuX09ydENyZWF0ZUJpbmRpbmc9VS5YYikoaSksci5fT3J0QmluZElucHV0PShpLHUsYyk9PihyLl9PcnRCaW5kSW5wdXQ9VS5ZYikoaSx1LGMpLHIuX09ydEJpbmRPdXRwdXQ9KGksdSxjLG0pPT4oci5fT3J0QmluZE91dHB1dD1VLlpiKShpLHUsYyxtKSxyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1pPT4oci5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9VS5fYikoaSksci5fT3J0UmVsZWFzZUJpbmRpbmc9aT0+KHIuX09ydFJlbGVhc2VCaW5kaW5nPVUuJGIpKGkpLHIuX09ydFJ1bldpdGhCaW5kaW5nPShpLHUsYyxtLGcpPT4oci5fT3J0UnVuV2l0aEJpbmRpbmc9VS5hYykoaSx1LGMsbSxnKSxyLl9PcnRSdW49KGksdSxjLG0sZyx4LEkseik9PihyLl9PcnRSdW49VS5iYykoaSx1LGMsbSxnLHgsSSx6KSxyLl9PcnRFbmRQcm9maWxpbmc9aT0+KHIuX09ydEVuZFByb2ZpbGluZz1VLmNjKShpKSxyLl9Kc2VwT3V0cHV0PShpLHUsYyk9PihyLl9Kc2VwT3V0cHV0PVUuZGMpKGksdSxjKSxyLl9Kc2VwR2V0Tm9kZU5hbWU9aT0+KHIuX0pzZXBHZXROb2RlTmFtZT1VLmVjKShpKTt2YXIgZ3I9KCk9Pihncj1VLmZjKSgpLGV0PXIuX2ZyZWU9aT0+KGV0PXIuX2ZyZWU9VS5nYykoaSkseXI9ci5fbWFsbG9jPWk9Pih5cj1yLl9tYWxsb2M9VS5pYykoaSksRG49KGksdSxjLG0sZyx4KT0+KERuPVUua2MpKGksdSxjLG0sZyx4KSxSaT0oKT0+KFJpPVUubGMpKCksVWk9KGksdSxjLG0sZyk9PihVaT1VLm1jKShpLHUsYyxtLGcpLE5pPWk9PihOaT1VLm5jKShpKSxCbj1pPT4oQm49VS5vYykoaSksVmk9KGksdSk9PihWaT1VLnBjKShpLHUpLFdpPSgpPT4oV2k9VS5xYykoKSxzZT0oaSx1KT0+KHNlPVUucmMpKGksdSksS3Q9aT0+KEt0PVUuc2MpKGkpLExpPShpLHUpPT4oTGk9VS50YykoaSx1KSxvZT1pPT4ob2U9VS51YykoaSksTW49aT0+KE1uPVUudmMpKGkpLGllPSgpPT4oaWU9VS53YykoKSxHaT1pPT4oR2k9VS54YykoaSksSGk9aT0+KEhpPVUueWMpKGkpLEZpPShpLHUsYyk9PihGaT1VLnpjKShpLHUsYykscWk9aT0+KHFpPVUuQWMpKGkpLEtpPXIuZHluQ2FsbF9paWk9KGksdSxjKT0+KEtpPXIuZHluQ2FsbF9paWk9VS5CYykoaSx1LGMpLGppPXIuZHluQ2FsbF92aT0oaSx1KT0+KGppPXIuZHluQ2FsbF92aT1VLkNjKShpLHUpLFJuPXIuZHluQ2FsbF9paT0oaSx1KT0+KFJuPXIuZHluQ2FsbF9paT1VLkRjKShpLHUpLFppPXIuZHluQ2FsbF92aWk9KGksdSxjKT0+KFppPXIuZHluQ2FsbF92aWk9VS5FYykoaSx1LGMpLFFpPXIuZHluQ2FsbF9paWlpPShpLHUsYyxtKT0+KFFpPXIuZHluQ2FsbF9paWlpPVUuRmMpKGksdSxjLG0pLFlpPXIuZHluQ2FsbF92aWlpPShpLHUsYyxtKT0+KFlpPXIuZHluQ2FsbF92aWlpPVUuR2MpKGksdSxjLG0pLFhpPXIuZHluQ2FsbF9paWlpaT0oaSx1LGMsbSxnKT0+KFhpPXIuZHluQ2FsbF9paWlpaT1VLkhjKShpLHUsYyxtLGcpLEppPXIuZHluQ2FsbF92aWlpaT0oaSx1LGMsbSxnKT0+KEppPXIuZHluQ2FsbF92aWlpaT1VLkljKShpLHUsYyxtLGcpLGVhPXIuZHluQ2FsbF92aWlpaWlpPShpLHUsYyxtLGcseCxJKT0+KGVhPXIuZHluQ2FsbF92aWlpaWlpPVUuSmMpKGksdSxjLG0sZyx4LEkpLHRhPXIuZHluQ2FsbF92aWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6KT0+KHRhPXIuZHluQ2FsbF92aWlpaWlpaT1VLktjKShpLHUsYyxtLGcseCxJLHopLHJhPXIuZHluQ2FsbF9qaT0oaSx1KT0+KHJhPXIuZHluQ2FsbF9qaT1VLkxjKShpLHUpLG5hPXIuZHluQ2FsbF92PWk9PihuYT1yLmR5bkNhbGxfdj1VLk1jKShpKSxvYT1yLmR5bkNhbGxfdmlpaWlpPShpLHUsYyxtLGcseCk9PihvYT1yLmR5bkNhbGxfdmlpaWlpPVUuTmMpKGksdSxjLG0sZyx4KSxpYT1yLmR5bkNhbGxfaT1pPT4oaWE9ci5keW5DYWxsX2k9VS5PYykoaSksYWE9ci5keW5DYWxsX2ZpaT0oaSx1LGMpPT4oYWE9ci5keW5DYWxsX2ZpaT1VLlBjKShpLHUsYyksc2E9ci5keW5DYWxsX3ZpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIpPT4oc2E9ci5keW5DYWxsX3ZpaWlpaWlpaT1VLlFjKShpLHUsYyxtLGcseCxJLHosQiksdWE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEpPT4odWE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpPVUuUmMpKGksdSxjLG0sZyx4LEkseixCLEwscSksZGE9ci5keW5DYWxsX2ppaWk9KGksdSxjLG0pPT4oZGE9ci5keW5DYWxsX2ppaWk9VS5TYykoaSx1LGMsbSksbGE9ci5keW5DYWxsX2RpaT0oaSx1LGMpPT4obGE9ci5keW5DYWxsX2RpaT1VLlRjKShpLHUsYyksY2E9ci5keW5DYWxsX3ZpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwpPT4oY2E9ci5keW5DYWxsX3ZpaWlpaWlpaWk9VS5VYykoaSx1LGMsbSxnLHgsSSx6LEIsTCkscGE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgpPT4ocGE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpaT1VLlZjKShpLHUsYyxtLGcseCxJLHosQixMLHEsWCksbWE9ci5keW5DYWxsX2lpaWlpaT0oaSx1LGMsbSxnLHgpPT4obWE9ci5keW5DYWxsX2lpaWlpaT1VLldjKShpLHUsYyxtLGcseCksZmE9ci5keW5DYWxsX2lpaj0oaSx1LGMpPT4oZmE9ci5keW5DYWxsX2lpaj1VLlhjKShpLHUsYyksaGE9ci5keW5DYWxsX2lpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwpPT4oaGE9ci5keW5DYWxsX2lpaWlpaWlpaWk9VS5ZYykoaSx1LGMsbSxnLHgsSSx6LEIsTCksZ2E9ci5keW5DYWxsX2lpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEpPT4oZ2E9ci5keW5DYWxsX2lpaWlpaWlpaWlpPVUuWmMpKGksdSxjLG0sZyx4LEkseixCLEwscSkseWE9ci5keW5DYWxsX3Zpaj0oaSx1LGMpPT4oeWE9ci5keW5DYWxsX3Zpaj1VLl9jKShpLHUsYyksYmE9ci5keW5DYWxsX2lpaWY9KGksdSxjLG0pPT4oYmE9ci5keW5DYWxsX2lpaWY9VS4kYykoaSx1LGMsbSksX2E9ci5keW5DYWxsX2lpaWo9KGksdSxjLG0pPT4oX2E9ci5keW5DYWxsX2lpaWo9VS5hZCkoaSx1LGMsbSksd2E9ci5keW5DYWxsX2ZpaWk9KGksdSxjLG0pPT4od2E9ci5keW5DYWxsX2ZpaWk9VS5iZCkoaSx1LGMsbSksdmE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9Pih2YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpaWk9VS5jZCkoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpLCRhPXIuZHluQ2FsbF92amlpaT0oaSx1LGMsbSxnKT0+KCRhPXIuZHluQ2FsbF92amlpaT1VLmRkKShpLHUsYyxtLGcpLHhhPXIuZHluQ2FsbF92aWY9KGksdSxjKT0+KHhhPXIuZHluQ2FsbF92aWY9VS5lZCkoaSx1LGMpLFNhPXIuZHluQ2FsbF9paWlpaWlpPShpLHUsYyxtLGcseCxJKT0+KFNhPXIuZHluQ2FsbF9paWlpaWlpPVUuZmQpKGksdSxjLG0sZyx4LEkpLFRhPXIuZHluQ2FsbF9paWlpaj0oaSx1LGMsbSxnKT0+KFRhPXIuZHluQ2FsbF9paWlpaj1VLmdkKShpLHUsYyxtLGcpLENhPXIuZHluQ2FsbF9paWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6KT0+KENhPXIuZHluQ2FsbF9paWlpaWlpaT1VLmhkKShpLHUsYyxtLGcseCxJLHopLElhPXIuZHluQ2FsbF92aWlpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSk9PihJYT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpaT1VLmlkKShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSksQWE9ci5keW5DYWxsX2RpaWk9KGksdSxjLG0pPT4oQWE9ci5keW5DYWxsX2RpaWk9VS5qZCkoaSx1LGMsbSksa2E9ci5keW5DYWxsX2ppaWlpPShpLHUsYyxtLGcpPT4oa2E9ci5keW5DYWxsX2ppaWlpPVUua2QpKGksdSxjLG0sZyksRWE9ci5keW5DYWxsX3ZpaWlqPShpLHUsYyxtLGcpPT4oRWE9ci5keW5DYWxsX3ZpaWlqPVUubGQpKGksdSxjLG0sZyksUGE9ci5keW5DYWxsX2ZpaWlpPShpLHUsYyxtLGcpPT4oUGE9ci5keW5DYWxsX2ZpaWlpPVUubWQpKGksdSxjLG0sZyksemE9ci5keW5DYWxsX3ZpaWlmPShpLHUsYyxtLGcpPT4oemE9ci5keW5DYWxsX3ZpaWlmPVUubmQpKGksdSxjLG0sZyksT2E9ci5keW5DYWxsX2RpaWlpPShpLHUsYyxtLGcpPT4oT2E9ci5keW5DYWxsX2RpaWlpPVUub2QpKGksdSxjLG0sZyksRGE9ci5keW5DYWxsX3ZpaWlkPShpLHUsYyxtLGcpPT4oRGE9ci5keW5DYWxsX3ZpaWlkPVUucGQpKGksdSxjLG0sZyksQmE9ci5keW5DYWxsX2lpaWlqaWk9KGksdSxjLG0sZyx4LEkpPT4oQmE9ci5keW5DYWxsX2lpaWlqaWk9VS5xZCkoaSx1LGMsbSxnLHgsSSksTWE9ci5keW5DYWxsX2lpaWlpaWo9KGksdSxjLG0sZyx4LEkpPT4oTWE9ci5keW5DYWxsX2lpaWlpaWo9VS5yZCkoaSx1LGMsbSxnLHgsSSksUmE9aT0+KFJhPVUuc2QpKGkpLFVhPSgpPT4oVWE9VS50ZCkoKSxOYT1pPT4oTmE9VS51ZCkoaSksVmE9KCk9PihWYT1VLnZkKSgpO2Z1bmN0aW9uIE1tKGksdSxjKXt2YXIgbT1pZSgpO3RyeXtaaShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIFJtKGksdSxjKXt2YXIgbT1pZSgpO3RyeXtyZXR1cm4gS2koaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBVbShpLHUpe3ZhciBjPWllKCk7dHJ5e2ppKGksdSl9Y2F0Y2gobSl7aWYob2UoYyksbSE9PW0rMCl0aHJvdyBtO3NlKDEsMCl9fWZ1bmN0aW9uIE5tKGksdSl7dmFyIGM9aWUoKTt0cnl7cmV0dXJuIFJuKGksdSl9Y2F0Y2gobSl7aWYob2UoYyksbSE9PW0rMCl0aHJvdyBtO3NlKDEsMCl9fWZ1bmN0aW9uIFZtKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiBRaShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gV20oaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtKaShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBMbShpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBYaShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBHbShpLHUsYyxtKXt2YXIgZz1pZSgpO3RyeXtZaShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gSG0oaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7cmV0dXJuIFNhKGksdSxjLG0sZyx4LEkpfWNhdGNoKEIpe2lmKG9lKHopLEIhPT1CKzApdGhyb3cgQjtzZSgxLDApfX1mdW5jdGlvbiBGbShpKXt2YXIgdT1pZSgpO3RyeXtuYShpKX1jYXRjaChjKXtpZihvZSh1KSxjIT09YyswKXRocm93IGM7c2UoMSwwKX19ZnVuY3Rpb24gcW0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3JldHVybiBmYShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIEttKGksdSxjLG0sZyx4KXt2YXIgST1pZSgpO3RyeXtvYShpLHUsYyxtLGcseCl9Y2F0Y2goeil7aWYob2UoSSkseiE9PXorMCl0aHJvdyB6O3NlKDEsMCl9fWZ1bmN0aW9uIGptKGksdSxjKXt2YXIgbT1pZSgpO3RyeXt5YShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIFptKGksdSxjLG0sZyx4LEkpe3ZhciB6PWllKCk7dHJ5e2VhKGksdSxjLG0sZyx4LEkpfWNhdGNoKEIpe2lmKG9lKHopLEIhPT1CKzApdGhyb3cgQjtzZSgxLDApfX1mdW5jdGlvbiBRbShpLHUsYyxtLGcseCxJLHope3ZhciBCPWllKCk7dHJ5e3RhKGksdSxjLG0sZyx4LEkseil9Y2F0Y2goTCl7aWYob2UoQiksTCE9PUwrMCl0aHJvdyBMO3NlKDEsMCl9fWZ1bmN0aW9uIFltKGksdSxjLG0sZyx4KXt2YXIgST1pZSgpO3RyeXtyZXR1cm4gbWEoaSx1LGMsbSxnLHgpfWNhdGNoKHope2lmKG9lKEkpLHohPT16KzApdGhyb3cgejtzZSgxLDApfX1mdW5jdGlvbiBYbShpLHUsYyxtLGcseCxJLHope3ZhciBCPWllKCk7dHJ5e3JldHVybiBDYShpLHUsYyxtLGcseCxJLHopfWNhdGNoKEwpe2lmKG9lKEIpLEwhPT1MKzApdGhyb3cgTDtzZSgxLDApfX1mdW5jdGlvbiBKbShpLHUsYyxtLGcseCxJLHosQixMKXt2YXIgcT1pZSgpO3RyeXtjYShpLHUsYyxtLGcseCxJLHosQixMKX1jYXRjaChYKXtpZihvZShxKSxYIT09WCswKXRocm93IFg7c2UoMSwwKX19ZnVuY3Rpb24gZWYoaSx1LGMsbSxnLHgsSSx6LEIpe3ZhciBMPWllKCk7dHJ5e3NhKGksdSxjLG0sZyx4LEkseixCKX1jYXRjaChxKXtpZihvZShMKSxxIT09cSswKXRocm93IHE7c2UoMSwwKX19ZnVuY3Rpb24gdGYoaSl7dmFyIHU9aWUoKTt0cnl7cmV0dXJuIGlhKGkpfWNhdGNoKGMpe2lmKG9lKHUpLGMhPT1jKzApdGhyb3cgYztzZSgxLDApfX1mdW5jdGlvbiByZihpLHUsYyxtLGcseCxJLHosQixMKXt2YXIgcT1pZSgpO3RyeXtyZXR1cm4gaGEoaSx1LGMsbSxnLHgsSSx6LEIsTCl9Y2F0Y2goWCl7aWYob2UocSksWCE9PVgrMCl0aHJvdyBYO3NlKDEsMCl9fWZ1bmN0aW9uIG5mKGksdSxjKXt2YXIgbT1pZSgpO3RyeXtyZXR1cm4gYWEoaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBvZihpLHUsYyxtKXt2YXIgZz1pZSgpO3RyeXtyZXR1cm4gZGEoaSx1LGMsbSl9Y2F0Y2goeCl7aWYob2UoZykseCE9PXgrMCl0aHJvdyB4O3JldHVybiBzZSgxLDApLDBufX1mdW5jdGlvbiBhZihpLHUsYyl7dmFyIG09aWUoKTt0cnl7cmV0dXJuIGxhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gc2YoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgpe3ZhciB1ZT1pZSgpO3RyeXtwYShpLHUsYyxtLGcseCxJLHosQixMLHEsWCl9Y2F0Y2goJGUpe2lmKG9lKHVlKSwkZSE9PSRlKzApdGhyb3cgJGU7c2UoMSwwKX19ZnVuY3Rpb24gdWYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKXt2YXIgWD1pZSgpO3RyeXt1YShpLHUsYyxtLGcseCxJLHosQixMLHEpfWNhdGNoKHVlKXtpZihvZShYKSx1ZSE9PXVlKzApdGhyb3cgdWU7c2UoMSwwKX19ZnVuY3Rpb24gZGYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKXt2YXIgWD1pZSgpO3RyeXtyZXR1cm4gZ2EoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKX1jYXRjaCh1ZSl7aWYob2UoWCksdWUhPT11ZSswKXRocm93IHVlO3NlKDEsMCl9fWZ1bmN0aW9uIGxmKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiBiYShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gY2YoaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIF9hKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBwZihpLHUsYyxtKXt2YXIgZz1pZSgpO3RyeXtyZXR1cm4gd2EoaSx1LGMsbSl9Y2F0Y2goeCl7aWYob2UoZykseCE9PXgrMCl0aHJvdyB4O3NlKDEsMCl9fWZ1bmN0aW9uIG1mKGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKXt2YXIgTGU9aWUoKTt0cnl7dmEoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpfWNhdGNoKGp0KXtpZihvZShMZSksanQhPT1qdCswKXRocm93IGp0O3NlKDEsMCl9fWZ1bmN0aW9uIGZmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7JGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gaGYoaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3hhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gZ2YoaSx1KXt2YXIgYz1pZSgpO3RyeXtyZXR1cm4gcmEoaSx1KX1jYXRjaChtKXtpZihvZShjKSxtIT09bSswKXRocm93IG07cmV0dXJuIHNlKDEsMCksMG59fWZ1bmN0aW9uIHlmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7cmV0dXJuIFRhKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIGJmKGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlKXt2YXIgJGU9aWUoKTt0cnl7SWEoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUpfWNhdGNoKExlKXtpZihvZSgkZSksTGUhPT1MZSswKXRocm93IExlO3NlKDEsMCl9fWZ1bmN0aW9uIF9mKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiBBYShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gd2YoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtyZXR1cm4ga2EoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7cmV0dXJuIHNlKDEsMCksMG59fWZ1bmN0aW9uIHZmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7RWEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gJGYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtyZXR1cm4gUGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24geGYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXt6YShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBTZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBPYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBUZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e0RhKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIENmKGksdSxjLG0sZyx4LEkpe3ZhciB6PWllKCk7dHJ5e3JldHVybiBCYShpLHUsYyxtLGcseCxJKX1jYXRjaChCKXtpZihvZSh6KSxCIT09QiswKXRocm93IEI7c2UoMSwwKX19ZnVuY3Rpb24gSWYoaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7cmV0dXJuIE1hKGksdSxjLG0sZyx4LEkpfWNhdGNoKEIpe2lmKG9lKHopLEIhPT1CKzApdGhyb3cgQjtzZSgxLDApfX1yZXR1cm4gci5zdGFja1NhdmU9KCk9PmllKCksci5zdGFja1Jlc3RvcmU9aT0+b2UoaSksci5zdGFja0FsbG9jPWk9Pk1uKGkpLHIuc2V0VmFsdWU9ZnVuY3Rpb24oaSx1LGM9XCJpOFwiKXtzd2l0Y2goYy5lbmRzV2l0aChcIipcIikmJihjPVwiKlwiKSxjKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6WigpW2k+Pj4wXT11O2JyZWFrO2Nhc2VcImkxNlwiOmtlKClbaT4+PjE+Pj4wXT11O2JyZWFrO2Nhc2VcImkzMlwiOkQoKVtpPj4+Mj4+PjBdPXU7YnJlYWs7Y2FzZVwiaTY0XCI6V1tpPj4+M109QmlnSW50KHUpO2JyZWFrO2Nhc2VcImZsb2F0XCI6WSgpW2k+Pj4yPj4+MF09dTticmVhaztjYXNlXCJkb3VibGVcIjpmZSgpW2k+Pj4zPj4+MF09dTticmVhaztjYXNlXCIqXCI6UigpW2k+Pj4yPj4+MF09dTticmVhaztkZWZhdWx0OnV0KGBpbnZhbGlkIHR5cGUgZm9yIHNldFZhbHVlOiAke2N9YCl9fSxyLmdldFZhbHVlPWZ1bmN0aW9uKGksdT1cImk4XCIpe3N3aXRjaCh1LmVuZHNXaXRoKFwiKlwiKSYmKHU9XCIqXCIpLHUpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpyZXR1cm4gWigpW2k+Pj4wXTtjYXNlXCJpMTZcIjpyZXR1cm4ga2UoKVtpPj4+MT4+PjBdO2Nhc2VcImkzMlwiOnJldHVybiBEKClbaT4+PjI+Pj4wXTtjYXNlXCJpNjRcIjpyZXR1cm4gV1tpPj4+M107Y2FzZVwiZmxvYXRcIjpyZXR1cm4gWSgpW2k+Pj4yPj4+MF07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIGZlKClbaT4+PjM+Pj4wXTtjYXNlXCIqXCI6cmV0dXJuIFIoKVtpPj4+Mj4+PjBdO2RlZmF1bHQ6dXQoYGludmFsaWQgdHlwZSBmb3IgZ2V0VmFsdWU6ICR7dX1gKX19LHIuVVRGOFRvU3RyaW5nPUFlLHIuc3RyaW5nVG9VVEY4PUJ0LHIubGVuZ3RoQnl0ZXNVVEY4PVlvLGZ1bmN0aW9uIGkoKXtpZigwPHh0KUh0PWk7ZWxzZSBpZihkKXQociksWWUoKTtlbHNle2Zvcig7MDx5bi5sZW5ndGg7KXluLnNoaWZ0KCkocik7MDx4dD9IdD1pOihyLmNhbGxlZFJ1bj0hMCxlZXx8KFllKCksdChyKSkpfX0oKSxyLlBUUl9TSVpFPTQsb30pLEJmPXdzLE1mPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT8uc3RhcnRzV2l0aChcImVtLXB0aHJlYWRcIik7TWYmJndzKCl9KTt2YXIgVHMsUmYsVmUsQ3Msam4sVWYsTmYsSXMsVmYseHMsQXMsU3Msa3MsU3I9RygoKT0+e1widXNlIHN0cmljdFwiO3hyKCk7VHM9dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sUmY9KCk9PntpZighITEpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsVHMpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxWZT1SZigpLENzPSgpPT57aWYoVmUmJiFWZS5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIFZlLnN1YnN0cmluZygwLFZlLmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sam49KGUsdCk9Pnt0cnl7bGV0IG49dD8/VmU7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLm9yaWdpbj09PVRzfWNhdGNoe3JldHVybiExfX0sVWY9KGUsdCk9PntsZXQgbj10Pz9WZTt0cnl7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sTmY9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxJcz1hc3luYyBlPT57bGV0IG49YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuKX0sVmY9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQseHM9KF9zKCksYnIoYnMpKS5kZWZhdWx0LEFzPWFzeW5jKCk9PntpZighVmUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYoam4oVmUpKXJldHVyblt2b2lkIDAseHMoKV07bGV0IGU9YXdhaXQgSXMoVmUpO3JldHVybltlLHhzKGUpXX0sU3M9KCRzKCksYnIodnMpKS5kZWZhdWx0LGtzPWFzeW5jKGUsdCxuKT0+e2lmKCFlJiYhdCYmU3MmJlZlJiZqbihWZSkpcmV0dXJuW3ZvaWQgMCxTc107e2xldCByPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qc1wiLG89ZT8/VWYocix0KSxhPSEhMSYmbiYmbyYmIWpuKG8sdCkscz1hP2F3YWl0IElzKG8pOm8/P05mKHIsdCk7cmV0dXJuW2E/czp2b2lkIDAsYXdhaXQgVmYocyldfX19KTt2YXIgWm4sUW4sT3IsRXMsV2YsTGYsVHIsSWUsYnQ9RygoKT0+e1widXNlIHN0cmljdFwiO1NyKCk7UW49ITEsT3I9ITEsRXM9ITEsV2Y9KCk9PntpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuITE7dHJ5e3JldHVybiB0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LExmPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LFRyPWFzeW5jIGU9PntpZihRbilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoT3IpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoRXMpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7T3I9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxuPWUubnVtVGhyZWFkcztpZighTGYoKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXCIpO2xldCByPVdmKCk7bj4xJiYhciYmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIituK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSxjb25zb2xlLndhcm4oXCJXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuXCIpLGUubnVtVGhyZWFkcz1uPTEpO2xldCBvPWUud2FzbVBhdGhzLGE9dHlwZW9mIG89PVwic3RyaW5nXCI/bzp2b2lkIDAscz1vPy5tanMsZD1zPy5ocmVmPz9zLGw9bz8ud2FzbSxwPWw/LmhyZWY/P2wsZj1lLndhc21CaW5hcnksW2gseV09YXdhaXQga3MoZCxhLG4+MSksXz0hMSxiPVtdO2lmKHQ+MCYmYi5wdXNoKG5ldyBQcm9taXNlKHc9PntzZXRUaW1lb3V0KCgpPT57Xz0hMCx3KCl9LHQpfSkpLGIucHVzaChuZXcgUHJvbWlzZSgodyxTKT0+e2xldCAkPXtudW1UaHJlYWRzOm59O2lmKGYpJC53YXNtQmluYXJ5PWY7ZWxzZSBpZihwfHxhKSQubG9jYXRlRmlsZT12PT5wPz9hK3Y7ZWxzZSBpZihkJiZkLmluZGV4T2YoXCJibG9iOlwiKSE9PTApJC5sb2NhdGVGaWxlPXY9Pm5ldyBVUkwodixkKS5ocmVmO2Vsc2UgaWYoaCl7bGV0IHY9Q3MoKTt2JiYoJC5sb2NhdGVGaWxlPVQ9PnYrVCl9eSgkKS50aGVuKHY9PntPcj0hMSxRbj0hMCxabj12LHcoKSxoJiZVUkwucmV2b2tlT2JqZWN0VVJMKGgpfSx2PT57T3I9ITEsRXM9ITAsUyh2KX0pfSkpLGF3YWl0IFByb21pc2UucmFjZShiKSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sSWU9KCk9PntpZihRbiYmWm4pcmV0dXJuIFpuO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBQZSxYdCxoZSxEcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnQoKTtQZT0oZSx0KT0+e2xldCBuPUllKCkscj1uLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89bi5fbWFsbG9jKHIpO3JldHVybiBuLnN0cmluZ1RvVVRGOChlLG8sciksdC5wdXNoKG8pLG99LFh0PShlLHQsbixyKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYobi5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7bi5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28sYV0pPT57bGV0IHM9dD90K286bztpZih0eXBlb2YgYT09XCJvYmplY3RcIilYdChhLHMrXCIuXCIsbixyKTtlbHNlIGlmKHR5cGVvZiBhPT1cInN0cmluZ1wifHx0eXBlb2YgYT09XCJudW1iZXJcIilyKHMsYS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBhPT1cImJvb2xlYW5cIilyKHMsYT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgYX1gKX0pfSxoZT1lPT57bGV0IHQ9SWUoKSxuPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCByPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipyKTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvK3IpO2xldCBhPU51bWJlcih0LmdldFZhbHVlKG8scj09PTQ/XCJpMzJcIjpcImk2NFwiKSkscz10LmdldFZhbHVlKG8rcixcIipcIiksZD1zP3QuVVRGOFRvU3RyaW5nKHMpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7YX0sIEVSUk9SX01FU1NBR0U6ICR7ZH1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKG4pfX19KTt2YXIgUHMsenM9RygoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7RHIoKTtQcz1lPT57bGV0IHQ9SWUoKSxuPTAscj1bXSxvPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW8ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW8ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoby50ZXJtaW5hdGU9ITEpO2xldCBhPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGE9UGUoZS50YWcscikpLG49dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhvLmxvZ1NldmVyaXR5TGV2ZWwsby5sb2dWZXJib3NpdHlMZXZlbCwhIW8udGVybWluYXRlLGEpLG49PT0wJiZoZShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJlh0KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwocyxkKT0+e2xldCBsPVBlKHMscikscD1QZShkLHIpO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KG4sbCxwKSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke3N9IC0gJHtkfS5gKX0pLFtuLHJdfWNhdGNoKGEpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhuKSxyLmZvckVhY2gocz0+dC5fZnJlZShzKSksYX19fSk7dmFyIEdmLEhmLEZmLHFmLE9zLERzPUcoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO0RyKCk7R2Y9ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sSGY9ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LEZmPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShuPT4odHlwZW9mIG49PVwic3RyaW5nXCI/bjpuLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxxZj0oZSx0LG4pPT57Zm9yKGxldCByIG9mIHQpe2xldCBvPXR5cGVvZiByPT1cInN0cmluZ1wiP3I6ci5uYW1lO3N3aXRjaChvKXtjYXNlXCJ3ZWJublwiOmlmKG89XCJXRUJOTlwiLHR5cGVvZiByIT1cInN0cmluZ1wiKXtsZXQgZD1yPy5kZXZpY2VUeXBlO2lmKGQpe2xldCBsPVBlKFwiZGV2aWNlVHlwZVwiLG4pLHA9UGUoZCxuKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLHApIT09MCYmaGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2R9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihvPVwiSlNcIix0eXBlb2YgciE9XCJzdHJpbmdcIil7bGV0IHM9cjtpZihzPy5wcmVmZXJyZWRMYXlvdXQpe2lmKHMucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJnMucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHtzLnByZWZlcnJlZExheW91dH1gKTtsZXQgZD1QZShcInByZWZlcnJlZExheW91dFwiLG4pLGw9UGUocy5wcmVmZXJyZWRMYXlvdXQsbik7SWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxsKSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke3MucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfWApfWxldCBhPVBlKG8sbik7SWUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxhKSE9PTAmJmhlKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299LmApfX0sT3M9ZT0+e2xldCB0PUllKCksbj0wLHI9W10sbz1lfHx7fTtGZihvKTt0cnl7bGV0IGE9R2Yoby5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxzPUhmKG8uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGQ9dHlwZW9mIG8ubG9nSWQ9PVwic3RyaW5nXCI/UGUoby5sb2dJZCxyKTowLGw9by5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGwpfHxsPDB8fGw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2x9YCk7bGV0IHA9by5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBmPXR5cGVvZiBvLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/UGUoby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLHIpOjA7aWYobj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhhLCEhby5lbmFibGVDcHVNZW1BcmVuYSwhIW8uZW5hYmxlTWVtUGF0dGVybixzLCEhby5lbmFibGVQcm9maWxpbmcsMCxkLGwscCxmKSxuPT09MCYmaGUoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxvLmV4ZWN1dGlvblByb3ZpZGVycyYmcWYobixvLmV4ZWN1dGlvblByb3ZpZGVycyxyKSxvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIG8uZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgaD1QZShcImVuYWJsZUdyYXBoQ2FwdHVyZVwiLHIpLHk9UGUoby5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxyKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixoLHkpIT09MCYmaGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7by5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W2gseV1vZiBPYmplY3QuZW50cmllcyhvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgaCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtofWApO2lmKHR5cGVvZiB5IT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih5KXx8eTwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3l9YCk7bGV0IF89UGUoaCxyKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUobixfLHkpIT09MCYmaGUoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke2h9IC0gJHt5fS5gKX1yZXR1cm4gby5leHRyYSE9PXZvaWQgMCYmWHQoby5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChoLHkpPT57bGV0IF89UGUoaCxyKSxiPVBlKHkscik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG4sXyxiKSE9PTAmJmhlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtofSAtICR7eX0uYCl9KSxbbixyXX1jYXRjaChhKXt0aHJvdyBuIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKG4pIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksci5mb3JFYWNoKHM9PnQuX2ZyZWUocykpLGF9fX0pO3ZhciBSdCxfdCx3dCxCcixKdCxNcixScixZbix0ZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UnQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sX3Q9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sd3Q9KGUsdCk9PntsZXQgbj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxhKT0+byphLDEpO3JldHVybiBuPjA/TWF0aC5jZWlsKHIqbik6dm9pZCAwfSxCcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxKdD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sTXI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixScj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFluPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBlcixYbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHIoKTtlcj1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT1ObihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOm59PU5uKFwibm9kZTpmc1wiKSxyPW4oZSksbz1bXTtmb3IgYXdhaXQobGV0IGEgb2YgcilvLnB1c2goYSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCBuPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxyPW4/cGFyc2VJbnQobiwxMCk6MDtpZihyPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGE7dHJ5e2E9bmV3IEFycmF5QnVmZmVyKHIpfWNhdGNoKGQpe2lmKGQgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgbD1NYXRoLmNlaWwoci82NTUzNik7YT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmwsbWF4aW11bTpsfSkuYnVmZmVyfWVsc2UgdGhyb3cgZH1sZXQgcz0wO2Zvcig7Oyl7bGV0e2RvbmU6ZCx2YWx1ZTpsfT1hd2FpdCBvLnJlYWQoKTtpZihkKWJyZWFrO2xldCBwPWwuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShhLHMscCkuc2V0KGwpLHMrPXB9cmV0dXJuIG5ldyBVaW50OEFycmF5KGEsMCxyKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBLZixqZixCcyxNcyxVcixaZixtZSx0dD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtLZj1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLGpmPShlLHQpPT57Y29uc29sZS5sb2coYFske0tmW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxVcj0oZSx0KT0+e0JzPWUsTXM9dH0sWmY9KGUsdCk9PntsZXQgbj1KdChlKSxyPUp0KEJzKTtuPj1yJiZqZihuLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSxtZT0oLi4uZSk9PntNcyYmWmYoLi4uZSl9fSk7dmFyIE5yLEpuPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO05yPShlLHQpPT5uZXcoQnIodCkpKGUpfSk7dmFyIFZyPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBScyxlbyx0byxRZixZZixVcyxubyxybyxWcyxXcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dHQoKTtWcigpO1JzPW5ldyBNYXAoW1s2NCwyNTBdLFsxMjgsMjAwXSxbMjU2LDIwMF0sWzUxMiwyMDBdLFsyMDQ4LDIzMF0sWzQwOTYsMjAwXSxbODE5Miw1MF0sWzE2Mzg0LDUwXSxbMzI3NjgsNTBdLFs2NTUzNiw1MF0sWzEzMTA3Miw1MF0sWzI2MjE0NCw1MF0sWzUyNDI4OCw1MF0sWzEwNDg1NzYsNTBdLFsyMDk3MTUyLDMwXSxbNDE5NDMwNCwyMF0sWzgzODg2MDgsMTBdLFsxMjU4MjkxMiwxMF0sWzE2Nzc3MjE2LDEwXSxbMjYyMTQ0MDAsMTVdLFszMzU1NDQzMiwyMl0sWzQ0MjM2ODAwLDJdLFs1ODk4MjQwMCw2XSxbNjcxMDg4NjQsNl0sWzEzNDIxNzcyOCw2XSxbMTY3NzcyMTYwLDZdXSksZW89W10sdG89ZT0+TWF0aC5jZWlsKE51bWJlcihlKS8xNikqMTYsUWY9ZT0+e2ZvcihsZXQgdD0wO3Q8ZW8ubGVuZ3RoO3QrKyl7bGV0IG49ZW9bdF07aWYoZTw9bilyZXR1cm4gbn1yZXR1cm4gTWF0aC5jZWlsKGUvMTYpKjE2fSxZZj0xLFVzPSgpPT5ZZisrLG5vPWFzeW5jKGUsdCxuLHIpPT57bGV0IG89dG8obiksYT1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgcz1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLHMuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxhLDAsbyksZS5mbHVzaCgpLGF3YWl0IGEubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgZD1hLmdldE1hcHBlZFJhbmdlKCk7aWYocil7bGV0IGw9cigpO3JldHVybiBsLnNldChuZXcgVWludDhBcnJheShkLDAsbikpLGx9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZC5zbGljZSgwLG4pKX1maW5hbGx5e2EuZGVzdHJveSgpfX0scm89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwO2ZvcihsZXRbbl1vZiBScyllby5wdXNoKG4pLHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KG4sW10pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChuLFtdKTt0aGlzLnNlc3Npb25Db3VudD0wfXVwbG9hZCh0LG4pe2xldCByPW4uYnVmZmVyLG89bi5ieXRlT2Zmc2V0LGE9bi5ieXRlTGVuZ3RoLHM9dG8oYSksZD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihOdW1iZXIoZC5vcmlnaW5hbFNpemUpIT09YSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtkLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2F9YCk7bGV0IGw9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTpzLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLHA9bC5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KHApLnNldChuZXcgVWludDhBcnJheShyLG8sYSkpLGwudW5tYXAoKTtsZXQgZj10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7Zi5jb3B5QnVmZmVyVG9CdWZmZXIobCwwLGQuZ3B1RGF0YS5idWZmZXIsMCxzKSx0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbZi5maW5pc2goKV0pLGwuZGVzdHJveSgpLG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCl9bWVtY3B5KHQsbil7bGV0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldChuKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKHIub3JpZ2luYWxTaXplIT09by5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgYT10byhyLm9yaWdpbmFsU2l6ZSkscz10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxzLmNvcHlCdWZmZXJUb0J1ZmZlcihyLmdwdURhdGEuYnVmZmVyLDAsby5ncHVEYXRhLmJ1ZmZlciwwLGEpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxuLHIpe2xldCBvO2lmKHIpe2lmKG89clswXSx0PT09clsxXSlyZXR1cm4gbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtufSkgPT4gaWQ9JHtvfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG87aWYodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKSl0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApfWVsc2Ugbz1VcygpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobyx7Z3B1RGF0YTp7aWQ6byx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpufSksbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtufSkgPT4gaWQ9JHtvfSwgcmVnaXN0ZXJlZC5gKSxvfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXt0IT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHt0fWApKX1jcmVhdGUodCxuPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCByPVFmKHQpLG8sYT0obiZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0Uscz0obiZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoYXx8cyl7bGV0IHA9KGE/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycykuZ2V0KHIpO3A/cC5sZW5ndGg+MD9vPXAucG9wKCk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLHVzYWdlOm59KTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnIsdXNhZ2U6bn0pfWVsc2Ugbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpyLHVzYWdlOm59KTtsZXQgZD17aWQ6VXMoKSx0eXBlOjAsYnVmZmVyOm99O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZC5pZCx7Z3B1RGF0YTpkLG9yaWdpbmFsU2l6ZTpOdW1iZXIodCl9KSxtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7ZC5pZH1gKSxkfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IG49dHlwZW9mIHQ9PVwiYmlnaW50XCI/TnVtYmVyKHQpOnQscj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQobik7aWYoIXIpe2lmKHRoaXMuc3RvcmFnZUNhY2hlLnNpemU9PT0wKXJldHVybiAwO3Rocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpfXJldHVybiBtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtufSksIGdwdURhdGFJZD0ke3IuZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUobiksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKHIuZ3B1RGF0YS5idWZmZXIpLHIub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQsbil7bGV0IHI9dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcih0KSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBubyh0aGlzLmJhY2tlbmQsci5ncHVEYXRhLmJ1ZmZlcixyLm9yaWdpbmFsU2l6ZSxuKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtpZih0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCE9PTApaWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImRlZmF1bHRcIil7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpe2xldCBuPVJzLmdldCh0LnNpemUpO2lmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSl7bGV0IHI9dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKXx8W107bj09PXZvaWQgMHx8ci5sZW5ndGg+PW4/dC5kZXN0cm95KCk6ci5wdXNoKHQpfWVsc2UgaWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNKXtsZXQgcj10aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKXx8W107bj09PXZvaWQgMHx8ci5sZW5ndGg+PW4/dC5kZXN0cm95KCk6ci5wdXNoKHQpfWVsc2UgdC5kZXN0cm95KCl9dGhpcy5idWZmZXJzUGVuZGluZz1bXX1lbHNle2xldCB0PXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpO3R8fCh0PVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsdCkpO2ZvcihsZXQgbiBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXQucHVzaChuKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gobj0+e24uZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwfW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuc2Vzc2lvbkNvdW50Kz0xfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IG49dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0KTtuJiYobi5mb3JFYWNoKHI9PntyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUodCkpLHRoaXMuc2Vzc2lvbkNvdW50LT0xLHRoaXMuc2Vzc2lvbkNvdW50PT09MCYmKG1lKFwid2FybmluZ1wiLCgpPT5cIltXZWJHUFVdIENsZWFyaW5nIHdlYmdwdSBidWZmZXIgY2FjaGVcIiksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaChyPT57ci5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwKX19LFZzPSguLi5lKT0+bmV3IHJvKC4uLmUpfSk7dmFyIG9vLHJlLENlPUcoKCk9PntcInVzZSBzdHJpY3RcIjtvbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LHJlPWU9Pm5ldyBvbyhlKX0pO3ZhciBpbyxydCxFLGt0LFdyLExzLEdzLGFlPUcoKCk9PntcInVzZSBzdHJpY3RcIjtpbz1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQsbil7cmV0dXJuIHRbMV0hPT1uWzBdP3ZvaWQgMDpbdFswXSxuWzFdXX19LHJ0PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxuLHI9ITEpe2xldCBvPXQubGVuZ3RoLGE9bi5sZW5ndGg7aWYobz09PTApcmV0dXJuIG47aWYoYT09PTApcmV0dXJuIHQ7bGV0IHM9TWF0aC5tYXgodC5sZW5ndGgsbi5sZW5ndGgpLGQ9bmV3IEFycmF5KHMpO2lmKHIpe2lmKG88Mnx8YTwyKXJldHVybjtsZXQgbD1pby5jYWxjTWF0TXVsU2hhcGUoW3Rbby0yXSx0W28tMV1dLFtuW2EtMl0sblthLTFdXSk7aWYobD09PXZvaWQgMClyZXR1cm47W2Rbcy0yXSxkW3MtMV1dPWx9Zm9yKGxldCBsPXI/MzoxO2w8PXM7bCsrKXtsZXQgcD1vLWw8MD8xOnRbby1sXSxmPWEtbDwwPzE6blthLWxdO2lmKHAhPT1mJiZwPjEmJmY+MSlyZXR1cm47bGV0IGg9TWF0aC5tYXgocCxmKTtpZihwJiZmKWRbcy1sXT1NYXRoLm1heChwLGYpO2Vsc2V7aWYoaD4xKXJldHVybjtkW3MtbF09MH19cmV0dXJuIGR9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxuKXtsZXQgcj10Lmxlbmd0aCxvPW4ubGVuZ3RoO2lmKHI+bylyZXR1cm4hMTtmb3IobGV0IGE9MTthPD1yO2ErKylpZih0W3ItYV0hPT0xJiZ0W3ItYV0hPT1uW28tYV0pcmV0dXJuITE7cmV0dXJuITB9fSxFPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBjb252ZXJ0U2hhcGUodCxuPTQpe2xldCByPXQubGVuZ3RoO2lmKHI9PT0wKXJldHVybltdO2xldCBvPW5ldyBBcnJheShyKSxhPXItMTtmb3IoO2E+PTA7KXtpZih0W2FdJW49PT0wKXtvW2FdPXRbYV0vbjticmVha31pZihuJXRbYV0hPT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHNoYXBlXCIpO29bYV09MSxuLz10W2FdLGEtLX1mb3IoYS0tO2E+PTA7YS0tKW9bYV09dFthXTtyZXR1cm4gb31zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxuKXtpZihuPDB8fG4+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke259IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LG4sdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxuKXtpZihuPDB8fG4+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke259IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLG4pfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsbixyKXtsZXQgbz0xO2ZvcihsZXQgYT1uO2E8cjthKyspe2lmKHRbYV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO28qPU51bWJlcih0W2FdKX1yZXR1cm4gb31zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IG49dC5sZW5ndGg7aWYobj09PTApcmV0dXJuW107aWYobj09PTEpcmV0dXJuWzFdO2xldCByPW5ldyBBcnJheShuKTtyW24tMV09MSxyW24tMl09dFtuLTFdO2ZvcihsZXQgbz1uLTM7bz49MDstLW8pcltvXT1yW28rMV0qdFtvKzFdO3JldHVybiByfXN0YXRpYyBub3JtYWxpemVBeGlzKHQsbil7aWYodDwtbiYmdD49bil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K246dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LG4pe3JldHVybiB0Lm1hcChyPT50aGlzLm5vcm1hbGl6ZUF4aXMocixuPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxuKXtyZXR1cm4gbj9uLm1hcChyPT50W3JdKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LG4pe2xldCByPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobyxhKT0+bytuW2FdK25bYStyXSl9c3RhdGljIGFyZUVxdWFsKHQsbil7cmV0dXJuIHQubGVuZ3RoIT09bi5sZW5ndGg/ITE6dC5ldmVyeSgocixvKT0+cj09PW5bb10pfX0sa3Q9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxuLHIsbyxhLHMpe2lmKCF0JiZyLmxlbmd0aCE9PW4ubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgZD0wO2Q8bi5sZW5ndGgtMjtkKyspZD49ci5sZW5ndGg/ci5wdXNoKG5bZCsyXSk6cltkXT1uW2QrMl07Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspaWYoZDxvLmxlbmd0aCl7aWYob1tkXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGg7ZCsrKWlmKGQ8YS5sZW5ndGgpe2lmKGFbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgYS5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8ci5sZW5ndGgqMjtkKyspaWYoZDxzLmxlbmd0aCl7aWYoc1tkXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBzLnB1c2goMCk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspe2lmKHJbZF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKHNbZF0+PXJbZF18fHNbZCtyLmxlbmd0aF0+PXJbZF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LG4scixvLGEscyxkKXtpZihkKXtpZihhLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihuLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG8ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBsPTA7bDx0Lmxlbmd0aC0yO2wrKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbbCsocz8xOjIpXSxuW2xdLHJbbF0sb1tsXSxhLGwsbCt0Lmxlbmd0aC0yLGQpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LG4scixvLGEscyxkKXtpZihuLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IGw9W25bMF0sblsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQsbixsLHIsbyxhLHMsZCksbH1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LG4scixvLGEscyxkKXtpZih0Lmxlbmd0aDw9MHx8bi5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgbD1bdFswXSxuWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxsLHIsbyxhLHMsZCksbH1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQsbixyLG8sYSxzLGQsbCl7aWYodClmb3IobGV0IHA9MDtwPG4ubGVuZ3RoLTI7cCsrKXIucHVzaCgxKTtlbHNlIGZvcihsZXQgcD0wO3A8bi5sZW5ndGgtMjtwKyspci5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUobltwKzJdLG9bcF0sYVtwXSxzW3BdLGQscCxwK24ubGVuZ3RoLTIsbCkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LG4scixvLGEscyxkLGwpe2xldCBwPXIqKG8tMSkrMTtpZihsJiZsIT09XCJOT1RTRVRcIilzd2l0Y2gobCl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gYVtzXT0wLGFbZF09MCxNYXRoLmZsb29yKCh0LXApL24rMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihyIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCBoPSgodCtuLTEpL24tMSkqbitvLXQ7cmV0dXJuIGFbc109TWF0aC5mbG9vcihsPT09XCJTQU1FX0xPV0VSXCI/KGgrMSkvMjpoLzIpLGFbZF09aC1hW3NdLE1hdGguZmxvb3IoKHQraC1vKS9uKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQrYVtzXSthW2RdLXApL24rMSl9fSxXcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxuLHIsbyxhKXtpZih0Lmxlbmd0aCE9PTJ8fHIubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgcyxkLGw7bj8ocz10WzFdLGQ9dFswXSk6KHM9dFswXSxkPXRbMV0pO2xldCBwPS0xO2lmKG8/KGw9clswXSxwPTEpOihsPXJbMV0scD0wKSxyW3BdIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoczw9MHx8bDw9MHx8ZDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihhJiYhcnQuaXNWYWxpZEJyb2FkY2FzdChhLFtzLGxdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bcyxsLGRdfX0sTHM9LTM0MDI4MjM0NjYzODUyODg2ZTIyLEdzPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIEV0LHNvLF9lLHplLEgsZ2UsdW8sUHQsS2UsSyxMcixQLE4sSHMsR3IsYW8sRnMsY2U9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtFdD02NCxzbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxfZT0oZSx0PTEpPT57bGV0IG49c28oZSx0KTtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCI/bjpuWzBdfSx6ZT0oZSx0PTEpPT57bGV0IG49c28oZSx0KTtyZXR1cm4gdHlwZW9mIG49PVwic3RyaW5nXCI/bjpuWzFdfSxIPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gobj0+e24ubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpFLmNvbXB1dGVTdHJpZGVzKG4pfSl9KSx0fSxnZT1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsdW89KGU9XCJmMzJcIix0LG49XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtufSlgOmB2ZWMke3R9PCR7ZX0+KCR7bn0pYCxQdD0oZSx0LG4pPT5lPT09XCJmMzJcIj9uOnQ9PT0xP2BmMzIoJHtufSlgOmB2ZWMke3R9PGYzMj4oJHtufSlgLEtlPShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLEs9KGUsdCxuLHIpPT5lLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJm4+ND90eXBlb2YgdD09XCJzdHJpbmdcIj9yPT09XCJmMTZcIj9gJHtlfVsoJHt0fSkgLyA4XVsoJHt0fSkgJSA4IC8gNF1bKCR7dH0pICUgOCAlIDRdYDpgJHtlfVsoJHt0fSkgLyA0XVsoJHt0fSkgJSA0XWA6cj09PVwiZjE2XCI/YCR7ZX1bJHtNYXRoLmZsb29yKHQvOCl9XVske01hdGguZmxvb3IodCU4LzQpfV1bJHt0JTglNH1dYDpgJHtlfVske01hdGguZmxvb3IodC80KX1dWyR7dCU0fV1gOm4+MT9gJHtlfVske3R9XWA6ZSxMcj0oZSx0LG4scixvKT0+e2xldCBhPXR5cGVvZiBuPT1cIm51bWJlclwiLHM9YT9uOm4ubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheShzKS5rZXlzKCldLGw9czwyP1widTMyXCI6czw9ND9gdmVjJHtzfTx1MzI+YDpgYXJyYXk8dTMyLCAke3N9PmAscD1zbyh0LG8pLGY9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLGg9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLHk9e2luZGljZXM6bCx2YWx1ZTpmLHN0b3JhZ2U6aCx0ZW5zb3I6dH0sXz1SPT50eXBlb2YgUj09XCJzdHJpbmdcIj9SOmAke1J9dWAsYj17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LHc9YT9cInVuaWZvcm1zLlwiOlwiXCIsUz1gJHt3fSR7ZX1fc2hhcGVgLCQ9YCR7d30ke2V9X3N0cmlkZXNgLHY9XCJcIjtmb3IobGV0IFI9MDtSPHMtMTtSKyspdis9YFxuICAgIGxldCBkaW0ke1J9ID0gY3VycmVudCAvICR7SygkLFIscyl9O1xuICAgIGxldCByZXN0JHtSfSA9IGN1cnJlbnQgJSAke0soJCxSLHMpfTtcbiAgICBpbmRpY2VzWyR7Un1dID0gZGltJHtSfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7Un07XG4gICAgYDt2Kz1gaW5kaWNlc1ske3MtMX1dID0gY3VycmVudDtgO2xldCBUPXM8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7eS5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7eS5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke3Z9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLEM9Uj0+KGIub2Zmc2V0VG9JbmRpY2VzPSEwLHM8Mj9SOmBvMmlfJHtlfSgke1J9KWApLEE9W107aWYocz49Milmb3IobGV0IFI9cy0xO1I+PTA7Ui0tKUEucHVzaChgJHtLKCQsUixzKX0gKiAoaW5kaWNlc1ske1J9XSlgKTtsZXQgaz1zPDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7eS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtBLmpvaW4oXCIrXCIpfTtcbiAgfWAsTz1SPT4oYi5pbmRpY2VzVG9PZmZzZXQ9ITAsczwyP1I6YGkyb18ke2V9KCR7Un0pYCksTT0oLi4uUik9PnM9PT0wP1wiMHVcIjpgJHt5LmluZGljZXN9KCR7Ui5tYXAoXykuam9pbihcIixcIil9KWAsVj0oUixZKT0+czwyP2Ake1J9YDpgJHtLKFIsWSxzKX1gLEY9KFIsWSxmZSk9PnM8Mj9gJHtSfT0ke2ZlfTtgOmAke0soUixZLHMpfT0ke2ZlfTtgLGo9e30sbmU9KFIsWSk9PntiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0PSEwO2xldCBmZT1gJHtZLm5hbWV9YnJvYWRjYXN0ZWRJbmRpY2VzVG8ke2V9T2Zmc2V0YDtpZihmZSBpbiBqKXJldHVybmAke2ZlfSgke1J9KWA7bGV0IEZlPVtdO2ZvcihsZXQgeGU9cy0xO3hlPj0wO3hlLS0pe2xldCBiZT1ZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIseGUrWS5yYW5rLXMpO0ZlLnB1c2goYCR7VigkLHhlKX0gKiAoJHtiZX0gJSAke1YoUyx4ZSl9KWApfXJldHVybiBqW2ZlXT1gZm4gJHtmZX0ob3V0cHV0SW5kaWNlczogJHtZLnR5cGUuaW5kaWNlc30pIC0+IHUzMiB7XG4gICAgICAgICAgICAgcmV0dXJuICR7RmUubGVuZ3RoPjA/RmUuam9pbihcIitcIik6XCIwdVwifTtcbiAgICAgICAgICAgfWAsYCR7ZmV9KCR7Un0pYH0sVz0oUixZKT0+KCgpPT57aWYoeS5zdG9yYWdlPT09eS52YWx1ZSlyZXR1cm5gJHtlfVske1J9XT0ke1l9O2A7aWYoeS5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmeS52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYCR7ZX1bJHtSfV09dmVjMjx1MzI+KHUzMigke1l9KSwgc2VsZWN0KDB1LCAweEZGRkZGRkZGdSwgJHtZfSA8IDApKTtgO2lmKHkuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnkudmFsdWU9PT1cInUzMlwiKXJldHVybmAke2V9WyR7Un1dPXZlYzI8dTMyPih1MzIoJHtZfSksIDB1KTtgO2lmKHkuc3RvcmFnZT09PVwidTMyXCImJnkudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gJHtlfVske1J9XT1kb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPigke1l9KSk7YDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7eS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3kudmFsdWV9IHlldGApfSkoKSxKPVI9PigoKT0+e2lmKHkuc3RvcmFnZT09PXkudmFsdWUpcmV0dXJuYCR7ZX1bJHtSfV1gO2lmKHkuc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJnkudmFsdWU9PT1cImkzMlwiKXJldHVybmBpMzIoJHtlfVske1J9XS54KWA7aWYoeS5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmeS52YWx1ZT09PVwidTMyXCIpcmV0dXJuYHUzMigke2V9WyR7Un1dLngpYDtpZih5LnN0b3JhZ2U9PT1cInUzMlwiJiZ5LnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYHZlYzQ8Ym9vbD4oYm9vbCgke2V9WyR7Un1dICYgMHhGRnUpLCBib29sKCR7ZX1bJHtSfV0gJiAweEZGMDB1KSwgYm9vbCgke2V9WyR7Un1dICYgMHhGRjAwMDB1KSwgYm9vbCgke2V9WyR7Un1dICYgMHhGRjAwMDAwMHUpKWA7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke3kuc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHt5LnZhbHVlfSB5ZXRgKX0pKCksdmU9czwyP1wiXCI6YFxuICBmbiBnZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3kuaW5kaWNlc30pIC0+ICR7Zn0ge1xuICAgIHJldHVybiAke0ooYGkyb18ke2V9KGluZGljZXMpYCl9O1xuICB9YCxRPXM8Mj9cIlwiOigoKT0+e2xldCBSPWQubWFwKGZlPT5gZCR7ZmV9OiB1MzJgKS5qb2luKFwiLCBcIiksWT1kLm1hcChmZT0+YGQke2ZlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIGdldF8ke2V9KCR7Un0pIC0+ICR7Zn0ge1xuICAgIHJldHVybiBnZXRfJHtlfUJ5SW5kaWNlcygke00oWSl9KTtcbiAgfWB9KSgpLGVlPSguLi5SKT0+e2lmKFIubGVuZ3RoIT09cyl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtzfWApO2xldCBZPVIubWFwKF8pLmpvaW4oXCIsXCIpO3JldHVybiBzPT09MD9KKFwiMHVcIik6cz09PTE/SihZWzBdKTooYi5nZXQ9ITAsYi5nZXRCeUluZGljZXM9ITAsYi5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9KCR7WX0pYCl9LGxlPVI9PnM8Mj9KKFIpOihiLmdldEJ5SW5kaWNlcz0hMCxiLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtSfSlgKSxaPXM8Mj9cIlwiOmBcbiAgZm4gc2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHt5LmluZGljZXN9LCB2YWx1ZTogJHtmfSkge1xuICAgICR7VyhgaTJvXyR7ZX0oaW5kaWNlcylgLFwidmFsdWVcIil9XG4gIH1gLHBlPXM8Mj9cIlwiOigoKT0+e2xldCBSPWQubWFwKGZlPT5gZCR7ZmV9OiB1MzJgKS5qb2luKFwiLCBcIiksWT1kLm1hcChmZT0+YGQke2ZlfWApLmpvaW4oXCIsIFwiKTtyZXR1cm5gXG4gIGZuIHNldF8ke2V9KCR7Un0sIHZhbHVlOiAke2Z9KSB7XG4gICAgc2V0XyR7ZX1CeUluZGljZXMoJHtNKFkpfSwgdmFsdWUpO1xuICB9YH0pKCk7cmV0dXJue2ltcGw6KCk9PntsZXQgUj1bXSxZPSExO3JldHVybiBiLm9mZnNldFRvSW5kaWNlcyYmKFIucHVzaChUKSxZPSEwKSxiLmluZGljZXNUb09mZnNldCYmKFIucHVzaChrKSxZPSEwKSxiLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0JiYoT2JqZWN0LnZhbHVlcyhqKS5mb3JFYWNoKGZlPT5SLnB1c2goZmUpKSxZPSEwKSxiLnNldCYmKFIucHVzaChwZSksWT0hMCksYi5zZXRCeUluZGljZXMmJihSLnB1c2goWiksWT0hMCksYi5nZXQmJihSLnB1c2goUSksWT0hMCksYi5nZXRCeUluZGljZXMmJihSLnB1c2godmUpLFk9ITApLCFhJiZZJiZSLnVuc2hpZnQoYGNvbnN0ICR7U30gPSAke3kuaW5kaWNlc30oJHtuLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHskfSA9ICR7eS5pbmRpY2VzfSgke0UuY29tcHV0ZVN0cmlkZXMobikuam9pbihcIixcIil9KTtgKSxSLmpvaW4oYFxuYCl9LHR5cGU6eSxvZmZzZXRUb0luZGljZXM6QyxpbmRpY2VzVG9PZmZzZXQ6Tyxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpuZSxpbmRpY2VzOk0saW5kaWNlc0dldDpWLGluZGljZXNTZXQ6RixzZXQ6KC4uLlIpPT57aWYoUi5sZW5ndGghPT1zKzEpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7c31gKTtsZXQgWT1SW3NdO2lmKHR5cGVvZiBZIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihcInZhbHVlIG11c3QgYmUgc3RyaW5nXCIpO2xldCBmZT1SLnNsaWNlKDAscykubWFwKF8pLmpvaW4oXCIsXCIpO3JldHVybiBzPT09MD9XKFwiMHVcIixZKTpzPT09MT9XKGZlWzBdLFkpOihiLnNldD0hMCxiLnNldEJ5SW5kaWNlcz0hMCxiLmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX0oJHtmZX0sICR7WX0pYCl9LHNldEJ5T2Zmc2V0Olcsc2V0QnlJbmRpY2VzOihSLFkpPT5zPDI/VyhSLFkpOihiLnNldEJ5SW5kaWNlcz0hMCxiLmluZGljZXNUb09mZnNldD0hMCxgc2V0XyR7ZX1CeUluZGljZXMoJHtSfSwgJHtZfSk7YCksZ2V0OmVlLGdldEJ5T2Zmc2V0OkosZ2V0QnlJbmRpY2VzOmxlLHVzYWdlOnIsbmFtZTplLHN0cmlkZXM6JCxzaGFwZTpTLHJhbms6c319LFA9KGUsdCxuLHI9MSk9PkxyKGUsdCxuLFwiaW5wdXRcIixyKSxOPShlLHQsbixyPTEpPT5McihlLHQsbixcIm91dHB1dFwiLHIpLEhzPShlLHQsbik9PkxyKGUsdCxuLFwiYXRvbWljT3V0cHV0XCIsMSksR3I9KGUsdCxuLHI9MSk9PkxyKGUsdCxuLFwiaW50ZXJuYWxcIixyKSxhbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4pe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmxpbWl0cz1uO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1FdCl7bGV0IG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdO2lmKG4+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfHxyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWXx8bz50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVopdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtufSwgJHtyfSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWX0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCk7aWYobipyKm8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7bn0sICR7cn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gKTtsZXQgYT10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEscz1hP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YCxkPWE/YGxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YDpgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke24qcipvfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7bn0sICR7cn0sICR7b30pXG4gIGZuIG1haW4oJHtzfSkge1xuICAgICR7ZH1cbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxuKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgcj10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG89dC51c2FnZT09PVwiYXRvbWljT3V0cHV0XCI/XCJhdG9taWM8aTMyPlwiOnQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtufSkgdmFyPHN0b3JhZ2UsICR7cn0+ICR7dC5uYW1lfTogYXJyYXk8JHtvfT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChuPT50aGlzLmRlY2xhcmVWYXJpYWJsZShuLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXG5gKX1yZWdpc3RlckludGVybmFsVmFyaWFibGUodCl7aWYodC51c2FnZSE9PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5mb3JFYWNoKG49PnRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKG4pKSx0aGlzfXJlZ2lzdGVyVW5pZm9ybSh0LG4scj0xKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpuLGxlbmd0aDpyfSksdGhpc31yZWdpc3RlclVuaWZvcm1zKHQpe3JldHVybiB0aGlzLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMuY29uY2F0KHQpLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOm4sdHlwZTpyLGxlbmd0aDpvfW9mIHRoaXMudW5pZm9ybXMpaWYobyYmbz40KXI9PT1cImYxNlwiP3QucHVzaChgQGFsaWduKDE2KSAke259OmFycmF5PG1hdDJ4NDwke3J9PiwgJHtNYXRoLmNlaWwoby84KX0+YCk6dC5wdXNoKGAke259OmFycmF5PHZlYzQ8JHtyfT4sICR7TWF0aC5jZWlsKG8vNCl9PmApO2Vsc2V7bGV0IGE9bz09bnVsbHx8bz09PTE/cjpgdmVjJHtvfTwke3J9PmA7dC5wdXNoKGAke259OiR7YX1gKX1yZXR1cm5gXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy52YXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApK3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApfWdldCB2YXJpYWJsZXNJbmZvKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVybjtsZXQgdD1uPT5bMTIsMTAsMSw2XVtbXCJ1MzJcIixcImYxNlwiLFwiZjMyXCIsXCJpMzJcIl0uaW5kZXhPZihuKV07cmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKG49Plt0KG4udHlwZSksbi5sZW5ndGg/PzFdKX19LEZzPShlLHQpPT5uZXcgYW8oZSx0KX0pO3ZhciBYZixxcyxKZixlaCx0aCxyaCxPZSxLcyxqcyxjdD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtYZj0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKHQubGVuZ3RoIT09MCYmdC5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgcGVybSBzaXplICR7dC5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGlucHV0IHJhbmsgJHtlWzBdLmRpbXMubGVuZ3RofWApfSxxcz0oZSx0KT0+dC5sZW5ndGghPT0wP3Q6Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKSxKZj0oZSx0KT0+RS5zb3J0QmFzZWRPblBlcm0oZSxxcyhlLmxlbmd0aCx0KSksZWg9KGUsdCxuLHIpPT57bGV0IG89YGZuIHBlcm0oaTogJHtyLnR5cGUuaW5kaWNlc30pIC0+ICR7bi50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtuLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IGE9MDthPHQ7KythKW8rPWBhWyR7ZVthXX1dPWlbJHthfV07YDtyZXR1cm4gbys9XCJyZXR1cm4gYTt9XCJ9LHRoPShlLHQpPT57bGV0IG49W10scj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyllW29dIT09MSYmbi5wdXNoKGVbb10pLGVbdFtvXV0hPT0xJiZyLnB1c2godFtvXSk7cmV0dXJue25ld1NoYXBlOm4sbmV3UGVybTpyfX0scmg9KGUsdCk9PntsZXQgbj0wO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKHRbZVtyXV0hPT0xKXtpZihlW3JdPG4pcmV0dXJuITE7bj1lW3JdfXJldHVybiEwfSxPZT0oZSx0KT0+e2xldCBuPWUuZGF0YVR5cGUscj1lLmRpbXMubGVuZ3RoLG89cXMocix0KSxhPUpmKGUuZGltcyxvKSxzPWUuZGltcyxkPWEsbD1yPDJ8fHJoKG8sZS5kaW1zKSxwO2lmKGwpcmV0dXJuIHA9dz0+e2xldCBTPVAoXCJpbnB1dFwiLG4scyw0KSwkPU4oXCJvdXRwdXRcIixuLGQsNCk7cmV0dXJuYFxuICAke3cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKFMsJCl9XG4gICR7dy5tYWluU3RhcnQoKX1cbiAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VDb3B5XCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgdz1FLnNpemUoYSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHcvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwody80KX1dfX0sZ2V0U2hhZGVyU291cmNlOnB9O2xldHtuZXdTaGFwZTpmLG5ld1Blcm06aH09dGgoZS5kaW1zLG8pLHk9RS5hcmVFcXVhbChoLFsyLDMsMV0pLF89RS5hcmVFcXVhbChoLFszLDEsMl0pO2lmKGYubGVuZ3RoPT09Mnx8eXx8Xyl7cz15P1tmWzBdLGZbMV0qZlsyXV06Xz9bZlswXSpmWzFdLGZbMl1dOmYsZD1bc1sxXSxzWzBdXTtsZXQgdz0xNjtyZXR1cm4gcD1TPT57bGV0ICQ9UChcImFcIixuLHMubGVuZ3RoKSx2PU4oXCJvdXRwdXRcIixuLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7Uy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoJCx2KX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHt3KzF9PiwgJHt3fT47XG4gICR7Uy5tYWluU3RhcnQoW3csdywxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7d30gKyAxO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeCA9IHdvcmtncm91cF9pbmRleCAlIHN0cmlkZTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHt3fXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7d311ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHskLmdldEJ5SW5kaWNlcyhgJHskLnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHt3fXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke3d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xuICAgICAgJHt2LnNldEJ5SW5kaWNlcyhgJHt2LnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLFwidGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XVwiKX1cbiAgICB9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVNoYXJlZFwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IFM9RS5zaXplKGEpO3JldHVybntvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkWzFdL3cpLHk6TWF0aC5jZWlsKGRbMF0vdyl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpTfSwuLi5IKHMsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fXJldHVybiBwPXc9PntsZXQgUz1QKFwiYVwiLG4scy5sZW5ndGgpLCQ9TihcIm91dHB1dFwiLG4sZC5sZW5ndGgpO3JldHVybmBcbiAgJHt3LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhTLCQpfVxuXG4gICR7ZWgobyxyLFMsJCl9XG5cbiAgJHt3Lm1haW5TdGFydCgpfVxuICAgICR7dy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFMuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCB3PUUuc2l6ZShhKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwody82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTp3fSwuLi5IKHMsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fSxLcz0oZSx0KT0+e1hmKGUuaW5wdXRzLHQucGVybSksZS5jb21wdXRlKE9lKGUuaW5wdXRzWzBdLHQucGVybSkpfSxqcz1lPT5yZSh7cGVybTplLnBlcm19KX0pO3ZhciBuaCxvaCxpaCxhaCxzaCx1aCxkaCxsaCxjaCxwaCxudCxacyxRcyxZcyxYcyxKcyxldSx0dSxydSxudSxvdSxpdT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7SHIoKTtjdCgpO25oPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpXCIsbDE6XCJiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LG9oPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwxOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0saWg9e21heDpcIl9BW29mZnNldF1cIixtaW46XCJfQVtvZmZzZXRdXCIsbWVhbjpcIjBcIixzdW06XCIwXCIscHJvZDpcIjFcIixzdW1TcXVhcmU6XCIwXCIsbG9nU3VtRXhwOlwiMFwiLGwxOlwiMFwiLGwyOlwiMFwiLGxvZ1N1bTpcIjBcIn0sYWg9e21heDpcImJlc3RWYWx1ZVwiLG1pbjpcImJlc3RWYWx1ZVwiLHN1bTpcImJlc3RWYWx1ZVwiLHByb2Q6XCJiZXN0VmFsdWVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWVcIixsb2dTdW1FeHA6XCJsb2coYmVzdFZhbHVlKVwiLGwxOlwiYmVzdFZhbHVlXCIsbDI6XCJzcXJ0KGJlc3RWYWx1ZSlcIixsb2dTdW06XCJsb2coYmVzdFZhbHVlKVwifSxzaD0oZSx0KT0+e2xldCBuPVtdO2ZvcihsZXQgcj10LWU7cjx0OysrciluLnB1c2gocik7cmV0dXJuIG59LHVoPShlLHQpPT57bGV0IG49W10scj1lLmxlbmd0aDtmb3IobGV0IGE9MDthPHI7YSsrKXQuaW5kZXhPZihhKT09PS0xJiZuLnB1c2goZVthXSk7bGV0IG89dC5tYXAoYT0+ZVthXSk7cmV0dXJuW24sb119LGRoPShlLHQpPT57bGV0IG49ZS5sZW5ndGgrdC5sZW5ndGgscj1bXSxvPTA7Zm9yKGxldCBhPTA7YTxuO2ErKyl0LmluZGV4T2YoYSk9PT0tMT9yLnB1c2goZVtvKytdKTpyLnB1c2goMSk7cmV0dXJuIHJ9LGxoPShlLHQpPT57Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24paWYoZVtlLmxlbmd0aC1uLTFdIT09dC0xLW4pcmV0dXJuITE7cmV0dXJuITB9LGNoPShlLHQpPT57bGV0IG49W107aWYoIWxoKGUsdCkpe2ZvcihsZXQgcj0wO3I8dDsrK3IpZS5pbmRleE9mKHIpPT09LTEmJm4ucHVzaChyKTtlLmZvckVhY2gocj0+bi5wdXNoKHIpKX1yZXR1cm4gbn0scGg9KGUsdCxuLHIsbyxhLHMpPT57bGV0IGQ9blswXS5kaW1zLGw9RS5zaXplKGEpLHA9RS5zaXplKHMpLGY9UChcIl9BXCIsblswXS5kYXRhVHlwZSxkKSxoPU4oXCJvdXRwdXRcIixvLGEpLHk9NjQ7bD09PTEmJih5PTI1Nik7bGV0IF89YFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8ZjMyLCAke3l9PjtcbiAgICAgICBgLGI9dz0+YFxuICAgICAgICAke3cucmVnaXN0ZXJVbmlmb3JtKFwicmVkdWNlU2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZixoKX1cbiAgICAgICAgJHtffVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHt3Lm1haW5TdGFydCh5KX1cblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke3l9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7aWhbcl19KTtcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7eX0pIHtcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGYzMigke2YuZ2V0QnlPZmZzZXQoXCJvZmZzZXQgKyBrXCIpfSk7XG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7bmhbcl19O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke3l9dSk7XG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtvaFtyXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHtoLnNldEJ5T2Zmc2V0KFwib3V0cHV0SW5kZXhcIixgJHtyPT09XCJtZWFuXCI/YCR7aC50eXBlLnN0b3JhZ2V9KGJlc3RWYWx1ZSAvIGYzMih1bmlmb3Jtcy5yZWR1Y2VTaXplKSlgOmAke2gudHlwZS5zdG9yYWdlfSgke2FoW3JdfSlgfWApfTtcbiAgICAgICAgIH1cbiAgICAgICAgfWA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHt0fTske3l9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6YixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6bH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnB9XX0pfX0sbnQ9KGUsdCxuLHIpPT57bGV0IG89ZS5pbnB1dHMubGVuZ3RoPT09MT9uOmxvKGUuaW5wdXRzLG4pLGE9by5heGVzO2EubGVuZ3RoPT09MCYmIW8ubm9vcFdpdGhFbXB0eUF4ZXMmJihhPWUuaW5wdXRzWzBdLmRpbXMubWFwKChfLGIpPT5iKSk7bGV0IHM9RS5ub3JtYWxpemVBeGVzKGEsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpLGQ9cyxsPWUuaW5wdXRzWzBdLHA9Y2goZCxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCk7cC5sZW5ndGg+MCYmKGw9ZS5jb21wdXRlKE9lKGUuaW5wdXRzWzBdLHApLHtpbnB1dHM6WzBdLG91dHB1dHM6Wy0xXX0pWzBdLGQ9c2goZC5sZW5ndGgsbC5kaW1zLmxlbmd0aCkpO2xldFtmLGhdPXVoKGwuZGltcyxkKSx5PWY7by5rZWVwRGltcyYmKHk9ZGgoZixzKSksZS5jb21wdXRlKHBoKHQsby5jYWNoZUtleSxbbF0scixlLmlucHV0c1swXS5kYXRhVHlwZSx5LGgpLHtpbnB1dHM6W2xdfSl9LFpzPShlLHQpPT57bnQoZSxcIlJlZHVjZU1lYW5TaGFyZWRcIix0LFwibWVhblwiKX0sUXM9KGUsdCk9PntudChlLFwiUmVkdWNlTDFTaGFyZWRcIix0LFwibDFcIil9LFlzPShlLHQpPT57bnQoZSxcIlJlZHVjZUwyU2hhcmVkXCIsdCxcImwyXCIpfSxYcz0oZSx0KT0+e250KGUsXCJSZWR1Y2VMb2dTdW1FeHBTaGFyZWRcIix0LFwibG9nU3VtRXhwXCIpfSxKcz0oZSx0KT0+e250KGUsXCJSZWR1Y2VNYXhTaGFyZWRcIix0LFwibWF4XCIpfSxldT0oZSx0KT0+e250KGUsXCJSZWR1Y2VNaW5TaGFyZWRcIix0LFwibWluXCIpfSx0dT0oZSx0KT0+e250KGUsXCJSZWR1Y2VQcm9kU2hhcmVkXCIsdCxcInByb2RcIil9LHJ1PShlLHQpPT57bnQoZSxcIlJlZHVjZVN1bVNoYXJlZFwiLHQsXCJzdW1cIil9LG51PShlLHQpPT57bnQoZSxcIlJlZHVjZVN1bVNxdWFyZVNoYXJlZFwiLHQsXCJzdW1TcXVhcmVcIil9LG91PShlLHQpPT57bnQoZSxcIlJlZHVjZUxvZ1N1bVNoYXJlZFwiLHQsXCJsb2dTdW1cIil9fSk7dmFyIG90LG1oLEZyLGxvLGl0LGZoLGhoLGdoLHloLGJoLF9oLHdoLHZoLCRoLHhoLGF0LGF1LHN1LHV1LGR1LGx1LGN1LHB1LG11LGZ1LGh1LEhyPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO2l1KCk7b3Q9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxtaD1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSxGcj0oZSx0LG4scixvLGEscz0hMSxkPSExKT0+e2xldCBsPVtdLHA9blswXS5kaW1zLGY9cC5sZW5ndGgsaD1FLm5vcm1hbGl6ZUF4ZXMobyxmKSx5PSFkJiZoLmxlbmd0aD09PTA7cC5mb3JFYWNoKChTLCQpPT57eXx8aC5pbmRleE9mKCQpPj0wP3MmJmwucHVzaCgxKTpsLnB1c2goUyl9KTtsZXQgXz1sLmxlbmd0aCxiPUUuc2l6ZShsKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOlM9PntsZXQgJD1bXSx2PVAoXCJfQVwiLG5bMF0uZGF0YVR5cGUsZiksVD1OKFwib3V0cHV0XCIsYSxfKSxDPXIodixULGgpLEE9Q1syXTtmb3IobGV0IGs9MCxPPTA7azxmO2srKyl5fHxoLmluZGV4T2Yoayk+PTA/KHMmJk8rKyxBPWBmb3IodmFyIGoke2t9OiB1MzIgPSAwOyBqJHtrfSA8ICR7cFtrXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgICAgICAgICR7Q1syXS5pbmNsdWRlcyhcImxhc3RfaW5kZXhcIik/YGxldCBsYXN0X2luZGV4ID0gaiR7a307YDpcIlwifVxuICAgICAgICAgICAgICAgICAgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsayxgaiR7a31gKX1cbiAgICAgICAgICAgICAgICAgICR7QX1cbiAgICAgICAgICAgICAgICB9YCk6KCQucHVzaChgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsayxULmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLE8pKX07YCksTysrKTtyZXR1cm5gXG5cbiAgICAgICAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh2LFQpfVxuXG4gICAgICAgICR7Uy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3YudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAkeyQuam9pbihgXG5gKX1cbiAgICAgICAgICAke0NbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7Q1sxXX1cbiAgICAgICAgICAke0F9XG4gICAgICAgICAgJHtDWzNdfVxuICAgICAgICAgICR7Qy5sZW5ndGg9PT00P1Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTpDLnNsaWNlKDQpLmpvaW4oYFxuYCl9XG4gICAgICAgIH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6Yn0sLi4uSChwLGwpXX0pfX0sbG89KGUsdCk9PntsZXQgbj1bXTtyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJmVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gocj0+bi5wdXNoKE51bWJlcihyKSkpLHJlKHtheGVzOm4sa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LGl0PShlLHQsbixyKT0+e2xldCBvPWUuaW5wdXRzLGE9by5sZW5ndGg9PT0xP246bG8obyxuKTtlLmNvbXB1dGUoRnIodCx7aGludDphLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtvWzBdXSxhLm5vb3BXaXRoRW1wdHlBeGVzJiZhLmF4ZXMubGVuZ3RoPT09MD9taDpyLGEuYXhlcyxvWzBdLmRhdGFUeXBlLGEua2VlcERpbXMsYS5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0sZmg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxoaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTDFcIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXSl9LGdoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMMlwiLHQsKHIsbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0seWg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGJoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNYXhcIix0LChyLG8sYSk9PntsZXQgcz1bXTtmb3IobGV0IGQ9MDtkPHIucmFuaztkKyspKGEuaW5kZXhPZihkKT49MHx8YS5sZW5ndGg9PT0wKSYmcy5wdXNoKHIuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLDApKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LF9oPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNZWFuXCIsdCwocixvLGEpPT57bGV0IHM9MTtmb3IobGV0IGQ9MDtkPHIucmFuaztkKyspKGEuaW5kZXhPZihkKT49MHx8YS5sZW5ndGg9PT0wKSYmKHMqPWUuaW5wdXRzWzBdLmRpbXNbZF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsYGxldCB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfShzdW0gLyAke3N9KTtgXX0pfSx3aD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTWluXCIsdCwocixvLGEpPT57bGV0IHM9W107Zm9yKGxldCBkPTA7ZDxyLnJhbms7ZCsrKShhLmluZGV4T2YoZCk+PTB8fGEubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSx2aD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlUHJvZFwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LCRoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VTdW1cIix0LChyLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSx4aD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwocixvKT0+W2B2YXIgdCA9ICR7by50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LGF0PShlLHQsbik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuIG47bGV0IHI9MSxvPTE7Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspdC5pbmRleE9mKGEpPT09LTE/cio9ZVthXTpvKj1lW2FdO3JldHVybiBvPDMyJiZyPjEwMjR9LGF1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/X2goZSx0KTpacyhlLHQpfSxzdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2hoKGUsdCk6UXMoZSx0KX0sdXU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9naChlLHQpOllzKGUsdCl9LGR1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/eWgoZSx0KTpYcyhlLHQpfSxsdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2JoKGUsdCk6SnMoZSx0KX0sY3U9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT93aChlLHQpOmV1KGUsdCl9LHB1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/dmgoZSx0KTp0dShlLHQpfSxtdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpPyRoKGUsdCk6cnUoZSx0KX0sZnU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT94aChlLHQpOm51KGUsdCl9LGh1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/ZmgoZSx0KTpvdShlLHQpfX0pO3ZhciBndSx5dSxidSxjbyxfdT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtDZSgpO0hyKCk7Z3U9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0seXU9KGUsdCk9PntndShlLmlucHV0cyk7bGV0IG49KHIsbyxhKT0+e2xldCBzPVtdO2ZvcihsZXQgZD0wO2Q8ci5yYW5rO2QrKykoYS5pbmRleE9mKGQpPj0wfHxhLmxlbmd0aD09PTApJiZzLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEZyKFwiQXJnTWluXCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLG4sW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxidT0oZSx0KT0+e2d1KGUuaW5wdXRzKTtsZXQgbj0ocixvLGEpPT57bGV0IHM9W107Zm9yKGxldCBkPTA7ZDxyLnJhbms7ZCsrKShhLmluZGV4T2YoZCk+PTB8fGEubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoRnIoXCJhcmdNYXhcIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0sbixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGNvPWU9PnJlKGUpfSk7dmFyIFNoLHBvLFRoLENoLEloLFV0LEFoLHd1LHFyPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7VnIoKTtjZSgpO1NoPShlLHQpPT57bGV0IG49ZVswXSxyPWVbMV0sbz1lWzJdLGE9ZVszXSxzPWVbNF0sZD1lWzVdO2lmKHMmJmQpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgYXR0ZW50aW9uX2JpYXNcIik7aWYobi5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO2xldCBsPW4uZGltc1swXSxwPW4uZGltc1sxXSxmPW4uZGltc1syXTtpZihvLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7aWYoci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PWYpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgMSBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMiBvZiBpbnB1dCAwXCIpO2lmKG8uZGltc1swXSE9PXIuZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAxIG9mIGlucHV0IFwid2VpZ2h0c1wiJyk7bGV0IGg9by5kaW1zWzBdLzMseT1oLF89eTtpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aD4wKXtpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50c1wiKTtmb3IobGV0IFQgb2YgdC5xa3ZIaWRkZW5TaXplcylpZihUJXQubnVtSGVhZHMhPT0wKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHNcIik7aD10LnFrdkhpZGRlblNpemVzWzBdLHk9dC5xa3ZIaWRkZW5TaXplc1sxXSxfPXQucWt2SGlkZGVuU2l6ZXNbMl19bGV0IGI9cDtpZihoIT09eSl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZFwiKTtpZihvLmRpbXNbMF0hPT1oK3krXyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtsZXQgdz0wO2lmKHMpe2lmKHkhPT1fKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO2lmKHMuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgbXVzdCBoYXZlIDUgZGltZW5zaW9ucycpO2lmKHMuZGltc1swXSE9PTIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaXJzdCBkaW1lbnNpb24gbXVzdCBiZSAyJyk7aWYocy5kaW1zWzFdIT09bCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplJyk7aWYocy5kaW1zWzJdIT09dC5udW1IZWFkcyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHRoaXJkIGRpbWVuc2lvbiBtdXN0IGJlIG51bV9oZWFkcycpO2lmKHMuZGltc1s0XSE9PXkvdC5udW1IZWFkcyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTt0LnBhc3RQcmVzZW50U2hhcmVCdWZmZXJ8fCh3PXMuZGltc1szXSl9bGV0IFM9Yit3LCQ9LTEsdj0wO2lmKGEpdGhyb3cgbmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpO2lmKHMpdGhyb3cgbmV3IEVycm9yKFwicGFzdCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGQpe2lmKGQuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIG11c3QgaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1sfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT1wfHxkLmRpbXNbM10hPT1TKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6dyxrdlNlcXVlbmNlTGVuZ3RoOmIsdG90YWxTZXF1ZW5jZUxlbmd0aDpTLG1heFNlcXVlbmNlTGVuZ3RoOiQsaW5wdXRIaWRkZW5TaXplOmYsaGlkZGVuU2l6ZTpoLHZIaWRkZW5TaXplOl8saGVhZFNpemU6TWF0aC5mbG9vcihoL3QubnVtSGVhZHMpLHZIZWFkU2l6ZTpNYXRoLmZsb29yKF8vdC5udW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxpc1VuaWRpcmVjdGlvbmFsOiExLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza0ZpbHRlclZhbHVlOnQubWFza0ZpbHRlclZhbHVlLG1hc2tUeXBlOnYsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOiExLHBhc3NQYXN0SW5LdjohMSxxa3ZGb3JtYXQ6MX19LHBvPShlLHQsbik9PnQmJmU/YFxuICAgICAgbGV0IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCA9IHUzMigke3QuZ2V0QnlPZmZzZXQoXCIwXCIpfSk7XG4gICAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSBtYXgodG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0LCB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCk7XG4gICAgICBsZXQgaXNfc3Vic2VxdWVudF9wcm9tcHQ6IGJvb2wgPSBzZXF1ZW5jZV9sZW5ndGggPiAxICYmIHNlcXVlbmNlX2xlbmd0aCAhPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICBsZXQgaXNfZmlyc3RfcHJvbXB0OiBib29sID0gaXNfc3Vic2VxdWVudF9wcm9tcHQgPT0gZmFsc2UgJiYgc2VxdWVuY2VfbGVuZ3RoID09IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHUzMigke2U/LmdldEJ5T2Zmc2V0KFwiYmF0Y2hJZHhcIil9KSArIDE7XG4gICAgICB2YXIgcGFzdF9zZXF1ZW5jZV9sZW5ndGg6IHUzMiA9IDA7XG4gICAgICBpZiAoaXNfZmlyc3RfcHJvbXB0ID09IGZhbHNlKSB7XG4gICAgICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoIC0gc2VxdWVuY2VfbGVuZ3RoO1xuICAgICAgfVxuICAgICAgIGA6YFxuICAgICR7bj9cImxldCBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCI6XCJcIn07XG4gICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGAsVGg9KGUsdCxuLHIsbyxhLHMsZCk9PntsZXQgbD1nZShzPzE6YSkscD02NCxmPWEvbDtmPHAmJihwPTMyKTtsZXQgaD1NYXRoLmNlaWwoYS9sL3ApLHk9W3t0eXBlOjEyLGRhdGE6dH0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpmfSx7dHlwZToxMixkYXRhOmh9XSxfPV9lKGUuZGF0YVR5cGUsbCksYj16ZSgxLGwpLHc9W1widHlwZVwiXTtzJiZ3LnB1c2goXCJ0eXBlXCIpLGQmJncucHVzaChcInR5cGVcIik7bGV0IFM9JD0+e2xldCB2PU4oXCJ4XCIsZS5kYXRhVHlwZSxlLmRpbXMsbCksVD1bdl0sQz1zP1AoXCJzZXFfbGVuc1wiLHMuZGF0YVR5cGUscy5kaW1zKTp2b2lkIDA7QyYmVC5wdXNoKEMpO2xldCBBPWQ/UChcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7QSYmVC5wdXNoKEEpO2xldCBrPXplKGUuZGF0YVR5cGUpLE89W3tuYW1lOlwiYmF0Y2hfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInRvdGFsX3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlbGVtZW50c19wZXJfdGhyZWFkXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7cH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfc3VtOiBhcnJheTxmMzIsICR7cH0+O1xuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhPKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAkeyQubWFpblN0YXJ0KFtwLDEsMV0pfVxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgICR7cG8oQyxBLCExKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gKGdsb2JhbF9pZHggLyAke3B9KSAqIHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aCArIGxvY2FsX29mZnNldDtcbiAgICBsZXQgc2VxX2NhdXNhbF9sZW5ndGggPSAke3M/XCJ1MzIocGFzdF9zZXF1ZW5jZV9sZW5ndGggKyB3b3JrZ3JvdXBfaWQueSArIDEpXCI6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIn07XG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHtifSgtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRocmVhZF9tYXhfdmVjdG9yID0gbWF4KCR7Yn0oeFtvZmZzZXQgKyBpXSksIHRocmVhZF9tYXhfdmVjdG9yKTtcbiAgICB9XG4gICAgdGhyZWFkX21heFtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwidGhyZWFkX21heF92ZWN0b3JcIjtjYXNlIDI6cmV0dXJuXCJtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSlcIjtjYXNlIDQ6cmV0dXJuXCJtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7bH1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4X3ZhbHVlID0gIGYzMigtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtwfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7Yn0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bV92ZWN0b3IgKz0gZXhwKCR7Yn0oeFtvZmZzZXQgKyBpXSkgLSBtYXhfdmFsdWUpO1xuICAgIH1cbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKT0+e3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCJzdW1fdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55XCI7Y2FzZSA0OnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55ICsgc3VtX3ZlY3Rvci56ICsgc3VtX3ZlY3Rvci53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7bH1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgc3VtOiBmMzIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHt2LnR5cGUudmFsdWV9KCR7a30oMS4wKSAvICR7a30oc2VxX2NhdXNhbF9sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHtifSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhfdmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAke3M/YFxuICAgICAgICBmb3IgKHZhciB0b3RhbF9zZXFfaWQ6IHUzMiA9IHNlcV9jYXVzYWxfbGVuZ3RoOyB0b3RhbF9zZXFfaWQgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IHRvdGFsX3NlcV9pZCsrKSB7XG4gICAgICAgICAgeFtvZmZzZXQgKyB0b3RhbF9zZXFfaWRdID0gJHt2LnR5cGUudmFsdWV9KCR7a30oMCkpO1xuICAgICAgICB9YDpcIlwifTtcbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uUHJvYnNTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cH07JHtffTske2x9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W10sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS9wKSx5Om8sejp0Km59LHByb2dyYW1Vbmlmb3Jtczp5fSl9fSxDaD0oZSx0LG4scixvLGEscyxkLGwpPT57bGV0IHA9cythLmt2U2VxdWVuY2VMZW5ndGgsZj1bYS5iYXRjaFNpemUsYS5udW1IZWFkcyxhLnNlcXVlbmNlTGVuZ3RoLHBdLGg9ZT4xJiZyLHk9YS5rdk51bUhlYWRzP2Eua3ZOdW1IZWFkczphLm51bUhlYWRzLF89aD9bYS5iYXRjaFNpemUseSxwLGEuaGVhZFNpemVdOnZvaWQgMCxiPWEublJlcHM/YS5uUmVwczoxLHc9YS5zY2FsZT09PTA/MS9NYXRoLnNxcnQoYS5oZWFkU2l6ZSk6YS5zY2FsZSxTPWdlKGEuaGVhZFNpemUpLCQ9YS5oZWFkU2l6ZS9TLHY9MTIsVD17eDpNYXRoLmNlaWwocC92KSx5Ok1hdGguY2VpbChhLnNlcXVlbmNlTGVuZ3RoL3YpLHo6YS5iYXRjaFNpemUqYS5udW1IZWFkc30sQz1be3R5cGU6MTIsZGF0YTphLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTphLm51bUhlYWRzfSx7dHlwZToxMixkYXRhOmEuaGVhZFNpemV9LHt0eXBlOjEsZGF0YTp3fSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6YS5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOmJ9XSxBPWgmJnImJkUuc2l6ZShyLmRpbXMpPjAsaz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO0EmJmsucHVzaChcInR5cGVcIiksbyYmay5wdXNoKFwidHlwZVwiKSxkJiZrLnB1c2goXCJ0eXBlXCIpLGwmJmsucHVzaChcInR5cGVcIik7bGV0IE89W3tkaW1zOmYsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07aCYmTy5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IE09Vj0+e2xldCBGPVAoXCJxXCIsdC5kYXRhVHlwZSx0LmRpbXMsUyksaj1QKFwia2V5XCIsbi5kYXRhVHlwZSxuLmRpbXMsUyksbmU9W0Ysal07aWYoQSl7bGV0IFo9UChcInBhc3Rfa2V5XCIsci5kYXRhVHlwZSxyLmRpbXMsUyk7bmUucHVzaChaKX1vJiZuZS5wdXNoKFAoXCJhdHRlbnRpb25fYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zKSk7bGV0IFc9ZD9QKFwic2VxX2xlbnNcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO1cmJm5lLnB1c2goVyk7bGV0IEo9bD9QKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsbC5kYXRhVHlwZSxsLmRpbXMpOnZvaWQgMDtKJiZuZS5wdXNoKEopO2xldCB2ZT1OKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxmKSxRPVt2ZV07aCYmUS5wdXNoKE4oXCJwcmVzZW50X2tleVwiLHQuZGF0YVR5cGUsXyxTKSk7bGV0IGVlPXplKDEsUyksbGU9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3Z9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtGLnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke0YudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgJHtWLnJlZ2lzdGVyVW5pZm9ybXMobGUpLmRlY2xhcmVWYXJpYWJsZXMoLi4ubmUsLi4uUSl9XG4gICR7Vi5tYWluU3RhcnQoW3YsdiwxXSl9XG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGt2SGVhZElkeCA9ICR7Yj09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBrdl9udW1faGVhZHMgPSAke2I9PT0xP1widW5pZm9ybXMubnVtX2hlYWRzXCI6XCJ1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xuICAgICR7cG8oVyxKLCEwKX1cbiAgICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7XG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICAgJHtBJiZoP1wibGV0IHBhc3RLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XCI6XCJcIn07XG4gICAgbGV0IGtPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1xuICAgICR7aD9cImxldCBwcmVzZW50S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLks7XCI6XCJcIn1cbiAgICB2YXIgdmFsdWUgPSAke2VlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBxW3FPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICR7QSYmaD9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWB9XG4gICAgICAke2g/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke2VlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKFMpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7U31gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3ZlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke1N9OyR7byE9PXZvaWQgMH07JHtyIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczprfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6TyxkaXNwYXRjaEdyb3VwOlQscHJvZ3JhbVVuaWZvcm1zOkN9KSxnZXRTaGFkZXJTb3VyY2U6TX19LEloPShlLHQsbixyLG8sYSxzPXZvaWQgMCxkPXZvaWQgMCk9PntsZXQgbD1hK28ua3ZTZXF1ZW5jZUxlbmd0aCxwPW8ublJlcHM/by5uUmVwczoxLGY9by52SGlkZGVuU2l6ZSpwLGg9ZT4xJiZyLHk9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLF89aD9bby5iYXRjaFNpemUseSxsLG8uaGVhZFNpemVdOnZvaWQgMCxiPVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLGZdLHc9MTIsUz17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvdykseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC93KSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LCQ9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTpmfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnB9XSx2PWgmJnImJkUuc2l6ZShyLmRpbXMpPjAsVD1bXCJ0eXBlXCIsXCJ0eXBlXCJdO3YmJlQucHVzaChcInR5cGVcIikscyYmVC5wdXNoKFwidHlwZVwiKSxkJiZULnB1c2goXCJ0eXBlXCIpO2xldCBDPVt7ZGltczpiLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO2gmJkMucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBBPWs9PntsZXQgTz1QKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksTT1QKFwidlwiLG4uZGF0YVR5cGUsbi5kaW1zKSxWPVtPLE1dO3YmJlYucHVzaChQKFwicGFzdF92YWx1ZVwiLHIuZGF0YVR5cGUsci5kaW1zKSk7bGV0IEY9cz9QKFwic2VxX2xlbnNcIixzLmRhdGFUeXBlLHMuZGltcyk6dm9pZCAwO3MmJlYucHVzaChGKTtsZXQgaj1kP1AoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO2QmJlYucHVzaChqKTtsZXQgVz1bTihcIm91dHB1dFwiLHQuZGF0YVR5cGUsYildO2gmJlcucHVzaChOKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsXykpO2xldCBKPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3d9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7Ty50eXBlLnZhbHVlfSwgJHt3Knd9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7Ty50eXBlLnZhbHVlfSwgJHt3Knd9PjtcbiAgJHtrLnJlZ2lzdGVyVW5pZm9ybXMoSikuZGVjbGFyZVZhcmlhYmxlcyguLi5WLC4uLlcpfVxuICAke2subWFpblN0YXJ0KFt3LHcsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7cD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7cD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7cG8oRixqLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke3YmJmg/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke2g/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke08udHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAke3YmJmg/YFxuICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwYXN0X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSBwYXN0X3ZhbHVlW3Bhc3RWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfSBlbHNlIGlmICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9XG4gICAgICBgOmBcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICAgICAgfWB9XG4gICAgICAgICR7aD9gXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHByZXNlbnRfdmFsdWVbcHJlc2VudFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dID0gdGlsZVZbaWR4XTtcbiAgICAgICAgfWA6XCJcIn1cbiAgICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IGsrKykge1xuICAgICAgIHZhbHVlICs9IHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVWW1RJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54XTtcbiAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICB9XG5cbiAgIC8vIHdlIG5lZWQgdG8gdHJhbnNwb3NlIG91dHB1dCBmcm9tIEJOU0hfdiB0byBCU05EX3ZcbiAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICBsZXQgb3V0cHV0SWR4ID0gYmF0Y2hJZHggKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZSArIG0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplXG4gICAgICAgKyBoZWFkSWR4ICogdW5pZm9ybXMuTiArIG47XG4gICAgIG91dHB1dFtvdXRwdXRJZHhdID0gdmFsdWU7XG4gICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblNjb3JlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ciE9PXZvaWQgMH07JHtlfWAsaW5wdXREZXBlbmRlbmNpZXM6VH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkMsZGlzcGF0Y2hHcm91cDpTLHByb2dyYW1Vbmlmb3JtczokfSksZ2V0U2hhZGVyU291cmNlOkF9fSxVdD0oZSx0LG4scixvLGEscyxkLGwscCxmPXZvaWQgMCxoPXZvaWQgMCk9PntsZXQgeT1NYXRoLm1pbihlLm91dHB1dENvdW50LDErKHM/MTowKSsoZD8xOjApKSxfPXk+MT9wLnBhc3RTZXF1ZW5jZUxlbmd0aDowLGI9XytwLmt2U2VxdWVuY2VMZW5ndGgsdz1sJiZFLnNpemUobC5kaW1zKT4wP2w6dm9pZCAwLFM9W3Qsbl07eT4xJiZzJiZFLnNpemUocy5kaW1zKT4wJiZTLnB1c2gocyksdyYmUy5wdXNoKHcpLGYmJlMucHVzaChmKSxoJiZTLnB1c2goaCk7bGV0ICQ9ZS5jb21wdXRlKENoKHksdCxuLHMsdyxwLF8sZixoKSx7aW5wdXRzOlMsb3V0cHV0czp5PjE/Wy0xLDFdOlstMV19KVswXTtlLmNvbXB1dGUoVGgoJCxwLmJhdGNoU2l6ZSxwLm51bUhlYWRzLF8scC5zZXF1ZW5jZUxlbmd0aCxiLGYsaCkse2lucHV0czpmJiZoP1skLGYsaF06WyRdLG91dHB1dHM6W119KTtsZXQgdj1bJCxyXTt5PjEmJmQmJkUuc2l6ZShkLmRpbXMpPjAmJnYucHVzaChkKSxmJiZ2LnB1c2goZiksaCYmdi5wdXNoKGgpLGUuY29tcHV0ZShJaCh5LCQscixkLHAsXyxmLGgpLHtpbnB1dHM6dixvdXRwdXRzOnk+MT9bMCwyXTpbMF19KX0sQWg9KGUsdCk9PntsZXQgbj1bdC5iYXRjaFNpemUsdC5udW1IZWFkcyx0LnNlcXVlbmNlTGVuZ3RoLHQuaGVhZFNpemVdLHI9dC5zZXF1ZW5jZUxlbmd0aCxvPXQuaW5wdXRIaWRkZW5TaXplLGE9dC5oZWFkU2l6ZSxzPTEyLGQ9e3g6TWF0aC5jZWlsKHQuaGVhZFNpemUvcykseTpNYXRoLmNlaWwodC5zZXF1ZW5jZUxlbmd0aC9zKSx6OnQuYmF0Y2hTaXplKnQubnVtSGVhZHN9LGw9W2UuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxwPVt7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnQubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6dC5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemV9LHt0eXBlOjEyLGRhdGE6dC5oaWRkZW5TaXplK3QuaGlkZGVuU2l6ZSt0LnZIaWRkZW5TaXplfV0sZj1oPT57bGV0IHk9TihcIm91dHB1dF9xXCIsbFswXS5kYXRhVHlwZSxuKSxfPU4oXCJvdXRwdXRfa1wiLGxbMF0uZGF0YVR5cGUsbiksYj1OKFwib3V0cHV0X3ZcIixsWzBdLmRhdGFUeXBlLG4pLHc9UChcImlucHV0XCIsbFswXS5kYXRhVHlwZSxsWzBdLmRpbXMpLFM9UChcIndlaWdodFwiLGxbMV0uZGF0YVR5cGUsbFsxXS5kaW1zKSwkPVAoXCJiaWFzXCIsbFsyXS5kYXRhVHlwZSxsWzJdLmRpbXMpLHY9dy50eXBlLnN0b3JhZ2UsVD1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImxkYlwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgY29uc3QgVElMRV9TSVpFID0gJHtzfXU7XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVJbnB1dDogYXJyYXk8JHt2fSwgJHtzKnN9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFE6IGFycmF5PCR7dn0sICR7cypzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRLOiBhcnJheTwke3Z9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0VjogYXJyYXk8JHt2fSwgJHtzKnN9PjtcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybXMoVCkuZGVjbGFyZVZhcmlhYmxlcyh3LFMsJCx5LF8sYil9XG4gICR7aC5tYWluU3RhcnQoW3MscywxXSl9XG4gICAgbGV0IGJhdGNoSW5kZXggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZE51bWJlciA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICAgbGV0IG4gPSBnbG9iYWxfaWQueDtcblxuICAgIGxldCBpbnB1dE9mZnNldCA9IGJhdGNoSW5kZXggKiAodW5pZm9ybXMuTSAqIHVuaWZvcm1zLkspICsgbSAqIHVuaWZvcm1zLks7XG4gICAgbGV0IGJpYXNPZmZzZXRRID0gaGVhZE51bWJlciAqIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICBsZXQgYmlhc09mZnNldEsgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRRO1xuICAgIGxldCBiaWFzT2Zmc2V0ViA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldEs7XG5cbiAgICB2YXIgdmFsdWVRID0gJHt2fSgwKTtcbiAgICB2YXIgdmFsdWVLID0gJHt2fSgwKTtcbiAgICB2YXIgdmFsdWVWID0gJHt2fSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVJbnB1dFtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBpbnB1dFtpbnB1dE9mZnNldCArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgbGV0IG9mZnNldCA9IG4gKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMubGRiO1xuICAgICAgICB0aWxlV2VpZ2h0UVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFEgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0S1tUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldEsgKyBvZmZzZXRdO1xuICAgICAgICB0aWxlV2VpZ2h0VltUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSB3ZWlnaHRbYmlhc09mZnNldFYgKyBvZmZzZXRdO1xuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGs8VElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICBsZXQgaW5wdXRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGs7XG4gICAgICAgIGxldCB3ZWlnaHRUaWxlT2Zmc2V0ID0gVElMRV9TSVpFICogayArIGxvY2FsX2lkLng7XG4gICAgICAgIHZhbHVlUSArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRRW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZUsgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0S1t3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVWICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFZbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBsZXQgaGVhZE9mZnNldCA9IChtICogdW5pZm9ybXMuTiArIG4pICUgdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIHZhbHVlUSArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0UV07XG4gICAgdmFsdWVLICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRLXTtcbiAgICB2YWx1ZVYgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFZdO1xuXG4gICAgbGV0IG9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gb2Zmc2V0ICsgbSAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICAgb3V0cHV0X3Fbb3V0cHV0SWR4XSA9IHZhbHVlUTtcbiAgICAgIG91dHB1dF9rW291dHB1dElkeF0gPSB2YWx1ZUs7XG4gICAgICBvdXRwdXRfdltvdXRwdXRJZHhdID0gdmFsdWVWO1xuICAgIH1cbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJBdHRlbnRpb25QcmVwYXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpuLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOm4sZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6ZCxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTpmfSx7aW5wdXRzOmwsb3V0cHV0czpbLTEsLTEsLTFdfSl9LHd1PShlLHQpPT57bGV0IG49U2goZS5pbnB1dHMsdCksW3IsbyxhXT1BaChlLG4pO3JldHVybiBVdChlLHIsbyxhLGUuaW5wdXRzWzRdLHZvaWQgMCx2b2lkIDAsdm9pZCAwLGUuaW5wdXRzWzVdLG4pfX0pO3ZhciBraCxFaCxQaCx2dSwkdT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt0ZSgpO2FlKCk7Q2UoKTtjZSgpO2toPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gcmVxdWlyZXMgNSBpbnB1dHNcIik7bGV0IG49KHIsbyxhKT0+e2xldCBzPW8ubGVuZ3RoO2lmKHMhPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYCR7YX06IG51bSBkaW1lbnNpb25zICE9ICR7c31gKTtvLmZvckVhY2goKGQsbCk9PntpZihkIT09cltsXSl0aHJvdyBuZXcgRXJyb3IoYCR7YX06IGRpbVske2x9XSBkbyBub3QgbWF0Y2hgKX0pfTtpZihlWzBdLmRpbXMubGVuZ3RoPjEpe2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCI/dC5zcGF0aWFsP2VbMF0uZGltcy5zbGljZSgtMSk6ZVswXS5kaW1zLnNsaWNlKC0xKS5jb25jYXQoZVswXS5kaW1zLnNsaWNlKDEsZVswXS5kaW1zLmxlbmd0aC0xKSk6ZVswXS5kaW1zLnNsaWNlKDEsdC5zcGF0aWFsPzI6dm9pZCAwKTtuKGVbMV0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxuKGVbMl0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCBCXCIpLG4oZVszXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IG1lYW5cIiksbihlWzRdLmRpbXMscixcIkludmFsaWQgaW5wdXQgdmFyXCIpfWVsc2UgbihlWzFdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBzY2FsZVwiKSxuKGVbMl0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IEJcIiksbihlWzNdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLG4oZVs0XS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgdmFyXCIpfSxFaD0oZSx0KT0+e2xldHtlcHNpbG9uOm4sc3BhdGlhbDpyLGZvcm1hdDpvfT10LGE9ZVswXS5kaW1zLHM9cj9nZShhW2EubGVuZ3RoLTFdKToxLGQ9bz09PVwiTkhXQ1wiJiZhLmxlbmd0aD4xP3M6MSxsPUUuc2l6ZShhKS9zLHA9cixmPXA/YS5sZW5ndGg6YSxoPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMscykseT1QKFwic2NhbGVcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyxkKSxfPVAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsZCksYj1QKFwiaW5wdXRNZWFuXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMsZCksdz1QKFwiaW5wdXRWYXJcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcyxkKSxTPU4oXCJ5XCIsZVswXS5kYXRhVHlwZSxmLHMpLCQ9KCk9PntsZXQgVD1cIlwiO2lmKHIpVD1gbGV0IGNPZmZzZXQgPSAke2EubGVuZ3RoPT09MT9cIjB1XCI6bz09PVwiTkhXQ1wiP2BvdXRwdXRJbmRpY2VzWyR7YS5sZW5ndGgtMX1dIC8gJHtzfWA6XCJvdXRwdXRJbmRpY2VzWzFdXCJ9O2A7ZWxzZSBpZihvPT09XCJOQ0hXXCIpVD1gXG4gICAgICAgICAgICAke1MuaW5kaWNlc1NldChcIm91dHB1dEluZGljZXNcIixcIjBcIixcIjBcIil9XG4gICAgICAgICAgICBsZXQgY09mZnNldCA9ICR7Uy5pbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIpfTtgO2Vsc2V7VD1gdmFyIGNJbmRpY2VzID0gJHt5LnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgIGNJbmRpY2VzWzBdID0gb3V0cHV0SW5kaWNlc1ske2EubGVuZ3RoLTF9XTtgO2ZvcihsZXQgQz0xO0M8eS5yYW5rO0MrKylUKz1gY0luZGljZXNbJHtDfV0gPSBvdXRwdXRJbmRpY2VzWyR7Q31dO2A7VCs9YGxldCBjT2Zmc2V0ID0gJHt5LmluZGljZXNUb09mZnNldChcImNJbmRpY2VzXCIpfTtgfXJldHVybiBUfSx2PVQ9PmBcbiAgY29uc3QgZXBzaWxvbiA9ICR7bn07XG4gICR7VC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLHksXyxiLHcsUyl9XG4gICR7VC5tYWluU3RhcnQoKX1cbiAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7c31gKX07XG4gICAgJHskKCl9XG4gICAgbGV0IHNjYWxlID0gJHt5LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGJpYXMgPSAke18uZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRNZWFuID0gJHtiLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0VmFyID0gJHt3LmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IHggPSAke2guZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgdmFsdWUgPSAoeCAtIGlucHV0TWVhbikgKiBpbnZlcnNlU3FydChpbnB1dFZhciArIGVwc2lsb24pICogc2NhbGUgKyBiaWFzO1xuICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YDtyZXR1cm57bmFtZTpcIkJhdGNoTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuZXBzaWxvbn1fJHt0LmZvcm1hdH1fJHtyfV8ke3N9YCxpbnB1dERlcGVuZGVuY2llczpwP1tcInJhbmtcIixcInR5cGVcIixcInR5cGVcIixcInR5cGVcIixcInR5cGVcIl06dm9pZCAwfSxnZXRTaGFkZXJTb3VyY2U6dixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpwP1t7dHlwZToxMixkYXRhOmx9LC4uLkgoYSldOlt7dHlwZToxMixkYXRhOmx9XX0pfX0sUGg9ZT0+cmUoZSksdnU9KGUsdCk9PntsZXR7aW5wdXRzOm4sb3V0cHV0Q291bnQ6cn09ZSxvPVBoKHsuLi50LG91dHB1dENvdW50OnJ9KTtpZih3ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJmtoKG4sbyksdC50cmFpbmluZ01vZGUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHRyYWluaW5nTW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cIik7ZS5jb21wdXRlKEVoKG4sbykpfX0pO3ZhciB6aCxPaCx4dSxTdT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWUoKTtjZSgpO3poPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVszMjAsNjQwLDEyODBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwibnVtYmVyIG9mIGNoYW5uZWxzIHNob3VsZCBiZSAzMjAsIDY0MCBvciAxMjgwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LE9oPWU9PntsZXQgdD1lWzBdLmRpbXMsbj1lWzBdLmRpbXNbMl0scj1FLnNpemUodCkvNCxvPWVbMF0uZGF0YVR5cGUsYT1QKFwiaW5wdXRcIixvLHQsNCkscz1QKFwiYmlhc1wiLG8sW25dLDQpLGQ9UChcInJlc2lkdWFsXCIsbyx0LDQpLGw9TihcIm91dHB1dFwiLG8sdCw0KTtyZXR1cm57bmFtZTpcIkJpYXNBZGRcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpmPT5gXG4gIGNvbnN0IGNoYW5uZWxzID0gJHtufXUgLyA0O1xuICAke2YuZGVjbGFyZVZhcmlhYmxlcyhhLHMsZCxsKX1cblxuICAke2YubWFpblN0YXJ0KCl9XG4gICAgJHtmLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMocil9XG4gICAgbGV0IHZhbHVlID0gJHthLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX1cbiAgICAgICsgJHtzLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAlIGNoYW5uZWxzXCIpfSArICR7ZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH19LHh1PWU9Pnt6aChlLmlucHV0cyksZS5jb21wdXRlKE9oKGUuaW5wdXRzKSl9fSk7dmFyIERoLHllLFR1LEN1LEl1LEF1LGt1LEV1LFB1LHp1LE91LEJoLER1LEJ1LE11LFJ1LHRyLFV1LEtyLE51LFZ1LFd1LEx1LEd1LEh1LEZ1LHF1LEt1LGp1LFp1LFF1LFl1LFh1LEp1LGVkLHRkLHJkLG1vLGZvLG5kLG9kLGlkLE1oLFJoLGFkLGpyPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0RoPShlLHQsbixyLG8sYSxzKT0+e2xldCBkPU1hdGguY2VpbCh0LzQpLGw9XCJcIjt0eXBlb2Ygbz09XCJzdHJpbmdcIj9sPWAke299KGEpYDpsPW8oXCJhXCIpO2xldCBwPVAoXCJpbnB1dERhdGFcIixuLFtkXSw0KSxmPU4oXCJvdXRwdXREYXRhXCIscixbZF0sNCksaD1be25hbWU6XCJ2ZWNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybiBzJiZoLnB1c2goLi4ucyksYFxuICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMoaCkuZGVjbGFyZVZhcmlhYmxlcyhwLGYpfVxuXG4gICR7YT8/XCJcIn1cblxuICAke2UubWFpblN0YXJ0KCl9XG4gICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cblxuICAgIGxldCBhID0gJHtwLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtmLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGwpfVxuICB9YH0seWU9KGUsdCxuLHIsbyxhPWUuZGF0YVR5cGUscyxkKT0+e2xldCBsPVt7dHlwZToxMixkYXRhOk1hdGguY2VpbChFLnNpemUoZS5kaW1zKS80KX1dO3JldHVybiBzJiZsLnB1c2goLi4ucykse25hbWU6dCxzaGFkZXJDYWNoZTp7aGludDpvLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTpwPT5EaChwLEUuc2l6ZShlLmRpbXMpLGUuZGF0YVR5cGUsYSxuLHIsZCksZ2V0UnVuRGF0YTpwPT4oe291dHB1dHM6W3tkaW1zOmUuZGltcyxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRS5zaXplKHBbMF0uZGltcykvNjQvNCl9LHByb2dyYW1Vbmlmb3JtczpsfSl9fSxUdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQWJzXCIsXCJhYnNcIikpfSxDdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQWNvc1wiLFwiYWNvc1wiKSl9LEl1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBY29zaFwiLFwiYWNvc2hcIikpfSxBdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQXNpblwiLFwiYXNpblwiKSl9LGt1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBc2luaFwiLFwiYXNpbmhcIikpfSxFdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQXRhblwiLFwiYXRhblwiKSl9LFB1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBdGFuaFwiLFwiYXRhbmhcIikpfSx6dT1lPT5yZShlKSxPdT0oZSx0KT0+e2xldCBuO3N3aXRjaCh0LnRvKXtjYXNlIDEwOm49XCJ2ZWM0PGYxNj5cIjticmVhaztjYXNlIDE6bj1cInZlYzQ8ZjMyPlwiO2JyZWFrO2Nhc2UgMTI6bj1cInZlYzQ8dTMyPlwiO2JyZWFrO2Nhc2UgNjpuPVwidmVjNDxpMzI+XCI7YnJlYWs7Y2FzZSA5Om49XCJ2ZWM0PGJvb2w+XCI7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgUmFuZ2VFcnJvcihgbm90IHN1cHBvcnRlZCB0eXBlIChzcGVjaWZpZWQgaW4gYXR0cmlidXRlICd0bycgZnJvbSAnQ2FzdCcgb3BlcmF0b3IpOiAke3QudG99YCl9ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQ2FzdFwiLG4sdm9pZCAwLHQuY2FjaGVLZXksdC50bykpfSxCaD1lPT57bGV0IHQsbixyPWUubGVuZ3RoPj0yJiZlWzFdLmRhdGEhPT0wLG89ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YSE9PTA7c3dpdGNoKGVbMF0uZGF0YVR5cGUpe2Nhc2UgMTp0PXI/ZVsxXS5nZXRGbG9hdDMyQXJyYXkoKVswXTotMzQwMjgyMzQ2NjM4NTI4ODZlMjIsbj1vP2VbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MzQwMjgyMzQ2NjM4NTI4ODZlMjI7YnJlYWs7Y2FzZSAxMDp0PXI/ZVsxXS5nZXRVaW50MTZBcnJheSgpWzBdOjY0NTExLG49bz9lWzJdLmdldFVpbnQxNkFycmF5KClbMF06MzE3NDM7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnQgZGF0YSB0eXBlXCIpfXJldHVybiByZSh7bWluOnQsbWF4Om59KX0sRHU9KGUsdCk9PntsZXQgbj10fHxCaChlLmlucHV0cykscj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQ2xpcFwiLG89PmBjbGFtcCgke299LCB2ZWM0PCR7cn0+KHVuaWZvcm1zLm1pbiksIHZlYzQ8JHtyfT4odW5pZm9ybXMubWF4KSlgLHZvaWQgMCxuLmNhY2hlS2V5LHZvaWQgMCxbe3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpuLm1pbn0se3R5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZGF0YTpuLm1heH1dLFt7bmFtZTpcIm1pblwiLHR5cGU6cn0se25hbWU6XCJtYXhcIix0eXBlOnJ9XSkse2lucHV0czpbMF19KX0sQnU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkNlaWxcIixcImNlaWxcIikpfSxNdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQ29zXCIsXCJjb3NcIikpfSxSdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQ29zaFwiLFwiY29zaFwiKSl9LHRyPWU9PnJlKGUpLFV1PShlLHQpPT57bGV0IG49emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkVsdVwiLHI9PmBlbHVfdmYzMigke3J9KWAsYFxuICBjb25zdCBlbHVfYWxwaGFfID0gJHtufSgke3QuYWxwaGF9KTtcblxuICBmbiBlbHVfZjMyKGE6ICR7bn0pIC0+ICR7bn0ge1xuICByZXR1cm4gc2VsZWN0KChleHAoYSkgLSAxLjApICogZWx1X2FscGhhXywgYSwgYSA+PSAwLjApO1xuICB9XG5cbiAgZm4gZWx1X3ZmMzIodjogdmVjNDwke259PikgLT4gdmVjNDwke259PiB7XG4gIHJldHVybiB2ZWM0KGVsdV9mMzIodi54KSwgZWx1X2YzMih2LnkpLCBlbHVfZjMyKHYueiksIGVsdV9mMzIodi53KSk7XG4gIH1gLHQuY2FjaGVLZXkpKX0sS3I9KGU9XCJmMzJcIik9PmBcbmNvbnN0IHIwOiAke2V9ID0gMC4zMjc1OTExO1xuY29uc3QgcjE6ICR7ZX0gPSAwLjI1NDgyOTU5MjtcbmNvbnN0IHIyOiAke2V9ID0gLTAuMjg0NDk2NzM2O1xuY29uc3QgcjM6ICR7ZX0gPSAxLjQyMTQxMzc0MTtcbmNvbnN0IHI0OiAke2V9ID0gLTEuNDUzMTUyMDI3O1xuY29uc3QgcjU6ICR7ZX0gPSAxLjA2MTQwNTQyOTtcblxuZm4gZXJmX3ZmMzIodjogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIGxldCBhYnN2ID0gYWJzKHYpO1xuICBsZXQgeCA9IDEuMCAvICgxLjAgKyByMCAqIGFic3YpO1xuICByZXR1cm4gc2lnbih2KSAqICgxLjAgLSAoKCgocjUgKiB4ICsgcjQpICogeCArIHIzKSAqIHggKyByMikgKiB4ICsgcjEpICogeCAqIGV4cCgtYWJzdiAqIGFic3YpKTtcbn1gLE51PWU9PntsZXQgdD16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiRXJmXCIsbj0+YGVyZl92ZjMyKCR7bn0pYCxLcih0KSkpfSxWdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiRXhwXCIsXCJleHBcIikpfSxXdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiRmxvb3JcIixcImZsb29yXCIpKX0sTHU9ZT0+e2xldCB0PXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJHZWx1XCIsbj0+YDAuNSAqICR7bn0gKiAoMS4wICsgZXJmX3ZmMzIoJHtufSAqIDAuNzA3MTA2NzgxMTg2NTQ3NSkpYCxLcih0KSkpfSxHdT0oZSx0KT0+e2xldCBuPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJMZWFreVJlbHVcIixyPT5gc2VsZWN0KGxlYWt5X3JlbHVfYWxwaGFfICogJHtyfSwgJHtyfSwgJHtyfSA+PSB2ZWM0PCR7bn0+KDAuMCkpYCxgY29uc3QgbGVha3lfcmVsdV9hbHBoYV8gPSAke259KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpfSxIdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiTm90XCIsdD0+YCEke3R9YCkpfSxGdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiTmVnXCIsdD0+YC0ke3R9YCkpfSxxdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiUmVjaXByb2NhbFwiLHQ9PmAxLjAvJHt0fWApKX0sS3U9ZT0+e2xldCB0PXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJSZWx1XCIsbj0+YHNlbGVjdCh2ZWM0PCR7dH0+KDAuMCksICR7bn0sICR7bn0gPiB2ZWM0PCR7dH0+KDAuMCkpYCkpfSxqdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiU2lnbW9pZFwiLHQ9PmAoMS4wIC8gKDEuMCArIGV4cCgtJHt0fSkpKWApKX0sWnU9ZT0+cmUoZSksUXU9KGUsdCk9PntsZXQgbj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiSGFyZFNpZ21vaWRcIixyPT5gbWF4KHZlYzQ8JHtufT4oMC4wKSwgbWluKHZlYzQ8JHtufT4oMS4wKSwgJHt0LmFscGhhfSAqICR7cn0gKyB2ZWM0PCR7bn0+KCR7dC5iZXRhfSkpKWAsdm9pZCAwLHQuY2FjaGVLZXkpKX0sWXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlNpblwiLFwic2luXCIpKX0sWHU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlNpbmhcIixcInNpbmhcIikpfSxKdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiU3FydFwiLFwic3FydFwiKSl9LGVkPWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJUYW5cIixcInRhblwiKSl9LHRkPWU9PmBzaWduKCR7ZX0pICogKDEgLSBleHAoLTIgKiBhYnMoJHtlfSkpKSAvICgxICsgZXhwKC0yICogYWJzKCR7ZX0pKSlgLHJkPWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJUYW5oXCIsdGQpKX0sbW89KGU9XCJmMzJcIik9PmBcbmNvbnN0IGZhc3RfZ2VsdV9hOiAke2V9ID0gMC41O1xuY29uc3QgZmFzdF9nZWx1X2I6ICR7ZX0gPSAwLjc5Nzg4NDU2MDgwMjg2NTQ7XG5jb25zdCBmYXN0X2dlbHVfYzogJHtlfSA9IDAuMDM1Njc3NDA4MTM2MzAwMTI1O1xuXG5mbiB0YW5oX3YodjogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIHJldHVybiAke3RkKFwidlwiKX07XG59XG5gLGZvPWU9PmAoZmFzdF9nZWx1X2EgKyBmYXN0X2dlbHVfYSAqIHRhbmhfdigke2V9ICogKGZhc3RfZ2VsdV9jICogJHtlfSAqICR7ZX0gKyBmYXN0X2dlbHVfYikpKSAqICR7ZX1gLG5kPWU9PntsZXQgdD16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiRmFzdEdlbHVcIixmbyxtbyh0KSx2b2lkIDAsZS5pbnB1dHNbMF0uZGF0YVR5cGUpKX0sb2Q9KGUsdCk9PntsZXQgbj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7cmV0dXJuIGUuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlRocmVzaG9sZGVkUmVsdVwiLHI9PmBzZWxlY3QodmVjNDwke259PigwLjApLCAke3J9LCAke3J9ID4gdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8pYCxgY29uc3QgdGhyZXNob2xkZWRfcmVsdV9hbHBoYV8gPSB2ZWM0PCR7bn0+KCR7dC5hbHBoYX0pO2AsdC5jYWNoZUtleSkpLDB9LGlkPWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJMb2dcIixcImxvZ1wiKSl9LE1oPShlLHQpPT5gXG5jb25zdCBhbHBoYSA9IHZlYzQ8JHtlfT4oJHt0fSk7XG5jb25zdCBvbmUgPSAke2V9KDEuMCk7XG5jb25zdCB6ZXJvID0gJHtlfSgwLjApO1xuXG5mbiBxdWlja19nZWx1X2ltcGwoeDogdmVjNDwke2V9PikgLT4gdmVjNDwke2V9PiB7XG4gIGxldCB2ID0geCAqYWxwaGE7XG4gIHZhciB4MSA6IHZlYzQ8JHtlfT47XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XG4gICAgaWYgKHZbaV0gPj0gemVybykge1xuICAgICAgeDFbaV0gPSBvbmUgLyAob25lICsgZXhwKC12W2ldKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHgxW2ldID0gb25lIC0gb25lIC8gKG9uZSArIGV4cCh2W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB4ICogeDE7XG59XG5gLFJoPWU9PmBxdWlja19nZWx1X2ltcGwoJHtlfSlgLGFkPShlLHQpPT57bGV0IG49emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlF1aWNrR2VsdVwiLFJoLE1oKG4sdC5hbHBoYSksdC5jYWNoZUtleSxlLmlucHV0c1swXS5kYXRhVHlwZSkpfX0pO3ZhciBVaCxOaCx1ZCxkZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWUoKTtjZSgpO2pyKCk7VWg9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzI1NjAsNTEyMCwxMDI0MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJoaWRkZW4gc3RhdGUgc2hvdWxkIGJlIDI1NjAsIDUxMjAgb3IgMTAyNDBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sTmg9ZT0+e2xldCB0PWVbMF0uZGltcy5zbGljZSgpO3RbMl09dFsyXS8yO2xldCBuPVAoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLDQpLHI9UChcImJpYXNcIixlWzBdLmRhdGFUeXBlLFtlWzBdLmRpbXNbMl1dLDQpLG89TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdCw0KSxhPUUuc2l6ZSh0KS80LHM9X2UoZVswXS5kYXRhVHlwZSk7cmV0dXJue25hbWU6XCJCaWFzU3BsaXRHZWx1XCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bD0+YFxuICBjb25zdCBNX1NRUlQyID0gc3FydCgyLjApO1xuICBjb25zdCBoYWxmQ2hhbm5lbHMgPSAke2VbMF0uZGltc1syXS80LzJ9dTtcblxuICAke2wuZGVjbGFyZVZhcmlhYmxlcyhuLHIsbyl9XG5cbiAgJHtLcihzKX1cblxuICAke2wubWFpblN0YXJ0KCl9XG4gICAgJHtsLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoYSl9XG4gICAgbGV0IGJpYXNJZHggPSBnbG9iYWxfaWR4ICUgaGFsZkNoYW5uZWxzO1xuICAgIGxldCBiYXRjaEluZGV4ID0gZ2xvYmFsX2lkeCAvIGhhbGZDaGFubmVscztcbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiaWFzSWR4ICsgYmF0Y2hJbmRleCAqIGhhbGZDaGFubmVscyAqIDI7XG4gICAgbGV0IHZhbHVlTGVmdCA9IGlucHV0W2lucHV0T2Zmc2V0XSArIGJpYXNbYmlhc0lkeF07XG4gICAgbGV0IHZhbHVlUmlnaHQgPSBpbnB1dFtpbnB1dE9mZnNldCArIGhhbGZDaGFubmVsc10gKyBiaWFzW2JpYXNJZHggKyBoYWxmQ2hhbm5lbHNdO1xuICAgIGxldCBnZWx1UmlnaHQgPSB2YWx1ZVJpZ2h0ICogMC41ICogKGVyZl92ZjMyKHZhbHVlUmlnaHQgLyBNX1NRUlQyKSArIDEpO1xuXG4gICAgJHtvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVMZWZ0ICogZ2VsdVJpZ2h0XCIpfVxuICB9YH19LHVkPWU9PntVaChlLmlucHV0cyksZS5jb21wdXRlKE5oKGUuaW5wdXRzKSl9fSk7dmFyIFZoLFdoLHN0LGxkLGNkLHBkLG1kLGZkLGhkLGdkLHlkLGJkLF9kLHdkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtWaD0oZSx0LG4scixvLGEscyxkLGwscCxmLGgpPT57bGV0IHksXzt0eXBlb2YgZD09XCJzdHJpbmdcIj95PV89KHYsVCk9PmAke2R9KCgke3Z9KSwoJHtUfSkpYDp0eXBlb2YgZD09XCJmdW5jdGlvblwiP3k9Xz1kOih5PWQuc2NhbGFyLF89ZC52ZWN0b3IpO2xldCBiPU4oXCJvdXRwdXREYXRhXCIsZixyLmxlbmd0aCw0KSx3PVAoXCJhRGF0YVwiLGwsdC5sZW5ndGgsNCksUz1QKFwiYkRhdGFcIixwLG4ubGVuZ3RoLDQpLCQ7aWYobylpZihhKXtsZXQgdj1FLnNpemUodCk9PT0xLFQ9RS5zaXplKG4pPT09MSxDPXQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTAsQT1uLmxlbmd0aD4wJiZuW24ubGVuZ3RoLTFdJTQ9PT0wO3Z8fFQ/JD1iLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLF8odj9gJHt3LnR5cGUudmFsdWV9KCR7dy5nZXRCeU9mZnNldChcIjBcIil9LngpYDp3LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxUP2Ake1MudHlwZS52YWx1ZX0oJHtTLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOlMuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk6JD1gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4ICogNHVcIil9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEgPSAke3cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsYil9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIgPSAke1MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsYil9O1xuICAgICAgICAgICAgJHtiLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLF8oc3x8Qz93LmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpOmAke3cudHlwZS52YWx1ZX0oJHt3LmdldEJ5T2Zmc2V0KFwib2Zmc2V0QSAvIDR1XCIpfVtvZmZzZXRBICUgNHVdKWAsc3x8QT9TLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpOmAke1MudHlwZS52YWx1ZX0oJHtTLmdldEJ5T2Zmc2V0KFwib2Zmc2V0QiAvIDR1XCIpfVtvZmZzZXRCICUgNHVdKWApKX1cbiAgICAgICAgICBgfWVsc2UgJD1iLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLF8ody5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksUy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2lmKCFhKXRocm93IG5ldyBFcnJvcihcIm5vIG5lY2Vzc2FyeSB0byB1c2Ugc2NhbGFyIGltcGxlbWVudGF0aW9uIGZvciBlbGVtZW50LXdpc2UgYmluYXJ5IG9wIGltcGxlbWVudGF0aW9uLlwiKTtsZXQgdj0oVCxDLEE9XCJcIik9PntsZXQgaz1gYURhdGFbaW5kZXhBJHtDfV1bY29tcG9uZW50QSR7Q31dYCxPPWBiRGF0YVtpbmRleEIke0N9XVtjb21wb25lbnRCJHtDfV1gO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtDfSA9ICR7Yi5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7Q311YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEEke0N9ID0gJHt3LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHtDfWAsYil9O1xuICAgICAgICAgICAgbGV0IG9mZnNldEIke0N9ID0gJHtTLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRJbmRpY2VzJHtDfWAsYil9O1xuICAgICAgICAgICAgbGV0IGluZGV4QSR7Q30gPSBvZmZzZXRBJHtDfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4QiR7Q30gPSBvZmZzZXRCJHtDfSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEEke0N9ID0gb2Zmc2V0QSR7Q30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRCJHtDfSA9IG9mZnNldEIke0N9ICUgNHU7XG4gICAgICAgICAgICAke1R9WyR7Q31dID0gJHtBfSgke3koayxPKX0pO1xuICAgICAgICAgIGB9O2Y9PT05PyQ9YFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgICAgIG91dHB1dERhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDokPWBcbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dihcIm91dHB1dERhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh3LFMsYil9XG5cbiAgICAgICAgJHtoPz9cIlwifVxuXG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHskfVxuICAgICAgfWB9LFdoPShlLHQsbixyLG8sYSxzPW4uZGF0YVR5cGUpPT57bGV0IGQ9bi5kaW1zLm1hcCh3PT5OdW1iZXIodyk/PzEpLGw9ci5kaW1zLm1hcCh3PT5OdW1iZXIodyk/PzEpLHA9IUUuYXJlRXF1YWwoZCxsKSxmPWQsaD1FLnNpemUoZCkseT0hMSxfPSExLGI9W3BdO2lmKHApe2xldCB3PXJ0LmNhbGNTaGFwZShkLGwsITEpO2lmKCF3KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gYmluYXJ5IG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2Y9dy5zbGljZSgpLGg9RS5zaXplKGYpO2xldCBTPUUuc2l6ZShkKT09PTEsJD1FLnNpemUobCk9PT0xLHY9ZC5sZW5ndGg+MCYmZFtkLmxlbmd0aC0xXSU0PT09MCxUPWwubGVuZ3RoPjAmJmxbbC5sZW5ndGgtMV0lND09PTA7Yi5wdXNoKFMpLGIucHVzaCgkKSxiLnB1c2godiksYi5wdXNoKFQpO2xldCBDPTE7Zm9yKGxldCBBPTE7QTxmLmxlbmd0aDtBKyspe2xldCBrPWRbZC5sZW5ndGgtQV0sTz1sW2wubGVuZ3RoLUFdO2lmKGs9PT1PKUMqPWs7ZWxzZSBicmVha31DJTQ9PT0wPyhfPSEwLHk9ITApOihTfHwkfHx2fHxUKSYmKHk9ITApfWVsc2UgeT0hMDtyZXR1cm4gYi5wdXNoKHkpLHtuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6dCtiLm1hcCh3PT53LnRvU3RyaW5nKCkpLmpvaW4oXCJfXCIpLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp3PT5WaCh3LGQsbCxmLHkscCxfLG8sbi5kYXRhVHlwZSxyLmRhdGFUeXBlLHMsYSksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpmLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKEUuc2l6ZShmKS80KX0sLi4uSChkLGwsZildfSl9fSxzdD0oZSx0LG4scixvLGEpPT57ZS5jb21wdXRlKFdoKHQsbz8/XCJcIixlLmlucHV0c1swXSxlLmlucHV0c1sxXSxuLHIsYSkpfSxsZD1lPT57c3QoZSxcIkFkZFwiLCh0LG4pPT5gJHt0fSske259YCl9LGNkPWU9PntzdChlLFwiRGl2XCIsKHQsbik9PmAke3R9LyR7bn1gKX0scGQ9ZT0+e3N0KGUsXCJFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT09JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PT0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LG1kPWU9PntzdChlLFwiTXVsXCIsKHQsbik9PmAke3R9KiR7bn1gKX0sZmQ9ZT0+e2xldCB0PVAoXCJpbnB1dFwiLGUuaW5wdXRzWzBdLmRhdGFUeXBlLGUuaW5wdXRzWzBdLmRpbXMpLnR5cGUudmFsdWU7c3QoZSxcIlBvd1wiLHtzY2FsYXI6KHIsbyk9PmBwb3dfY3VzdG9tKCR7cn0sJHtvfSlgLHZlY3RvcjoocixvKT0+YHBvd192ZWN0b3JfY3VzdG9tKCR7cn0sJHtvfSlgfSxgXG4gICAgZm4gcG93X2N1c3RvbShhIDogJHt0fSwgYiA6ICR7dH0pIC0+ICR7dH0ge1xuICAgICAgaWYgKGIgPT0gJHt0fSgwLjApKSB7XG4gICAgICAgIHJldHVybiAke3R9KDEuMCk7XG4gICAgICB9IGVsc2UgaWYgKGEgPCAke3R9KDAuMCkgJiYgZjMyKGIpICE9IGZsb29yKGYzMihiKSkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0ocG93KGYzMihhKSwgZjMyKGIpKSk7IC8vIE5hTlxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdChzaWduKGEpLCAke3R9KDEuMCksIHJvdW5kKGYzMihhYnMoYikgJSAke3R9KDIuMCkpKSAhPSAxLjApICogJHt0fSgke3Q9PT1cImkzMlwiP1wicm91bmRcIjpcIlwifShwb3coZjMyKGFicyhhKSksIGYzMihiKSkpKTtcbiAgICB9XG4gICAgZm4gcG93X3ZlY3Rvcl9jdXN0b20oYSA6IHZlYzQ8JHt0fT4sIGIgOiB2ZWM0PCR7dH0+KSAtPiB2ZWM0PCR7dH0+IHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudCB2ZWN0b3JpemVkIHBvd1xuICAgICAgcmV0dXJuIHZlYzQ8JHt0fT4ocG93X2N1c3RvbShhLngsIGIueCksIHBvd19jdXN0b20oYS55LCBiLnkpLCBwb3dfY3VzdG9tKGEueiwgYi56KSwgcG93X2N1c3RvbShhLncsIGIudykpO1xuICAgIH1cbiAgICAgIGApfSxoZD1lPT57c3QoZSxcIlN1YlwiLCh0LG4pPT5gJHt0fS0ke259YCl9LGdkPWU9PntzdChlLFwiR3JlYXRlclwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT4ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH0+JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSx5ZD1lPT57c3QoZSxcIkxlc3NcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH08JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PCR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sYmQ9ZT0+e3N0KGUsXCJHcmVhdGVyT3JFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fT49JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9Pj0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LF9kPWU9PntzdChlLFwiTGVzc09yRXF1YWxcIix7c2NhbGFyOih0LG4pPT5gdTMyKCR7dH08PSR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fTw9JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfX0pO3ZhciBHaCxIaCxGaCxxaCx2ZCwkZCx4ZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtHaD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2xldCBuPTAscj1lW25dLG89ci5kYXRhVHlwZSxhPXIuZGltcy5sZW5ndGg7ZS5mb3JFYWNoKChzLGQpPT57aWYoZCE9PW4pe2lmKHMuZGF0YVR5cGUhPT1vKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGJlIG9uZSB0eXBlXCIpO2lmKHMuZGltcy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvcnMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7cy5kaW1zLmZvckVhY2goKGwscCk9PntpZihwIT09dCYmbCE9PXIuZGltc1twXSl0aHJvdyBuZXcgRXJyb3IoXCJub24gY29uY2F0IGRpbWVuc2lvbnMgbXVzdCBtYXRjaFwiKX0pfX0pfSxIaD0oZSx0KT0+YFxuICBmbiBjYWxjdWxhdGVJbnB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7ZX11Pigke3R9KTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX07IGkgKz0gMXUgKSB7XG4gICAgICBpZiAoaW5kZXggPCBzaXplSW5Db25jYXRBeGlzW2ldKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG4gIH1gLEZoPShlLHQpPT57bGV0IG49ZS5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPG47KytvKXtsZXQgYT10LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGVbb10uZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKSk7bj09PTE/ci5wdXNoKGEpOm89PT0wP3IucHVzaChgaWYgKGlucHV0SW5kZXggPT0gJHtvfXUpIHsgJHthfSB9YCk6bz09PW4tMT9yLnB1c2goYGVsc2UgeyAke2F9IH1gKTpyLnB1c2goYGVsc2UgaWYgKGlucHV0SW5kZXggPT0gJHtvfSkgeyAke2F9IH1gKX1yZXR1cm4gci5qb2luKGBcbmApfSxxaD0oZSx0LG4scik9PntsZXQgbz1FLnNpemUobiksYT1uZXcgQXJyYXkoZS5sZW5ndGgpLHM9bmV3IEFycmF5KGUubGVuZ3RoKSxkPTAsbD1bXSxwPVtdLGY9W3t0eXBlOjEyLGRhdGE6b31dO2ZvcihsZXQgdz0wO3c8ZS5sZW5ndGg7Kyt3KWQrPWVbd10uZGltc1t0XSxhW3ddPWQscC5wdXNoKGVbd10uZGltcy5sZW5ndGgpLHNbd109UChgaW5wdXQke3d9YCxyLHBbd10pLGwucHVzaChcInJhbmtcIiksZi5wdXNoKHt0eXBlOjEyLGRhdGE6YVt3XX0pO2ZvcihsZXQgdz0wO3c8ZS5sZW5ndGg7Kyt3KWYucHVzaCguLi5IKGVbd10uZGltcykpO2YucHVzaCguLi5IKG4pKTtsZXQgaD1OKFwib3V0cHV0XCIscixuLmxlbmd0aCkseT1oLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsdCksXz1BcnJheS5mcm9tKEFycmF5KGEubGVuZ3RoKS5rZXlzKCkpLm1hcCh3PT5gdW5pZm9ybXMuc2l6ZUluQ29uY2F0QXhpcyR7d31gKS5qb2luKFwiLFwiKSxiPXc9PmBcblxuICAkeygoKT0+e3cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpO2ZvcihsZXQgUz0wO1M8ZS5sZW5ndGg7UysrKXcucmVnaXN0ZXJVbmlmb3JtKGBzaXplSW5Db25jYXRBeGlzJHtTfWAsXCJ1MzJcIik7cmV0dXJuIHcuZGVjbGFyZVZhcmlhYmxlcyguLi5zLGgpfSkoKX1cblxuICAke0hoKGEubGVuZ3RoLF8pfVxuXG4gICR7dy5tYWluU3RhcnQoKX1cbiAgICAke3cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7aC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgIGxldCBpbnB1dEluZGV4ID0gY2FsY3VsYXRlSW5wdXRJbmRleCgke3l9KTtcbiAgICBpZiAoaW5wdXRJbmRleCAhPSAwdSkge1xuICAgICAgbGV0IHNpemVJbkNvbmNhdEF4aXMgPSBhcnJheTx1MzIsICR7YS5sZW5ndGh9dT4oJHtffSk7XG4gICAgICAke3l9IC09IHNpemVJbkNvbmNhdEF4aXNbaW5wdXRJbmRleCAtIDF1XTtcbiAgICB9XG5cbiAgICAke0ZoKHMsaCl9XG4gIH1gO3JldHVybntuYW1lOlwiQ29uY2F0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOmx9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTpyfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOmJ9fSx2ZD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzLHI9blswXS5kaW1zLG89RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCk7R2gobixvKTtsZXQgYT1yLnNsaWNlKCk7YVtvXT1uLnJlZHVjZSgoZCxsKT0+ZCsobC5kaW1zLmxlbmd0aD5vP2wuZGltc1tvXTowKSwwKTtsZXQgcz1uLmZpbHRlcihkPT5FLnNpemUoZC5kaW1zKT4wKTtlLmNvbXB1dGUocWgocyxvLGEsblswXS5kYXRhVHlwZSkse2lucHV0czpzfSl9LCRkPWU9PnJlKHtheGlzOmUuYXhpc30pfSk7dmFyIGplLFplLFFlLFpyLHZ0PUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7amU9KGUsdCxuPVwiZjMyXCIpPT57c3dpdGNoKGUuYWN0aXZhdGlvbil7Y2FzZVwiUmVsdVwiOnJldHVybmB2YWx1ZSA9IG1heCh2YWx1ZSwgJHt0fSgwLjApKTtgO2Nhc2VcIlNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSAoJHt0fSgxLjApIC8gKCR7dH0oMS4wKSArIGV4cCgtdmFsdWUpKSk7YDtjYXNlXCJDbGlwXCI6cmV0dXJuYHZhbHVlID0gY2xhbXAodmFsdWUsICR7dH0oJHtufSh1bmlmb3Jtcy5jbGlwX21pbikpLCAke3R9KCR7bn0odW5pZm9ybXMuY2xpcF9tYXgpKSk7YDtjYXNlXCJIYXJkU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9IG1heCgke3R9KDAuMCksIG1pbigke3R9KDEuMCksICR7bn0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUgKyAke259KHVuaWZvcm1zLmJldGEpKSk7YDtjYXNlXCJMZWFreVJlbHVcIjpyZXR1cm5gdmFsdWUgPSBzZWxlY3QoJHtufSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSwgdmFsdWUsIHZhbHVlID49ICR7dH0oMC4wKSk7YDtjYXNlXCJUYW5oXCI6cmV0dXJuYGxldCBlMnggPSBleHAoLTIuMCAqIGFicyh2YWx1ZSkpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHNpZ24odmFsdWUpICogKDEuMCAtIGUyeCkgLyAoMS4wICsgZTJ4KTtcbiAgICAgICAgYDtjYXNlXCJcIjpyZXR1cm5cIlwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBhY3RpdmF0aW9uICR7ZS5hY3RpdmF0aW9ufWApfX0sWmU9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuY2xpcE1heH0se3R5cGU6MSxkYXRhOmUuY2xpcE1pbn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9LHt0eXBlOjEsZGF0YTplLmJldGF9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe3R5cGU6MSxkYXRhOmUuYWxwaGF9KX0sUWU9KGUsdCk9PntlLmFjdGl2YXRpb249PT1cIkNsaXBcIj90LnB1c2goe25hbWU6XCJjbGlwX21heFwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJjbGlwX21pblwiLHR5cGU6XCJmMzJcIn0pOmUuYWN0aXZhdGlvbj09PVwiSGFyZFNpZ21vaWRcIj90LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJMZWFreVJlbHVcIiYmdC5wdXNoKHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9KX0sWnI9ZT0+e2xldCB0PWU/LmFjdGl2YXRpb258fFwiXCI7aWYodD09PVwiSGFyZFNpZ21vaWRcIil7bGV0W24scl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMiwuNV07cmV0dXJue2FjdGl2YXRpb246dCxhbHBoYTpuLGJldGE6cn19ZWxzZSBpZih0PT09XCJDbGlwXCIpe2xldFtuLHJdPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbTHMsR3NdO3JldHVybnthY3RpdmF0aW9uOnQsY2xpcE1heDpyLGNsaXBNaW46bn19ZWxzZSBpZih0PT09XCJMZWFreVJlbHVcIil7bGV0W25dPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbLjAxXTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOm59fXJldHVybnthY3RpdmF0aW9uOnR9fX0pO3ZhciBFZSxTZCxRcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7RWU9KGUsdCk9Pntzd2l0Y2goZSl7Y2FzZSAxOnJldHVybiB0O2Nhc2UgMjpyZXR1cm5gdmVjMjwke3R9PmA7Y2FzZSAzOnJldHVybmB2ZWMzPCR7dH0+YDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt0fT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2V9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0sU2Q9ZT0+YFxuICAgICAgJHtlP1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpO1wiOlwiXCJ9XG4gICAgICBgfSk7dmFyIFRkLENkPUcoKCk9PntcInVzZSBzdHJpY3RcIjtUZD1lPT5gXG5mbiBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZHMgOiB2ZWM0PGkzMj4sIHNoYXBlIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgICAgc2hhcGUueSAqIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS56ICogc2hhcGUudywgc2hhcGUudywgMSkpO1xufVxuZm4gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKGNvb3JkcyA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICBpMzIoJHtlfS54KSwgaTMyKCR7ZX0ueSksIGkzMigke2V9LnopLCAxKSk7XG59XG5gfSk7dmFyIHJyLFlyLFhyPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTt2dCgpO3JyPShlLHQsbixyLG8pPT57bGV0IGE9ci1uO3JldHVybmBcbiAgICAgICR7QXJyYXkuZnJvbSh7bGVuZ3RoOm59KS5tYXAoKHMsZCk9PmBcbiAgICAgIGlmICgke0sodC5zaGFwZSxkLHQucmFuayl9ICE9IDEpIHtcbiAgICAgICAgJHt0LmluZGljZXNTZXQoZSxkLEsobyxkK2EscikpfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHt0LmluZGljZXNTZXQoZSxkLDApfVxuICAgICAgfWApLmpvaW4oXCJcIil9XG5gfSxZcj0oZSx0LG4scixvPSExLGEpPT57bGV0IHM9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9c1tzLmxlbmd0aC0yXSxwPWRbZC5sZW5ndGgtMV0sZj1zW3MubGVuZ3RoLTFdLGg9Z2UocCkseT1nZShmKSxfPWdlKGwpLGI9RS5zaXplKG4pL2gvXyx3PWUubGVuZ3RoPjIsUz1yP3Iuc2xpY2UoMCwtMik6bi5zbGljZSgwLC0yKSx2PVtFLnNpemUoUyksbCxwXSxUPVt7dHlwZToxMixkYXRhOmJ9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOmZ9XTtaZSh0LFQpLFQucHVzaCguLi5IKFMscyxkKSksdyYmVC5wdXNoKC4uLkgoZVsyXS5kaW1zKSksVC5wdXNoKC4uLkgodikpO2xldCBDPUE9PntsZXQgaz1HcihcImJhdGNoX2RpbXNcIixlWzBdLmRhdGFUeXBlLFMubGVuZ3RoKSxPPVAoXCJhXCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCx5KSxNPVAoXCJiXCIsZVsxXS5kYXRhVHlwZSxkLmxlbmd0aCxoKSxWPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHYubGVuZ3RoLGgpLEY9X2UoVi50eXBlLnRlbnNvciksaj1qZSh0LFYudHlwZS52YWx1ZSxGKSxuZT1bTyxNXSxXPVwiXCI7aWYodyl7bGV0IFE9bz9oOjE7bmUucHVzaChQKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxRKSksVz1gJHtvP2B2YWx1ZSArPSBiaWFzW2NvbCAvICR7UX1dO2A6YHZhbHVlICs9ICR7Vi50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IEo9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9XTtRZSh0LEopO2xldCB2ZT0oKT0+e2xldCBRPWB2YXIgYV9kYXRhOiAke08udHlwZS52YWx1ZX07YDtmb3IobGV0IGVlPTA7ZWU8eTtlZSsrKVErPWBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7ZWV9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7ZWV9KSAqIHVuaWZvcm1zLk4gKyBjb2wpIC8gJHtofV07YDtmb3IobGV0IGVlPTA7ZWU8XztlZSsrKXtRKz1gYV9kYXRhID0gYVsoYV9vZmZzZXQgKyAocm93ICsgJHtlZX0pICogdW5pZm9ybXMuSyArIGspIC8gJHt5fV07YDtmb3IobGV0IGxlPTA7bGU8eTtsZSsrKVErPWBcbiAgICAgICAgICAgIHZhbHVlc1ske2VlfV0gPSBmbWEoJHtNLnR5cGUudmFsdWV9KGFfZGF0YSR7eT09PTE/XCJcIjpgWyR7bGV9XWB9KSwgYl9kYXRhJHtsZX0sIHZhbHVlc1ske2VlfV0pO1xuYH1yZXR1cm4gUX07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhKKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGspLmRlY2xhcmVWYXJpYWJsZXMoLi4ubmUsVil9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHtofSkpICogJHtofTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHtofSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtffTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtffTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtuLmxlbmd0aD09PTI/XCJcIjpgbGV0IGJhdGNoX2luZGljZXMgPSAke2sub2Zmc2V0VG9JbmRpY2VzKFwiYmF0Y2hcIil9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke08udHlwZS5pbmRpY2VzfTtcbiAgICAke3JyKFwiYV9pbmRpY2VzXCIsTyxPLnJhbmstMixrLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7Ty5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsTy5yYW5rLTIsMCl9XG4gICAgJHtPLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixPLnJhbmstMSwwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke08uaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7TS50eXBlLmluZGljZXN9O1xuICAgICR7cnIoXCJiX2luZGljZXNcIixNLE0ucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtNLmluZGljZXNTZXQoXCJiX2luZGljZXNcIixNLnJhbmstMiwwKX1cbiAgICAke00uaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLE0ucmFuay0xLDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7TS5pbmRpY2VzVG9PZmZzZXQoXCJiX2luZGljZXNcIil9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7Vi50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7eX0pIHtcbiAgICAgICR7dmUoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtffXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtXfVxuICAgICAgJHtqfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtWLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtWLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7Vi5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHtofWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7aH07JHt5fTske199OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOnc/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmE/YShuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChiLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6Q319fSk7dmFyIEtoLGpoLGhvLElkLFpoLGdvLFFoLG5yLEpyPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTt2dCgpO1hyKCk7UXIoKTtLaD0oZSx0KT0+ZT9gXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGA6YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYCxqaD0oZSx0KT0+ZT9gXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gOmBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gLGhvPShlLHQsbj1cImYzMlwiLHIsbz0hMSxhPTMyLHM9ITEsZD0zMik9PntsZXQgbD10WzFdKmVbMV0scD10WzBdKmVbMF0sZj1vP2w6YSxoPW8/YTpsLHk9Zi90WzBdLF89YS90WzFdO2lmKCEoKG8mJnk9PT00JiZlWzFdPT09NHx8IW8mJih5PT09M3x8eT09PTQpKSYmZiV0WzBdPT09MCYmYSV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke299IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHt5fSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke3l9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7Zn0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke2F9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7eX08JHtufT4sICR7Zi95fT4sICR7aH0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke259PiwgJHtwL2VbMF19PiwgJHthfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7eX07XG5jb25zdCB0aWxlSW5uZXIgPSAke2F9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHtzP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAke3I/YGxldCBiYXRjaEluZGljZXMgPSAke3Iub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2x9O1xuXG4gIGxldCBudW1fdGlsZXMgPSAke3M/YCR7TWF0aC5jZWlsKGQvYSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gIHZhciBrU3RhcnQgPSAke3M/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7bn0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7X307XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHtLaChvLHIpfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke3I/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHt5PT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxuXG4gICAgICAgICAgJHtqaChvLHkpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YH0sSWQ9KGUsdCk9PmU/YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgOmBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYCxaaD1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixnbz0oZSx0LG49XCJmMzJcIixyLG89ITEsYT0zMixzPSExLGQ9MzIsbD0hMSk9PntsZXQgcD1lWzFdKnRbMV0sZj1lWzBdKnRbMF0saD1vP3A6YSx5PW8/YTpwO2lmKCEoeSV0WzFdPT09MCYmaCV0WzBdPT09MCYmYSV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7eX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHtofSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7YX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgXz15L3RbMV0sYj1oL3RbMF0sdz1hL3RbMV0sUz1sP2BcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7Zn07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7eX07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHtofTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICAke0lkKG8scil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHthfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHtmfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7cj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke259LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bz9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgOmBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtffTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHtifTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHt3fTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke2J9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke0lkKG8scil9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHt3fTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke3I/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtufSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtaaChvKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke259LCAke2h9PiwgJHt5fT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke259LCAke2Z9PiwgJHthfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7YX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke3M/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICAgJHtyP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtyLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgICBsZXQgbnVtX3RpbGVzID0gJHtzP2Ake01hdGguY2VpbChkL2EpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICAgIHZhciBrU3RhcnQgPSAke3M/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke259LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7U31cbiAgfVxuYH0sUWg9KGUsdCxuLHIsbz0hMSk9PntsZXRbYSxzLGQsbF09cixwPV9lKHJbMF0udHlwZS50ZW5zb3IpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfSkgLT4gJHtFZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0VlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICB2YXIgYUluZGljZXM6ICR7cy50eXBlLmluZGljZXN9O1xuICAgICAgICAke3JyKFwiYUluZGljZXNcIixzLHMucmFuay0yLGEucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHtzLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLHMucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7cy5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixzLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHtzLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2EudHlwZS5pbmRpY2VzfSkgLT4gJHtFZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0VlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgICB2YXIgYkluZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgICAke3JyKFwiYkluZGljZXNcIixkLGQucmFuay0yLGEucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHtkLmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtFZShlLHApfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtvP1wiYmlhc1tjb2xJbl1cIjpgJHtFZShlLHApfShiaWFzW3Jvd10pYH07YDpcIlwifVxuICAgICAgICAke259XG4gICAgICAgICR7bC5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XG4gICAgICB9XG4gICAgfVxuICAgIGB9LG5yPShlLHQsbixyLG89ITEsYSk9PntsZXQgcz1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1zLnNsaWNlKDAsLTIpLHA9ZC5zbGljZSgwLC0yKSxmPXI/ci5zbGljZSgwLC0yKTpuLnNsaWNlKDAsLTIpLGg9RS5zaXplKGYpLHk9c1tzLmxlbmd0aC0yXSxfPXNbcy5sZW5ndGgtMV0sYj1kW2QubGVuZ3RoLTFdLHc9XyU0PT09MCYmYiU0PT09MCxTPXk8PTg/WzQsMSwxXTpbNCw0LDFdLCQ9WzgsOCwxXSx2PVtNYXRoLmNlaWwoYi8kWzBdL1NbMF0pLE1hdGguY2VpbCh5LyRbMV0vU1sxXSksTWF0aC5jZWlsKGgvJFsyXS9TWzJdKV0sVD13PzQ6MSxDPVsuLi5sLHksXy9UXSxBPUMubGVuZ3RoLGs9Wy4uLnAsXyxiL1RdLE89ay5sZW5ndGgsTT1baCx5LGIvVF0sVj1be3R5cGU6NixkYXRhOnl9LHt0eXBlOjYsZGF0YTpifSx7dHlwZTo2LGRhdGE6X31dO1plKHQsViksVi5wdXNoKC4uLkgoZixDLGspKTtsZXQgRj1bXCJyYW5rXCIsXCJyYW5rXCJdLGo9ZS5sZW5ndGg+MjtqJiYoVi5wdXNoKC4uLkgoZVsyXS5kaW1zKSksRi5wdXNoKFwicmFua1wiKSksVi5wdXNoKC4uLkgoTSkpO2xldCBuZT1XPT57bGV0IEo9Zi5sZW5ndGgsdmU9R3IoXCJiYXRjaERpbXNcIixlWzBdLmRhdGFUeXBlLEosMSksUT1fZShlWzBdLmRhdGFUeXBlKSxlZT1QKFwiYVwiLGVbMF0uZGF0YVR5cGUsQSxUKSxsZT1QKFwiYlwiLGVbMV0uZGF0YVR5cGUsTyxUKSxaPU4oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLE0ubGVuZ3RoLFQpLHBlPVtlZSxsZV07aWYoail7bGV0IFk9bz9UOjE7cGUucHVzaChQKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxZKSl9bGV0IGtlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn1dO1FlKHQsa2UpO2xldCBTZT1fZShaLnR5cGUudGVuc29yKSxEPWplKHQsWi50eXBlLnZhbHVlLFNlKSxSPVFoKFQsaixELFt2ZSxlZSxsZSxaXSxvKTtyZXR1cm5gXG4gICR7Vy5yZWdpc3RlclVuaWZvcm1zKGtlKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKHZlKS5kZWNsYXJlVmFyaWFibGVzKC4uLnBlLFopfVxuICAke1J9XG4gICR7dz9obyhTLCQsUSx2ZSk6Z28oUywkLFEsdmUpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7U307JHt0LmFjdGl2YXRpb259OyR7d307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6Rn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphP2Eobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp2WzBdLHk6dlsxXSx6OnZbMl19LHByb2dyYW1Vbmlmb3JtczpWfSksZ2V0U2hhZGVyU291cmNlOm5lfX19KTt2YXIgWWgsQWQsa2Q9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7dHQoKTtjZSgpO3Z0KCk7UXIoKTtDZCgpO0pyKCk7WWg9KGUsdCxuLHIsbz0hMSxhLHM9NCxkPTQsbD00LHA9XCJmMzJcIik9PntsZXQgZj1GPT57c3dpdGNoKEYpe2Nhc2UgMTpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleF07XCI7Y2FzZSAzOnJldHVybmByZXNEYXRhID0gdmVjMzwke3B9Pih4W3hJbmRleF0sIHhbeEluZGV4ICsgMV0sIHhbeEluZGV4ICsgMl0pO2A7Y2FzZSA0OnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4IC8gNF07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtGfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0saD1GPT57c3dpdGNoKEYpe2Nhc2UgMTpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSArIGNvbEluXTtcIjtjYXNlIDQ6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgLyA0ICsgY29sSW5dO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7Rn0gaXMgbm90IHN1cHBvcnRlZC5gKX19LHk9ZT9gXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Um93LCB4Q29sLCB4Q2gpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeENoLCB4Um93LCB4Q29sKTtcbiAgICBgLF89ZT9gXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93IC8gb3V0V2lkdGgsXG4gICAgICByb3cgJSBvdXRXaWR0aCxcbiAgICAgIGNvbCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkcyA9IHZlYzQ8aTMyPihcbiAgICAgIGJhdGNoLFxuICAgICAgcm93LFxuICAgICAgY29sIC8gb3V0V2lkdGgsXG4gICAgICBjb2wgJSBvdXRXaWR0aCk7XG4gICAgYCxiPWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsxXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzJdKVwiLHc9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbM10pXCIsUz1lP1wicm93XCI6XCJjb2xcIiwkPWU/XCJjb2xcIjpcInJvd1wiLHY9YFxuICAgIGxldCBpbkNoYW5uZWxzID0gaTMyKHVuaWZvcm1zLndfc2hhcGVbMl0pO1xuICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICBsZXQgb3V0Um93ID0gJHtTfSAvIG91dFdpZHRoO1xuICAgIGxldCBvdXRDb2wgPSAke1N9ICUgb3V0V2lkdGg7XG5cbiAgICBsZXQgV1JvdyA9ICR7JH0gLyAoaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pICogaW5DaGFubmVscyk7XG4gICAgbGV0IFdDb2wgPSAkeyR9IC8gaW5DaGFubmVscyAlIGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKTtcbiAgICBsZXQgeFJvdyA9IG91dFJvdyAqIHVuaWZvcm1zLnN0cmlkZVswXSArIHVuaWZvcm1zLmRpbGF0aW9uWzBdICogV1JvdyAtIHVuaWZvcm1zLnBhZFswXTtcbiAgICBsZXQgeENvbCA9IG91dENvbCAqIHVuaWZvcm1zLnN0cmlkZVsxXSArIHVuaWZvcm1zLmRpbGF0aW9uWzFdICogV0NvbCAtIHVuaWZvcm1zLnBhZFsxXTtcbiAgICBsZXQgeENoID0gJHskfSAlIGluQ2hhbm5lbHM7XG4gICAgdmFyIHJlc0RhdGEgPSAke0VlKHMscCl9KDAuMCk7XG4gICAgLy8gVGhlIGJvdW5kcyBjaGVja2luZyBpcyBhbHdheXMgbmVlZGVkIHNpbmNlIHdlIHVzZSBpdCB0byBwYWQgemVybyBmb3JcbiAgICAvLyB0aGUgJ3NhbWUnIHBhZGRpbmcgdHlwZS5cbiAgICBpZiAoeFJvdyA+PSAwICYmIHhSb3cgPCAke2J9ICYmIHhDb2wgPj0gMCAmJiB4Q29sIDwgJHt3fSkge1xuICAgICAgJHt5fVxuICAgICAgbGV0IHhJbmRleCA9IGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkLCB2ZWM0PGkzMj4odW5pZm9ybXMueF9zaGFwZSkpO1xuICAgICAgJHtmKHMpfVxuICAgIH1cbiAgICByZXR1cm4gcmVzRGF0YTtgLFQ9ZT90JiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgICR7dn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke3N9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpIHtcbiAgICAgICR7dn1cbiAgICB9XG4gICAgcmV0dXJuICR7RWUocyxwKX0oMC4wKTtgOnImJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtFZShzLHApfSgwLjApO2AsQz1lP3ImJm4/aChkKTpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke2goZCl9XG4gICAgfVxuICAgIHJldHVybiAke0VlKGQscCl9KDAuMCk7YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtkfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9hX291dGVyKSB7XG4gICAgICAke2goZCl9XG4gICAgfVxuICAgIHJldHVybiAke0VlKGQscCl9KDAuMCk7YCxBPUVlKGwscCksaz1lP0VlKHMscCk6RWUoZCxwKSxPPWU/RWUoZCxwKTpFZShzLHApLE09amUoYSxBLHApO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke2t9IHtcbiAgICAgICR7ZT9UOkN9XG4gICAgfVxuXG4gICAgZm4gbW1fcmVhZEIoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtPfSB7XG4gICAgICAke2U/QzpUfVxuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIsIHZhbHVlSW4gOiAke0F9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2x9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVJbjtcbiAgICAgIGxldCBvdXRXaWR0aCA9ICR7ZT9cImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzNdKVwifTtcbiAgICAgICR7X31cbiAgICAgICR7U2Qobyl9XG4gICAgICAke019XG4gICAgICBzZXRPdXRwdXRBdENvb3Jkcyhjb29yZHNbMF0sIGNvb3Jkc1sxXSwgY29vcmRzWzJdLCBjb29yZHNbM10sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9YH0sQWQ9KGUsdCxuLHIsbyxhLHMsZCxsKT0+e2xldCBwPXQuZm9ybWF0PT09XCJOSFdDXCIsZj1wP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0saD1uWzBdLHk9cD9uWzJdOm5bM10sXz1wP25bMV06blsyXSxiPXA/blszXTpuWzFdLHc9cCYmKGYlND09PTB8fGYlMz09PTApJiZiJTQ9PT0wLFM9cD9iOnkqXywkPXA/eSpfOmIsdj1bOCw4LDFdLFQ9cjw9OD9bNCwxLDFdOls0LDQsMV0sQz1bTWF0aC5jZWlsKFMvdlswXS9UWzBdKSxNYXRoLmNlaWwoJC92WzFdL1RbMV0pLE1hdGguY2VpbChoL3ZbMl0vVFsyXSldO21lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9tbV93ZWJncHVdIGRpc3BhdGNoID0gJHtDfWApO2xldCBBPXc/cCYmZiU0IT09MD8zOjQ6MSxrPXZbMV0qVFsxXSxPPXZbMF0qVFswXSxNPU1hdGgubWF4KHZbMF0qQSx2WzFdKSxWPXIlaz09PTAsRj1vJU89PT0wLGo9YSVNPT09MCxuZT13P1tBLDQsNF06WzEsMSwxXSxXPVt7dHlwZTo2LGRhdGE6cn0se3R5cGU6NixkYXRhOm99LHt0eXBlOjYsZGF0YTphfSx7dHlwZTo2LGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZTo2LGRhdGE6dC5zdHJpZGVzfSx7dHlwZTo2LGRhdGE6dC5kaWxhdGlvbnN9XTtaZSh0LFcpLFcucHVzaCguLi5IKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgSj1bXCJyYW5rXCIsXCJyYW5rXCJdO3MmJihXLnB1c2goLi4uSChlWzJdLmRpbXMpKSxKLnB1c2goXCJyYW5rXCIpKSxXLnB1c2goLi4uSChuKSk7bGV0IHZlPVE9PntsZXQgZWU9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInBhZFwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJzdHJpZGVcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtRZSh0LGVlKTtsZXQgbGU9dz80OjEsWj1fZShlWzBdLmRhdGFUeXBlKSxwZT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke3c/YHZlYzQ8JHtafT5gOlp9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHt3P2B2ZWM0PCR7Wn0+YDpafSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmbiBzZXRPdXRwdXRBdENvb3JkcyhkMCA6IGkzMiwgZDEgOiBpMzIsIGQyIDogaTMyLCBkMyA6IGkzMiwgdmFsdWUgOiAke3c/YHZlYzQ8JHtafT5gOlp9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7dz9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YCxrZT1QKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxBPT09Mz8xOkEpLFNlPVAoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGxlKSxEPVtrZSxTZV0sUj1OKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCxsZSk7aWYocyl7bGV0IFk9UChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsbGUpO0QucHVzaChZKSxwZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke3c/YHZlYzQ8JHtafT5gOlp9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1tjb29yZHMuJHtwP1wid1wiOlwieVwifSR7dz9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWB9cmV0dXJuYFxuICAgICAgICAke1RkKFwidW5pZm9ybXMucmVzdWx0X3N0cmlkZXNcIil9XG4gICAgICAgIC8vc3RydWN0IFVuaWZvcm1zIHsgeFNoYXBlIDogdmVjNDxpMzI+LCB3U2hhcGUgOiB2ZWM0PGkzMj4sIG91dFNoYXBlIDogdmVjNDxpMzI+LFxuICAgICAgICAvLyAgb3V0U2hhcGVTdHJpZGVzOiB2ZWMzPGkzMj4sIGZpbHRlckRpbXMgOiB2ZWMyPGkzMj4sIHBhZCA6IHZlYzI8aTMyPiwgc3RyaWRlIDogdmVjMjxpMzI+LFxuICAgICAgICAvLyAgZGlsYXRpb24gOiB2ZWMyPGkzMj4sIGRpbUFPdXRlciA6IGkzMiwgZGltQk91dGVyIDogaTMyLCBkaW1Jbm5lciA6IGkzMiB9O1xuICAgICAgICAke1EucmVnaXN0ZXJVbmlmb3JtcyhlZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5ELFIpfVxuICAgICAgICAke3BlfVxuICAgICAgICAke1loKHAsVixGLGoscyx0LG5lWzBdLG5lWzFdLG5lWzJdLFopfVxuICAgICAgICAke3c/aG8oVCx2LFosdm9pZCAwLCFwLE0pOmdvKFQsdixaLHZvaWQgMCwhcCxNLCExLHZvaWQgMCxkKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7QX07JHt3fTske1Z9OyR7Rn07JHtqfTske2t9OyR7T307JHtNfWAsaW5wdXREZXBlbmRlbmNpZXM6Sn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsP2wobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpDWzBdLHk6Q1sxXSx6OkNbMl19LHByb2dyYW1Vbmlmb3JtczpXfSksZ2V0U2hhZGVyU291cmNlOnZlfX19KTt2YXIgWGgsRWQsZW4sSmgsUGQsZWcsemQsT2QsRGQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7dHQoKTthZSgpO2NlKCk7dnQoKTtRcigpO1hoPWU9PntsZXQgdD0xO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXQqPWVbbl07cmV0dXJuIHR9LEVkPWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxlbj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSksSmg9KGUsdCxuLHI9MSk9PntsZXQgbz1lbih0LHIpO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihuLTEpLW4rbykvMil9LFBkPShlLHQsbixyLG8pPT57bz09bnVsbCYmKG89SmgoZSx0WzBdLHJbMF0pKTtsZXQgYT1bMCwwLDAsbl07Zm9yKGxldCBzPTA7czwzO3MrKyllW3NdKzIqbz49dFtzXSYmKGFbc109TWF0aC50cnVuYygoZVtzXS10W3NdKzIqbykvcltzXSsxKSk7cmV0dXJuIGF9LGVnPShlLHQsbixyLG8sYSxzLGQsbCxwKT0+e2xldCBmLGgseSxfO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXtmPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IGI9UGQoW3QsbixyLDFdLFtkLGwscF0sMSxbbyxhLHNdLGUpO2g9YlswXSx5PWJbMV0sXz1iWzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKHcsUywkKT0+dz09PSRbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO2Y9e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgYj1QZChbdCxuLHIsMV0sW2QsbCxwXSwxLFtvLGEsc10sZVswXSk7aD1iWzBdLHk9YlsxXSxfPWJbMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe2g9TWF0aC5jZWlsKHQvbykseT1NYXRoLmNlaWwobi9hKSxfPU1hdGguY2VpbChyL3MpO2xldCBiPShoLTEpKm8rZC10LHc9KHktMSkqYStsLW4sUz0oXy0xKSpzK3AtciwkPU1hdGguZmxvb3IoYi8yKSx2PWItJCxUPU1hdGguZmxvb3Iody8yKSxDPXctVCxBPU1hdGguZmxvb3IoUy8yKSxrPVMtQTtmPXt0b3A6VCxib3R0b206QyxsZWZ0OkEscmlnaHQ6ayxmcm9udDokLGJhY2s6dn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOmYsb3V0RGVwdGg6aCxvdXRIZWlnaHQ6eSxvdXRXaWR0aDpffX0semQ9KGUsdCxuLHIsbyxhPSExLHM9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgZCxsLHAsZixoO2lmKHM9PT1cImNoYW5uZWxzTGFzdFwiKVtkLGwscCxmLGhdPWU7ZWxzZSBpZihzPT09XCJjaGFubmVsc0ZpcnN0XCIpW2QsaCxsLHAsZl09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7c31gKTtsZXRbeSwsXyxiLHddPXQsW1MsJCx2XT1FZChuKSxbVCxDLEFdPUVkKHIpLGs9ZW4oXyxUKSxPPWVuKGIsQyksTT1lbih3LEEpLHtwYWRJbmZvOlYsb3V0RGVwdGg6RixvdXRIZWlnaHQ6aixvdXRXaWR0aDpuZX09ZWcobyxsLHAsZixTLCQsdixrLE8sTSksVz1hP3kqaDp5LEo9WzAsMCwwLDAsMF07cmV0dXJuIHM9PT1cImNoYW5uZWxzRmlyc3RcIj9KPVtkLFcsRixqLG5lXTpzPT09XCJjaGFubmVsc0xhc3RcIiYmKEo9W2QsRixqLG5lLFddKSx7YmF0Y2hTaXplOmQsZGF0YUZvcm1hdDpzLGluRGVwdGg6bCxpbkhlaWdodDpwLGluV2lkdGg6ZixpbkNoYW5uZWxzOmgsb3V0RGVwdGg6RixvdXRIZWlnaHQ6aixvdXRXaWR0aDpuZSxvdXRDaGFubmVsczpXLHBhZEluZm86VixzdHJpZGVEZXB0aDpTLHN0cmlkZUhlaWdodDokLHN0cmlkZVdpZHRoOnYsZmlsdGVyRGVwdGg6XyxmaWx0ZXJIZWlnaHQ6YixmaWx0ZXJXaWR0aDp3LGVmZmVjdGl2ZUZpbHRlckRlcHRoOmssZWZmZWN0aXZlRmlsdGVySGVpZ2h0Ok8sZWZmZWN0aXZlRmlsdGVyV2lkdGg6TSxkaWxhdGlvbkRlcHRoOlQsZGlsYXRpb25IZWlnaHQ6QyxkaWxhdGlvbldpZHRoOkEsaW5TaGFwZTplLG91dFNoYXBlOkosZmlsdGVyU2hhcGU6dH19LE9kPShlLHQsbixyLG8sYSk9PntsZXQgcz1hPT09XCJjaGFubmVsc0xhc3RcIixkPXM/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxsPSExLHA9WzY0LDEsMV0sZj17eDpuLm1hcCgodixUKT0+VCl9LGg9W01hdGguY2VpbChYaChmLngubWFwKHY9Pm5bdl0pKS9wWzBdKSwxLDFdO21lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYzZF9uYWl2ZV93ZWJncHVdIGRpc3BhdGNoID0gJHtofWApO2xldCB5PWw/cyYmZCU0IT09MD8zOjQ6MSxfPUUuc2l6ZShuKSxiPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnQuc3RyaWRlc30se3R5cGU6MTIsZGF0YTp0LmRpbGF0aW9uc31dO1plKHQsYiksYi5wdXNoKC4uLkgoZVswXS5kaW1zLGVbMV0uZGltcykpO2xldCB3PVtcInJhbmtcIixcInJhbmtcIl0sUz1lLmxlbmd0aD09PTM7UyYmKGIucHVzaCguLi5IKGVbMl0uZGltcykpLHcucHVzaChcInJhbmtcIikpLGIucHVzaCguLi5IKG4pKTtsZXQgJD12PT57bGV0IFQ9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnIubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9XTtRZSh0LFQpO2xldCBDPWw/NDoxLEE9X2UoZVswXS5kYXRhVHlwZSksaz1QKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCx5PT09Mz8xOnkpLE89UChcIldcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgsQyksTT1bayxPXSxWPU4oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoLEMpLEY9XCJcIjtpZihTKXtsZXQgVz1QKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxDKTtNLnB1c2goVyksRis9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogYXJyYXk8dTMyLCA1PikgLT4gJHtsP2B2ZWM0PCR7QX0+YDpBfSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbJHtzP0soXCJjb29yZHNcIiw0LDUpOksoXCJjb29yZHNcIiwxLDUpfSR7bD9cIi8gNFwiOlwiXCJ9XTtcbiAgICAgICAgfWB9bGV0IGo9RWUoeSxBKSxuZT1qZSh0LGosQSk7cmV0dXJuYFxuICAgICAgICAgICAgJHtGfVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7ay5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHtPLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAke3YucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKC4uLk0sVil9XG4gICAgICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgICAgIGxldCBjb29yZHMgPSAke1Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7SyhcImNvb3Jkc1wiLDAsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7cz9LKFwiY29vcmRzXCIsay5yYW5rLTEsay5yYW5rKTpLKFwiY29vcmRzXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhGUkNDb3JuZXIgPSB2ZWMzPHUzMj4oJHtzP0soXCJjb29yZHNcIiwxLGsucmFuayk6SyhcImNvb3Jkc1wiLDIsay5yYW5rKX0sXG4gICAgICAgICAgICAgICR7cz9LKFwiY29vcmRzXCIsMixrLnJhbmspOksoXCJjb29yZHNcIiwzLGsucmFuayl9LFxuICAgICAgICAgICAgICAke3M/SyhcImNvb3Jkc1wiLDMsay5yYW5rKTpLKFwiY29vcmRzXCIsNCxrLnJhbmspfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke3M/SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwxLGsucmFuayk6SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7cz9LKFwidW5pZm9ybXMueF9zaGFwZVwiLDIsay5yYW5rKTpLKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHtzP0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMyxrLnJhbmspOksoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke3M/SyhcInVuaWZvcm1zLnhfc2hhcGVcIiw0LGsucmFuayk6SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwxLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke3M/YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7cz9gdmFsdWUgKz0gZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YDpgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtzP2BsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7cz9gbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke1M/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcylcIjpcIlwifTtcbiAgICAgICAgICAgICAgJHtuZX1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7c307JHt5fTske1N9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6aFswXSx5OmhbMV0sejpoWzJdfSxwcm9ncmFtVW5pZm9ybXM6Yn0pLGdldFNoYWRlclNvdXJjZTokfX19KTt2YXIgQmQsTWQsUmQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3Z0KCk7QmQ9KGUsdCxuLHIpPT57bGV0IG89ZS5sZW5ndGg+MixhPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLHM9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPWw/blszXTpuWzFdLGY9cC90Lmdyb3VwLGg9bCYmZj49ND9nZShwKToxLHk9RS5zaXplKG4pL2gsXz1be3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZToxMixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6MTIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjEyLGRhdGE6Zn1dO1plKHQsXyksXy5wdXNoKC4uLkgocyxbZFswXSxkWzFdLGRbMl0sZFszXS9oXSkpO2xldCBiPW8/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdO18ucHVzaCguLi5IKFtuWzBdLG5bMV0sblsyXSxuWzNdL2hdKSk7bGV0IHc9Uz0+e2xldCAkPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoLGgpLHY9X2UoJC50eXBlLnRlbnNvciksVD1qZSh0LCQudHlwZS52YWx1ZSx2KSxDPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCksQT1QKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsaCksaz1bQyxBXTtvJiZrLnB1c2goUChcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxoKSk7bGV0IE89W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XTtRZSh0LE8pO2xldCBNPWw/YFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICAgICAgbGV0IHhWYWwgPSAke0MuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIixcIndJbkNoYW5uZWxcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDpgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7Qy5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO3JldHVybmBcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybXMoTykuZGVjbGFyZVZhcmlhYmxlcyguLi5rLCQpfVxuXG4gICR7Uy5tYWluU3RhcnQoKX1cbiAgICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2w/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtsPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHtofSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7bD8yOjF9XTtcblxuICAgIHZhciB2YWx1ZTogJHskLnR5cGUudmFsdWV9ID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgICR7TX1cbiAgICAke2F9XG4gICAgJHtUfVxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7aH1gLGlucHV0RGVwZW5kZW5jaWVzOmJ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cj9yKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp3fX0sTWQ9KGUsdCxuLHIpPT57bGV0IG89ZS5sZW5ndGg+MixhPWdlKG5bM10pLHM9Z2UoblsyXSksZD1FLnNpemUobikvYS9zLGw9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9hXSxwPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vYV0sZj1bblswXSxuWzFdLG5bMl0sblszXS9hXSxoPVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtaZSh0LGgpLGgucHVzaCguLi5IKGwscCxmKSk7bGV0IHk9KHMtMSkqdC5zdHJpZGVzWzFdK3BbMV0sXz1iPT57bGV0IHc9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZi5sZW5ndGgsYSksUz1fZSh3LnR5cGUudGVuc29yKSwkPWplKHQsdy50eXBlLnZhbHVlLFMpLHY9UChcInhcIixlWzBdLmRhdGFUeXBlLGwubGVuZ3RoLGEpLFQ9UChcIndcIixlWzFdLmRhdGFUeXBlLHAubGVuZ3RoLGEpLEM9W3YsVF07byYmQy5wdXNoKFAoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsYSkpO2xldCBBPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIFFlKHQsayksYFxuICAke2IucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLkMsdyl9XG4gICR7Yi5tYWluU3RhcnQoKX1cbiAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHtzfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHtzfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHt5fT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHt3LnR5cGUudmFsdWV9LCAke3N9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3BbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHt5fTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7cFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7VC5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7c311OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3N9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0F9XG4gICAgICAkeyR9XG4gICAgICAke3cuc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7YX07JHtzfTske3l9OyR7cFswXX07JHtwWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cj9yKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pLGdldFNoYWRlclNvdXJjZTpffX19KTt2YXIgdGcseW8scmcsYm8sX28sVWQsbmcsb2csd28sTmQ9RygoKT0+e1widXNlIHN0cmljdFwiO2FlKCk7a2QoKTtEZCgpO0pyKCk7UmQoKTt2dCgpO1hyKCk7Y3QoKTt0Zz0oZSx0LG4scixvLGEpPT57bGV0IHM9ZVswXSxkPWUuc2xpY2UoYT8xOjIsYT8zOjQpLGw9ZC5sZW5ndGgscD10WzBdLGg9dC5zbGljZSgyKS5tYXAoKGIsdyk9PmIrKGItMSkqKG5bd10tMSkpLF89ZC5tYXAoKGIsdyk9PmIrclt3XStyW3crbF0pLm1hcCgoYix3KT0+TWF0aC5mbG9vcigoYi1oW3ddK29bd10pL29bd10pKTtyZXR1cm4gXy5zcGxpY2UoMCwwLHMpLF8uc3BsaWNlKGE/MzoxLDAscCksX30seW89WzIsMywxLDBdLHJnPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IG49ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLHI9ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYobiE9PXIpdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG89ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke299RGApO2lmKHQucGFkcy5sZW5ndGghPT1vKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke28qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0sYm89KGUsdCk9PntsZXQgbj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7bi5sZW5ndGg8dFsxXS5kaW1zLmxlbmd0aC0yJiZuLnB1c2goLi4uQXJyYXkodFsxXS5kaW1zLmxlbmd0aC0yLW4ubGVuZ3RoKS5maWxsKDApKTtmb3IobGV0IGE9MjthPHRbMV0uZGltcy5sZW5ndGg7KythKW5bYS0yXT09PTAmJihuW2EtMl09dFsxXS5kaW1zW2FdKTtsZXQgcj1lLnBhZHMuc2xpY2UoKTtrdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxuLHIsZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBvPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6bixwYWRzOnJ9KSxvfSxfbz1lPT57bGV0IHQ9WnIoZSksbj1lLmZvcm1hdCxyPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbz1lLmRpbGF0aW9ucyxhPWUuZ3JvdXAscz1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOnIsZm9ybWF0Om4sZGlsYXRpb25zOm8sZ3JvdXA6YSxrZXJuZWxTaGFwZTpzLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LFVkPShlLHQsbixyKT0+e2xldCBvPW4uZm9ybWF0PT09XCJOSFdDXCIsYT10Zyh0WzBdLmRpbXMsdFsxXS5kaW1zLG4uZGlsYXRpb25zLG4ucGFkcyxuLnN0cmlkZXMsbyk7aWYobi5ncm91cCE9PTEpe2xldCBrPVt0WzBdXTtpZihvKXtsZXQgTT1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShPZSh0WzFdLHlvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO24ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9TSksay5wdXNoKE0pfWVsc2Ugay5wdXNoKHRbMV0pO3QubGVuZ3RoPT09MyYmay5wdXNoKHRbMl0pLCFlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiYW1wZXJlXCIpJiZvJiZ0WzFdLmRpbXNbMF09PT1uLmdyb3VwJiZ0WzFdLmRpbXNbMV09PT0xJiZuLmRpbGF0aW9uc1swXT09PTEmJm4uZGlsYXRpb25zWzFdPT09MT9lLmNvbXB1dGUoTWQoayxuLGEscikse2lucHV0czprfSk6ZS5jb21wdXRlKEJkKGssbixhLHIpLHtpbnB1dHM6a30pO3JldHVybn1sZXQgcz10Lmxlbmd0aD09PTMsZD10WzBdLmRpbXNbbz8xOjJdLGw9dFswXS5kaW1zW28/MjozXSxwPXRbMF0uZGltc1tvPzM6MV0sZj10WzFdLmRpbXNbMl0saD10WzFdLmRpbXNbM10seT1hW28/MToyXSxfPWFbbz8yOjNdLGI9YVtvPzM6MV0sdz1vJiZmPT09ZCYmaD09PWwmJm4ucGFkc1swXT09PTAmJm4ucGFkc1sxXT09PTA7aWYod3x8Zj09PTEmJmg9PT0xJiZuLmRpbGF0aW9uc1swXT09PTEmJm4uZGlsYXRpb25zWzFdPT09MSYmbi5zdHJpZGVzWzBdPT09MSYmbi5zdHJpZGVzWzFdPT09MSYmbi5wYWRzWzBdPT09MCYmbi5wYWRzWzFdPT09MCl7bGV0IGs9YVswXSxPLE0sVixGPVtdO2lmKG8pe2xldCBXPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKE9lKHRbMV0seW8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYobi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1XKSx3KXtsZXQgSj1kKmwqcDtPPXRbMF0ucmVzaGFwZShbMSxrLEpdKSxNPVcucmVzaGFwZShbMSxKLGJdKSxWPVsxLGssYl19ZWxzZSBPPXRbMF0ucmVzaGFwZShbayxkKmwscF0pLE09Vy5yZXNoYXBlKFsxLHAsYl0pLFY9W2sseSpfLGJdO0YucHVzaChPKSxGLnB1c2goTSl9ZWxzZSBPPXRbMF0ucmVzaGFwZShbayxwLGQqbF0pLE09dFsxXS5yZXNoYXBlKFsxLGIscF0pLFY9W2ssYix5Kl9dLEYucHVzaChNKSxGLnB1c2goTyk7cyYmRi5wdXNoKHRbMl0pO2xldCBqPVZbMl0sbmU9RlswXS5kaW1zW0ZbMF0uZGltcy5sZW5ndGgtMV07ajw4JiZuZTw4P2UuY29tcHV0ZShZcihGLG4sYSxWLG8scikse2lucHV0czpGfSk6ZS5jb21wdXRlKG5yKEYsbixhLFYsbyxyKSx7aW5wdXRzOkZ9KTtyZXR1cm59bGV0IFM9ITAsJD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShPZSh0WzFdLHlvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltuLndJc0NvbnN0Py0yOi0xXX0pWzBdO24ud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9JCk7bGV0IHY9W3RbMF0sJF07cyYmdi5wdXNoKHRbMl0pO2xldCBUPW8/eSpfOmIsQz1vP2I6eSpfLEE9ZipoKnA7ZS5jb21wdXRlKEFkKHYsbixhLFQsQyxBLHMsUyxyKSx7aW5wdXRzOnZ9KX0sbmc9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9W2UuaW5wdXRzWzBdLnJlc2hhcGUobj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJnIucHVzaChlLmlucHV0c1syXSk7bGV0IG89WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxhPVsxXS5jb25jYXQodC5zdHJpZGVzKSxzPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGQ9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxsPWJvKHsuLi50LHBhZHM6byxzdHJpZGVzOmEsZGlsYXRpb25zOnMsa2VybmVsU2hhcGU6ZH0scik7VWQoZSxyLGwscD0+bj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxvZz0oZSx0LG4pPT57bGV0IHI9bi5mb3JtYXQ9PT1cIk5IV0NcIj9cImNoYW5uZWxzTGFzdFwiOlwiY2hhbm5lbHNGaXJzdFwiLG89Ym8obix0KSxhPW4uYXV0b1BhZD09PVwiTk9UU0VUXCI/bi5wYWRzOm4uYXV0b1BhZCxzPXpkKHRbMF0uZGltcyx0WzFdLmRpbXMsbi5zdHJpZGVzLG4uZGlsYXRpb25zLGEsITEscik7ZS5jb21wdXRlKE9kKHQsbyxzLm91dFNoYXBlLFtzLmZpbHRlckRlcHRoLHMuZmlsdGVySGVpZ2h0LHMuZmlsdGVyV2lkdGhdLFtzLnBhZEluZm8uZnJvbnQscy5wYWRJbmZvLnRvcCxzLnBhZEluZm8ubGVmdF0scikpfSx3bz0oZSx0KT0+e2lmKHJnKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09MyluZyhlLHQpO2Vsc2UgaWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KW9nKGUsZS5pbnB1dHMsdCk7ZWxzZXtsZXQgbj1ibyh0LGUuaW5wdXRzKTtVZChlLGUuaW5wdXRzLG4pfX19KTt2YXIgVmQsV2Q9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7dHQoKTthZSgpO2NlKCk7VmQ9KGUsdCxuKT0+e2xldCByPWUubGVuZ3RoPjIsbz10Lm91dHB1dFNoYXBlLGE9dC5mb3JtYXQ9PT1cIk5IV0NcIixzPXQuZ3JvdXAsZD1lWzFdLmRpbXMsbD1kWzJdL3MscD1kWzNdLGY9YT9nZShsKToxLGg9YT9nZShwKToxLHk9YT9wPT09MT9mOmg6MSxfPUUuc2l6ZShvKS9oLGI9W01hdGguY2VpbChfLzY0KSwxLDFdO21lKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHtifWApO2xldCB3PVtcInJhbmtcIixcInJhbmtcIl0sUz1bdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV0sJD1bdC5rZXJuZWxTaGFwZVthPzE6Ml0sdC5rZXJuZWxTaGFwZVthPzI6M11dLHY9W3QuZGlsYXRpb25zWzBdLHQuZGlsYXRpb25zWzFdXSxUPVskWzBdKyh0LmRpbGF0aW9uc1swXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2E/MToyXS0xKSoodC5kaWxhdGlvbnNbMF0tMSkpLCRbMV0rKHQuZGlsYXRpb25zWzFdPD0xPzA6KHQua2VybmVsU2hhcGVbYT8yOjNdLTEpKih0LmRpbGF0aW9uc1sxXS0xKSldLEM9W1RbMF0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMF0rdC5wYWRzWzJdKS8yKSxUWzFdLTEtTWF0aC5mbG9vcigodC5wYWRzWzFdK3QucGFkc1szXSkvMildLEE9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpTfSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6dn0se3R5cGU6MTIsZGF0YTpUfSx7dHlwZTo2LGRhdGE6Q30se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LC4uLkgoZVswXS5kaW1zLGVbMV0uZGltcyldO3ImJihBLnB1c2goLi4uSChlWzJdLmRpbXMpKSx3LnB1c2goXCJyYW5rXCIpKSxBLnB1c2goLi4uSChvKSk7bGV0IGs9Tz0+e2xldCBNPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlMubGVuZ3RofSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOiQubGVuZ3RofSx7bmFtZTpcImVmZmVjdGl2ZV9maWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6VC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Qy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XSxWPV9lKGVbMF0uZGF0YVR5cGUpLEY9YT8xOjIsaj1hPzI6MyxuZT1hPzM6MSxXPVAoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLHkpLEo9UChcIkR5XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGYpLHZlPVtKLFddO3ImJnZlLnB1c2goUChcImJpYXNcIixlWzJdLmRhdGFUeXBlLFtvW25lXV0ubGVuZ3RoLGgpKTtsZXQgUT1OKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCxoKSxlZT0oKT0+e2xldCBaPVwiXCI7aWYoZj09PTEpWis9YFxuICAgICAgICBsZXQgd19vZmZzZXQgPSAke1cuaW5kaWNlc1RvT2Zmc2V0KGAke1cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xuICAgICAgICBsZXQgd1ZhbHVlID0gJHtXLmdldEJ5T2Zmc2V0KGB3X29mZnNldCAvICR7eX1gKX07XG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO2A7ZWxzZSBpZihwPT09MSlaKz1gXG4gICAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vy5nZXRCeU9mZnNldChgJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfSAvICR7eX1gKX07XG4gICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyBkb3QoeFZhbHVlLCB3VmFsdWUpO2A7ZWxzZSBmb3IobGV0IHBlPTA7cGU8ZjtwZSsrKVorPWBcbiAgICAgICAgICAgIGxldCB3VmFsdWUke3BlfSA9ICR7Vy5nZXRCeU9mZnNldChgJHtXLmluZGljZXNUb09mZnNldChgJHtXLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke3BlfSwgd091dENoYW5uZWwpYCl9IC8gJHt5fWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7cGV9XSAqIHdWYWx1ZSR7cGV9O2A7cmV0dXJuIFp9LGxlPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtRLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7aH1gKX07XG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke1EuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke1EuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixuZSl9O1xuICAgICAgICAgICAgbGV0IHIgPSAke1EuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixGKX07XG4gICAgICAgICAgICBsZXQgYyA9ICR7US5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGopfTtcbiAgICAgICAgICAgIGxldCBkeUNvcm5lciA9IHZlYzI8aTMyPihpMzIociksIGkzMihjKSkgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgICAgbGV0IGR5UkNvcm5lciA9IGR5Q29ybmVyLng7XG4gICAgICAgICAgICBsZXQgZHlDQ29ybmVyID0gZHlDb3JuZXIueTtcbiAgICAgICAgICAgIGxldCBncm91cElkID0gZDEgLyB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgbGV0IHdPdXRDaGFubmVsID0gZDEgLSBncm91cElkICogdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQyKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBjb21wdXRlIGR4KHhSLCB4QywgZDEpLlxuICAgICAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXG4gICAgICAgICAgICB2YXIgZG90UHJvZCA9ICR7US50eXBlLnZhbHVlfSgwLjApO1xuICAgICAgICAgICAgdmFyIHdSOiB1MzIgPSAwO1xuICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy54ID09IDEpIHtcbiAgICAgICAgICAgICAgLy8gTWluaW11bSB3UiA+PSAwIHRoYXQgc2F0aXNmaWVzIChkeVJDb3JuZXIgKyB3UikgJSAodW5pZm9ybXMuc3RyaWRlcy54KSA9PSAwXG4gICAgICAgICAgICAgIHdSID0gdTMyKCgoZHlSQ29ybmVyICsgaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSAxKSAvIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpKSAqIGkzMih1bmlmb3Jtcy5zdHJpZGVzLngpIC0gZHlSQ29ybmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgICBpZiAod1IgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGR5UiA9ICgke1Z9KGR5UkNvcm5lcikgKyAke1Z9KHdSKSkgLyAke1Z9KHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xuICAgICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xuICAgICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke1Z9KHVuaWZvcm1zLkR5X3NoYXBlWyR7Rn1dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuICAgICAgICAgICAgICB2YXIgd0M6IHUzMiA9IDA7XG4gICAgICAgICAgICAgIGlmICh1bmlmb3Jtcy5kaWxhdGlvbnMueSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTWluaW11bSB3QyA+PSAwIHRoYXQgc2F0aXNmaWVzIChkeUNDb3JuZXIgKyB3QykgJSAodW5pZm9ybXMuc3RyaWRlcy55KSA9PSAwXG4gICAgICAgICAgICAgICAgd0MgPSB1MzIoKChkeUNDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueSkgLSBkeUNDb3JuZXIpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZm9yICg7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtWfShkeUNDb3JuZXIpICsgJHtWfSh3QykpIC8gJHtWfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtWfSh1bmlmb3Jtcy5EeV9zaGFwZVske2p9XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArICR7Zn0pIHtcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke2E/Si5nZXRCeU9mZnNldChgJHtKLmluZGljZXNUb09mZnNldChgJHtKLnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke2Z9YCk6Si5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcbiAgICAgICAgICAgICAgICAgICR7ZWUoKX1cbiAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArICR7Zn07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdDID0gd0MgKyB1bmlmb3Jtcy5zdHJpZGVzLnkgLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdSID0gd1IgKyB1bmlmb3Jtcy5zdHJpZGVzWzBdIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGRvdFByb2Qke3I/YCArIGJpYXNbZDEgLyAke2h9XWA6XCJcIn07XG4gICAgICAgICAgICAke1Euc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICAgICAgYDtyZXR1cm5gXG4gICAgJHtPLnJlZ2lzdGVyVW5pZm9ybXMoTSkuZGVjbGFyZVZhcmlhYmxlcyguLi52ZSxRKX1cbiAgICAgICR7Ty5tYWluU3RhcnQoKX1cbiAgICAgICR7Ty5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9O1xuICAgICR7bGV9fWB9O3JldHVybntuYW1lOlwiQ29udlRyYW5zcG9zZTJEXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtmfSR7eX0ke2h9JHtwPT09MX1gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFJ1bkRhdGE6KCk9Pih7ZGlzcGF0Y2hHcm91cDp7eDpiWzBdLHk6YlsxXSx6OmJbMl19LG91dHB1dHM6W3tkaW1zOm4/bihvKTpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6QX0pLGdldFNoYWRlclNvdXJjZTprfX19KTt2YXIgaWcsYWcsc2csTGQsR2QsdWcsSGQsZGcsRmQscWQ9RygoKT0+e1widXNlIHN0cmljdFwiO1dkKCk7dnQoKTtjdCgpO2lnPShlLHQsbixyLG8sYSk9PihlLTEpKnQrbisoci0xKSpvKzEtYSxhZz0oZSx0LG4scixvKT0+e2xldCBhPU1hdGguZmxvb3IoZS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KG5bcl09YSxuW29dPWUtYSk6dD09PVwiU0FNRV9MT1dFUlwiJiYobltyXT1lLWEsbltvXT1hKX0sc2c9KGUsdCxuLHIsbyxhLHMsZCxsLHApPT57bGV0IGY9ZS5sZW5ndGgtMixoPXAubGVuZ3RoPT09MDtsLmxlbmd0aDxmJiZsLnB1c2goLi4uQXJyYXkoZi1sLmxlbmd0aCkuZmlsbCgwKSk7bGV0IHk9ZVswXSxfPXRbZD8zOjFdKm87Zm9yKGxldCBiPTAsdz1lLmxlbmd0aC1mLShkPzE6MCk7YjxmOysrYiwrK3cpe2xldCBTPWVbd10sJD1oP1Mqc1tiXTpwW2JdLHY9aWcoUyxzW2JdLGFbYl0sdFt3XSxuW2JdLCQpO2FnKHYscixhLGIsYitmKSxoJiZwLnB1c2goc1tiXSooUy0xKStsW2JdKyh0W3ddLTEpKm5bYl0rMS1hW2JdLWFbYitmXSl9cC5zcGxpY2UoMCwwLHkpLHAuc3BsaWNlKGQ/MzoxLDAsXyl9LExkPShlLHQpPT57bGV0IG49ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPT09MHx8ZS5rZXJuZWxTaGFwZS5yZWR1Y2UoKGgseSk9PmgqeSwxKT09PTApe24ubGVuZ3RoPTA7Zm9yKGxldCBoPTI7aDx0WzFdLmRpbXMubGVuZ3RoOysraCluLnB1c2godFsxXS5kaW1zW2hdKX1sZXQgcj1lLmZvcm1hdD09PVwiTkhXQ1wiO24uc3BsaWNlKDAsMCx0WzFdLmRpbXNbMF0pLG4uc3BsaWNlKHI/MzoxLDAsdFsxXS5kaW1zWzFdKTtsZXQgbz1lLnBhZHMuc2xpY2UoKSxhPWUub3V0cHV0U2hhcGUuc2xpY2UoKSxzPWUub3V0cHV0UGFkZGluZy5zbGljZSgpLGQ9dFswXS5kaW1zLGw9ZS5kaWxhdGlvbnMuc2xpY2UoKTtpZihsLnJlZHVjZSgoaCx5KT0+aCt5LDApPT09MCl7bGV0IGg9dFswXS5kaW1zLmxlbmd0aC0yO2w9bmV3IEFycmF5KGgpLmZpbGwoMSl9bGV0IHA9ZS5zdHJpZGVzLnNsaWNlKCk7aWYocC5yZWR1Y2UoKGgseSk9PmgreSwwKT09PTApe2xldCBoPXRbMF0uZGltcy5sZW5ndGgtMjtwPW5ldyBBcnJheShoKS5maWxsKDEpfXNnKGQsbixsLGUuYXV0b1BhZCxlLmdyb3VwLG8scCxyLHMsYSk7bGV0IGY9T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihmLHtrZXJuZWxTaGFwZTpuLHBhZHM6byxvdXRwdXRQYWRkaW5nOnMsb3V0cHV0U2hhcGU6YSxkaWxhdGlvbnM6bCxzdHJpZGVzOnB9KSxmfSxHZD1lPT57bGV0IHQ9WnIoZSksbj1lLmZvcm1hdCxyPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bdHlwZW9mIGUuYXV0b1BhZD5cInVcIj8wOmUuYXV0b1BhZF0sbz1lLmRpbGF0aW9ucyxhPWUuZ3JvdXAscz1lLmtlcm5lbFNoYXBlLGQ9ZS5wYWRzLGw9ZS5zdHJpZGVzLHA9ZS53SXNDb25zdCgpLGY9ZS5vdXRwdXRQYWRkaW5nLGg9ZS5vdXRwdXRTaGFwZTtyZXR1cm57YXV0b1BhZDpyLGZvcm1hdDpuLGRpbGF0aW9uczpvLGdyb3VwOmEsa2VybmVsU2hhcGU6cyxvdXRwdXRQYWRkaW5nOmYsb3V0cHV0U2hhcGU6aCxwYWRzOmQsc3RyaWRlczpsLHdJc0NvbnN0OnAsLi4udCxjYWNoZUtleTpgJHtlLmZvcm1hdH07JHt0LmFjdGl2YXRpb259O2B9fSx1Zz0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCBuPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxyPWVbMV0uZGltc1swXTtpZihuIT09cil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2xldCBvPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzJdLmRpbXNbMF0hPT1vKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IGE9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLnJlZHVjZSgoZixoKT0+ZitoLDApPjAmJnQuZGlsYXRpb25zLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7YX1EYCk7aWYodC5zdHJpZGVzLnJlZHVjZSgoZixoKT0+ZitoLDApPjAmJnQuc3RyaWRlcy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHthfURgKTtpZih0LnBhZHMucmVkdWNlKChmLGgpPT5mK2gsMCk+MCYmdC5wYWRzLmxlbmd0aCE9PWEqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7YSoyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09YSYmdC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHthfURgKTtpZih0Lmtlcm5lbFNoYXBlLnJlZHVjZSgoZixoKT0+ZitoLDApPjAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYodC5vdXRwdXRTaGFwZS5sZW5ndGghPT0wJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKX0sSGQ9KGUsdCxuLHIpPT57bGV0IG89ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoT2UodFsxXSxbMiwzLDAsMV0pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1vKTtsZXQgYT1bdFswXSxvXTt0Lmxlbmd0aD09PTMmJmEucHVzaCh0WzJdKSxlLmNvbXB1dGUoVmQoYSxuLHIpLHtpbnB1dHM6YX0pfSxkZz0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj1bZS5pbnB1dHNbMF0ucmVzaGFwZShuP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmci5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz10Lmtlcm5lbFNoYXBlOyhvLmxlbmd0aD09PTB8fG9bMF09PT0wKSYmKG89W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgYT10LmRpbGF0aW9uczsoYS5sZW5ndGg9PT0wfHxhWzBdPT09MCkmJihhPVsxXSk7bGV0IHM9dC5zdHJpZGVzOyhzLmxlbmd0aD09PTB8fHNbMF09PT0wKSYmKHM9WzFdKTtsZXQgZD10LnBhZHM7ZC5sZW5ndGg9PT0wJiYoZD1bMCwwXSksZD1bMCxkWzBdLDAsZFsxXV0scz1bMV0uY29uY2F0KHMpLGE9WzFdLmNvbmNhdChhKSxvPVsxXS5jb25jYXQobyk7bGV0IGw9dC5vdXRwdXRQYWRkaW5nO2w9WzBdLmNvbmNhdChsKTtsZXQgcD1MZCh7Li4udCxwYWRzOmQsc3RyaWRlczpzLGRpbGF0aW9uczphLGtlcm5lbFNoYXBlOm8sb3V0cHV0UGFkZGluZzpsfSxyKTtIZChlLHIscCxmPT5uP1tmWzBdLGZbMl0sZlszXV06W2ZbMF0sZlsxXSxmWzNdXSl9LEZkPShlLHQpPT57aWYodWcoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKWRnKGUsdCk7ZWxzZXtsZXQgbj1MZCh0LGUuaW5wdXRzKTtIZChlLGUuaW5wdXRzLG4pfX19KTt2YXIgbGcsS2QsamQsWmQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7bGc9KGUsdCxuLHIpPT57bGV0IG89RS5zaXplKHQpLGE9dC5sZW5ndGgscz1QKFwiaW5wdXRcIixlLGEpLGQ9TihcIm91dHB1dFwiLGUsYSksbD1uLmRhdGFUeXBlPT09Nj9uLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIobi5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLHA9RS5ub3JtYWxpemVBeGlzKGwsYSksZj1oPT57bGV0IHk9YCBpMzIoJHtzLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLF89SyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJ1bmlmb3Jtcy5heGlzXCIsYSksYj1yLnJldmVyc2U/eSsoci5leGNsdXNpdmU/XCIgKyAxXCI6XCJcIik6XCIwXCIsdz1yLnJldmVyc2U/Xzp5KyhyLmV4Y2x1c2l2ZT9cIlwiOlwiICsgMVwiKTtyZXR1cm5gXG4gICAgICAgICAgICAgICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhzLGQpfVxuICAgICAgICAgICAgICAgICR7aC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtkLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHtifTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHt3fTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke3MuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGkpXCIpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHtzLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkN1bVN1bVwiLHNoYWRlckNhY2hlOntoaW50OnIuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6cH0sLi4uSCh0LHQpXX0pLGdldFNoYWRlclNvdXJjZTpmfX0sS2Q9KGUsdCk9PntsZXQgbj1lLmlucHV0c1swXS5kaW1zLHI9ZS5pbnB1dHNbMF0uZGF0YVR5cGUsbz1lLmlucHV0c1sxXTtlLmNvbXB1dGUobGcocixuLG8sdCkse2lucHV0czpbMF19KX0samQ9ZT0+e2xldCB0PWUuZXhjbHVzaXZlPT09MSxuPWUucmV2ZXJzZT09PTE7cmV0dXJuIHJlKHtleGNsdXNpdmU6dCxyZXZlcnNlOm59KX19KTt2YXIgY2cscGcsbWcsUWQsWWQsWGQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7Y2c9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC5cIil9LHBnPShlLHQsbixyKT0+e2xldCBvPVtdO28ucHVzaChgZm4gcGVybShpOiAke3IudHlwZS5pbmRpY2VzfSkgLT4gJHtuLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke24udHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IGE9MDthPHQ7KythKW8ucHVzaChuLmluZGljZXNTZXQoXCJhXCIsZVthXSxgaVske2F9XWApKTtyZXR1cm4gby5wdXNoKFwicmV0dXJuIGE7fVwiKSxvLmpvaW4oYFxuYCl9LG1nPShlLHQpPT57bGV0IG4scixvLGEscyxkLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPXQuYmxvY2tzaXplLGY9dC5tb2RlPT09XCJEQ1JcIjtsPyhbbixyLG8sYV09ZS5kaW1zLHM9Zj9bbixyLG8scCxwLGEvcCoqMl06W24scixvLGEvcCoqMixwLHBdLGQ9Zj9bMCwxLDMsMiw0LDVdOlswLDEsNCwyLDUsM10pOihbbixyLG8sYV09W2UuZGltc1swXSxlLmRpbXNbMl0sZS5kaW1zWzNdLGUuZGltc1sxXV0scz1mP1tuLHAscCxhL3AqKjIscixvXTpbbixhL3AqKjIscCxwLHIsb10sZD1mP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSk7bGV0IGg9ZS5yZXNoYXBlKHMpLHk9aC5kaW1zLmxlbmd0aCxfPWUuZGF0YVR5cGUsYj1QKFwiYVwiLF8seSksdz1OKFwib3V0cHV0XCIsXyx5KSxTPSQ9PmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhiLHcpfVxuXG4gICR7cGcoZCx5LGIsdyl9XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7dy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHt3LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGIuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIkRlcHRoVG9TcGFjZVwiLHNoYWRlckNhY2hlOntoaW50OmAke2UuZGltc307JHt0LmJsb2Nrc2l6ZX07JHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOiQ9PntsZXQgdj1sP1tuLHIqcCxvKnAsYS9wKioyXTpbbixhL3AqKjIscipwLG8qcF0sVD1FLnNpemUodiksQz1oLmRpbXMsQT1FLnNvcnRCYXNlZE9uUGVybShDLGQpO3JldHVybntvdXRwdXRzOlt7ZGltczp2LGRhdGFUeXBlOiRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChULzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOlR9LC4uLkgoQyxBKV19fSxnZXRTaGFkZXJTb3VyY2U6U319LFFkPShlLHQpPT57Y2coZS5pbnB1dHMpLGUuY29tcHV0ZShtZyhlLmlucHV0c1swXSx0KSl9LFlkPWU9PnJlKHtibG9ja3NpemU6ZS5ibG9ja3NpemUsbW9kZTplLm1vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgdm8sdG4sSmQsZmcsaGcsJG8seG8sZWwsZ2csdGwscmwsbmw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7dm89XCJbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC5cIix0bj1cIihcIit2bytcIikrXCIsSmQ9XCJeXCIrdG4rXCIkXCIsZmc9XCIoXCIrdG4rXCIsKSpcIit0bixoZz1cIl5cIitmZytcIiRcIiwkbz1jbGFzc3tjb25zdHJ1Y3Rvcih0PS0xKXt0aGlzLnN5bWJvbFRvSW5kaWNlcz1uZXcgTWFwLHRoaXMuaW5wdXRJbmRleD10fWFkZFN5bWJvbCh0LG4pe2xldCByPXRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldCh0KTtyPT09dm9pZCAwP3I9W25dOnIucHVzaChuKSx0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQodCxyKX19LHhvPWNsYXNze2NvbnN0cnVjdG9yKHQsbil7dGhpcy5lcXVhdGlvbj1uO3RoaXMuaGFzRWxsaXBzaXM9ITEsdGhpcy5zeW1ib2xUb0luZm89bmV3IE1hcCx0aGlzLmxocz1uZXcgQXJyYXksdGhpcy5vdXRwdXREaW1zPVtdO2xldFtyLG9dPW4uaW5jbHVkZXMoXCItPlwiKT9uLnNwbGl0KFwiLT5cIiwyKTpbbixcIlwiXTtpZighci5tYXRjaChSZWdFeHAoaGcpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2lmKHIuc3BsaXQoXCIsXCIpLmZvckVhY2goKGQsbCk9PntsZXQgcD10W2xdLmRpbXMuc2xpY2UoKTtpZighZC5tYXRjaChSZWdFeHAoSmQpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBmPXRoaXMucHJvY2Vzc1Rlcm0oZCwhMCxwLGwpO3RoaXMubGhzLnB1c2goZil9KSxvPT09XCJcIilvKz1bLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXS5maWx0ZXIoKFtkLGxdKT0+bC5jb3VudD09PTF8fGQ9PT1cIi4uLlwiKS5tYXAoKFtkXSk9PmQpLmpvaW4oXCJcIik7ZWxzZSBpZighby5tYXRjaChSZWdFeHAodG4pKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIU1wiKTtvLm1hdGNoKFJlZ0V4cCh2byxcImdcIikpPy5mb3JFYWNoKGQ9PntpZihkPT09XCIuLi5cIil0aGlzLm91dHB1dERpbXM9dGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7ZWxzZXtsZXQgbD10aGlzLnN5bWJvbFRvSW5mby5nZXQoZCk7aWYobD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIUyBzeW1ib2xcIik7dGhpcy5vdXRwdXREaW1zLnB1c2gobC5kaW1WYWx1ZSl9fSksdGhpcy5yaHM9dGhpcy5wcm9jZXNzVGVybShvLCExLHRoaXMub3V0cHV0RGltcyl9YWRkU3ltYm9sKHQsbixyKXtsZXQgbz10aGlzLnN5bWJvbFRvSW5mby5nZXQodCk7aWYobyE9PXZvaWQgMCl7aWYoby5kaW1WYWx1ZSE9PW4mJm8uY291bnQhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNtYXRjaFwiKTtvLmNvdW50Kyssby5pbnB1dEluZGljZXMucHVzaChyKX1lbHNlIG89e2NvdW50OjEsZGltVmFsdWU6bixpbnB1dEluZGljZXM6W3JdfTt0aGlzLnN5bWJvbFRvSW5mby5zZXQodCxvKX1wcm9jZXNzVGVybSh0LG4scixvPS0xKXtsZXQgYT1yLmxlbmd0aCxzPSExLGQ9W10sbD0wO2lmKCF0Lm1hdGNoKFJlZ0V4cChKZCkpJiYhbiYmdCE9PVwiXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgcD10Lm1hdGNoKFJlZ0V4cCh2byxcImdcIikpLGY9bmV3ICRvKG8pO3JldHVybiBwPy5mb3JFYWNoKChoLHkpPT57aWYoaD09PVwiLi4uXCIpe2lmKHMpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybVwiKTtzPSEwO2xldCBfPWEtcC5sZW5ndGgrMTtpZihfPDApdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihkPXIuc2xpY2UobCxsK18pLHRoaXMuaGFzRWxsaXBzaXMpe2lmKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCE9PWQubGVuZ3RofHx0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpIT09ZC50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2hcIil9ZWxzZSBpZihuKXRoaXMuaGFzRWxsaXBzaXM9ITAsdGhpcy5lbGxpcHNpc0RpbXM9ZDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFNcIik7Zm9yKGxldCBiPTA7YjxkLmxlbmd0aDtiKyspe2xldCB3PVN0cmluZy5mcm9tQ2hhckNvZGUoNDgrYik7Zi5hZGRTeW1ib2wodyx5K2IpLHRoaXMuYWRkU3ltYm9sKHcscltsKytdLG8pfX1lbHNlIGYuYWRkU3ltYm9sKGgseSsodGhpcy5oYXNFbGxpcHNpcz90aGlzLmVsbGlwc2lzRGltcy5sZW5ndGgtMTowKSksdGhpcy5hZGRTeW1ib2woaCxyW2wrK10sbyl9KSxmfX0sZWw9ZT0+ZStcIl9tYXhcIixnZz0oZSx0LG4scik9PntsZXQgYT1lLm1hcChmPT5mLmxlbmd0aCkubWFwKChmLGgpPT5QKGBpbnB1dCR7aH1gLHQsZikpLHM9RS5zaXplKHIpLGQ9TihcIm91dHB1dFwiLHQsci5sZW5ndGgpLGw9Wy4uLm4uc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKGY9PiFuLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKGYpKSxwPWY9PntsZXQgaD1bXSx5PVwidmFyIHByb2QgPSAxLjA7XCIsXz1cInZhciBzdW0gPSAwLjA7XCIsYj1cInN1bSArPSBwcm9kO1wiLHc9W10sUz1bXSwkPVtdLHY9W10sVD1uLnN5bWJvbFRvSW5mby5zaXplPT09bi5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7bi5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQSxrKT0+e2lmKG4ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoaykpe2xldCBPPW4ucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk/LlswXTtPIT09dm9pZCAwJiZuLmxocy5mb3JFYWNoKChNLFYpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoVikpe2xldCBGPU0uc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihGPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0YuZm9yRWFjaChqPT57aC5wdXNoKGAke2FbVl0uaW5kaWNlc1NldChgaW5wdXQke1Z9SW5kaWNlc2AsaixkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsTykpfWApfSl9fSl9ZWxzZSBuLmxocy5mb3JFYWNoKChPLE0pPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoTSkpe2xldCBWPU8uc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihWPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO1YuZm9yRWFjaChGPT57dy5wdXNoKGAke2FbTV0uaW5kaWNlc1NldChgaW5wdXQke019SW5kaWNlc2AsRixgJHtrfWApfWApfSksdi5wdXNoKGBwcm9kICo9ICR7YVtNXS5nZXRCeUluZGljZXMoYGlucHV0JHtNfUluZGljZXNgKX07YCl9fSksUy5wdXNoKGBmb3IodmFyICR7a306IHUzMiA9IDA7ICR7a30gPCB1bmlmb3Jtcy4ke2VsKGspfTsgJHtrfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBDPVQ/Wy4uLmgsYGxldCBzdW0gPSAke2EubWFwKChBLGspPT5BLmdldEJ5SW5kaWNlcyhgaW5wdXQke2t9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4uaCxfLC4uLlMsLi4udyx5LC4uLnYsYiwuLi4kXTtyZXR1cm5gXG4gICAgICAgICAgICAke2YucmVnaXN0ZXJVbmlmb3JtcyhsLm1hcChBPT4oe25hbWU6YCR7ZWwoQSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmEsZCl9XG5cbiAgICAgICAgICAgICR7Zi5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7Zi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgJHthLm1hcCgoQSxrKT0+YHZhciBpbnB1dCR7a31JbmRpY2VzOiAke2Fba10udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAgICAgJHtDLmpvaW4oYFxuYCl9O1xuICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDpuLmVxdWF0aW9uLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCgpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9PntsZXQgZj1sLmZpbHRlcih5PT5uLnN5bWJvbFRvSW5mby5oYXMoeSkpLm1hcCh5PT4oe3R5cGU6MTIsZGF0YTpuLnN5bWJvbFRvSW5mby5nZXQoeSk/LmRpbVZhbHVlfHwwfSkpO2YucHVzaCh7dHlwZToxMixkYXRhOnN9KTtsZXQgaD1lLm1hcCgoeSxfKT0+Wy4uLkgoeSldKS5yZWR1Y2UoKHksXyk9PnkuY29uY2F0KF8pLGYpO3JldHVybiBoLnB1c2goLi4uSChyKSkse291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6dH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH19LGdldFNoYWRlclNvdXJjZTpwfX0sdGw9KGUsdCk9PntsZXQgbj1uZXcgeG8oZS5pbnB1dHMsdC5lcXVhdGlvbikscj1uLm91dHB1dERpbXMsbz1lLmlucHV0cy5tYXAoKGEscyk9PmEuZGltcyk7ZS5jb21wdXRlKGdnKG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUsbixyKSl9LHJsPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gcmUoe2VxdWF0aW9uOnR9KX19KTt2YXIgeWcsb2wsYmcsX2csaWwsYWw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3lnPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMsbj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlcikscj1uLmxlbmd0aDx0Lmxlbmd0aD8wOm4ubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8bi5sZW5ndGg/MDp0Lmxlbmd0aC1uLmxlbmd0aDtmb3IoO3I8bi5sZW5ndGgmJm88dC5sZW5ndGg7KytyLCsrbylpZihuW3JdIT09dFtvXSYmbltyXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxvbD0oZSx0KT0+e2xldCBuPWUubGVuZ3RoLXQubGVuZ3RoLHI9W107Zm9yKGxldCBvPTA7bzxuOysrbylyLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pci5wdXNoKHRbb109PT0xP2VbbytuXTp0W29dKTtyZXR1cm4gcn0sYmc9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP29sKGUsdCk6b2wodCxlKSxfZz1lPT57bGV0IHQ9ZVswXS5kaW1zLG49QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLHI9YmcodCxuKSxvPWVbMF0uZGF0YVR5cGUsYT1vPT09OXx8RS5zaXplKHQpPT09MSxzPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxkPWF8fHIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA/NDoxLGw9TWF0aC5jZWlsKEUuc2l6ZShyKS9kKSxwPWg9PntsZXQgeT1QKFwiaW5wdXRcIixvLHQubGVuZ3RoLHMpLF89TihcIm91dHB1dFwiLG8sci5sZW5ndGgsZCksYjtpZihvPT09OSl7bGV0IHc9KFMsJCx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMkeyR9ID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHskfXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7JH0gPSAke3kuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMkeyR9YCxfKX07XG4gICAgICAgICAgbGV0IGluZGV4JHskfSA9IG9mZnNldCR7JH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHskfSA9IG9mZnNldCR7JH0gJSA0dTtcbiAgICAgICAgICAke1N9WyR7JH1dID0gJHt2fSgke3kuZ2V0QnlPZmZzZXQoYGluZGV4JHskfWApfVtjb21wb25lbnQkeyR9XSk7XG4gICAgICAgIGA7Yj1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtkfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7dyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3coXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHt3KFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7dyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSBiPWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtkfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHt5LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLF8pfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke18udHlwZS52YWx1ZX0oJHt5LmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7c31gKX0pO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxfKX1cbiAgICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke2J9YH0sZj1be3R5cGU6MTIsZGF0YTpsfSwuLi5IKHQscildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5sZW5ndGh9OyR7c30ke2R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pfX0saWw9ZT0+e3lnKGUuaW5wdXRzKSxlLmNvbXB1dGUoX2coZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHdnLHNsLHVsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtqcigpO3dnPWU9PntsZXQgdD1lWzBdLmRhdGFUeXBlLG49RS5zaXplKGVbMF0uZGltcykscj1FLnNpemUoZVsxXS5kaW1zKSxvPXIlND09PTAsYT1zPT57bGV0IGQ9UChcInhcIix0LFsxXSw0KSxsPVAoXCJiaWFzXCIsdCxbMV0sNCkscD1OKFwieVwiLHQsWzFdLDQpLGY9W3tuYW1lOlwib3V0cHV0X3ZlY19zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dLGg9Xz0+YFxuICAgICAgbGV0IGJpYXMke199X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtffSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7X30gPSAke2wuZ2V0QnlPZmZzZXQoYGJpYXMke199X29mZnNldCAvIDRgKX1bYmlhcyR7X31fb2Zmc2V0ICUgNF07YCx5PW8/YFxuICAgICAgbGV0IGJpYXMgPSAke2wuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpXCIpfTtgOmAke2goMCl9JHtoKDEpfSR7aCgyKX0ke2goMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7ZC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtyZXR1cm5gJHtzLnJlZ2lzdGVyVW5pZm9ybXMoZikuZGVjbGFyZVZhcmlhYmxlcyhkLGwscCl9XG5cbiAgICAke21vKHplKHQpKX1cblxuICAgICR7cy5tYWluU3RhcnQoRXQpfVxuICAgICAgJHtzLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemVcIil9XG5cbiAgICAgIGxldCB4ID0gJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke3l9XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGZvKFwieF9pblwiKSl9XG4gICAgfWB9O3JldHVybntuYW1lOlwiRmFzdEdlbHVXaXRoQmlhc1wiLHNoYWRlckNhY2hlOntoaW50OmAke299YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6YSxnZXRSdW5EYXRhOnM9Pih7b3V0cHV0czpbe2RpbXM6c1swXS5kaW1zLGRhdGFUeXBlOnNbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKG4vNCl9LHt0eXBlOjEyLGRhdGE6cn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vRXQvNCl9fSl9fSxzbD1lPT57ZS5pbnB1dHMubGVuZ3RoPDJ8fEUuc2l6ZShlLmlucHV0c1sxXS5kaW1zKT09PTA/bmQoZSk6ZS5jb21wdXRlKHdnKGUuaW5wdXRzKSl9fSk7dmFyIHZnLCRnLGRsLGxsLGNsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO3ZnPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LCRnPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVsxXS5kaW1zLG89bi5sZW5ndGgsYT1FLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLHM9bi5zbGljZSgwKTtzLnNwbGljZShhLDEsLi4ucik7bGV0IGQ9blthXSxsPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxwPU1hdGguY2VpbChFLnNpemUocykvbCksZj1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZTo2LGRhdGE6ZH0se3R5cGU6MTIsZGF0YTphfSwuLi5IKGVbMF0uZGltcyxlWzFdLmRpbXMscyldLGg9eT0+e2xldCBfPVAoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLGI9UChcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksdz1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxzLmxlbmd0aCxsKSxTPXY9PntsZXQgVD1yLmxlbmd0aCxDPWB2YXIgaW5kaWNlc0luZGljZXMke3Z9ICA9ICR7Yi50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBBPTA7QTxUO0ErKylDKz1gJHtUPjE/YGluZGljZXNJbmRpY2VzJHt2fVske0F9XWA6YGluZGljZXNJbmRpY2VzJHt2fWB9ID0gJHtzLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVt1bmlmb3Jtcy5heGlzICsgJHtBfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2A7Qys9YFxuICAgICAgICAgIHZhciBpZHgke3Z9ID0gJHtiLmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3Z9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3Z9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt2fSA9IGlkeCR7dn0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7dn0gOiAke18udHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IEE9MCxrPTA7QTxvO0ErKylBPT09YT8oQys9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9IHUzMihpZHgke3Z9KTtgLGsrPVQpOihDKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gJHtzLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVske2t9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YCxrKyspO3JldHVybiBDfSwkO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgdj0oVCxDLEE9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7Q30gPSAke3cub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke0N9dWApfTtcbiAgICAgICAgICAke1MoQyl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke0N9ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke0N9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7Q30gPSBvZmZzZXQke0N9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7Q30gPSBvZmZzZXQke0N9ICUgNHU7XG4gICAgICAgICAgJHtUfVske0N9XSA9ICR7QX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7Q31gKX1bY29tcG9uZW50JHtDfV0pO1xuICAgICAgICBgOyQ9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7bH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt2KFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke3cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSAkPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHtTKFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke3cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7eS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyxiLHcpfVxuICAgICAgJHt5Lm1haW5TdGFydCgpfVxuICAgICAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6aH19LGRsPWU9PnJlKHtheGlzOmUuYXhpc30pLGxsPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7dmcobiksZS5jb21wdXRlKCRnKGUuaW5wdXRzLHQpKX19KTt2YXIgeGcscGwsbWwsZmw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3hnPShlLHQsbixyLG8sYSxzLGQsbCk9PntsZXQgcD1be3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfV0sZj1bYV07cC5wdXNoKC4uLkgodC5kaW1zLGYpKTtsZXQgaD15PT57bGV0IF89UChcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksYj1OKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSx3PVtfLGJdLFM9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6bi5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKC4uLncpfVxuICAke3kubWFpblN0YXJ0KCl9XG4gICAgJHt5Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtuLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7bi5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmYsZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6aH0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LHBsPShlLHQpPT57bGV0IG49ZS5pbnB1dHMscj1uWzBdLmRpbXMsbz1uWzBdLmRhdGFUeXBlLGE9blsxXS5kaW1zLHM9YVthLmxlbmd0aC0xXSxkPUUuc2l6ZVRvRGltZW5zaW9uKGEsYS5sZW5ndGgtMSksbD1FLnNpemVGcm9tRGltZW5zaW9uKHIsdC5iYXRjaERpbXMrcykscD1FLnNpemVUb0RpbWVuc2lvbihyLHQuYmF0Y2hEaW1zKSxmPUUuc2l6ZUZyb21EaW1lbnNpb24ocix0LmJhdGNoRGltcyksaD1kL3AseT1uZXcgQXJyYXkocyksXz1sO2ZvcihsZXQgQz0wO0M8czsrK0MpeVtzLTEtQ109XyxfKj1yW3QuYmF0Y2hEaW1zK3MtMS1DXTtsZXQgYj14ZyhlLG5bMV0seSx0LmJhdGNoRGltcyxyLGQsaCxmLHMpLHc9dC5iYXRjaERpbXMrcztpZih3PnIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IFM9YS5zbGljZSgwLC0xKS5jb25jYXQoci5zbGljZSh3KSksJD1FLnNpemUoUyksdj1be3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOmx9LC4uLkgoblswXS5kaW1zLGIuZGltcyxTKV0sVD1DPT57bGV0IEE9UChcImRhdGFcIixuWzBdLmRhdGFUeXBlLG5bMF0uZGltcy5sZW5ndGgpLGs9UChcInNsaWNlX29mZnNldHNcIiwxMixiLmRpbXMubGVuZ3RoKSxPPU4oXCJvdXRwdXRcIixuWzBdLmRhdGFUeXBlLFMubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHtDLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoQSxrLE8pfVxuICAgICAgICAgICAgJHtDLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtDLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOlMsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpUfSx7aW5wdXRzOltuWzBdLGJdfSl9LG1sPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgU2csVGcsaGwsZ2wseWw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7U2c9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIkdhdGhlckJsb2NrUXVhbnRpemVkIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMuXCIpO2xldCBuPUUubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxyPXQuYmxvY2tTaXplLG89ZVswXSxhPWVbMl0scz1lLmxlbmd0aD09PTQ/ZVszXTp2b2lkIDA7aWYoYS5kaW1zLmxlbmd0aCE9PW8uZGltcy5sZW5ndGh8fCFvLmRpbXMubWFwKChkLGwpPT5sPT09bj9NYXRoLmNlaWwoZC9yKT09PWEuZGltc1tsXTpkPT09YS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlNjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuXCIpO2lmKHMpe2lmKHMuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihzLmRpbXMubGVuZ3RoIT09YS5kaW1zLmxlbmd0aHx8IXMuZGltcy5tYXAoKGQsbCk9PmQ9PT1hLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIHF1YW50aXplQXhpcy5cIil9fSxUZz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4ubGVuZ3RoLGE9RS5ub3JtYWxpemVBeGlzKHQuZ2F0aGVyQXhpcyxvKSxzPUUubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxvKSxkPW4uc2xpY2UoMCk7ZC5zcGxpY2UoYSwxLC4uLnIpO2xldCBsPUUuc2l6ZShkKSxwPWVbMl0uZGF0YVR5cGUsaD1lWzBdLmRhdGFUeXBlPT09MjIseT1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uSCguLi5lLm1hcCgoYix3KT0+Yi5kaW1zKSxkKV0sXz1iPT57bGV0IHc9UChcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLFM9UChcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksJD1QKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSx2PWUubGVuZ3RoPjM/UChcInplcm9Qb2ludFwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwLFQ9TihcIm91dHB1dFwiLHAsZC5sZW5ndGgpLEM9W3csUywkXTt2JiZDLnB1c2godik7bGV0IEE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicXVhbnRpemVfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJnYXRoZXJfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgICAke2IucmVnaXN0ZXJVbmlmb3JtcyhBKS5kZWNsYXJlVmFyaWFibGVzKC4uLkMsVCl9XG4gICAgICAgICR7Yi5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtULm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHtTLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICR7ci5sZW5ndGg+MT9gXG4gICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7VC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzICsgaVwiKX07XG4gICAgICAgICAgICAke1MuaW5kaWNlc1NldChcImluZGljZXNfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICAgIH1gOmBpbmRpY2VzX2luZGljZXMgPSAke1QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiKX07YH07XG4gICAgICAgIHZhciBkYXRhX2luZGljZXMgPSAke3cudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmdhdGhlcl9heGlzOyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke1QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAke3cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleF9mcm9tX2luZGljZXMgPSAke1MuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc19pbmRpY2VzXCIpfTtcbiAgICAgICAgaWYgKGluZGV4X2Zyb21faW5kaWNlcyA8IDApIHtcbiAgICAgICAgICBpbmRleF9mcm9tX2luZGljZXMgKz0gJHtuW2FdfTtcbiAgICAgICAgfVxuICAgICAgICAke3cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIixcInUzMihpbmRleF9mcm9tX2luZGljZXMpXCIpfTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHVuaWZvcm1zLmdhdGhlcl9heGlzICsgMTsgaSA8ICR7ZC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSAke1QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsYGkgKyAke3IubGVuZ3RofSAtIDFgKX07XG4gICAgICAgICAgJHt3LmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YV9vZmZzZXQgPSAke3cuaW5kaWNlc1RvT2Zmc2V0KFwiZGF0YV9pbmRpY2VzXCIpfTtcbiAgICAgICAgbGV0IGRhdGFfaW5kZXggPSBkYXRhX29mZnNldCAlIDg7XG4gICAgICAgIC8vIENvbnZlcnQgNC1iaXQgcGFja2VkIGRhdGEgdG8gOC1iaXQgcGFja2VkIGRhdGEuXG4gICAgICAgIGxldCBwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA9ICR7dy5nZXRCeU9mZnNldChcImRhdGFfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgIGxldCBwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSA9IChwYWNrZWRfNGJpdF9xdWFudGl6ZWRfZGF0YSA+PiAoNCAqIChkYXRhX2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YV92ZWMgPSAke2g/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF9xdWFudGl6ZWRfZGF0YSkpO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGEgPSBxdWFudGl6ZWRfZGF0YV92ZWNbZGF0YV9pbmRleCAvIDJdO1xuICAgICAgICB2YXIgc2NhbGVfaW5kaWNlcyA9IGRhdGFfaW5kaWNlcztcbiAgICAgICAgbGV0IHF1YW50aXplX2F4aXNfaW5kZXggPSAkeyQuaW5kaWNlc0dldChcImRhdGFfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAkeyQuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIixcInF1YW50aXplX2F4aXNfaW5kZXhcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAkeyQuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICR7dj9gXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3YuaW5kaWNlc1RvT2Zmc2V0KFwiemVyb19wb2ludF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSB6ZXJvX3BvaW50X29mZnNldCAlIDg7XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7di5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7aD9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A6XCJ2YXIgemVyb19wb2ludCA9IDBcIn07XG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHt6ZShwKX0ocXVhbnRpemVkX2RhdGEgLSB6ZXJvX3BvaW50KSAqIHNjYWxlO1xuICAgICAgICAke1Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkZXF1YW50aXplZF9kYXRhXCIpfTtcbiAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7ZS5maWx0ZXIoKGIsdyk9PnchPT0xKS5tYXAoYj0+Yi5kaW1zLmpvaW4oXCJfXCIpKS5qb2luKFwiO1wiKX1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5LmZyb20oe2xlbmd0aDplLmxlbmd0aH0sKGIsdyk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnB9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6X319LGhsPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7U2cobix0KSxlLmNvbXB1dGUoVGcoZS5pbnB1dHMsdCkpfSxnbD1lPT5yZSh7YmxvY2tTaXplOmUuYmxvY2tTaXplLGdhdGhlckF4aXM6ZS5nYXRoZXJBeGlzLHF1YW50aXplQXhpczplLnF1YW50aXplQXhpc30pfSk7dmFyIENnLElnLGJsLF9sLHdsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0NnPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCl9LElnPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVswXS5kYXRhVHlwZSxvPW4ubGVuZ3RoLGE9ZVsxXS5kaW1zLHM9ZVsxXS5kYXRhVHlwZSxkPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsbyksbD1uW2RdLHA9YS5zbGljZSgwKSxmPUUuc2l6ZShwKSxoPVAoXCJpbnB1dFwiLHIsbykseT1QKFwiaW5kaWNlc0lucHV0XCIscyxhLmxlbmd0aCksXz1OKFwib3V0cHV0XCIscixwLmxlbmd0aCksYj1be3R5cGU6MTIsZGF0YTpmfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTpkfV07cmV0dXJuIGIucHVzaCguLi5IKG4sYSxwKSkse25hbWU6XCJHYXRoZXJFbGVtZW50c1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnAsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGYvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Yn0pLGdldFNoYWRlclNvdXJjZTokPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNEaW1MaW1pdFwiLFwiaTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGgseSxfKX1cbiAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgIHZhciBpZHggPSAke3kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgIGlkeCA9IGlkeCArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2gudHlwZS5pbmRpY2VzfShvdXRwdXRJbmRpY2VzKTtcbiAgICAgICR7aC5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJ1MzIoaWR4KVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke2guZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpfTtcblxuICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH19LGJsPWU9PnJlKHtheGlzOmUuYXhpc30pLF9sPShlLHQpPT57bGV0IG49ZS5pbnB1dHM7Q2cobiksZS5jb21wdXRlKElnKGUuaW5wdXRzLHQpKX19KTt2YXIgQWcsa2csdmwsJGwseGw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO0FnPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxrZz0oZSx0KT0+e2xldCBuPWVbMF0uZGltcy5zbGljZSgpLHI9ZVsxXS5kaW1zLnNsaWNlKCksW28sYSxzXT1Xci5nZXRTaGFwZU9mR2VtbVJlc3VsdChuLHQudHJhbnNBLHIsdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGQ9W28sYV07aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGw9MTYscD1NYXRoLmNlaWwoYS9sKSxmPU1hdGguY2VpbChvL2wpLGg9ITAseT1FLnNpemUoZCksXz1be3R5cGU6MTIsZGF0YTpoP3A6eX0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MSxkYXRhOnQuYWxwaGF9LHt0eXBlOjEsZGF0YTp0LmJldGF9XSxiPVtcInR5cGVcIixcInR5cGVcIl07ZS5sZW5ndGg9PT0zJiYoXy5wdXNoKC4uLkgoZVsyXS5kaW1zKSksYi5wdXNoKFwicmFua1wiKSksXy5wdXNoKC4uLkgoZCkpO2xldCB3PSQ9PntsZXQgdj1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJih2PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiKTtsZXQgVD10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCIsQz1QKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxBPVAoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLGs9Qy50eXBlLnZhbHVlLE89bnVsbCxNPVtDLEFdO2UubGVuZ3RoPT09MyYmKE89UChcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLE0ucHVzaChPKSk7bGV0IFY9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZC5sZW5ndGgpO00ucHVzaChWKTtsZXQgRj1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhGKS5kZWNsYXJlVmFyaWFibGVzKC4uLk0pfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHtrfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHt2fVxuICAgIH1cblxuICAgICR7VH1cbiAgICAke08hPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtPLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLFYpfTsgdmFsdWUgKz0gJHtrfSh1bmlmb3Jtcy5iZXRhKSAqICR7Ty5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIn1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LFM9JD0+e2xldCB2PVAoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFQ9UChcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksQz1udWxsLEE9W3YsVF07ZS5sZW5ndGg9PT0zJiYoQz1QKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQS5wdXNoKEMpKTtsZXQgaz1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7QS5wdXNoKGspO2xldCBPPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLE09XCJcIixWPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhWPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtULnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxNPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhWPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtULnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxNPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhWPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtULnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxNPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKFY9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1QudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLE09XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCBGPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKE8pLmRlY2xhcmVWYXJpYWJsZXMoLi4uQSl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke1QudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICAkeyQubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7bH0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtrLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7Vn1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHtsfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke2x9OyBrKyspIHtcbiAgICAgICAgJHtNfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7Rn1cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAke0MhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtDLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLGspfTsgdmFsdWUgKz0gJHtrLnR5cGUudmFsdWV9KHVuaWZvcm1zLmJldGEpICogJHtDLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwifVxuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgb3V0cHV0W20gKiB1bmlmb3Jtcy5OICsgbl0gPSB2YWx1ZTtcbiAgICB9XG4gIH1gfTtyZXR1cm4gaD97bmFtZTpcIkdlbW1TaGFyZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6Yn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnAqZn0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6U306e25hbWU6XCJHZW1tXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOmJ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeS82NCl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOnd9fSx2bD1lPT57bGV0IHQ9ZS50cmFuc0Esbj1lLnRyYW5zQixyPWUuYWxwaGEsbz1lLmJldGE7cmV0dXJue3RyYW5zQTp0LHRyYW5zQjpuLGFscGhhOnIsYmV0YTpvLGNhY2hlS2V5OmAke2UudHJhbnNBfTske2UudHJhbnNCfTske2UuYWxwaGE9PT0xfWB9fSwkbD0oZSx0KT0+e0FnKGUuaW5wdXRzKSxlLmNvbXB1dGUoa2coZS5pbnB1dHMsdCkpfX0pO3ZhciBwdCwkdCxOdCxWdCxFZyxQZyx6ZyxPZyxEZyxCZyxNZyxSZyxTbCxUbCxDbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtbcHQsJHQsTnQsVnRdPVswLDEsMiwzXSxFZz1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwib25seSA0LUQgdGVuc29yIGlzIHN1cHBvcnRlZC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIHRvIGdyaWQgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoLTIhPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0xXSl0aHJvdyBuZXcgRXJyb3IoYGxhc3QgZGltZW5zaW9uIG9mIGdyaWQgbXVzdCBiZSBlcXVhbCB0byAke2VbMF0uZGltcy5sZW5ndGgtMn1gKTtpZihlWzBdLmRpbXNbMF0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwiZ3JpZCBiYXRjaCBzaXplIG11c3QgbWF0Y2ggaW5wdXQgYmF0Y2ggc2l6ZVwiKX0sUGc9YFxuICBmbiBnc19nZXRfY3ViaWNfY29lZmZzKHg6IGYzMikgLT4gdmVjNDxmMzI+IHtcbiAgICBsZXQgY3ViaWNfYWxwaGEgPSAtMC43NWY7XG4gICAgbGV0IHhfYWJzID0gYWJzKHgpO1xuICAgIHZhciBjb2VmZnM6IHZlYzQ8ZjMyPjtcbiAgICBjb2VmZnNbMF0gPSAoKChjdWJpY19hbHBoYSAqICh4X2FicyArIDEpIC0gNSAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpICsgOCAqIGN1YmljX2FscGhhKSAqICh4X2FicyArIDEpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICBjb2VmZnNbMV0gPSAoKChjdWJpY19hbHBoYSArIDIpICogeF9hYnMgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiB4X2FicyAqIHhfYWJzICsgMSk7XG4gICAgY29lZmZzWzJdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqICgxIC0geF9hYnMpIC0gKGN1YmljX2FscGhhICsgMykpICogKDEgLSB4X2FicykgKiAoMSAtIHhfYWJzKSArIDEpO1xuICAgIGNvZWZmc1szXSA9ICgoKGN1YmljX2FscGhhICogKDIgLSB4X2FicykgLSA1ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgKyA4ICogY3ViaWNfYWxwaGEpICogKDIgLSB4X2FicykgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cbmAsemc9ZT0+YFxuICBmbiBnc19iaWN1YmljX2ludGVycG9sYXRlKHA6IG1hdDR4NDwke2V9PiwgeDogZjMyLCB5OiBmMzIpIC0+ICR7ZX0ge1xuICAgIHZhciB2OiB2ZWM0PGYzMj47XG4gICAgdmFyIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHZbaV0gPSBjb2VmZnNbMF0gKiBwW2ldWzBdICsgY29lZmZzWzFdICogcFtpXVsxXSArIGNvZWZmc1syXSAqIHBbaV1bMl0gKyBjb2VmZnNbM10gKiBwW2ldWzNdO1xuICAgIH1cbiAgICBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHkpO1xuICAgIGxldCBwaXhlbCA9ICR7ZX0oY29lZmZzWzBdICogdlswXSArIGNvZWZmc1sxXSAqIHZbMV0gKyBjb2VmZnNbMl0gKiB2WzJdICsgY29lZmZzWzNdICogdlszXSk7XG4gICAgcmV0dXJuIHBpeGVsO1xuICB9XG5gLE9nPWU9PmBcbiAgZm4gZ3NfZGVub3JtYWxpemUobjogZjMyLCBsZW5ndGg6IGkzMikgLT4gZjMyIHtcbiAgICAke2UuYWxpZ25Db3JuZXJzPT09MD9gXG4gICAgLy8gYWxpZ25Db3JuZXJzOiBmYWxzZSA9PiBbLTEsIDFdIHRvIFstMC41LCBsZW5ndGggLSAwLjVdXG4gICAgcmV0dXJuICgobiArIDEuMCkgKiBmMzIobGVuZ3RoKSAtIDEuMCkgLyAyLjA7XG4gICAgYDpgXG4gICAgLy8gYWxpZ25Db3JuZXJzOiB0cnVlID0+IFstMSwgMV0gdG8gWzAsIGxlbmd0aCAtIDFdXG4gICAgcmV0dXJuIChuICsgMS4wKSAvIDIuMCAqIChmMzIobGVuZ3RoIC0gMSkpO1xuICAgIGB9XG4gIH1cbmAsRGc9ZT0+YFxuICAke2UucGFkZGluZ01vZGU9PT1cInJlZmxlY3Rpb25cIj9gXG4gICAgICBmbiBnc19yZWZsZWN0KHg6IGkzMiwgeF9taW46IGYzMiwgeF9tYXg6IGYzMikgLT4gdTMyIHtcbiAgICAgICAgdmFyIGR4ID0gMC4wO1xuICAgICAgICB2YXIgZnggPSBmMzIoeCk7XG4gICAgICAgIGxldCByYW5nZSA9IHhfbWF4IC0geF9taW47XG4gICAgICAgIGlmIChmeCA8IHhfbWluKSB7XG4gICAgICAgICAgZHggPSB4X21pbiAtIGZ4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmeCA+IHhfbWF4KSB7XG4gICAgICAgICAgZHggPSBmeCAtIHhfbWF4O1xuICAgICAgICAgIGxldCBuID0gdTMyKGR4IC8gcmFuZ2UpO1xuICAgICAgICAgIGxldCByID0gZHggLSBmMzIobikgKiByYW5nZTtcbiAgICAgICAgICBpZiAobiAlIDIgPT0gMCkge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdTMyKGZ4KTtcbiAgICAgIH1gOlwiXCJ9XG5gLEJnPShlLHQsbik9PmBcbiAgZm4gcGl4ZWxfYXRfZ3JpZChyOiBpMzIsIGM6IGkzMiwgSDogaTMyLCBXOiBpMzIsIGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgYm9yZGVyOiB2ZWM0PGYzMj4pIC0+ICR7dH0ge1xuICAgICB2YXIgcGl4ZWwgPSAke3R9KDApO1xuICAgICB2YXIgaW5kaWNlcyA9IHZlYzQ8dTMyPigwKTtcbiAgICAgaW5kaWNlc1ske3B0fV0gPSBiYXRjaDtcbiAgICAgaW5kaWNlc1skeyR0fV0gPSBjaGFubmVsO2ArKCgpPT57c3dpdGNoKG4ucGFkZGluZ01vZGUpe2Nhc2VcInplcm9zXCI6cmV0dXJuYFxuICAgICAgICAgIGlmIChyID49IDAgJiYgciA8IEggJiYgYyA+PTAgJiYgYyA8IFcpIHtcbiAgICAgICAgICAgIGluZGljZXNbJHtOdH1dID0gdTMyKHIpO1xuICAgICAgICAgICAgaW5kaWNlc1ske1Z0fV0gPSB1MzIoYyk7XG4gICAgICAgICAgfVxuICAgICAgICBgO2Nhc2VcImJvcmRlclwiOnJldHVybmBcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjbGFtcChyLCAwLCBIIC0gMSkpO1xuICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gdTMyKGNsYW1wKGMsIDAsIFcgLSAxKSk7XG4gICAgICAgIGA7Y2FzZVwicmVmbGVjdGlvblwiOnJldHVybmBcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IGdzX3JlZmxlY3QociwgYm9yZGVyWzFdLCBib3JkZXJbM10pO1xuICAgICAgICAgIGluZGljZXNbJHtWdH1dID0gZ3NfcmVmbGVjdChjLCBib3JkZXJbMF0sIGJvcmRlclsyXSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHBhZGRpbmcgbW9kZSAke24ucGFkZGluZ01vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2BcbiAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIil9O1xuICB9XG5gLE1nPShlLHQsbik9PigoKT0+e3N3aXRjaChuLm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IHBpeGVsX2F0X2dyaWQoaTMyKHJvdW5kKHkpKSwgaTMyKHJvdW5kKHgpKSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuICAgICAgICBgO2Nhc2VcImJpbGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MSA9IGkzMihmbG9vcih4KSk7XG4gICAgICAgICAgbGV0IHkxID0gaTMyKGZsb29yKHkpKTtcbiAgICAgICAgICBsZXQgeDIgPSB4MSArIDE7XG4gICAgICAgICAgbGV0IHkyID0geTEgKyAxO1xuXG4gICAgICAgICAgbGV0IHAxMSA9IHBpeGVsX2F0X2dyaWQoeTEsIHgxLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAxMiA9IHBpeGVsX2F0X2dyaWQoeTEsIHgyLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAyMSA9IHBpeGVsX2F0X2dyaWQoeTIsIHgxLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG4gICAgICAgICAgbGV0IHAyMiA9IHBpeGVsX2F0X2dyaWQoeTIsIHgyLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG5cbiAgICAgICAgICBsZXQgZHgyID0gJHt0fShmMzIoeDIpIC0geCk7XG4gICAgICAgICAgbGV0IGR4MSA9ICR7dH0oeCAtIGYzMih4MSkpO1xuICAgICAgICAgIGxldCBkeTIgPSAke3R9KGYzMih5MikgLSB5KTtcbiAgICAgICAgICBsZXQgZHkxID0gJHt0fSh5IC0gZjMyKHkxKSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGR5MiAqIChkeDIgKiBwMTEgKyBkeDEgKiBwMTIpICsgZHkxICogKGR4MiAqIHAyMSArIGR4MSAqIHAyMik7XG4gICAgICAgIGA7Y2FzZVwiYmljdWJpY1wiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDAgPSBpMzIoZmxvb3IoeCkpIC0gMTtcbiAgICAgICAgICBsZXQgeTAgPSBpMzIoZmxvb3IoeSkpIC0gMTtcbiAgICAgICAgICB2YXIgcDogbWF0NHg0PCR7dH0+O1xuICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoIDwgNDsgaCsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB3ID0gMDsgdyA8IDQ7IHcrKykge1xuICAgICAgICAgICAgICBwW2hdW3ddID0gcGl4ZWxfYXRfZ3JpZChoICsgeTAsIHcgKyB4MCwgSF9pbiwgV19pbiwgaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHskdH1dLCBib3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBkeCA9IHggLSBmMzIoeDAgKyAxKTtcbiAgICAgICAgICBsZXQgZHkgPSB5IC0gZjMyKHkwICsgMSk7XG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocCwgZHgsIGR5KTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbW9kZSAke24ubW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYCR7ZS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInJlc3VsdFwiKX1gLFJnPShlLHQpPT57bGV0IG49UChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHI9W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXSxvPVAoXCJncmlkXCIsZVsxXS5kYXRhVHlwZSxyLmxlbmd0aCwyKSxhPVtlWzBdLmRpbXNbMF0sZVswXS5kaW1zWzFdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dO3QuZm9ybWF0PT09XCJOSFdDXCImJihhPVtlWzBdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzBdLmRpbXNbM11dLFtwdCwkdCxOdCxWdF09WzAsMywxLDJdKTtsZXQgcz1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCksZD1uLnR5cGUudmFsdWUsbD1FLnNpemUoYSkscD1be3R5cGU6MTIsZGF0YTpsfSwuLi5IKGVbMF0uZGltcyxyLGEpXSxmPWg9PmBcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhuLG8scyl9XG4gICR7UGd9XG4gICR7emcoZCl9XG4gICR7T2codCl9XG4gICR7RGcodCl9XG4gICR7QmcobixkLHQpfVxuXG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IEhfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske050fV0pO1xuICAgICAgbGV0IFdfaW4gPSBpMzIodW5pZm9ybXMueF9zaGFwZVske1Z0fV0pO1xuXG4gICAgICAke3QuYWxpZ25Db3JuZXJzPT09MD9gXG4gICAgICBsZXQgeF9taW4gPSAtMC41O1xuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMC41O1xuICAgICAgbGV0IHlfbWluID0gLTAuNTtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDAuNTtcbiAgICAgIGA6YFxuICAgICAgbGV0IHhfbWluID0gMC4wO1xuICAgICAgbGV0IHhfbWF4ID0gZjMyKFdfaW4pIC0gMS4wO1xuICAgICAgbGV0IHlfbWluID0gMC4wO1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMS4wO1xuICAgICAgYH07XG4gICAgICBsZXQgYm9yZGVyID0gdmVjNDxmMzI+KHhfbWluLCB5X21pbiwgeF9tYXgsIHlfbWF4KTtcblxuICAgICAgbGV0IGluZGljZXMgPSAke3Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgZ3JpZF9pbmRpY2VzID0gdmVjMzx1MzI+KGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7TnR9XSwgaW5kaWNlc1ske1Z0fV0pO1xuICAgICAgbGV0IG54eSA9ICR7by5nZXRCeUluZGljZXMoXCJncmlkX2luZGljZXNcIil9O1xuICAgICAgdmFyIHggPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzBdKSwgV19pbik7XG4gICAgICB2YXIgeSA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMV0pLCBIX2luKTtcblxuICAgICAgJHtNZyhzLGQsdCl9XG4gIH1gO3JldHVybntuYW1lOlwiR3JpZFNhbXBsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOmg9PntsZXQgeT1FLnNpemUoYSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6aFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH19LGdldFNoYWRlclNvdXJjZTpmfX0sU2w9KGUsdCk9PntFZyhlLmlucHV0cyksZS5jb21wdXRlKFJnKGUuaW5wdXRzLHQpKX0sVGw9ZT0+cmUoe2FsaWduQ29ybmVyczplLmFsaWduX2Nvcm5lcnMsbW9kZTplLm1vZGUscGFkZGluZ01vZGU6ZS5wYWRkaW5nX21vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgTWUsVmcsQWwsSWwsV2csb3Isa2wsU289RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO1ZyKCk7cXIoKTtjZSgpO2N0KCk7TWU9KGUsdCk9PmUubGVuZ3RoPnQmJmVbdF0uZGltcy5sZW5ndGg+MD9lW3RdOnZvaWQgMCxWZz0oZSx0KT0+e2xldCBuPWVbMF0scj1NZShlLDEpLG89TWUoZSwyKSxhPU1lKGUsMykscz1NZShlLDQpLGQ9TWUoZSw1KSxsPU1lKGUsNikscD1NZShlLDcpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBmPW4uZGltc1swXSxoPW4uZGltc1sxXSx5PW4uZGltcy5sZW5ndGg9PT0zP24uZGltc1syXTp0Lm51bUhlYWRzKm4uZGltc1s0XSxfPWgsYj0wLHc9MCxTPU1hdGguZmxvb3IoeS90Lm51bUhlYWRzKTtpZihsJiZwJiZFLnNpemUobC5kaW1zKSYmRS5zaXplKHAuZGltcykpe2lmKGwuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYobC5kaW1zWzBdIT09Znx8bC5kaW1zWzFdIT09dC5udW1IZWFkc3x8bC5kaW1zWzNdIT09Uyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKHAuZGltc1swXSE9PWZ8fHAuZGltc1sxXSE9PXQubnVtSGVhZHN8fHAuZGltc1szXSE9PVMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBwYXN0X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKScpO2lmKGwuZGltc1syXSE9PXAuZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChwYXN0X3NlcXVlbmNlX2xlbmd0aCknKTtpZihwLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7Yj1sLmRpbXNbMl0sdz1sLmRpbXNbMl19ZWxzZSBpZihsJiZFLnNpemUobC5kaW1zKXx8cCYmRS5zaXplKHAuZGltcykpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO2xldCAkO2lmKHImJkUuc2l6ZShyLmRpbXMpPjApe2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYoci5kaW1zLmxlbmd0aDwzfHxyLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihyLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdIT09bi5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAoaGlkZGVuX3NpemUpJyk7JD0yLF89ci5kaW1zWzFdfWVsc2UgaWYoci5kaW1zLmxlbmd0aD09PTUpe2lmKHIuZGltc1syXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PTJ8fHIuZGltc1s0XSE9PVMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpOyQ9NSxfPXIuZGltc1sxXX1lbHNle2lmKHIuZGltc1sxXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PVMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7JD0wLF89ci5kaW1zWzJdfX1lbHNle2lmKG4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTskPTN9aWYoYSYmRS5zaXplKGEuZGltcyk+MCl7aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uJyk7aWYociYmci5kaW1zLmxlbmd0aD09PTUmJnIuZGltc1szXT09PTIpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBub3QgYWxsb3dlZCBmb3IgcGFja2VkIGt2LlwiKX1sZXQgdj1iK18sVD0wO2lmKHMmJkUuc2l6ZShzLmRpbXMpPjApe1Q9ODtsZXQgTz1zLmRpbXM7dGhyb3cgTy5sZW5ndGg9PT0xP09bMF09PT1mP1Q9MTpPWzBdPT09MypmKzImJihUPTMpOk8ubGVuZ3RoPT09MiYmT1swXT09PWYmJk9bMV09PT12JiYoVD01KSxUPT09OD9uZXcgRXJyb3IoJ0lucHV0IFwia2V5X3BhZGRpbmdfbWFza1wiIHNoYXBlIHNoYWxsIGJlIChiYXRjaF9zaXplKSBvciAoYmF0Y2hfc2l6ZSwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpOm5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKX1sZXQgQz0hMSxBPXk7aWYobyYmRS5zaXplKG8uZGltcyk+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKF8hPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYoXyE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMV0qby5kaW1zWzNdLEM9ITB9fWxldCBrPSExO2lmKHMmJkUuc2l6ZShzLmRpbXMpPjApdGhyb3cgbmV3IEVycm9yKFwiS2V5IHBhZGRpbmcgbWFzayBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGQmJkUuc2l6ZShkLmRpbXMpPjApe2lmKGQuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09Znx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09aHx8ZC5kaW1zWzNdIT09dil0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpmLHNlcXVlbmNlTGVuZ3RoOmgscGFzdFNlcXVlbmNlTGVuZ3RoOmIsa3ZTZXF1ZW5jZUxlbmd0aDpfLHRvdGFsU2VxdWVuY2VMZW5ndGg6dixtYXhTZXF1ZW5jZUxlbmd0aDp3LGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6eSx2SGlkZGVuU2l6ZTpBLGhlYWRTaXplOlMsdkhlYWRTaXplOk1hdGguZmxvb3IoQS90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6VCxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ayxwYXNzUGFzdEluS3Y6Qyxxa3ZGb3JtYXQ6JH19LEFsPWU9PnJlKHsuLi5lfSksSWw9cmUoe3Blcm06WzAsMiwxLDNdfSksV2c9KGUsdCxuLHIsbyxhLHMpPT57bGV0IGQ9W3IsbyxhXSxsPUUuc2l6ZShkKSxwPVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTphfV0sZj1oPT57bGV0IHk9TihcInFrdl93aXRoX2JpYXNcIix0LmRhdGFUeXBlLGQpLF89UChcInFrdlwiLHQuZGF0YVR5cGUsZCksYj1QKFwiYmlhc1wiLG4uZGF0YVR5cGUsZCksdz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiaWFzX29mZnNldFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgJHtoLnJlZ2lzdGVyVW5pZm9ybXModykuZGVjbGFyZVZhcmlhYmxlcyhfLGIseSl9XG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiaWFzX29mZnNldF9pZHggPSAoZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLmhpZGRlbl9zaXplKSArIHVuaWZvcm1zLmJpYXNfb2Zmc2V0O1xuXG4gICAgcWt2X3dpdGhfYmlhc1tnbG9iYWxfaWR4XSA9IHFrdltnbG9iYWxfaWR4XSArIGJpYXNbYmlhc19vZmZzZXRfaWR4XTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJNdWx0aUhlYWRBdHRlbnRpb25BZGRCaWFzXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6Zn0se2lucHV0czpbdCxuXSxvdXRwdXRzOlstMV19KVswXX0sb3I9KGUsdCxuLHIsbyxhLHMsZCk9PntsZXQgbD1hO2lmKHMmJkUuc2l6ZShzLmRpbXMpPjApe2lmKHI9PT0xKXRocm93IG5ldyBFcnJvcihcIkFkZEJpYXNSZXNoYXBlIGlzIG5vdCBpbXBsZW1lbnRlZC4gUGxlYXNlIGV4cG9ydCB5b3VyIG1vZGVsIHdpdGggcGFja2VkIFFLViBvciBLVlwiKTtyZXR1cm4gbD1XZyhlLGEscyx0LHIsbipvLGQpLGw9bC5yZXNoYXBlKFt0LHIsbixvXSksbj09PTF8fHI9PT0xP2w6ZS5jb21wdXRlKE9lKGwsSWwucGVybSkse2lucHV0czpbbF0sb3V0cHV0czpbLTFdfSlbMF19ZWxzZSByZXR1cm4gYS5kaW1zLmxlbmd0aD09PTMmJihsPWEucmVzaGFwZShbdCxyLG4sb10pKSxuPT09MXx8cj09PTE/bDplLmNvbXB1dGUoT2UobCxJbC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX0sa2w9KGUsdCk9PntsZXQgbj1WZyhlLmlucHV0cyx0KSxyPWUuaW5wdXRzWzBdLG89TWUoZS5pbnB1dHMsMSksYT1NZShlLmlucHV0cywyKSxzPU1lKGUuaW5wdXRzLDMpLGQ9TWUoZS5pbnB1dHMsNCksbD1NZShlLmlucHV0cyw1KSxwPU1lKGUuaW5wdXRzLDYpLGY9TWUoZS5pbnB1dHMsNyk7aWYoci5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7aWYobz8uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7bGV0IGg9byYmYSYmby5kaW1zLmxlbmd0aD09PTQmJmEuZGltcy5sZW5ndGg9PT00LHk9b3IoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4uc2VxdWVuY2VMZW5ndGgsbi5oZWFkU2l6ZSxyLHMsMCk7aWYoaClyZXR1cm4gVXQoZSx5LG8sYSxkLHZvaWQgMCxwLGYsbCxuKTtpZighb3x8IWEpdGhyb3cgbmV3IEVycm9yKFwia2V5IGFuZCB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkXCIpO2xldCBfPW9yKGUsbi5iYXRjaFNpemUsbi5udW1IZWFkcyxuLmt2U2VxdWVuY2VMZW5ndGgsbi5oZWFkU2l6ZSxvLHMsbi5oaWRkZW5TaXplKSxiPW9yKGUsbi5iYXRjaFNpemUsbi5udW1IZWFkcyxuLmt2U2VxdWVuY2VMZW5ndGgsbi52SGVhZFNpemUsYSxzLDIqbi5oaWRkZW5TaXplKTtVdChlLHksXyxiLGQsdm9pZCAwLHAsZixsLG4pfX0pO3ZhciBMZyxHZyxIZyxGZyxUbyxFbCxQbCxDbz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtMZz1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIil9LEdnPShlLHQpPT57bGV0IG49W10scj10Lm51bU91dHB1dHM7cmV0dXJuIGVbMV0uZGltc1swXT4wJiYoZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChvPT5uLnB1c2goTnVtYmVyKG8pKSkscj1uLmxlbmd0aCkscmUoe251bU91dHB1dHM6cixheGlzOnQuYXhpcyxzcGxpdFNpemVzOm59KX0sSGc9ZT0+YFxuZm4gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8ICR7ZX11OyBpICs9IDF1ICkge1xuICAgIGlmIChpbmRleCA8ICR7SyhcInVuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpc1wiLFwiaVwiLGUpfSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbn1gLEZnPWU9PntsZXQgdD1lLmxlbmd0aCxuPVtdO2ZvcihsZXQgcj0wO3I8dDsrK3Ipe2xldCBvPWVbcl0uc2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiLFwiaW5wdXRbZ2xvYmFsX2lkeF1cIik7dD09PTE/bi5wdXNoKG8pOnI9PT0wP24ucHVzaChgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtyfXUpIHsgJHtvfSB9YCk6cj09PXQtMT9uLnB1c2goYGVsc2UgeyAke299IH1gKTpuLnB1c2goYGVsc2UgaWYgKG91dHB1dF9udW1iZXIgPT0gJHtyfSkgeyAke299IH1gKX1yZXR1cm5gXG4gICAgICBmbiB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlcjogdTMyLCBpbmRpY2VzOiAke2VbMF0udHlwZS5pbmRpY2VzfSwgZ2xvYmFsX2lkeDogdTMyKSB7XG4gICAgICAgICR7bi5qb2luKGBcbmApfVxuICAgICAgfWB9LFRvPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9RS5zaXplKG4pLG89ZVswXS5kYXRhVHlwZSxhPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsbi5sZW5ndGgpLHM9bmV3IEFycmF5KHQubnVtT3V0cHV0cyksZD1QKFwiaW5wdXRcIixvLG4ubGVuZ3RoKSxsPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLHA9W10sZj1bXSxoPTAseT1be3R5cGU6MTIsZGF0YTpyfV07Zm9yKGxldCBiPTA7Yjx0Lm51bU91dHB1dHM7YisrKXtoKz10LnNwbGl0U2l6ZXNbYl0sbFtiXT1oO2xldCB3PW4uc2xpY2UoKTt3W2FdPXQuc3BsaXRTaXplc1tiXSxmLnB1c2godyksc1tiXT1OKGBvdXRwdXQke2J9YCxvLHcubGVuZ3RoKSxwLnB1c2goe2RpbXM6ZltiXSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSl9eS5wdXNoKHt0eXBlOjEyLGRhdGE6bH0sLi4uSChuLC4uLmYpKTtsZXQgXz1iPT5gXG4gICR7Yi5yZWdpc3RlclVuaWZvcm0oXCJpbnB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJ1MzJcIixsLmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyhkLC4uLnMpfVxuICAke0hnKGwubGVuZ3RoKX1cbiAgJHtGZyhzKX1cblxuICAke2IubWFpblN0YXJ0KCl9XG4gICAgJHtiLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5pbnB1dF9zaXplXCIpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgdmFyIGluZGV4ID0gJHtkLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsYSl9O1xuICAgIGxldCBvdXRwdXRfbnVtYmVyID0gY2FsY3VsYXRlT3V0cHV0SW5kZXgoaW5kZXgpO1xuICAgIGlmIChvdXRwdXRfbnVtYmVyICE9IDApIHtcbiAgICAgIGluZGV4IC09ICR7SyhcInVuaWZvcm1zLnNpemVfaW5fc3BsaXRfYXhpc1wiLFwib3V0cHV0X251bWJlciAtIDF1XCIsbC5sZW5ndGgpfTtcbiAgICAgICR7ZC5pbmRpY2VzU2V0KFwiaW5kaWNlc1wiLGEsXCJpbmRleFwiKX07XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyLCBpbmRpY2VzLCBnbG9iYWxfaWR4KTtcbiAgfWA7cmV0dXJue25hbWU6XCJTcGxpdFwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOl8sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOnAsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci82NCl9LHByb2dyYW1Vbmlmb3Jtczp5fSl9fSxFbD0oZSx0KT0+e0xnKGUuaW5wdXRzKTtsZXQgbj1lLmlucHV0cy5sZW5ndGg9PT0xP3Q6R2coZS5pbnB1dHMsdCk7ZS5jb21wdXRlKFRvKGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9LFBsPWU9PntsZXQgdD1lLmF4aXMsbj1lLnNwbGl0U2l6ZXMscj1lLm51bU91dHB1dHM8MD9uLmxlbmd0aDplLm51bU91dHB1dHM7aWYociE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIm51bU91dHB1dHMgYW5kIHNwbGl0U2l6ZXMgbGVuZ2ggbXVzdCBiZSBlcXVhbFwiKTtyZXR1cm4gcmUoe2F4aXM6dCxudW1PdXRwdXRzOnIsc3BsaXRTaXplczpufSl9fSk7dmFyIHFnLEtnLHpsLE9sLERsPUcoKCk9PntcInVzZSBzdHJpY3RcIjtDZSgpO3FyKCk7U28oKTtDbygpO2N0KCk7cWc9KGUsdCk9PntpZih0LmRvUm90YXJ5KXRocm93IG5ldyBFcnJvcihcIkdyb3VwUXVlcnJ5QXR0ZW50aW9uIGRvX3JvdGFyeSBhdHRyaWJ1dGUgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LmRvUm90YXJ5JiZlLmxlbmd0aDw9Nyl0aHJvdyBuZXcgRXJyb3IoXCJjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbnB1dHMgYXJlIHJlcXVpcmVkIGlmIGRvX3JvdGFyeSBpcyBzcGVjaWZpZWRcIik7bGV0IG49ZVswXSxyPWVbMV0sbz1lWzJdLGE9ZVszXSxzPWVbNF07aWYodC5sb2NhbFdpbmRvd1NpemUhPT0tMSl0aHJvdyBuZXcgRXJyb3IoXCJMb2NhbCBhdHRlbnRpb24gaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnNvZnRjYXAhPT0wKXRocm93IG5ldyBFcnJvcihcIlNvZnRjYXAgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnJvdGFyeUludGVybGVhdmVkIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSb3RhcnkgaW50ZXJsZWF2ZWQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih0LnNtb290aFNvZnRtYXgpdGhyb3cgbmV3IEVycm9yKFwiU21vb3RoIHNvZnRtYXggaXMgbm90IHN1cHBvcnRlZFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgZD0hMSxsPW4uZGltc1swXSxwPW4uZGltc1sxXSxmPW4uZGltcy5sZW5ndGg9PT0zP2Q/bi5kaW1zWzJdLzM6bi5kaW1zWzJdOnQubnVtSGVhZHMqbi5kaW1zWzRdLGg9cCx5PTAsXz0hcnx8ci5kaW1zLmxlbmd0aD09PTAsYj1NYXRoLmZsb29yKF8/Zi8odC5udW1IZWFkcysyKnQua3ZOdW1IZWFkcyk6Zi90Lm51bUhlYWRzKTtfJiYoZj1iKnQubnVtSGVhZHMpO2xldCB3PWEmJmEuZGltcy5sZW5ndGghPT0wLFM9cyYmcy5kaW1zLmxlbmd0aCE9PTA7aWYodyYmYS5kaW1zLmxlbmd0aD09PTQmJmEuZGltc1swXT09PWwmJmEuZGltc1sxXSE9PXQua3ZOdW1IZWFkcyYmYS5kaW1zWzJdPT09dC5rdk51bUhlYWRzJiZhLmRpbXNbM109PT1iKXRocm93IG5ldyBFcnJvcihcIkJTTkggcGFzdEtleS9wYXN0VmFsdWUgaXMgbm90IHN1cHBvcnRlZFwiKTtpZih3JiZTKXtpZihhLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKHMuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTt5PWEuZGltc1syXX1lbHNlIGlmKHd8fFMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGJlIGJvdGggcHJlc2VudCBvciBib3RoIGFic2VudCcpO2xldCB2PTE7aWYociYmci5kaW1zLmxlbmd0aD4wKXtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKHIuZGltcy5sZW5ndGg8M3x8ci5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PXIuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYoci5kaW1zLmxlbmd0aD09PTMpe2lmKG4uZGltc1syXSVyLmRpbXNbMl0hPT0wKXRocm93IG5ldyBFcnJvcignRGltZW5zaW9uIDIgb2YgXCJxdWVyeVwiIHNob3VsZCBiZSBhIG11bHRpcGxlIG9mIFwia2V5XCInKTtoPXIuZGltc1sxXX1lbHNlIGlmKHIuZGltcy5sZW5ndGg9PT01KXtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0yfHxyLmRpbXNbNF0hPT1iKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihvKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTtoPXIuZGltc1sxXX1lbHNle2lmKHIuZGltc1sxXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PWIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSkgZm9yIHBhc3Rfa2V5Jyk7aD1yLmRpbXNbMl19fWVsc2V7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihuLmRpbXMubGVuZ3RoPT09NSYmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTMpKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO3Y9M31sZXQgVD0wLEM9ITEsQT10Lmt2TnVtSGVhZHM/Yip0Lmt2TnVtSGVhZHM6ZjtpZihvJiZvLmRpbXMubGVuZ3RoPjApe2lmKG8uZGltcy5sZW5ndGghPT0zJiZvLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09by5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihoIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1syXX1lbHNle2lmKGghPT1vLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sQz0hMH19bGV0IGs9ZS5sZW5ndGg+ND9lWzVdOnZvaWQgMDtpZihrJiZrLmRpbXMubGVuZ3RoIT09MSYmay5kaW1zWzBdIT09bCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwic2VxbGVuc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24gYW5kIHRoZSBzYW1lIGRpbSAwIGFzIGJhdGNoX3NpemUnKTtyZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6eSxrdlNlcXVlbmNlTGVuZ3RoOmgsdG90YWxTZXF1ZW5jZUxlbmd0aDotMSxtYXhTZXF1ZW5jZUxlbmd0aDotMSxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOmYsdkhpZGRlblNpemU6QSxoZWFkU2l6ZTpiLHZIZWFkU2l6ZTpNYXRoLmZsb29yKEEvdC5rdk51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGt2TnVtSGVhZHM6dC5rdk51bUhlYWRzLG5SZXBzOnQubnVtSGVhZHMvdC5rdk51bUhlYWRzLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza1R5cGU6VCxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OkMscWt2Rm9ybWF0OnZ9fSxLZz1yZSh7cGVybTpbMCwyLDEsM119KSx6bD0oZSx0LG4pPT57bGV0IHI9dCxvPW4ua3ZOdW1IZWFkcztyZXR1cm4gdC5kaW1zLmxlbmd0aD09PTMmJm4ua3ZTZXF1ZW5jZUxlbmd0aCE9PTAmJihyPXQucmVzaGFwZShbbi5iYXRjaFNpemUsbi5rdlNlcXVlbmNlTGVuZ3RoLG8sbi5oZWFkU2l6ZV0pLHI9ZS5jb21wdXRlKE9lKHIsS2cucGVybSkse2lucHV0czpbcl0sb3V0cHV0czpbLTFdfSlbMF0pLHJ9LE9sPShlLHQpPT57bGV0IG49cWcoZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgcj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxhPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxzPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGQ9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsbD1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAscD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsZj1uLmt2TnVtSGVhZHM/bi5rdk51bUhlYWRzOm4ubnVtSGVhZHMsaD1yZSh7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltuLm51bUhlYWRzKm4uaGVhZFNpemUsZipuLmhlYWRTaXplLGYqbi5oZWFkU2l6ZV19KSxbeSxfLGJdPSFvJiYhYT9lLmNvbXB1dGUoVG8oW3JdLGgpLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltyLG8sYV0sdz1vcihlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5zZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLHksdm9pZCAwLDApO1V0KGUsdyx6bChlLF8sbiksemwoZSxiLG4pLHZvaWQgMCx2b2lkIDAscyxkLHZvaWQgMCxuLGwscCl9fSk7dmFyIEJsLGpnLFpnLE1sLFJsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y3QoKTtjZSgpO0JsPShlLHQsbixyLG8sYSxzLGQpPT57bGV0IGw9Z2UoYSkscD1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmAsZj1sPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtsfWZgLGg9bypzLHk9NjQ7aD09PTEmJih5PTI1Nik7bGV0IF89W28scyxhL2xdLGI9W28scywyXSx3PVtcInJhbmtcIixcInR5cGVcIixcInR5cGVcIl0sUz1bXTtTLnB1c2goLi4uSChfLGIpKTtsZXQgJD12PT57bGV0IFQ9UChcInhcIix0LmRhdGFUeXBlLDMsbCksQz1QKFwic2NhbGVcIixuLmRhdGFUeXBlLG4uZGltcyksQT1QKFwiYmlhc1wiLHIuZGF0YVR5cGUsci5kaW1zKSxrPU4oXCJvdXRwdXRcIiwxLDMsMiksTz1bVCxDLEEsa107cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHtmfSwgJHt5fT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHt5fXU7XG4gICR7di5kZWNsYXJlVmFyaWFibGVzKC4uLk8pfVxuICAke3YubWFpblN0YXJ0KHkpfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7cH0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtwfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7cH0oJHtULmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke2Z9KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7S2UoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke0tlKFwid29ya2dyb3VwX3NoYXJlZFswXVsxXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2R9KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke2x9OyR7ZH07JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpiLGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4Omh9LHByb2dyYW1Vbmlmb3JtczpTfSksZ2V0U2hhZGVyU291cmNlOiR9LHtpbnB1dHM6W3QsbixyXSxvdXRwdXRzOlstMV19KVswXX0samc9KGUsdCxuKT0+e2xldCByPXRbMF0uZGltcyxvPXIsYT0yLHM9clswXSxkPXJbMV0sbD1FLnNpemVGcm9tRGltZW5zaW9uKHIsYSkscD1nZShsKSxmPUUuc2l6ZShvKS9wLGg9QmwoZSx0WzBdLHRbMV0sdFsyXSxzLGwsZCxuLmVwc2lsb24pLHk9W3MsZCxsL3BdLF89W3MsZF0sYj1bXCJ0eXBlXCIsXCJub25lXCJdLHc9Uz0+e2xldCAkPVAoXCJ4XCIsdFswXS5kYXRhVHlwZSx5Lmxlbmd0aCxwKSx2PVAoXCJzY2FsZV9zaGlmdFwiLDEsXy5sZW5ndGgsMiksVD1OKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSx5Lmxlbmd0aCxwKSxDPVskLHYsVF07cmV0dXJuYFxuICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLkMpfVxuICAke1MubWFpblN0YXJ0KCl9XG4gICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7VC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3YuZ2V0QnlJbmRpY2VzKFwidmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfSAqICR7VC50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7VC50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC55KTtcbiAgICAgICR7VC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9YCxpbnB1dERlcGVuZGVuY2llczpifSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGYvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6Zn0sLi4uSCh5LF8seSldfSksZ2V0U2hhZGVyU291cmNlOnd9LHtpbnB1dHM6W3RbMF0saF19KX0sWmc9KGUsdCxuKT0+e2xldCByPXRbMF0uZGltcyxvPXIsYT1yWzBdLHM9cltyLmxlbmd0aC0xXSxkPUUuc2l6ZUZyb21EaW1lbnNpb24ociwxKS9zLGw9Z2UocykscD1FLnNpemUobykvbCxmPVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihzL2wpfV0saD1bXCJ0eXBlXCIsXCJ0eXBlXCJdLHk9ITEsXz1bMCxyLmxlbmd0aC0xXTtmb3IobGV0ICQ9MDskPHIubGVuZ3RoLTI7JCsrKXk9eXx8clskKzFdIT09MSxfLnB1c2goJCsxKTt5PXkmJnJbci5sZW5ndGgtMV0hPT0xO2xldCBiPXk/ZS5jb21wdXRlKE9lKGUuaW5wdXRzWzBdLF8pLHtpbnB1dHM6W2UuaW5wdXRzWzBdXSxvdXRwdXRzOlstMV19KVswXTplLmlucHV0c1swXS5yZXNoYXBlKEFycmF5LmZyb20oe2xlbmd0aDpyLmxlbmd0aH0sKCQsdik9PnJbX1t2XV0pKSx3PUJsKGUsYix0WzFdLHRbMl0sYSxkLHMsbi5lcHNpbG9uKSxTPSQ9PntsZXQgdj1fZSh0WzBdLmRhdGFUeXBlKSxUPWw9PT0xP1widmVjMmZcIjpgbWF0JHtsfXgyZmAsQz1PPT57bGV0IE09Tz09PTA/XCJ4XCI6XCJ5XCIsVj1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmA7c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5gJHt2fSgke1Z9KHNjYWxlLiR7TX0pKWA7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dn0+KCR7Vn0oc2NhbGVbMF0uJHtNfSwgc2NhbGVbMV0uJHtNfSkpYDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt2fT4oJHtWfShzY2FsZVswXS4ke019LCBzY2FsZVsxXS4ke019LCBzY2FsZVsyXS4ke019LCBzY2FsZVszXS4ke019KSlgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2x9YCl9fSxBPVAoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLGwpLGs9TihcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbyxsKTtyZXR1cm5gXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke0EudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVfaW5wdXQgOiBhcnJheTwke1R9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2sudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50X2ltYWdlX251bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgc2NhbGVfb2Zmc2V0ID0gY3VycmVudF9pbWFnZV9udW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudF9jaGFubmVsX251bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtDKDApfSwgJHtDKDEpfSk7XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOmh9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOlN9LHtpbnB1dHM6W3RbMF0sd119KX0sTWw9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP1pnKGUsZS5pbnB1dHMsdCk6amcoZSxlLmlucHV0cyx0KX19KTt2YXIgUWcsWWcsVWwsTmw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO1FnPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxZZz0oZSx0LG4pPT57bGV0IHI9dC5zaW1wbGlmaWVkLG89ZVswXS5kaW1zLGE9ZVsxXSxzPSFyJiZlWzJdLGQ9byxsPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLHA9RS5zaXplVG9EaW1lbnNpb24obyxsKSxmPUUuc2l6ZUZyb21EaW1lbnNpb24obyxsKSxoPUUuc2l6ZShhLmRpbXMpLHk9cz9FLnNpemUocy5kaW1zKTowO2lmKGghPT1mfHxzJiZ5IT09Zil0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke2Z9LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHtofSBhbmQgYmlhcyBzaXplIG9mICR7eX1gKTtsZXQgXz1bXTtmb3IobGV0IEE9MDtBPG8ubGVuZ3RoOysrQSlBPGw/Xy5wdXNoKG9bQV0pOl8ucHVzaCgxKTtsZXQgYj1nZShmKSx3PVtcInR5cGVcIixcInR5cGVcIl0sUz1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6Zn0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKGYvYil9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTtzJiZ3LnB1c2goXCJ0eXBlXCIpO2xldCAkPW4+MSx2PW4+MixUPUE9PntsZXQgaz1fZShlWzBdLmRhdGFUeXBlKSxPPVtQKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLGIpLFAoXCJzY2FsZVwiLGEuZGF0YVR5cGUsYS5kaW1zLGIpXTtzJiZPLnB1c2goUChcImJpYXNcIixzLmRhdGFUeXBlLHMuZGltcyxiKSksTy5wdXNoKE4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQsYikpLCQmJk8ucHVzaChOKFwibWVhbl9kYXRhX291dHB1dFwiLDEsXykpLHYmJk8ucHVzaChOKFwiaW52X3N0ZF9vdXRwdXRcIiwxLF8pKTtsZXQgTT1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhNKS5kZWNsYXJlVmFyaWFibGVzKC4uLk8pfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHt1byhcImYzMlwiLGIpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHt1byhcImYzMlwiLGIpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtQdChrLGIsXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtLZShcIm1lYW5fdmVjdG9yXCIsYil9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7S2UoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIixiKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtyP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtQdChrLGIsXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7UHQoayxiLFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtPWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke3I/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7cz9gKyAke1B0KGssYixcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAkeyQ/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7dj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LEM9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiAkJiZDLnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSksdiYmQy5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7Yn07JHtufTske3J9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6QyxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6VH19LFVsPShlLHQpPT57UWcoZS5pbnB1dHMpLGUuY29tcHV0ZShZZyhlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgWGcsVmwsV2w9RygoKT0+e1widXNlIHN0cmljdFwiO2FlKCk7WHIoKTtKcigpO1hnPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sVmw9ZT0+e1hnKGUuaW5wdXRzKTtsZXQgdD1ydC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBuPXRbdC5sZW5ndGgtMV0scj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKG48OCYmcjw4KWUuY29tcHV0ZShZcihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGE9RS5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLHM9RS5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGEhPT0xJiZvPT09MSYmcz09PTEpe2xldCBkPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsYSxyXSksbD1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLHIsbl0pLHA9WzEsYSxuXSxmPVtkLGxdO2UuY29tcHV0ZShucihmLHthY3RpdmF0aW9uOlwiXCJ9LHQscCkse2lucHV0czpmfSl9ZWxzZSBlLmNvbXB1dGUobnIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgSmcsZXksdHksTGwsR2wsSGw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7Smc9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IG49ZVswXSxyPW4uZGltcy5sZW5ndGg7aWYobi5kaW1zW3ItMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksYT10LmJsb2NrU2l6ZS84KnQuYml0cyxzPWVbMV07aWYoIUUuYXJlRXF1YWwocy5kaW1zLFt0Lm4sbyxhXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCBsPWVbMl0uZGltcztpZihFLnNpemUobCkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgZj1lWzNdLmRpbXMsaD10LmJpdHM+ND90Lm4qbzp0Lm4qTWF0aC5mbG9vcigobysxKS8yKTtpZihFLnNpemUoZikhPT1oKXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxleT0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPW4ubGVuZ3RoLG89bltyLTJdLGE9dC5rLHM9dC5uLGQ9bi5zbGljZSgwLHItMiksbD1FLnNpemUoZCksZj1lWzFdLmRpbXNbMl0vNCxoPWVbMF0uZGF0YVR5cGUseT1nZSh0LmspLF89Z2UoZiksYj1nZShzKSx3PWQuY29uY2F0KFtvLHNdKSxTPW8+MSYmcy9iJTI9PT0wPzI6MSwkPUUuc2l6ZSh3KS9iL1Msdj02NCxUPVtdLEM9W2wsbyxhL3ldLEE9RS5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Euc3BsaWNlKC0xLDEsZi9fKSxULnB1c2goLi4uSChDKSksVC5wdXNoKC4uLkgoQSkpLFQucHVzaCguLi5IKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmVC5wdXNoKC4uLkgoRS5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBrPVtsLG8scy9iXTtULnB1c2goLi4uSChrKSk7bGV0IE89TT0+e2xldCBWPUMubGVuZ3RoLEY9UChcImFcIixlWzBdLmRhdGFUeXBlLFYseSksaj1QKFwiYlwiLDEyLEEubGVuZ3RoLF8pLG5lPVAoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFc9W0YsaixuZV0sSj1lLmxlbmd0aD09PTQ/UChcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO0omJlcucHVzaChKKTtsZXQgdmU9ay5sZW5ndGgsUT1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx2ZSxiKSxlZT1fZShlWzBdLmRhdGFUeXBlKSxsZT0oKCk9Pntzd2l0Y2goeSl7Y2FzZSAxOnJldHVybmBhcnJheTwke2VlfSwgOD5gO2Nhc2UgMjpyZXR1cm5gbWF0NHgyPCR7ZWV9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtlZX0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHt5fS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19KSgpLFo9KCk9PntsZXQgU2U9YFxuICAgICAgICAgIC8vIHJldXNlIGEgZGF0YVxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7Ri5pbmRpY2VzVG9PZmZzZXQoYCR7Ri50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7bGV9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OC95fTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7Ri5nZXRCeU9mZnNldChcImlucHV0X29mZnNldFwiKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7Zm9yKGxldCBEPTA7RDxiKlM7RCsrKVNlKz1gXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtfPT09MT9gYiR7RH1fZGF0YWA6YGIke0R9X2RhdGFbaV1gfTtcbiAgICAgICAgICAgIGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiBiX21hc2spO1xuICAgICAgICAgICAgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiBiX21hc2spO1xuICAgICAgICAgICAgYl9xdWFudGl6ZWRfdmFsdWVzID0gJHtsZX0oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKFIsWSk9PmAke2VlfShiX3ZhbHVlX2xvd2VyWyR7WX1dKSwgJHtlZX0oYl92YWx1ZV91cHBlclske1l9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHt5PT09MT9gJHtsZX0oJHtBcnJheS5mcm9tKHtsZW5ndGg6OH0sKFIsWSk9PmAoYl9xdWFudGl6ZWRfdmFsdWVzWyR7WX1dIC0gJHtKP2B6ZXJvX3BvaW50JHtEfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtEfWApLmpvaW4oXCIsIFwiKX0pO2A6YChiX3F1YW50aXplZF92YWx1ZXMgLSAke2xlfSgke0FycmF5KDgpLmZpbGwoYCR7Sj9gemVyb19wb2ludCR7RH1gOlwiemVyb19wb2ludFwifWApLmpvaW4oXCIsXCIpfSkpICogc2NhbGUke0R9O2B9O1xuICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZC54ICogJHtTfSArICR7TWF0aC5mbG9vcihEL2IpfV0ke2I+MT9gWyR7RCVifV1gOlwiXCJ9ICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjgveX0sKFIsWSk9PmAke3k9PT0xP2BhX2RhdGFbJHtZfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske1l9XWA6YGRvdChhX2RhdGFbJHtZfV0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7WX1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgYDtyZXR1cm4gU2V9LHBlPSgpPT57bGV0IFNlPWBcbiAgICAgICAgICAgIHZhciBjb2xfaW5kZXggPSBjb2wgKiAke2J9O1xuICAgICAgICAgICAgJHtKP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobkJsb2Nrc1BlckNvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfY291bnQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmRfaW5kZXg6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9iaXRzX29mZnNldDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZDogdTMyO2A6YFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZWV9KDgpO2B9XG4gICAgICAgICAgICBgO2ZvcihsZXQgRD0wO0Q8YipTO0QrKylTZSs9YFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtEfSA9ICR7bmUuZ2V0QnlPZmZzZXQoXCJjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tcIil9O1xuICAgICAgICAgICAgJHtKP2BcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHtKLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQke0R9ID0gJHtlZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgOlwiXCJ9XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiBTZX0sa2U9KCk9PntsZXQgU2U9YGNvbF9pbmRleCA9IGNvbCAqICR7Yn07YDtmb3IobGV0IEQ9MDtEPGIqUztEKyspU2UrPWBcbiAgICAgICAgICAgIGxldCBiJHtEfV9kYXRhID0gJHtqLmdldEJ5SW5kaWNlcyhgJHtqLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiBTZSs9YFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke2xlfTtcbiAgICAgICAgICAgIHZhciBiX2RlcXVhbnRpemVkX3ZhbHVlczogJHtsZX07YCxTZX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkOiBhcnJheTwke1EudHlwZS52YWx1ZX0sICR7Uyp2fT47XG4gICAgICAgICR7TS5kZWNsYXJlVmFyaWFibGVzKC4uLlcsUSl9XG4gICAgICAgICR7TS5tYWluU3RhcnQoW3YsMSwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtRLm9mZnNldFRvSW5kaWNlcyhgKGdsb2JhbF9pZHggLyAke3Z9KSAqICR7U31gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt2fSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7dC5ibG9ja1NpemUveX07XG4gICAgICAgICAgICAke3BlKCl9XG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkOiB1MzIgPSAwOyB3b3JkIDwgJHtmfTsgd29yZCArPSAke199KSB7XG4gICAgICAgICAgICAgICR7a2UoKX1cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAgICR7WigpfVxuICAgICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OC95fTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWQueCA8ICR7U30pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7US50eXBlLnZhbHVlfSA9ICR7US50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgIHZhciB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldDogdTMyID0gbG9jYWxfaWQueDtcbiAgICAgICAgICAgIGZvciAodmFyIGI6IHUzMiA9IDB1OyBiIDwgJHt2fXU7IGIrKykge1xuICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gd29ya2dyb3VwX3NoYXJlZFt3b3JrZ3JvdXBfc2hhcmVkX29mZnNldF07XG4gICAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0ICs9ICR7U307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke1Euc2V0QnlJbmRpY2VzKGAke1EudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBjb2wgKyBsb2NhbF9pZC54KWAsXCJvdXRwdXRfdmFsdWVcIil9O1xuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiTWF0TXVsTkJpdHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmJsb2NrU2l6ZX07JHt0LmJpdHN9OyR7eX07JHtffTske2J9OyR7U307JHt2fWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkoZS5sZW5ndGgpLmZpbGwoXCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOncsZGF0YVR5cGU6aH1dLGRpc3BhdGNoR3JvdXA6e3g6JH0scHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6T319LHR5PShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9bi5sZW5ndGgsbz1uW3ItMl0sYT10Lmsscz10Lm4sZD1uLnNsaWNlKDAsci0yKSxsPUUuc2l6ZShkKSxmPWVbMV0uZGltc1syXS80LGg9ZVswXS5kYXRhVHlwZSx5PWdlKHQuayksXz1nZShmKSxiPWQuY29uY2F0KFtvLHNdKSx3PTEyOCxTPXMlOD09PTA/ODpzJTQ9PT0wPzQ6MSwkPXcvUyx2PSQqXyo4LFQ9di95LEM9di90LmJsb2NrU2l6ZSxBPUUuc2l6ZShiKS9TLGs9W10sTz1bbCxvLGEveV0sTT1FLmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7TS5zcGxpY2UoLTEsMSxmL18pLGsucHVzaCguLi5IKE8pKSxrLnB1c2goLi4uSChNKSksay5wdXNoKC4uLkgoZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiZrLnB1c2goLi4uSChFLmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IFY9W2wsbyxzXTtrLnB1c2goLi4uSChWKSk7bGV0IEY9aj0+e2xldCBuZT1PLmxlbmd0aCxXPVAoXCJhXCIsZVswXS5kYXRhVHlwZSxuZSx5KSxKPVAoXCJiXCIsMTIsTS5sZW5ndGgsXyksdmU9UChcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksUT1bVyxKLHZlXSxlZT1lLmxlbmd0aD09PTQ/UChcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO2VlJiZRLnB1c2goZWUpO2xldCBsZT1WLmxlbmd0aCxaPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGxlKSxwZT1fZShlWzBdLmRhdGFUeXBlKSxrZT0oKT0+e3N3aXRjaCh5KXtjYXNlIDE6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke3BlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdLCBzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgNF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgNV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgNl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgN10pO2A7Y2FzZSAyOnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7cGV9PihzdWJfYVt3b3JkX29mZnNldCArIDJdLCBzdWJfYVt3b3JkX29mZnNldCArIDNdKTtgO2Nhc2UgNDpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSBzdWJfYVt3b3JkX29mZnNldF07XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSBzdWJfYVt3b3JkX29mZnNldCArIDFdO2A7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7eX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fTtyZXR1cm5gXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1Yl9hOiBhcnJheTwke1cudHlwZS52YWx1ZX0sICR7VH0+O1xuICAgICAgICB2YXI8d29ya2dyb3VwPiBpbnRlcl9yZXN1bHRzOiBhcnJheTxhcnJheTwke1oudHlwZS52YWx1ZX0sICR7JH0+LCAke1N9PjtcbiAgICAgICAgJHtqLmRlY2xhcmVWYXJpYWJsZXMoLi4uUSxaKX1cbiAgICAgICAgJHtqLm1haW5TdGFydChbJCxTLDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1oub2Zmc2V0VG9JbmRpY2VzKGB3b3JrZ3JvdXBfaW5kZXggKiAke1N9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5fYmxvY2tzX3Blcl9jb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBudW1fdGlsZXMgPSAgKG5fYmxvY2tzX3Blcl9jb2wgLSAxKSAvICR7Q30gKyAxO1xuXG4gICAgICAgICAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gICAgICAgICAgZm9yICh2YXIgdGlsZTogdTMyID0gMDsgdGlsZSA8IG51bV90aWxlczsgdGlsZSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgYV9jb2xfc3RhcnQgPSB0aWxlICogJHtUfTtcbiAgICAgICAgICAgIC8vIGxvYWQgb25lIHRpbGUgQSBkYXRhIGludG8gc2hhcmVkIG1lbW9yeS5cbiAgICAgICAgICAgIGZvciAodmFyIGFfb2Zmc2V0ID0gbG9jYWxfaWR4OyBhX29mZnNldCA8ICR7VH07IGFfb2Zmc2V0ICs9ICR7d30pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxldCBhX2NvbCA9IGFfY29sX3N0YXJ0ICsgYV9vZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChhX2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMl0pXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1cuZ2V0QnlJbmRpY2VzKGAke1cudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCBhX2NvbClgKX07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHtXLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgICAgIC8vIGVhY2ggdGhyZWFkIHByb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICBsZXQgYl9yb3cgPSBjb2wgKyBsb2NhbF9pZC55O1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGlsZSAqICR7Q30gKyBsb2NhbF9pZC54O1xuICAgICAgICAgICAgJHtlZT9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5fYmxvY2tzX3Blcl9jb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX2NvdW50ID0gYl9yb3cgKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmQgPSAke2VlLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke3BlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6YFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7cGV9KDgpO2B9XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSAke3ZlLmdldEJ5T2Zmc2V0KFwiYl9yb3cgKiBuX2Jsb2Nrc19wZXJfY29sICsgYmxvY2tcIil9O1xuICAgICAgICAgICAgbGV0IGJfZGF0YSA9ICR7Si5nZXRCeUluZGljZXMoYCR7Si50eXBlLmluZGljZXN9KGJfcm93LCBibG9jaywgMClgKX07XG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQgPSBsb2NhbF9pZC54ICogJHt0LmJsb2NrU2l6ZS95fTtcbiAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgJHtrZSgpfVxuICAgICAgICAgICAgICBsZXQgYl92YWx1ZSA9ICR7Xz09PTE/XCJiX2RhdGFcIjpcImJfZGF0YVtpXVwifTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfbG93ZXIgPSB1bnBhY2s0eFU4KGJfdmFsdWUgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfcXVhbnRpemVkX3ZhbHVlcyA9IG1hdDJ4NDwke3BlfT4oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKFNlLEQpPT5gJHtwZX0oYl92YWx1ZV9sb3dlclske0R9XSksICR7cGV9KGJfdmFsdWVfdXBwZXJbJHtEfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICAgIGxldCBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9IChiX3F1YW50aXplZF92YWx1ZXMgLSBtYXQyeDQ8JHtwZX0+KCR7QXJyYXkoOCkuZmlsbChcInplcm9fcG9pbnRcIikuam9pbihcIixcIil9KSkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgaW50ZXJfcmVzdWx0c1tsb2NhbF9pZC55XVtsb2NhbF9pZC54XSArPSAke0FycmF5LmZyb20oe2xlbmd0aDoyfSwoU2UsRCk9PmAke2Bkb3QoYV9kYXRhJHtEfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtEfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L3l9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb2NhbF9pZHggPCAke1N9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke1oudHlwZS52YWx1ZX0gPSAke1oudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMHU7IGIgPCAkeyR9OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IGludGVyX3Jlc3VsdHNbbG9jYWxfaWR4XVtiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgKyBsb2NhbF9pZHggPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICR7Wi5zZXRCeUluZGljZXMoYCR7Wi50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3l9OyR7X307JHskfTske1N9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YixkYXRhVHlwZTpofV0sZGlzcGF0Y2hHcm91cDp7eDpBfSxwcm9ncmFtVW5pZm9ybXM6a30pLGdldFNoYWRlclNvdXJjZTpGfX0sTGw9KGUsdCk9PntKZyhlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUodHkoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShleShlLmlucHV0cyx0KSl9LEdsPWU9PnJlKGUpfSk7dmFyIHJ5LG55LG95LGl5LGF5LHN5LHV5LGR5LEZsLHFsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtyeT1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxueT0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7SyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtLKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sb3k9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtLKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0soXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtyfVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxpeT0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0soXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7SyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LGF5PShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7SyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7SyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHN5PShlLHQsbik9Pntzd2l0Y2gobi5tb2RlKXtjYXNlIDA6cmV0dXJuIG55KGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIG95KGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIGl5KGUsdCxuLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuIGF5KGUsdCxuLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHV5PShlLHQpPT57bGV0IG49RS5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLHI9ZVswXS5kaW1zLG89RS5zaXplKG4pLGE9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLHM9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZhLnB1c2goe3R5cGU6cz9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksYS5wdXNoKC4uLkgoZVswXS5kaW1zLG4pKTtsZXQgZD1bXCJyYW5rXCJdLGw9cD0+e2xldCBmPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoKSxoPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCkseT1oLnR5cGUudmFsdWUsXz1zeShmLHIubGVuZ3RoLHQpLGI9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZiLnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6cz95OlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3JtcyhiKS5kZWNsYXJlVmFyaWFibGVzKGgsZil9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7Zi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHt5fSgwKTtcbiAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHtzfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChFLnNpemUobikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6YX0pLGdldFNoYWRlclNvdXJjZTpsfX0sZHk9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgbj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxyPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGE9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGw9MDtsPGQubGVuZ3RoO2wrKylhW051bWJlcihkW2xdKV09TnVtYmVyKG5bbF0pLGFbTnVtYmVyKGRbbF0pK29dPU51bWJlcihuW2wrZC5sZW5ndGhdKX1lbHNlIG4uZm9yRWFjaCgoZCxsKT0+YVtOdW1iZXIobCldPU51bWJlcihkKSk7bGV0IHM9W107cmV0dXJuIGEuZm9yRWFjaChkPT5zLnB1c2goZCkpLHttb2RlOnQubW9kZSx2YWx1ZTpyLHBhZHM6c319ZWxzZSByZXR1cm4gdH0sRmw9KGUsdCk9PntyeShlLmlucHV0cyk7bGV0IG49ZHkoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHV5KGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHJuLEtsLGpsLFpsLFFsLGx5LGN5LFlsLFhsLEpsLGVjLHRjLHJjLG5jLG9jLGljLGFjLHNjLHVjLGRjPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3RlKCk7YWUoKTtjZSgpO3JuPWU9PntpZih3ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJighZXx8ZS5sZW5ndGghPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKX0sS2w9KGUsdCxuKT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1lLmRpbXMuc2xpY2UoKTtyJiZvLnNwbGljZSgxLDAsby5wb3AoKSk7bGV0IGE9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxzPXQua2VybmVsU2hhcGUuc2xpY2UoKSxkPXQuc3RyaWRlcy5zbGljZSgpLGw9YT90LmRpbGF0aW9ucy5zbGljZSgpOltdLHA9dC5wYWRzLnNsaWNlKCk7a3QuYWRqdXN0UG9vbEF0dHJpYnV0ZXMobixvLHMsZCxsLHApO2xldCBmPWt0LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUobixvLGQsbCxzLHAsdC5hdXRvUGFkKSxoPU9iamVjdC5hc3NpZ24oe30sdCk7YT9PYmplY3QuYXNzaWduKGgse2tlcm5lbFNoYXBlOnMsc3RyaWRlczpkLHBhZHM6cCxkaWxhdGlvbnM6bCxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbihoLHtrZXJuZWxTaGFwZTpzLHN0cmlkZXM6ZCxwYWRzOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCB5PWYuc2xpY2UoKTtyZXR1cm4geS5wdXNoKHkuc3BsaWNlKDEsMSlbMF0pLFtoLHI/eTpmXX0samw9KGUsdCk9PntsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiLHI9RS5zaXplKGUpLG89RS5zaXplKHQua2VybmVsU2hhcGUpLGE9W3t0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfV0scz1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwidTMyXCJ9XTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGQ9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxsPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLHA9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxmPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLGg9ISEocCtmKTthLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTpmfSkscy5wdXNoKHtuYW1lOlwia3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd0VuZFwiLHR5cGU6XCJ1MzJcIn0pO2xldCB5PSExO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IF89dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSxiPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLHc9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSxTPXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdO3k9ISEodytTKSxhLnB1c2goe3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOmJ9LHt0eXBlOjEyLGRhdGE6d30se3R5cGU6MTIsZGF0YTpTfSkscy5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVyblthLHMsITAsaCx5XX1lbHNle2lmKG4pdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBkPUUuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7YS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTp0LnBhZHN9LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSkscy5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ZC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IGw9dC5wYWRzLnJlZHVjZSgocCxmKT0+cCtmKTtyZXR1cm5bYSxzLCEhbCwhMSwhMV19fSxabD0oZSx0LG4scixvLGEscyxkLGwscCxmLGgpPT57bGV0IHk9by5mb3JtYXQ9PT1cIk5IV0NcIixfPXQudHlwZS52YWx1ZSxiPU4oXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLHIpO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgdz1cIlwiLFM9XCJcIiwkPVwiXCIsdj1uLSh5PzI6MSk7aWYoZj93PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHt2fV0gPCAwIHx8IHhJbmRpY2VzWyR7dn1dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske3Z9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHthfVxuICAgICAgICAgICAgICAgIH1gOnc9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICAgICAgfWAsby5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgQz1uLSh5PzM6Mik7aD9TPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7Q31dID0gaW5kaWNlc1ske0N9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtDfV0gPCAwIHx8IHhJbmRpY2VzWyR7Q31dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtDfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOlM9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtDfV0gPSBpbmRpY2VzWyR7Q31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLCQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCxiKX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHtTfVxuICAgICAgICAgICAgICAke3d9XG4gICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgJHtzfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZih5KXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgdz1vLmtlcm5lbFNoYXBlLmxlbmd0aCxTPW8ucGFkcy5sZW5ndGgsJD1cIlwiO3JldHVybiBwPyQ9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICAgIH1gOiQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LGIpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke2Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke3d9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke3ctMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke0soXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsdyl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke0soXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsdyl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7dy0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke24td311OyBqIDwgJHtufXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtLKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtuLXd9dWAsdyl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtuLXd9dV0gLSAke0soXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIixTKX07XG4gICAgICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHtzfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSxRbD1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLGx5PWU9PmAke1FsKGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAsY3k9ZT0+YCR7UWwoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCxZbD1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxYbD0oZSx0LG4scik9PntsZXRbbyxhXT1LbCh0LHIsbikscz1QKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksZD1zLnR5cGUudmFsdWUsbD1cInZhbHVlICs9IHhfdmFsO1wiLHA9XCJcIjtvLmNvdW50SW5jbHVkZVBhZD9wKz1gdmFsdWUgLz0gJHtkfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOnArPWB2YWx1ZSAvPSAke2R9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbZixoLHksXyxiXT1qbChhLG8pO2YucHVzaCguLi5IKHQuZGltcyxhKSk7bGV0IHc9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9OyR7eX07JHtffTske2J9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEUuc2l6ZShhKS82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOlM9PlpsKFMscyx0LmRpbXMubGVuZ3RoLGEubGVuZ3RoLG8sbCxwLDAsaCx5LF8sYil9fSxKbD1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAsbj1ZbChlKTtpZihuLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCByPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5uLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5yLGNhY2hlS2V5Omx5KHIpfX0sZWM9KGUsdCk9PntybihlLmlucHV0cyksZS5jb21wdXRlKFhsKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LHRjPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0scmM9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi50YyxjYWNoZUtleTp0fX0sbmM9KGUsdCk9PntybihlLmlucHV0cyksZS5jb21wdXRlKFhsKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LG9jPShlLHQsbixyKT0+e2xldFtvLGFdPUtsKHQscixuKSxzPWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxkPVwiXCIsbD1QKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkscD1bXCJyYW5rXCJdLFtmLGgseSxfLGJdPWpsKGEsbyk7cmV0dXJuIGYucHVzaCguLi5IKHQuZGltcyxhKSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtyLmNhY2hlS2V5fTske3l9OyR7X307JHtifWAsaW5wdXREZXBlbmRlbmNpZXM6cH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChFLnNpemUoYSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTp3PT5abCh3LGwsdC5kaW1zLmxlbmd0aCxhLmxlbmd0aCxvLHMsZCx0LmRhdGFUeXBlPT09MTA/LTY1NTA0Oi0xZTUsaCx5LF8sYil9fSxpYz0oZSx0KT0+e3JuKGUuaW5wdXRzKSxlLmNvbXB1dGUob2MoXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSxhYz1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLG49ZS5kaWxhdGlvbnMscj1ZbChlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IG89e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpuLC4uLnIsY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm8sY2FjaGVLZXk6Y3kobyl9fSxzYz1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLnRjLGNhY2hlS2V5OnR9fSx1Yz0oZSx0KT0+e3JuKGUuaW5wdXRzKSxlLmNvbXB1dGUob2MoXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBteSxmeSxsYyxjYyxwYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtteT0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChuLHIpPT5uPT09ZVsyXS5kaW1zW3JdKS5yZWR1Y2UoKG4scik9Pm4mJnIsITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxhKT0+YT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1thXSkucmVkdWNlKChvLGEpPT5vJiZhLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IG49ZVswXS5kaW1zW3QuYXhpc10scj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwobi9yKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKG4vKHItMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxmeT0oZSx0KT0+e2xldCBuPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCkscj1lWzBdLmRhdGFUeXBlLG89cj09PTMsYT1lWzBdLmRpbXMscz1lWzFdLmRhdGFUeXBlLGQ9RS5zaXplKGEpLGw9cj09PTN8fHI9PT0yLHA9bD9bTWF0aC5jZWlsKEUuc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsZj1lWzFdLmRpbXMsaD1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLHk9aD9sP1tNYXRoLmNlaWwoRS5zaXplKGguZGltcykvNCldOmguZGltczp2b2lkIDAsXz1mLmxlbmd0aD09PTB8fGYubGVuZ3RoPT09MSYmZlswXT09PTEsYj1fPT09ITEmJmYubGVuZ3RoPT09MSx3PWdlKGQpLFM9XyYmKCFsfHx3PT09NCksJD1TP3c6MSx2PVMmJiFsP3c6MSxUPVAoXCJpbnB1dFwiLGw/MTI6cixwLmxlbmd0aCx2KSxDPVAoXCJzY2FsZVwiLHMsZi5sZW5ndGgpLEE9aD9QKFwiemVyb19wb2ludFwiLGw/MTI6cix5Lmxlbmd0aCk6dm9pZCAwLGs9TihcIm91dHB1dFwiLHMsYS5sZW5ndGgsJCksTz1bVCxDXTtBJiZPLnB1c2goQSk7bGV0IE09W3AsZl07aCYmTS5wdXNoKHkpO2xldCBWPVt7dHlwZToxMixkYXRhOmQvJH0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5IKC4uLk0sYSldLEY9aj0+e2xldCBuZT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJheGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAke2oucmVnaXN0ZXJVbmlmb3JtcyhuZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5PLGspfVxuICAgICAgJHtqLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7ai5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtrLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgLy8gU2V0IGlucHV0IHhcbiAgICAgICAgICAke2w/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAkeyQ9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7VC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2B9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHtfP2BsZXQgc2NhbGVfdmFsdWU9ICR7Qy5nZXRCeU9mZnNldChcIjBcIil9YDpiP2BcbiAgICAgICAgICAgIGxldCBzY2FsZV9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke0MuZ2V0QnlPZmZzZXQoXCJzY2FsZV9pbmRleFwiKX07YDpgXG4gICAgICAgICAgICB2YXIgc2NhbGVfaW5kaWNlczogJHtDLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICR7Qy5pbmRpY2VzR2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX0gLyB1bmlmb3Jtcy5ibG9ja19zaXplO1xuICAgICAgICAgICAgJHtDLmluZGljZXNTZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7Qy5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgfTtcblxuICAgICAgICAgIC8vIFNldCB6ZXJvLXBvaW50IGlucHV0XG4gICAgICAgICAgJHtBP18/bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcIjBcIil9YDpiP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gOmBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleFwiKX07YDpsP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke0MuaW5kaWNlc1RvT2Zmc2V0KFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X29mZnNldCAlIDRdO2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtsP28/XCJpMzJcIjpcInUzMlwiOlQudHlwZS52YWx1ZX0oMCk7YH07XG4gICAgICAvLyBDb21wdXRlIGFuZCB3cml0ZSBvdXRwdXRcbiAgICAgICR7ay5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixgJHtrLnR5cGUudmFsdWV9KHhfdmFsdWUgLSB6ZXJvX3BvaW50X3ZhbHVlKSAqIHNjYWxlX3ZhbHVlYCl9O1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiRGVxdWFudGl6ZUxpbmVhclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6QT9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpGLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpzfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC8kLzY0KSx5OjEsejoxfSxwcm9ncmFtVW5pZm9ybXM6Vn0pfX0sbGM9KGUsdCk9PntteShlLmlucHV0cyx0KSxlLmNvbXB1dGUoZnkoZS5pbnB1dHMsdCkpfSxjYz1lPT5yZSh7YXhpczplLmF4aXMsYmxvY2tTaXplOmUuYmxvY2tTaXplfSl9KTt2YXIgaHksZ3ksbWMsZmM9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7dGUoKTtjZSgpO2h5PShlLHQsbik9PntsZXQgcj1lPT09dCxvPWU8dCYmbjwwLGE9ZT50JiZuPjA7aWYocnx8b3x8YSl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sZ3k9KGUsdCxuLHIpPT57bGV0IG89TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL24pKSxhPVtvXSxzPW8sZD1be3R5cGU6MTIsZGF0YTpzfSx7dHlwZTpyLGRhdGE6ZX0se3R5cGU6cixkYXRhOm59LC4uLkgoYSldLGw9cD0+e2xldCBmPU4oXCJvdXRwdXRcIixyLGEubGVuZ3RoKSxoPWYudHlwZS52YWx1ZSx5PVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRcIix0eXBlOmh9LHtuYW1lOlwiZGVsdGFcIix0eXBlOmh9XTtyZXR1cm5gXG4gICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKHkpLmRlY2xhcmVWYXJpYWJsZXMoZil9XG4gICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7aH0oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gfSxnZXRTaGFkZXJTb3VyY2U6bCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6cn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pfX0sbWM9ZT0+e2xldCB0PTAsbj0wLHI9MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0scj1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksd2Uud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZoeSh0LG4sciksZS5jb21wdXRlKGd5KHQsbixyLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIHl5LGJ5LGhjLGdjLHljPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO3l5PShlLHQsbixyKT0+e2lmKGUhPT1cIm5vbmVcIiYmciE9PVwiaTMyXCImJnIhPT1cInUzMlwiJiZyIT09XCJmMzJcIil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7cn0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke2V9LmApO2xldCBvPWB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBsb29wIHtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZUYzMiA9YCxhPWA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBiaXRjYXN0PGkzMj4obmV3VmFsdWVGMzIpO1xuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7dH0sIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiByZXMuZXhjaGFuZ2VkIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlcy5vbGRfdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9YDtzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybmAke3R9PSR7bn07YDtjYXNlXCJhZGRcIjpyZXR1cm4gcj09PVwiaTMyXCJ8fHI9PT1cInUzMlwiP2BhdG9taWNBZGQoJiR7dH0sIGJpdGNhc3Q8JHtyfT4oJHtufSkpO2A6YFxuICAgICAgICAgICAgICAke299Yml0Y2FzdDwke3J9PihvbGRWYWx1ZSkgKyAoJHtufSkke2F9YDtjYXNlXCJtYXhcIjpyZXR1cm4gcj09PVwiaTMyXCJ8fHI9PT1cInUzMlwiP2BhdG9taWNNYXgoJiR7dH0sIGJpdGNhc3Q8JHtyfT4oJHtufSkpO2A6YFxuICAgICAgICAgICAgICAgICR7b31tYXgoYml0Y2FzdDxmMzI+KG9sZFZhbHVlKSwgKCR7bn0pKSR7YX1gO2Nhc2VcIm1pblwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY01pbigmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgJHtvfW1pbihiaXRjYXN0PCR7cn0+KG9sZFZhbHVlKSwgKCR7bn0pKSR7YX1gO2Nhc2VcIm11bFwiOnJldHVybmAke299KGJpdGNhc3Q8JHtyfT4ob2xkVmFsdWUpICogKCR7bn0pKSR7YX1gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBSZWR1Y3Rpb24gJHtlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sYnk9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzFdLmRpbXMsbz1uLGE9MSxzPU1hdGguY2VpbChFLnNpemUocikvYSksZD1yW3IubGVuZ3RoLTFdLGw9RS5zaXplRnJvbURpbWVuc2lvbihuLGQpLHA9W3t0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LC4uLkgoZVsxXS5kaW1zLGVbMl0uZGltcyxvKV0sZj1oPT57bGV0IHk9UChcImluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLF89UChcInVwZGF0ZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsYSksYj10LnJlZHVjdGlvbiE9PVwibm9uZVwiJiZ0LnJlZHVjdGlvbiE9PVwiXCI/SHMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoKTpOKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCxhKTtyZXR1cm5gXG4gICAgICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJsYXN0X2luZGV4X2RpbWVuc2lvblwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcIm51bV91cGRhdGVzX2VsZW1lbnRzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LF8sYil9XG4gICAgICAke2gubWFpblN0YXJ0KCl9XG4gICAgICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gIHZhciBoYXNEdXBsaWNhdGVzID0gZmFsc2U7XG4gIGlmICgke3QucmVkdWN0aW9uPT09XCJub25lXCJ9KSB7XG4gICAgbGV0IG4gPSAke0Uuc2l6ZShyKX07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpID0gaSArIDEpIHtcbiAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG47IGogPSBqICsgMSkge1xuICAgICAgICB2YXIgaW5kZXhfaSA9IGkzMihpbmRpY2VzW2ldLngpO1xuICAgICAgICB2YXIgaW5kZXhfaiA9IGkzMihpbmRpY2VzW2pdLngpO1xuICAgICAgICBpZiAoaW5kZXhfaSA9PSBpbmRleF9qKSB7XG4gICAgICAgICAgaGFzRHVwbGljYXRlcyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNEdXBsaWNhdGVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkYXRhX29mZnNldCA9IDB1O1xuICB2YXIgaW5kaWNlc19zdGFydCA9IHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uICogZ2xvYmFsX2lkeDtcbiAgaWYgKCR7dC5yZWR1Y3Rpb249PT1cIm5vbmVcIn0gJiYgaGFzRHVwbGljYXRlcykge1xuICAgIGlmIChnbG9iYWxfaWR4ICE9IDB1KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGluZGljZXNfc3RhcnQgPSAwdTtcbiAgfVxuICBsZXQgaW5kaWNlc19lbmQgPSBpbmRpY2VzX3N0YXJ0ICsgdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb247XG4gIGZvciAodmFyIGkgPSBpbmRpY2VzX3N0YXJ0OyBpIDwgaW5kaWNlc19lbmQ7IGkrKykge1xuICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzW2ldLngpO1xuICAgICR7ZVswXS5kaW1zLmxlbmd0aD09PTE/YFxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGU7YDpgXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXNbaSAtIGluZGljZXNfc3RhcnRdO1xuICAgIGxldCBkaW1fdmFsdWUgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbaSAtIGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbl07YH1cbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgaWYgKGluZGV4ID49IGkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gaTMyKGRpbV92YWx1ZSAtIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaW5kZXggPCAtaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggKz0gaTMyKGRpbV92YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGFfb2Zmc2V0ICs9IHUzMigodTMyKGluZGV4KSAqIGVsZW1lbnRfY291bnRfZGltKSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMHU7IGkgPCB1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50czsgaSsrKSB7XG4gICAgbGV0IHZhbHVlID0gdXBkYXRlc1t1bmlmb3Jtcy5udW1fdXBkYXRlc19lbGVtZW50cyAqIGdsb2JhbF9pZHggKyBpXTtcbiAgICAke3l5KHQucmVkdWN0aW9uLFwib3V0cHV0W2RhdGFfb2Zmc2V0ICsgaV1cIixcInZhbHVlXCIsYi50eXBlLnZhbHVlKX1cbiAgfVxuXG4gICAgICB9YH07cmV0dXJue25hbWU6XCJTY2F0dGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fV8ke3QucmVkdWN0aW9ufWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChzLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6Zn19LGhjPWU9PnJlKHtyZWR1Y3Rpb246ZS5yZWR1Y3Rpb259KSxnYz0oZSx0KT0+e2UuY29tcHV0ZShieShlLmlucHV0cyx0KSx7aW5wdXRzOltlLmlucHV0c1sxXSxlLmlucHV0c1syXV0sb3V0cHV0czpbXX0pfX0pO3ZhciBfeSx3eSx2eSxiYywkeSx4eSxTeSxUeSxDeSxJeSxBeSxreSxfYyxFeSxQeSx6eSxPeSxEeSx3Yyx2YywkYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtfeT0oZSx0KT0+e2lmKGUuZXZlcnkobj0+bj4wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZVwiKX0pKSxlLmxlbmd0aD4wKXtpZih0Lm1vZGU9PT1cImxpbmVhclwiKXtpZighKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT0zfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTF8fGUubGVuZ3RoPT09NSYmZVswXT09PTEmJmVbMV09PT0xKSl0aHJvdyBuZXcgRXJyb3IoYEZvciBsaW5lYXIgbW9kZSwgUmVzaXplIHJlcXVpcmVzIHNjYWxlcyB0byBiZSAyRCwgM0QsIDREIHdpdGggZWl0aGVyIHR3byBvdXRlcm1vc3Qgb3Igb25lIGlubmVybW9zdCBhbmRcbiAgICAgICAgICAgIG9uZSBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDEsIG9yIDVEIHdpdGggdHdvIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMWApfWVsc2UgaWYodC5tb2RlPT09XCJjdWJpY1wiJiYhKGUubGVuZ3RoPT09Mnx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgMiBvciA0IGZvciBjdWJpYyBtb2RlXCIpfX0sd3k9KGUsdCxuKT0+e3QuZXZlcnkobz0+bz49MCYmbzxufHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgYXhlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmUgYW5kIGxlc3MgdGhhbiByYW5rXCIpfSkpO2xldCByPW5ldyBBcnJheShuKS5maWxsKDEpO3JldHVybiB0LmZvckVhY2goKG8sYSk9PnJbb109ZVthXSkscn0sdnk9KGUsdCxuLHIsbyxhKT0+e2xldFtzLGQsbF09bj4xMD9bMSwyLDNdOlstMSxlLmxlbmd0aD4xPzE6LTEsLTFdLHA9ZVswXS5kaW1zLmxlbmd0aDtpZihzPjAmJmUubGVuZ3RoPnMmJmVbc10uZGltcy5sZW5ndGg+MCllW3NdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goZj0+YS5wdXNoKGYpKTtlbHNlIGlmKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBSb0kgaW5wdXQgdG8gYmUgc3BlY2lmaWVkIHdoZW4gY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUgaXMgdGZDcm9wQW5kUmVzaXplXCIpO2lmKGQ+MCYmZS5sZW5ndGg+ZCYmZVtkXS5kaW1zLmxlbmd0aD09PTEmJmVbZF0uZGltc1swXT4wKXtpZihlW2RdLmdldEZsb2F0MzJBcnJheSgpLmZvckVhY2goZj0+ci5wdXNoKGYpKSxyLmxlbmd0aCE9PTAmJnIubGVuZ3RoIT09cCYmbj49MTgmJnIubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2NhbGVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO195KHIsdCksdC5heGVzLmxlbmd0aD4wJiZ3eShyLHQuYXhlcyxwKS5mb3JFYWNoKChmLGgpPT5yW2hdPWYpfWlmKGw+MCYmZS5sZW5ndGg+bCYmZVtsXS5kaW1zLmxlbmd0aD09PTEmJmVbbF0uZGltc1swXT4wJiYoZVtsXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChmPT5vLnB1c2goTnVtYmVyKGYpKSksby5sZW5ndGghPT0wJiZvLmxlbmd0aCE9PXAmJm4+PTE4JiZvLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzaXplcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtpZih0LmF4ZXMubGVuZ3RoPjApe2lmKHIubGVuZ3RoIT09MCYmci5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2NhbGVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyk7aWYoby5sZW5ndGghPT0wJiZvLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzaXplc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgcmFuayBheGVzIHJhbmsgd2hlbiBheGVzIGF0dHJpYnV0ZXMgaXMgc3BlY2lmaWVkJyl9aWYodHlwZW9mIHI8XCJ1XCImJnR5cGVvZiBvPFwidVwiJiZyLmxlbmd0aD4wJiZvLmxlbmd0aD5wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBvbmx5IG9mIHNjYWxlcyBvciBzaXplcyB0byBiZSBzcGVjaWZpZWRcIil9LGJjPShlLHQsbixyKT0+YFxuICAvLyBUaGUgd2hvbGUgcGFydCBhbmQgdGhlIGZyYWN0aW9uYWwgcGFydCBhcmUgY2FsY3VsYXRlZCBzZXBhcmF0ZWx5IGR1ZSB0byBpbmFjY3VyYWN5IG9mIGZsb2F0aW5nXG4gIC8vIHBvaW50IGRpdmlzaW9uLiBBcyBhbiBleGFtcGxlLCBmMzIoMjEpIC8gZjMyKDcpIG1heSBldmFsdWF0ZSB0byAyLjk5Li4uIGluc3RlYWQgb2YgMywgY2F1c2luZyBhblxuICAvLyBvZmZzZXQtYnktb25lIGVycm9yIGxhdGVyIGluIGZsb29yKCkuXG4gIGxldCBiaWcgPSAoJHtlfSkgKiAoJHt0fSk7XG4gIGxldCB3aG9sZSA9ICR7cn0oYmlnIC8gKCR7bn0pKTtcbiAgbGV0IGZyYWN0ID0gJHtyfShiaWcgJSAoJHtufSkpIC8gJHtyfSgke259KTtcbiAgcmV0dXJuIHdob2xlICsgZnJhY3Q7XG5gLCR5PShlLHQpPT5gZm4gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKHhSZXNpemVkOiB1MzIsIHhTY2FsZTogZjMyLCBsZW5ndGhSZXNpemVkOiB1MzIsXG4gICAgIGxlbmd0aE9yaWdpbmFsOiB1MzIsIHJvaVN0YXJ0OiBmMzIsIHJvaUVuZDogZjMyKSAtPiAke3R9IHsgYCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwiYXN5bW1ldHJpY1wiOnJldHVybmBcbiAgICAgICAgICBpZiAoeFNjYWxlIDwgMS4wIHx8IGZsb29yKHhTY2FsZSkgIT0geFNjYWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gJHt0fSh4UmVzaXplZCkgLyAke3R9KHhTY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICR7YmMoXCJ4UmVzaXplZFwiLFwibGVuZ3RoT3JpZ2luYWxcIixcImxlbmd0aFJlc2l6ZWRcIix0KX1cbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiOnJldHVybmByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgJHtiYyhcInhSZXNpemVkXCIsXCJsZW5ndGhPcmlnaW5hbCAtIDFcIixcImxlbmd0aFJlc2l6ZWQgLSAxXCIsdCl9XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJ0Zl9jcm9wX2FuZF9yZXNpemVcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAke3R9KHJvaVN0YXJ0KSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoJHt0fSh4UmVzaXplZCkgKiAke3R9KHJvaUVuZCAtIHJvaVN0YXJ0KSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgJHt0fShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41ICogJHt0fShyb2lTdGFydCArIHJvaUVuZCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSk7XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJoYWxmX3BpeGVsX3N5bW1ldHJpY1wiOnJldHVybmBjb25zdCBvdXRwdXRXaWR0aCA9ICR7dH14U2NhbGUgKiAke3R9KGxlbmd0aFJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9ICR7dH0obGVuZ3RoUmVzaXplZCkgLyBvdXRwdXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9ICR7dH0obGVuZ3RoT3JpZ2luYWwpIC8gMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNlbnRlciAqICgxIC0gYWRqdXN0bWVudCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7Y2FzZVwiaGFsZl9waXhlbFwiOnJldHVybmByZXR1cm4gKCgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkpIC0gMC41O2A7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYENvb3JkaW5hdGUgdHJhbnNmb3JtIG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIix4eT0oZSx0LG4pPT5gZm4gZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKHhPcmlnaW5hbDogJHtufSwgaXNEb3duU2FtcGxlOiBib29sKSAtPiAke259IHtgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJyb3VuZF9wcmVmZXJfY2VpbFwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgIH1cIjtjYXNlXCJmbG9vclwiOnJldHVyblwicmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7XCI7Y2FzZVwiY2VpbFwiOnJldHVyblwicmV0dXJuIGNlaWwoeE9yaWdpbmFsKTtcIjtjYXNlXCJyb3VuZF9wcmVmZXJfZmxvb3JcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG9vcih4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICB9XCI7Y2FzZVwic2ltcGxlXCI6ZGVmYXVsdDppZih0PDExKXJldHVyblwiaWYgKGlzRG93blNhbXBsZSkgICAgICAgICAgICAgICAgICAgICB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geE9yaWdpbmFsOyAgICAgICAgICAgICAgICAgICAgIH1cIjt0aHJvdyBuZXcgRXJyb3IoYE5lYXJlc3QgbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLFN5PShlLHQsbik9PntsZXQgcj1uZXcgQXJyYXkobikuZmlsbCgwKS5jb25jYXQobmV3IEFycmF5KG4pLmZpbGwoMSkpLG89ZS5sZW5ndGg9PT0wP3I6ZS5zbGljZSgpO3JldHVybiB0Lmxlbmd0aD4wPyh0LmZvckVhY2goKGEscyk9PntyW2FdPW9bc10scltzK25dPW9bdC5sZW5ndGgrc119KSxyKTpvfSxUeT0oZSx0LG4scik9PntsZXQgbz1bXTtpZihuLmxlbmd0aD4wKWlmKHIubGVuZ3RoPjApe2lmKGUuZm9yRWFjaChhPT5vLnB1c2goYSkpLE1hdGgubWF4KC4uLnIpPmUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMgaXMgb3V0IG9mIGJvdW5kXCIpO3IuZm9yRWFjaCgoYSxzKT0+b1thXT1uW3NdKX1lbHNlIG4uZm9yRWFjaChhPT5vLnB1c2goYSkpO2Vsc2V7aWYodC5sZW5ndGg9PT0wKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBlaXRoZXIgc2NhbGVzIG9yIHNpemVzLlwiKTtvPWUubWFwKChhLHMpPT5NYXRoLnJvdW5kKGEqdFtzXSkpfXJldHVybiBvfSxDeT0oZSx0LG4pPT57bGV0IHI9KCgpPT57c3dpdGNoKG4ua2VlcEFzcGVjdFJhdGlvUG9saWN5KXtjYXNlXCJub3RfbGFyZ2VyXCI6cmV0dXJuIG4uYXhlcy5sZW5ndGg+MD9NYXRoLm1pbiguLi5uLmF4ZXMubWFwKGE9PnRbYV0pLE51bWJlci5NQVhfVkFMVUUpOk1hdGgubWluKC4uLnQsTnVtYmVyLk1BWF9WQUxVRSk7Y2FzZVwibm90X3NtYWxsZXJcIjpyZXR1cm4gbi5heGVzLmxlbmd0aD4wP01hdGgubWF4KC4uLm4uYXhlcy5tYXAoYT0+dFthXSksTnVtYmVyLk1JTl9WQUxVRSk6TWF0aC5tYXgoLi4udCxOdW1iZXIuTUlOX1ZBTFVFKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgS2VlcCBhc3BlY3QgcmF0aW8gcG9saWN5ICR7bi5rZWVwQXNwZWN0UmF0aW9Qb2xpY3l9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpO3QuZmlsbCgxLDAsdC5sZW5ndGgpO2xldCBvPWUuc2xpY2UoKTtyZXR1cm4gbi5heGVzLmxlbmd0aD4wPyhuLmF4ZXMuZm9yRWFjaChhPT50W2FdPXIpLG4uYXhlcy5mb3JFYWNoKGE9Pm9bYV09TWF0aC5yb3VuZChlW2FdKnRbYV0pKSk6KHQuZmlsbChyLDAsdC5sZW5ndGgpLG8uZm9yRWFjaCgoYSxzKT0+b1tzXT1NYXRoLnJvdW5kKGEqdFtzXSkpKSxvfSxJeT0oZSx0LG4scixvKT0+YFxuICAgIGZuIGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSkgLT4gYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke24ubGVuZ3RofT4ge1xuICAgICAgdmFyIG9yaWdpbmFsX2luZGljZXM6IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtuLmxlbmd0aH0+O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7SyhcInVuaWZvcm1zLnNjYWxlc1wiLFwiaVwiLHIpfTtcbiAgICAgICAgdmFyIHJvaV9sb3cgPSAke0soXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixvKX07XG4gICAgICAgIHZhciByb2lfaGkgPSAke0soXCJ1bmlmb3Jtcy5yb2lcIixgaSArICR7dC5sZW5ndGh9YCxvKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gJHtlLnR5cGUudmFsdWV9KG91dHB1dF9pbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke0soXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtLKFwidW5pZm9ybXMub3V0cHV0X3NoYXBlXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICBvcmlnaW5hbF9pbmRpY2VzW2ldID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbmFsX2luZGljZXM7XG4gICAgfWAsQXk9KGUsdCxuLHIsbyxhLHMpPT5gXG4gICAgZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4OiB1MzI7XG4gICAgICAgIHZhciBzY2FsZSA9ICR7SyhcInVuaWZvcm1zLnNjYWxlc1wiLFwiaVwiLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByb2lfbG93ID0gJHtLKFwidW5pZm9ybXMucm9pXCIsXCJpXCIsYSl9O1xuICAgICAgICAgIHZhciByb2lfaGkgPSAke0soXCJ1bmlmb3Jtcy5yb2lcIixgaSArICR7bi5sZW5ndGh9YCxhKX07XG4gICAgICAgICAgdmFyIGlucHV0X3NoYXBlX2kgPSAke0soXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG91dHB1dF9zaGFwZV9pID0gJHtLKFwidW5pZm9ybXMub3V0cHV0X3NoYXBlXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3JpZ2luYWxfaWR4ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgc2NhbGUsIG91dHB1dF9zaGFwZV9pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRfc2hhcGVfaSwgcm9pX2xvdywgcm9pX2hpKTtcbiAgICAgICAgICBpZiAoISR7c30gfHwgKG9yaWdpbmFsX2lkeCA+PSAwICYmIG9yaWdpbmFsX2lkeCA8ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pKSkpIHtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbF9pZHggPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxfaWR4ID4gJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kgLSAxKSkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIoZ2V0TmVhcmVzdFBpeGVsRnJvbU9yaWdpbmFsKG9yaWdpbmFsX2lkeCwgc2NhbGUgPCAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKG9yaWdpbmFsX2lkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfaW5kZXhcIil9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YCxreT0oZSx0KT0+YFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke0soXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLF9jPShlLHQsbixyKT0+ZS5yYW5rPnI/YFxuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHQsXCJjaGFubmVsXCIpfTtcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixuLFwiYmF0Y2hcIil9O1xuYDpcIlwiLEV5PShlLHQsbixyLG8pPT57bGV0W3MsZCxsLHBdPW4ubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpbMCwyLDMsMV0sZj1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7Zn0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihyb3csICR7bltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGNvbCwgJHtuW2xdfSAtIDEpKWApfTtcbiAgICAgICR7X2MoZSxwLHMsMil9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7Zn0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHtmfSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBjb2w6JHtmfSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgICR7cj9gaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7bltkXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke25bbF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7b307XG4gICAgICB9YDpcIlwifTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke25bZF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7bltsXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke24ubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtwfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke24ubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtzfV0pYDpcIjBcIn07XG4gICAgICB2YXIgeDExOiAke2Z9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke2Z9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke2Z9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke2Z9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke2Z9ID0gYWJzKHJvdyAtICR7Zn0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHtmfSA9IGFicygke2Z9KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7Zn0gPSBhYnMoY29sIC0gJHtmfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke2Z9ID0gYWJzKCR7Zn0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LFB5PShlLHQsbixyLG8sYSxzLGQsbCxwKT0+e2xldCBmPW4ubGVuZ3RoPT09MixoPSEwLFt5LF9dPWY/WzAsMV06aD9bMiwzXTpbMSwyXSxiPWUudHlwZS52YWx1ZSx3PVM9PntsZXQgJD1TPT09eT9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHskfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2J9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixTKX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHtifSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7b1tTXX0sXG4gICAgICAgICR7cltTXX0sICR7bltTXX0sICR7YVtTXX0sICR7YVtTXX0gKyAke24ubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke2J9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2R9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtuW1NdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2x9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke2J9LCA0PiA9IGFycmF5PCR7Yn0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7JH06ICR7Yn0gPSBvcmlnaW5hbElkeCArICR7Yn0oaSk7XG4gICAgICAgICAgaWYgKCR7JH0gPCAwIHx8ICR7JH0gPj0gJHtuW1NdfSkge1xuICAgICAgICAgICAgJHtwP2Bjb2Vmc1tpICsgMV0gPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtgOmQ/YHJldHVybiAke2x9O2A6YCR7JH0gPSBtYXgoMCwgbWluKCR7JH0sICR7bltTXX0gLSAxKSk7YH07XG4gICAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlc19jb3B5OiAke2UudHlwZS5pbmRpY2VzfSA9IGlucHV0X2luZGljZXM7XG4gICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIixTLGB1MzIoJHskfSlgKX07XG4gICAgICAgICAgZGF0YVtpICsgMV0gPSAke1M9PT15P2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc19jb3B5XCIpOlwicm93Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXNfY29weSwgb3V0cHV0X2luZGljZXMpXCJ9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdWJpY0ludGVycG9sYXRpb24xRChkYXRhLCBjb2Vmcyk7XG4gICAgICB9YH07cmV0dXJuYFxuICAgICR7dyh5KX07XG4gICAgJHt3KF8pfTtcbiAgZm4gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoczogJHtifSkgLT4gYXJyYXk8JHtifSwgND4ge1xuICAgIHZhciBhYnNTID0gYWJzKHMpO1xuICAgIHZhciBjb2VmZnM6IGFycmF5PCR7Yn0sIDQ+ID0gYXJyYXk8JHtifSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICB2YXIgb25lTWludXNBYnNTOiAke2J9ID0gMS4wIC0gYWJzUztcbiAgICB2YXIgdHdvTWludXNBYnNTOiAke2J9ID0gMi4wIC0gYWJzUztcbiAgICB2YXIgb25lUGx1c0Fic1M6ICR7Yn0gPSAxLjAgKyBhYnNTO1xuICAgIGNvZWZmc1swXSA9ICgoJHtzfSAqIG9uZVBsdXNBYnNTIC0gNSAqICR7c30pICogb25lUGx1c0Fic1MgKyA4ICogJHtzfSkgKiBvbmVQbHVzQWJzUyAtIDQgKiAke3N9O1xuICAgIGNvZWZmc1sxXSA9ICgoJHtzfSArIDIpICogYWJzUyAtICgke3N9ICsgMykpICogYWJzUyAqIGFic1MgKyAxO1xuICAgIGNvZWZmc1syXSA9ICgoJHtzfSArIDIpICogb25lTWludXNBYnNTIC0gKCR7c30gKyAzKSkgKiBvbmVNaW51c0Fic1MgKiBvbmVNaW51c0Fic1MgKyAxO1xuICAgIGNvZWZmc1szXSA9ICgoJHtzfSAqIHR3b01pbnVzQWJzUyAtIDUgKiAke3N9KSAqIHR3b01pbnVzQWJzUyArIDggKiAke3N9KSAqIHR3b01pbnVzQWJzUyAtIDQgKiAke3N9O1xuICAgIHJldHVybiBjb2VmZnM7XG4gIH1cblxuICBmbiBjdWJpY0ludGVycG9sYXRpb24xRCh4OiBhcnJheTwke2J9LCA0PiwgY29lZnM6IGFycmF5PCR7Yn0sIDQ+KSAtPiAke2J9IHtcbiAgICB2YXIgY29lZnNTdW06ICR7Yn0gPSBjb2Vmc1swXSArIGNvZWZzWzFdICsgY29lZnNbMl0gKyBjb2Vmc1szXTtcbiAgICByZXR1cm4gKHhbMF0gKiBjb2Vmc1swXSArIHhbMV0gKiBjb2Vmc1sxXSsgeFsyXSAqIGNvZWZzWzJdKyB4WzNdICogY29lZnNbM10pIC8gY29lZnNTdW07XG4gIH1cblxuICBmbiBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7Yn0ge1xuICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgIHJldHVybiBjb2xDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlcywgb3V0cHV0X2luZGljZXMpO1xuICB9XG4gICAgYH0senk9KGUsdCxuLHIsbyk9PntsZXRbcyxkLGwscCxmXT1uLmxlbmd0aD09PTM/Wy0xLDAsMSwyLC0xXTpbMCwyLDMsNCwxXSxoPWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGRlcHRoOnUzMiwgaGVpZ2h0OiB1MzIsIHdpZHRoOiB1MzIpIC0+ICR7aH0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihkZXB0aCwgJHtuW2RdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGwsYG1heCgwLCBtaW4oaGVpZ2h0LCAke25bbF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIscCxgbWF4KDAsIG1pbih3aWR0aCwgJHtuW3BdfSAtIDEpKWApfTtcbiAgICAgICR7X2MoZSxmLHMsMyl9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIHRyaWxpbmVhckludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2h9IHtcbiAgICAgIHZhciBvcmlnaW5hbEluZGljZXMgPSBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICB2YXIgZGVwdGg6JHtofSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBoZWlnaHQ6JHtofSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgIHZhciB3aWR0aDoke2h9ID0gb3JpZ2luYWxJbmRpY2VzWyR7cH1dO1xuICAgICAgJHtyP2BpZiAoZGVwdGggPCAwIHx8IGRlcHRoID4gKCR7bltkXX0gLSAxKSB8fCBoZWlnaHQgPCAwIHx8IGhlaWdodCA+ICgke25bbF19IC0gMSkgfHwgd2lkdGggPCAwIHx8ICh3aWR0aCA+ICR7bltwXX0gLSAxKSkge1xuICAgICAgcmV0dXJuICR7b307XG4gICAgICAgIH1gOlwiXCJ9O1xuXG4gICAgZGVwdGggPSBtYXgoMCwgbWluKGRlcHRoLCAke25bZF19IC0gMSkpO1xuICAgICAgaGVpZ2h0ID0gbWF4KDAsIG1pbihoZWlnaHQsICR7bltsXX0gLSAxKSk7XG4gICAgICB3aWR0aCA9IG1heCgwLCBtaW4od2lkdGgsICR7bltwXX0gLSAxKSk7XG4gICAgICB2YXIgZGVwdGgxOiB1MzIgPSB1MzIoZGVwdGgpO1xuICAgICAgdmFyIGhlaWdodDE6IHUzMiA9IHUzMihoZWlnaHQpO1xuICAgICAgdmFyIHdpZHRoMTogdTMyID0gdTMyKHdpZHRoKTtcbiAgICAgIHZhciBkZXB0aDI6IHUzMiA9IHUzMihkZXB0aCArIDEpO1xuICAgICAgdmFyIGhlaWdodDI6IHUzMiA9IHUzMihoZWlnaHQgKyAxKTtcbiAgICAgIHZhciB3aWR0aDI6IHUzMiA9IHUzMih3aWR0aCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7bi5sZW5ndGg+Mz9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2Z9XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7bi5sZW5ndGg+Mz9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3N9XSlgOlwiMFwifTtcblxuICAgICAgdmFyIHgxMTE6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDExMjogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MTIxOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMjI6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgeDIxMTogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjEyOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMjE6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIyMjogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciBkeDE6ICR7aH0gPSBhYnMoZGVwdGggLSAke2h9KGRlcHRoMSkpO1xuICAgICAgdmFyIGR4MjogJHtofSA9IGFicygke2h9KGRlcHRoMikgLSBkZXB0aCk7XG4gICAgICB2YXIgZHkxOiAke2h9ID0gYWJzKGhlaWdodCAtICR7aH0oaGVpZ2h0MSkpO1xuICAgICAgdmFyIGR5MjogJHtofSA9IGFicygke2h9KGhlaWdodDIpIC0gaGVpZ2h0KTtcbiAgICAgIHZhciBkejE6ICR7aH0gPSBhYnMod2lkdGggLSAke2h9KHdpZHRoMSkpO1xuICAgICAgdmFyIGR6MjogJHtofSA9IGFicygke2h9KHdpZHRoMikgLSB3aWR0aCk7XG4gICAgICBpZiAoZGVwdGgxID09IGRlcHRoMikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChoZWlnaHQxID09IGhlaWdodDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAod2lkdGgxID09IHdpZHRoMikge1xuICAgICAgICBkejEgPSAwLjU7XG4gICAgICAgIGR6MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExMSAqIGR4MiAqIGR5MiAqIGR6MiArIHgxMTIgKiBkeDIgKiBkeTIgKiBkejEgKyB4MTIxICogZHgyICogZHkxICpkejIgKyB4MTIyICogZHgyICogZHkxICogZHoxICtcbiAgICAgICAgICAgICAgeDIxMSAqIGR4MSAqIGR5MiAqIGR6MiArIHgyMTIgKiBkeDEgKiBkeTIgKiBkejEgKyB4MjIxICogZHgxICogZHkxICpkejIgKyB4MjIyICogZHgxICogZHkxICogZHoxKTtcbiAgICB9YH0sT3k9KGUsdCxuLHIsbyxhKT0+e2xldCBzPWUuZGltcyxkPVN5KGEsdC5heGVzLHMubGVuZ3RoKSxsPVR5KHMscixvLHQuYXhlcykscD1yLnNsaWNlKCk7ci5sZW5ndGg9PT0wJiYocD1zLm1hcCgodixUKT0+dj09PTA/MTpsW1RdL3YpLHQua2VlcEFzcGVjdFJhdGlvUG9saWN5IT09XCJzdHJldGNoXCImJihsPUN5KHMscCx0KSkpO2xldCBmPU4oXCJvdXRwdXRcIixlLmRhdGFUeXBlLGwubGVuZ3RoKSxoPVAoXCJpbnB1dFwiLGUuZGF0YVR5cGUscy5sZW5ndGgpLHk9RS5zaXplKGwpLF89cy5sZW5ndGg9PT1sLmxlbmd0aCYmcy5ldmVyeSgodixUKT0+dj09PWxbVF0pLGI9dC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIsdz10LmV4dHJhcG9sYXRpb25WYWx1ZSxTPWgudHlwZS52YWx1ZSwkPXY9PmBcbiAgICAgICR7Xz9cIlwiOmBcbiAgICAgICR7JHkodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxTKX07XG4gICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7a3koaCxzKX07XG4gICAgICAgICAgICAgICR7eHkodC5uZWFyZXN0TW9kZSxuLFMpfTtcbiAgICAgICAgICAgICAgJHtBeShoLGYscyxsLHAubGVuZ3RoLGQubGVuZ3RoLGIpfTtcbiAgICAgICAgICAgICAgYDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgICAgICR7SXkoZixzLGwscC5sZW5ndGgsZC5sZW5ndGgpfTtcbiAgICAgICAgICAgICAgJHsoKCk9PntpZihzLmxlbmd0aD09PTJ8fHMubGVuZ3RoPT09NClyZXR1cm5gJHtFeShoLGYscyxiLHcpfWA7aWYocy5sZW5ndGg9PT0zfHxzLmxlbmd0aD09PTUpcmV0dXJuYCR7enkoaCxmLHMsYix3KX1gO3Rocm93IEVycm9yKFwiTGluZWFyIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIsIDMsIDQgYW5kIDUgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7Y2FzZVwiY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgICAkeygoKT0+e2lmKHMubGVuZ3RoPT09Mnx8cy5sZW5ndGg9PT00KXJldHVybmAke1B5KGgsZixzLGwscCxkLHQuY3ViaWNDb2VmZkEsYix0LmV4dHJhcG9sYXRpb25WYWx1ZSx0LmV4Y2x1ZGVPdXRzaWRlKX1gO3Rocm93IEVycm9yKFwiQ3ViaWMgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiBhbmQgNCBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtkZWZhdWx0OnRocm93IEVycm9yKFwiSW52YWxpZCByZXNpemUgbW9kZVwiKX19KSgpfTtcbiAgICAgIGB9XG4gICAgICAke3YucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzY2FsZXNcIixcImYzMlwiLHAubGVuZ3RoKS5yZWdpc3RlclVuaWZvcm0oXCJyb2lcIixcImYzMlwiLGQubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGgsZil9XG4gICAgICAke3YubWFpblN0YXJ0KCl9XG4gICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICR7Xz9cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1wiOmBcbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtmLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtoLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja0lucHV0SW5kaWNlcyhpbnB1dF9pbmRpY2VzKSkge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtoLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3QuZXh0cmFwb2xhdGlvblZhbHVlfTtcbiAgICAgICAgICAgICAgICB9YDtjYXNlXCJsaW5lYXJcIjpyZXR1cm5gb3V0cHV0W2dsb2JhbF9pZHhdID0gJHtzLmxlbmd0aD09PTJ8fHMubGVuZ3RoPT09ND9cImJpbGluZWFySW50ZXJwb2xhdGlvblwiOlwidHJpbGluZWFySW50ZXJwb2xhdGlvblwifShvdXRwdXRfaW5kaWNlcyk7YDtjYXNlXCJjdWJpY1wiOnJldHVyblwib3V0cHV0W2dsb2JhbF9pZHhdID0gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXMpO1wiO2RlZmF1bHQ6dGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHJlc2l6ZSBtb2RlOiAke3QubW9kZX1gKX19KSgpfTtcbmB9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlJlc2l6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9fCR7bn18JHtwLmxlbmd0aD4wP3QubW9kZT09PVwiY3ViaWNcIj9wOnAubGVuZ3RoOlwiXCJ9fCR7by5sZW5ndGg+MD9vOlwiXCJ9fCR7ZC5sZW5ndGg+MD9kOlwiXCJ9fCR7X318JHt0Lm1vZGU9PT1cIm5lYXJlc3RcIj9zLmxlbmd0aDpzfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOiQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEsZGF0YTpwfSx7dHlwZToxLGRhdGE6ZH0sLi4uSChzLGwpXX0pfX0sRHk9ZT0+e2xldCB0PWUuY3VzdG9tRGF0YUJ1ZmZlcjtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHQsdC5ieXRlT2Zmc2V0LDEpWzBdfSx3Yz0oZSx0KT0+e2xldCBuPVtdLHI9W10sbz1bXSxhPUR5KGUpO2lmKHQuYW50aWFsaWFzIT09MCl0aHJvdyBFcnJvcihcIk9ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkXCIpO3Z5KGUuaW5wdXRzLHQsYSxuLHIsbyksZS5jb21wdXRlKE95KGUuaW5wdXRzWzBdLHQsYSxuLHIsbykse2lucHV0czpbMF19KX0sdmM9ZT0+e2xldCB0PWUuYW50aWFsaWFzLG49ZS5heGVzLHI9ZS5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxvPWUuY3ViaWNDb2VmZkEsYT1lLmV4Y2x1ZGVPdXRzaWRlIT09MCxzPWUuZXh0cmFwb2xhdGlvblZhbHVlLGQ9ZS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3ksbD1lLm1vZGUscD1lLm5lYXJlc3RNb2RlPT09XCJcIj9cInNpbXBsZVwiOmUubmVhcmVzdE1vZGU7cmV0dXJuIHJlKHthbnRpYWxpYXM6dCxheGVzOm4sY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6cixjdWJpY0NvZWZmQTpvLGV4Y2x1ZGVPdXRzaWRlOmEsZXh0cmFwb2xhdGlvblZhbHVlOnMsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmQsbW9kZTpsLG5lYXJlc3RNb2RlOnB9KX19KTt2YXIgQnksTXkseGMsU2M9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7Qnk9KGUsdCk9PntsZXRbbixyLG8sYV09ZSx7bnVtSGVhZHM6cyxyb3RhcnlFbWJlZGRpbmdEaW06ZH09dDtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAneCcgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucywgZ290ICR7bi5kaW1zLmxlbmd0aH1gKTtpZighRS5hcmVFcXVhbChyLmRpbXMsW10pJiYhRS5hcmVFcXVhbChyLmRpbXMsWzFdKSYmci5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7ci5kaW1zLmxlbmd0aH1gKTtpZihvLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtvLmRpbXMubGVuZ3RofWApO2lmKGEuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2EuZGltcy5sZW5ndGh9YCk7aWYoIUUuYXJlRXF1YWwoby5kaW1zLGEuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXRzICdjb3NfY2FjaGUnIGFuZCAnc2luX2NhY2hlJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtpZihkPjAmJnM9PT0wKXRocm93IG5ldyBFcnJvcihcIm51bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZFwiKTtsZXQgbD1uLmRpbXNbMF0scD1uLmRpbXNbbi5kaW1zLmxlbmd0aC0yXSxmPW8uZGltc1swXSxoPUUuc2l6ZUZyb21EaW1lbnNpb24obi5kaW1zLDEpL3AseT1kPT09MD9vLmRpbXNbMV0qMjpoL3M7aWYoZD55KXRocm93IG5ldyBFcnJvcihcInJvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZVwiKTtpZihyLmRpbXMubGVuZ3RoPT09Mil7aWYobCE9PXIuZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAwIHNob3VsZCBiZSBvZiBzaXplIGJhdGNoX3NpemUsIGdvdCAke3IuZGltc1swXX1gKTtpZihwIT09ci5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtyLmRpbXNbMV19YCl9aWYoeS8yIT09by5kaW1zWzFdJiZkLzIhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7by5kaW1zWzFdfWApO2lmKHA+Zil0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcIil9LE15PShlLHQpPT57bGV0e2ludGVybGVhdmVkOm4sbnVtSGVhZHM6cixyb3RhcnlFbWJlZGRpbmdEaW06byxzY2FsZTphfT10LHM9ZVswXS5kaW1zWzBdLGQ9RS5zaXplRnJvbURpbWVuc2lvbihlWzBdLmRpbXMsMSksbD1lWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0yXSxwPWQvbCxmPWVbMl0uZGltc1sxXSxoPW89PT0wP2YqMjpwL3IseT1uZXcgQXJyYXkocyxsLHAvaCxoLWYpLF89RS5jb21wdXRlU3RyaWRlcyh5KSxiPVt7dHlwZToxLGRhdGE6YX0se3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOl99LC4uLmVbMF0uZGltcy5sZW5ndGg9PT0zP25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLHAsaCwxXX0pOltdLC4uLmVbMF0uZGltcy5sZW5ndGg9PT00P25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLGgsbCpoLDFdfSk6W10sLi4uSChlWzBdLmRpbXMsZVsxXS5kaW1zLGVbMl0uZGltcyxlWzNdLmRpbXMsZVswXS5kaW1zKV0sdz1TPT57bGV0ICQ9UChcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSx2PVAoXCJwb3NpdGlvbl9pZHNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLFQ9UChcImNvc19jYWNoZVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQz1QKFwic2luX2NhY2hlXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKSxBPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpO3JldHVybiBTLnJlZ2lzdGVyVW5pZm9ybXMoW3tuYW1lOlwic2NhbGVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiZ2xvYmFsX3NoYXBlXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp5Lmxlbmd0aH0se25hbWU6XCJnbG9iYWxfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfb3V0cHV0X3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofV0pLGBcbiAgICAgICAgJHtTLmRlY2xhcmVWYXJpYWJsZXMoJCx2LFQsQyxBKX1cblxuICAgICAgICAke1MubWFpblN0YXJ0KEV0KX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7VC5uYW1lfV9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgYnNuaCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlcyAlIHVuaWZvcm1zLmdsb2JhbF9zaGFwZTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IHVuaWZvcm1zLmdsb2JhbF9zaGFwZVswXSAqIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzWzBdO1xuICAgICAgICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwic2l6ZVwiKX1cblxuICAgICAgICAgIGlmIChic25oWzNdIDwgaGFsZl9yb3RhcnlfZW1iX2RpbSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkc19pZHggPVxuICAgICAgICAgICAgICAgICR7di5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcImJzbmgueHlcIixOKFwiXCIsdi50eXBlLnRlbnNvciwyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHt2LmdldEJ5T2Zmc2V0KFwicG9zaXRpb25faWRzX2lkeFwiKX0pICsgc2VsZWN0KDAsIGJzbmhbMV0sIHBvc2l0aW9uX2lkc19pZHggPT0gMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtufSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtufSk7XG4gICAgICAgICAgICBsZXQgcmUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gLVxuICAgICAgICAgICAgICAgICR7JC5nZXRCeU9mZnNldChcImpcIil9ICogJHtDLmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImlcIixcInJlXCIpfVxuICAgICAgICAgICAgbGV0IGltID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke0MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9ICtcbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJqXCIsXCJpbVwiKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImtcIiwkLmdldEJ5T2Zmc2V0KFwia1wiKSl9XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJSb3RhcnlFbWJlZGRpbmdcIixzaGFkZXJDYWNoZTp7aGludDpyZSh7aW50ZXJsZWF2ZWQ6bn0pLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp3LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChFLnNpemUoeSkvRXQpfSxwcm9ncmFtVW5pZm9ybXM6Yn0pfX0seGM9KGUsdCk9PntCeShlLmlucHV0cyx0KSxlLmNvbXB1dGUoTXkoZS5pbnB1dHMsdCkpfX0pO3ZhciBSeSxVeSxUYyxDYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7Unk9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxuPWVbMV0scj1lWzJdO2lmKHQuZGF0YVR5cGUhPT1uLmRhdGFUeXBlfHx0LmRhdGFUeXBlIT09ci5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGVcIik7aWYodC5kaW1zLmxlbmd0aCE9PTMmJnQuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgMkQgb3IgM0RcIik7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBiZSAyRCBvciAzRFwiKTtsZXQgbz10LmRpbXNbdC5kaW1zLmxlbmd0aC0xXSxhPXQuZGltc1t0LmRpbXMubGVuZ3RoLTJdO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihuLmRpbXNbbi5kaW1zLmxlbmd0aC0yXSE9PWEpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0XCIpO2lmKHIuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgYmUgMURcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihlLmxlbmd0aD4zKXtsZXQgcz1lWzNdO2lmKHMuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBiZSAxRFwiKTtpZihzLmRpbXNbcy5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9aWYoZS5sZW5ndGg+NCl7bGV0IHM9ZVs0XTtpZihzLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgYmUgMURcIik7aWYocy5kaW1zW3MuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfX0sVXk9KGUsdCxuLHIpPT57bGV0IG89dC5zaW1wbGlmaWVkLGE9ZVswXS5kaW1zLHM9RS5zaXplKGEpLGQ9YSxsPXMscD1hLnNsaWNlKC0xKVswXSxmPXI/YS5zbGljZSgwLC0xKS5jb25jYXQoMSk6W10saD0hbyYmZS5sZW5ndGg+Myx5PWUubGVuZ3RoPjQsXz1yJiZuPjEsYj1yJiZuPjIsdz1uPjMsUz02NCwkPWdlKHApLHY9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XSxUPUE9PntsZXQgaz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJjb21wb25lbnRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XSxPPVtQKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLCQpLFAoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsJCksUChcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsJCldO2gmJk8ucHVzaChQKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLCQpKSx5JiZPLnB1c2goUChcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcywkKSksTy5wdXNoKE4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQsJCkpLF8mJk8ucHVzaChOKFwibWVhbl9vdXRwdXRcIiwxLGYpKSxiJiZPLnB1c2goTihcImludl9zdGRfb3V0cHV0XCIsMSxmKSksdyYmTy5wdXNoKE4oXCJpbnB1dF9za2lwX2JpYXNfc3VtXCIsZVswXS5kYXRhVHlwZSxkLCQpKTtsZXQgTT1fZShlWzBdLmRhdGFUeXBlKSxWPV9lKDEsJCk7cmV0dXJuYFxuXG4gICAgICAke0EucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLk8pfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7Vn0sICR7U30+O1xuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NxdWFyZWRfc2hhcmVkIDogYXJyYXk8JHtWfSwgJHtTfT47XG5cbiAgICAgICR7QS5tYWluU3RhcnQoW1MsMSwxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHtTfTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7U307XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke1MtMX0pIHtcbiAgICAgICAgICBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC0gc3RyaWRlICogaXg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xuICAgICAgICAgIGxldCBiaWFzX3ZhbHVlID0gJHt5P1wiYmlhc1tvZmZzZXQxZCArIGldXCI6TStcIigwLjApXCJ9O1xuICAgICAgICAgIGxldCBpbnB1dF92YWx1ZSA9IHhbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRfdmFsdWUgKyBza2lwX3ZhbHVlICsgYmlhc192YWx1ZTtcbiAgICAgICAgICAke3c/XCJpbnB1dF9za2lwX2JpYXNfc3VtW29mZnNldCArIGldID0gdmFsdWU7XCI6XCJcIn1cbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgZjMyX3ZhbHVlID0gJHtQdChNLCQsXCJ2YWx1ZVwiKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke1N9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke0tlKFwic3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtLZShcInNxdWFyZV9zdW1cIiwkKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7bz9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke18/XCJtZWFuX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cbiAgICAgICAgJHtiP1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjtcIjpcIlwifVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtvP1wiXCI6YC0gJHtNfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke019KGludl9zdGRfZGV2KSAqIGdhbW1hW29mZnNldDFkICsgaV1cbiAgICAgICAgICAgICR7aD9cIisgYmV0YVtvZmZzZXQxZCArIGldXCI6XCJcIn07XG4gICAgICAgIH1cbiAgICAgIH1gfSxDPVt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gbj4xJiZDLnB1c2goe2RpbXM6ZixkYXRhVHlwZToxfSksbj4yJiZDLnB1c2goe2RpbXM6ZixkYXRhVHlwZToxfSksbj4zJiZDLnB1c2goe2RpbXM6YSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSkse25hbWU6XCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7JH07JHtffTske2J9OyR7d31gLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKChBLGspPT5cInR5cGVcIil9LGdldFNoYWRlclNvdXJjZTpULGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpDLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvcCl9LHByb2dyYW1Vbmlmb3Jtczp2fSl9fSxUYz0oZSx0KT0+e1J5KGUuaW5wdXRzKTtsZXQgcj1bMF07ZS5vdXRwdXRDb3VudD4xJiZyLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MiYmci5wdXNoKC0zKSxlLm91dHB1dENvdW50PjMmJnIucHVzaCgzKSxlLmNvbXB1dGUoVXkoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50LCExKSx7b3V0cHV0czpyfSl9fSk7dmFyIE55LG5uLFZ5LEljLFd5LEx5LEFjLGtjLEVjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO055PShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKG4scik9PntpZihlW3IrMV0uZGF0YVR5cGUhPT02JiZlW3IrMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtyfSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0sbm49KGUsdCk9PntsZXQgbj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gocj0+bi5wdXNoKE51bWJlcihyKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChyPT5uLnB1c2goTnVtYmVyKHIpKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiBufSxWeT0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCBuPW5uKGUsMSkscj1ubihlLDIpLG89bm4oZSwzKTtyZXR1cm4gby5sZW5ndGg9PT0wJiYobz1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSkscmUoe3N0YXJ0czpuLGVuZHM6cixheGVzOm99KX1lbHNlIHJldHVybiB0fSxJYz0oZSx0LG4scixvKT0+e2xldCBhPWU7cmV0dXJuIGU8MCYmKGErPW5bclt0XV0pLG9bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKGEsbltyW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihhLG5bclt0XV0pKX0sV3k9KGUsdCxuKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7bi5sZW5ndGh9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke0soXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7SyhcInVuaWZvcm1zLnN0ZXBzXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtLKFwidW5pZm9ybXMuc2lnbnNcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtLKFwidW5pZm9ybXMuc3RhcnRzXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YCxMeT0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPUUuc2l6ZShuKSxvPXQuYXhlcy5sZW5ndGg+MD9FLm5vcm1hbGl6ZUF4ZXModC5heGVzLG4ubGVuZ3RoKTpbLi4uQXJyYXkobi5sZW5ndGgpLmtleXMoKV0sYT1ubihlLDQpO2EuZm9yRWFjaCgkPT4kIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxhLmxlbmd0aD09PTAmJihhPUFycmF5KG8ubGVuZ3RoKS5maWxsKDEpKTtsZXQgcz10LnN0YXJ0cy5tYXAoKCQsdik9PkljKCQsdixuLG8sYSkpLGQ9dC5lbmRzLm1hcCgoJCx2KT0+SWMoJCx2LG4sbyxhKSk7aWYoby5sZW5ndGghPT1zLmxlbmd0aHx8by5sZW5ndGghPT1kLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcIik7aWYoby5sZW5ndGghPT1uLmxlbmd0aClmb3IobGV0ICQ9MDskPG4ubGVuZ3RoOysrJClvLmluY2x1ZGVzKCQpfHwocy5zcGxpY2UoJCwwLDApLGQuc3BsaWNlKCQsMCxuWyRdKSxhLnNwbGljZSgkLDAsMSkpO2xldCBsPWEubWFwKCQ9Pk1hdGguc2lnbigkKSk7YS5mb3JFYWNoKCgkLHYsVCk9PntpZigkPDApe2xldCBDPShkW3ZdLXNbdl0pLyQsQT1zW3ZdLGs9QStDKmFbdl07c1t2XT1rLGRbdl09QSxUW3ZdPS0kfX0pO2xldCBwPW4uc2xpY2UoMCk7by5mb3JFYWNoKCgkLHYpPT57cFskXT1NYXRoLmNlaWwoKGRbJF0tc1skXSkvYVskXSl9KTtsZXQgZj17ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LGg9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscC5sZW5ndGgpLHk9UChcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxfPUUuc2l6ZShwKSxiPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpzLmxlbmd0aH0se25hbWU6XCJzaWduc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6bC5sZW5ndGh9LHtuYW1lOlwic3RlcHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmEubGVuZ3RofV0sdz1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnN9LHt0eXBlOjYsZGF0YTpsfSx7dHlwZToxMixkYXRhOmF9LC4uLkgoZVswXS5kaW1zLHApXSxTPSQ9PmBcbiAgICAgICR7JC5yZWdpc3RlclVuaWZvcm1zKGIpLmRlY2xhcmVWYXJpYWJsZXMoeSxoKX1cbiAgICAgICAgJHtXeSh5LGgsbil9XG4gICAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtoLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke2guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIseS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiU2xpY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsLmxlbmd0aH1fJHtzLmxlbmd0aH1fJHthLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpTLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbZl0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci82NCl9LHByb2dyYW1Vbmlmb3Jtczp3fSl9fSxBYz0oZSx0KT0+e055KGUuaW5wdXRzLHQpO2xldCBuPVZ5KGUuaW5wdXRzLHQpO2UuY29tcHV0ZShMeShlLmlucHV0cyxuKSx7aW5wdXRzOlswXX0pfSxrYz1lPT57bGV0IHQ9ZS5zdGFydHMsbj1lLmVuZHMscj1lLmF4ZXM7cmV0dXJuIHJlKHtzdGFydHM6dCxlbmRzOm4sYXhlczpyfSl9fSk7dmFyIEd5LEh5LFBjLHpjLE9jPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjdCgpO2NlKCk7R3k9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0sSHk9KGUsdCk9PntsZXQgbj1lLmlucHV0c1swXSxyPW4uZGltcyxvPUUuc2l6ZShyKSxhPXIubGVuZ3RoLHM9RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxhKSxkPXM8ci5sZW5ndGgtMSxsLHA9W107ZD8ocD1BcnJheS5mcm9tKHtsZW5ndGg6YX0sKE8sTSk9Pk0pLHBbc109YS0xLHBbYS0xXT1zLGw9ZS5jb21wdXRlKE9lKG4scCkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pOmw9bjtsZXQgZj1sLmRpbXMsaD1mW2EtMV0seT1vL2gsXz1nZShoKSxiPWgvXyx3PTY0O3k9PT0xJiYodz0yNTYpO2xldCBTPShPLE0pPT5NPT09ND9gbWF4KG1heCgke099LngsICR7T30ueSksIG1heCgke099LnosICR7T30udykpYDpNPT09Mj9gbWF4KCR7T30ueCwgJHtPfS55KWA6TT09PTM/YG1heChtYXgoJHtPfS54LCAke099LnkpLCAke099LnopYDpPLCQ9UChcInhcIixsLmRhdGFUeXBlLGwuZGltcyxfKSx2PU4oXCJyZXN1bHRcIixsLmRhdGFUeXBlLGwuZGltcyxfKSxUPSQudHlwZS52YWx1ZSxDPV9lKGwuZGF0YVR5cGUpPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7VH0oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke1R9KC02NTUwNC4waCk7YCxBPU89PmBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7VH07XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke1R9O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHtUfSwgJHt3fT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke1R9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7VH0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgJHtPLnJlZ2lzdGVyVW5pZm9ybShcInBhY2tlZENvbHNcIixcImkzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gICAgICAke08ubWFpblN0YXJ0KHcpfVxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHt3fTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke0N9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7VH0oJHtTKFwidGhyZWFkU2hhcmVkWzBdXCIsXyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7VH0oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7VH0oJHtLZShcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YCxrPWUuY29tcHV0ZSh7bmFtZTpcIlNvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtffTske3d9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmYsZGF0YVR5cGU6bC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6eX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTo2LGRhdGE6Yn1dfSksZ2V0U2hhZGVyU291cmNlOkF9LHtpbnB1dHM6W2xdLG91dHB1dHM6W2Q/LTE6MF19KVswXTtkJiZlLmNvbXB1dGUoT2UoayxwKSx7aW5wdXRzOltrXX0pfSxQYz0oZSx0KT0+e0d5KGUuaW5wdXRzKSxIeShlLHQpfSx6Yz1lPT5yZSh7YXhpczplLmF4aXN9KX0pO3ZhciBEYyxGeSxxeSxLeSxCYyxNYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7RGM9ZT0+QXJyYXkuZnJvbShlLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLEZ5PWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09MTAmJmVbMF0uZGF0YVR5cGUhPT02JiZlWzBdLmRhdGFUeXBlIT09MTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXNcIik7aWYoZVsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZVwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EXCIpO2lmKERjKGVbMV0pLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvclwiKX0scXk9KGUsdCk9PntsZXQgbj1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrciluLnB1c2goZVtyXSp0W3JdKTtyZXR1cm4gbn0sS3k9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj10Pz9EYyhlWzFdKSxvPXF5KG4sciksYT1FLnNpemUobykscz1lWzBdLmRhdGFUeXBlLGQ9UChcImlucHV0XCIscyxuLmxlbmd0aCksbD1OKFwib3V0cHV0XCIscyxvLmxlbmd0aCkscD1mPT5gXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHtkLmluZGljZXMoLi4ubil9O1xuICAgICAgJHtmLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhkLGwpfVxuICAgICAgJHtmLm1haW5TdGFydCgpfVxuICAgICAgJHtmLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2QudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2QuaW5kaWNlc0dldChcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7bC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfZGltX3ZhbHVlXCIpfVxuICAgICAgfVxuICAgICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGQuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTphfSwuLi5IKGVbMF0uZGltcyxvKV19KSxnZXRTaGFkZXJTb3VyY2U6cH19LEJjPWU9PntGeShlLmlucHV0cyksZS5jb21wdXRlKEt5KGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBqeSxaeSxSYyxVYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7ank9KGUsdCxuLHIsbyk9PntsZXQgYT1OKFwib3V0cHV0X2RhdGFcIixvLG4ubGVuZ3RoLDQpLHM9UChcImFfZGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCw0KSxkPVAoXCJiX2RhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcy5sZW5ndGgsNCksbD1QKFwiY19kYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLDQpLHAsZj0oaCx5LF8pPT5gc2VsZWN0KCR7eX0sICR7aH0sICR7X30pYDtpZighcilwPWEuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZihzLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IGg9KHksXyxiPVwiXCIpPT57bGV0IHc9YGFfZGF0YVtpbmRleF9hJHtffV1bY29tcG9uZW50X2Eke199XWAsUz1gYl9kYXRhW2luZGV4X2Ike199XVtjb21wb25lbnRfYiR7X31dYCwkPWBib29sKGNfZGF0YVtpbmRleF9jJHtffV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHtffSAqIDgpKSlgO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7X30gPSAke2Eub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke199dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7X30gPSAke3MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsYSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHtffSA9ICR7ZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxhKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke199ID0gJHtsLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGEpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHtffSA9IG9mZnNldF9hJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike199ID0gb2Zmc2V0X2Ike199IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7X30gPSBvZmZzZXRfYyR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7X30gPSBvZmZzZXRfYSR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7X30gPSBvZmZzZXRfYiR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7X30gPSBvZmZzZXRfYyR7X30gJSA0dTtcbiAgICAgICAgICAgICR7eX1bJHtffV0gPSAke2J9KCR7Zih3LFMsJCl9KTtcbiAgICAgICAgICBgfTtvPT09OT9wPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHtoKFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2goXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7aChcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtoKFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOnA9YFxuICAgICAgICAgICAgJHtoKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7aChcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke2goXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHtoKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhsLHMsZCxhKX1cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke3B9XG4gICAgICB9YH0sWnk9ZT0+e2xldCB0PWVbMV0uZGltcyxuPWVbMl0uZGltcyxyPWVbMF0uZGltcyxvPWVbMV0uZGF0YVR5cGUsYT0hKEUuYXJlRXF1YWwodCxuKSYmRS5hcmVFcXVhbChuLHIpKSxzPXQsZD1FLnNpemUodCk7aWYoYSl7bGV0IHA9cnQuY2FsY1NoYXBlKHJ0LmNhbGNTaGFwZSh0LG4sITEpLHIsITEpO2lmKCFwKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7cz1wLGQ9RS5zaXplKHMpfWxldCBsPU1hdGguY2VpbChkLzQpO3JldHVybntuYW1lOlwiV2hlcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnA9Pmp5KHAsZSxzLGEsbyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpzLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bH0sLi4uSChyLHQsbixzKV19KX19LFJjPWU9PntlLmNvbXB1dGUoWnkoZS5pbnB1dHMpKX19KTt2YXIgTmMsVmM9RygoKT0+e1widXNlIHN0cmljdFwiO191KCk7cXIoKTskdSgpO1N1KCk7ZGQoKTt3ZCgpO3hkKCk7TmQoKTtxZCgpO1pkKCk7WGQoKTtubCgpO2FsKCk7dWwoKTtjbCgpO2ZsKCk7eWwoKTt3bCgpO3hsKCk7Q2woKTtEbCgpO1JsKCk7TmwoKTtXbCgpO0hsKCk7U28oKTtxbCgpO2RjKCk7cGMoKTtmYygpO3ljKCk7SHIoKTskYygpO1NjKCk7Q2MoKTtFYygpO09jKCk7Q28oKTtNYygpO2N0KCk7anIoKTtVYygpO05jPW5ldyBNYXAoW1tcIkFic1wiLFtUdV1dLFtcIkFjb3NcIixbQ3VdXSxbXCJBY29zaFwiLFtJdV1dLFtcIkFkZFwiLFtsZF1dLFtcIkFyZ01heFwiLFtidSxjb11dLFtcIkFyZ01pblwiLFt5dSxjb11dLFtcIkFzaW5cIixbQXVdXSxbXCJBc2luaFwiLFtrdV1dLFtcIkF0YW5cIixbRXVdXSxbXCJBdGFuaFwiLFtQdV1dLFtcIkF0dGVudGlvblwiLFt3dV1dLFtcIkF2ZXJhZ2VQb29sXCIsW2VjLEpsXV0sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsW3Z1XV0sW1wiQmlhc0FkZFwiLFt4dV1dLFtcIkJpYXNTcGxpdEdlbHVcIixbdWRdXSxbXCJDYXN0XCIsW091LHp1XV0sW1wiQ2VpbFwiLFtCdV1dLFtcIkNsaXBcIixbRHVdXSxbXCJDb25jYXRcIixbdmQsJGRdXSxbXCJDb252XCIsW3dvLF9vXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtGZCxHZF1dLFtcIkNvc1wiLFtNdV1dLFtcIkNvc2hcIixbUnVdXSxbXCJDdW1TdW1cIixbS2QsamRdXSxbXCJEZXB0aFRvU3BhY2VcIixbUWQsWWRdXSxbXCJEZXF1YW50aXplTGluZWFyXCIsW2xjLGNjXV0sW1wiRGl2XCIsW2NkXV0sW1wiRWluc3VtXCIsW3RsLHJsXV0sW1wiRWx1XCIsW1V1LHRyXV0sW1wiRXF1YWxcIixbcGRdXSxbXCJFcmZcIixbTnVdXSxbXCJFeHBcIixbVnVdXSxbXCJFeHBhbmRcIixbaWxdXSxbXCJGYXN0R2VsdVwiLFtzbF1dLFtcIkZsb29yXCIsW1d1XV0sW1wiRnVzZWRDb252XCIsW3dvLF9vXV0sW1wiR2F0aGVyXCIsW2xsLGRsXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbX2wsYmxdXSxbXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLFtobCxnbF1dLFtcIkdhdGhlck5EXCIsW3BsLG1sXV0sW1wiR2VsdVwiLFtMdV1dLFtcIkdlbW1cIixbJGwsdmxdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFtuYyxyY11dLFtcIkdsb2JhbE1heFBvb2xcIixbdWMsc2NdXSxbXCJHcmVhdGVyXCIsW2dkXV0sW1wiR3JlYXRlck9yRXF1YWxcIixbYmRdXSxbXCJHcmlkU2FtcGxlXCIsW1NsLFRsXV0sW1wiR3JvdXBRdWVyeUF0dGVudGlvblwiLFtPbF1dLFtcIkhhcmRTaWdtb2lkXCIsW1F1LFp1XV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW01sXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1VsXV0sW1wiTGVha3lSZWx1XCIsW0d1LHRyXV0sW1wiTGVzc1wiLFt5ZF1dLFtcIkxlc3NPckVxdWFsXCIsW19kXV0sW1wiTG9nXCIsW2lkXV0sW1wiTWF0TXVsXCIsW1ZsXV0sW1wiTWF0TXVsTkJpdHNcIixbTGwsR2xdXSxbXCJNYXhQb29sXCIsW2ljLGFjXV0sW1wiTXVsXCIsW21kXV0sW1wiTXVsdGlIZWFkQXR0ZW50aW9uXCIsW2tsLEFsXV0sW1wiTmVnXCIsW0Z1XV0sW1wiTm90XCIsW0h1XV0sW1wiUGFkXCIsW0ZsXV0sW1wiUG93XCIsW2ZkXV0sW1wiUXVpY2tHZWx1XCIsW2FkLHRyXV0sW1wiUmFuZ2VcIixbbWNdXSxbXCJSZWNpcHJvY2FsXCIsW3F1XV0sW1wiUmVkdWNlTWluXCIsW2N1XV0sW1wiUmVkdWNlTWVhblwiLFthdV1dLFtcIlJlZHVjZU1heFwiLFtsdV1dLFtcIlJlZHVjZVN1bVwiLFttdV1dLFtcIlJlZHVjZVByb2RcIixbcHVdXSxbXCJSZWR1Y2VMMVwiLFtzdV1dLFtcIlJlZHVjZUwyXCIsW3V1XV0sW1wiUmVkdWNlTG9nU3VtXCIsW2h1XV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW2R1XV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW2Z1XV0sW1wiUmVsdVwiLFtLdV1dLFtcIlJlc2l6ZVwiLFt3Yyx2Y11dLFtcIlJvdGFyeUVtYmVkZGluZ1wiLFt4Y11dLFtcIlNjYXR0ZXJORFwiLFtnYyxoY11dLFtcIlNpZ21vaWRcIixbanVdXSxbXCJTaW5cIixbWXVdXSxbXCJTaW5oXCIsW1h1XV0sW1wiU2xpY2VcIixbQWMsa2NdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1RjXV0sW1wiU3BsaXRcIixbRWwsUGxdXSxbXCJTcXJ0XCIsW0p1XV0sW1wiU29mdG1heFwiLFtQYyx6Y11dLFtcIlN1YlwiLFtoZF1dLFtcIlRhblwiLFtlZF1dLFtcIlRhbmhcIixbcmRdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbb2QsdHJdXSxbXCJUaWxlXCIsW0JjXV0sW1wiVHJhbnNwb3NlXCIsW0tzLGpzXV0sW1wiV2hlcmVcIixbUmNdXV0pfSk7dmFyIG9uLFdjPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3R0KCk7Y2UoKTtvbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LG4pe3RoaXMucmVwby5zZXQodCxuKX1ydW4odCxuLHIsbyxhKXtOZSh0LnByb2dyYW1JbmZvLm5hbWUpO2xldCBzPXRoaXMuYmFja2VuZC5kZXZpY2UsZD10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMik7bGV0IGw9W107Zm9yKGxldCBmIG9mIG4pbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Zi5idWZmZXJ9fSk7Zm9yKGxldCBmIG9mIHIpbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6Zi5idWZmZXJ9fSk7YSYmbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOmF9KTtsZXQgcD1zLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmwsbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgZj17a2VybmVsSWQ6dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCxjb21wdXRlUGlwZWxpbmU6dC5jb21wdXRlUGlwZWxpbmUsYmluZEdyb3VwOnAsZGlzcGF0Y2hHcm91cDpvfTt0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2goZil9ZC5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSksZC5zZXRCaW5kR3JvdXAoMCxwKSxkLmRpc3BhdGNoV29ya2dyb3VwcyguLi5vKSx0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKywodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLmJhY2tlbmQucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5iYWNrZW5kLmZsdXNoKCksQmUodC5wcm9ncmFtSW5mby5uYW1lKX1kaXNwb3NlKCl7fWJ1aWxkKHQsbil7TmUodC5uYW1lKTtsZXQgcj10aGlzLmJhY2tlbmQuZGV2aWNlLG89W107W3tmZWF0dXJlOlwic2hhZGVyLWYxNlwiLGV4dGVuc2lvbjpcImYxNlwifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwc1wiLGV4dGVuc2lvbjpcInN1Ymdyb3Vwc1wifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwcy1mMTZcIixleHRlbnNpb246XCJzdWJncm91cHNfZjE2XCJ9XS5mb3JFYWNoKGg9PntyLmZlYXR1cmVzLmhhcyhoLmZlYXR1cmUpJiZvLnB1c2goYGVuYWJsZSAke2guZXh0ZW5zaW9ufTtgKX0pO2xldCBzPUZzKG4sdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMpLGQ9dC5nZXRTaGFkZXJTb3VyY2UocyksbD1gJHtvLmpvaW4oYFxuYCl9XG4ke3MuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7ZH1gLHA9ci5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6bCxsYWJlbDp0Lm5hbWV9KTttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdICR7dC5uYW1lfSBzaGFkZXIgY29kZTogJHtsfWApO2xldCBmPXIuY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6cCxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJuIEJlKHQubmFtZSkse3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOmYsdW5pZm9ybVZhcmlhYmxlc0luZm86cy52YXJpYWJsZXNJbmZvfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgbj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxyPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEsYT10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihuPD1hJiZyPD1hJiZvPD1hKXJldHVybltuLHIsb107bGV0IHM9bipyKm8sZD1NYXRoLmNlaWwoTWF0aC5zcXJ0KHMpKTtpZihkPmEpe2lmKGQ9TWF0aC5jZWlsKE1hdGguY2JydChzKSksZD5hKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2QsZCxkXX1lbHNlIHJldHVybltkLGQsMV19fX0pO3ZhciBReSxZeSxJbyxBbyxhbixMYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt0ZSgpO3R0KCk7Sm4oKTtXcygpO1ZjKCk7V2MoKTtReT0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IG49W107Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3Ipe2xldCBvPWVbcl0uZGF0YVR5cGU7c3dpdGNoKHRbcl0pe2Nhc2VcIm5vbmVcIjp7bi5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7bi5wdXNoKGAke299YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgYT1lW3JdLmRpbXMubGVuZ3RoO24ucHVzaChgJHtvfTske2F9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgYT1lW3JdLmRpbXMuam9pbihcIixcIik7bi5wdXNoKGAke299OyR7YX1gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W3JdfWApfX1yZXR1cm4gbi5qb2luKFwifFwiKX0sWXk9KGUsdCxuKT0+e2xldCByPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKHIrPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIikscis9XCI6XCIrbitgOiR7UXkodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxyfSxJbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0JiYodGhpcy5hcmNoaXRlY3R1cmU9dC5hcmNoaXRlY3R1cmUsdGhpcy52ZW5kb3I9dC52ZW5kb3IpfWlzQXJjaGl0ZWN0dXJlKHQpe3JldHVybiB0aGlzLmFyY2hpdGVjdHVyZT09PXR9aXNWZW5kb3IodCl7cmV0dXJuIHRoaXMudmVuZG9yPT09dH19LEFvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc3ViZ3JvdXBzU3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpLHRoaXMuc3ViZ3JvdXBzRjE2U3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpO2xldCBuPXQubGltaXRzOyF0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZHx8IW4ubWluU3ViZ3JvdXBTaXplfHwhbi5tYXhTdWJncm91cFNpemU/dGhpcy5zdWJncm91cFNpemVSYW5nZT12b2lkIDA6dGhpcy5zdWJncm91cFNpemVSYW5nZT1bbi5taW5TdWJncm91cFNpemUsbi5tYXhTdWJncm91cFNpemVdfX0sYW49Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9bnVsbDt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMubWF4RGlzcGF0Y2hOdW1iZXI9MTY7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO3RoaXMucGVuZGluZ1F1ZXJpZXM9bmV3IE1hcDt0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCI7dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0PW5ldyBNYXA7dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzPW5ldyBNYXA7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQsbil7dGhpcy5lbnY9dDtsZXQgcj1bXSxvPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6bi5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6bi5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6bi5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOnJ9LGE9cz0+bi5mZWF0dXJlcy5oYXMocykmJnIucHVzaChzKSYmITA7YShcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKXx8YShcInRpbWVzdGFtcC1xdWVyeVwiKSxhKFwic2hhZGVyLWYxNlwiKSxhKFwic3ViZ3JvdXBzXCIpJiZhKFwic3ViZ3JvdXBzLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCBuLnJlcXVlc3REZXZpY2UobyksdGhpcy5kZXZpY2VJbmZvPW5ldyBBbyh0aGlzLmRldmljZSksdGhpcy5hZGFwdGVySW5mbz1uZXcgSW8obi5pbmZvfHxhd2FpdCBuLnJlcXVlc3RBZGFwdGVySW5mbygpKSx0aGlzLmdwdURhdGFNYW5hZ2VyPVZzKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IG9uKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxVcih0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9cz0+e3MuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7cy5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImFkYXB0ZXJcIix7dmFsdWU6bix3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLHRoaXMuc2V0UXVlcnlUeXBlKCl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLG49e307dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiJiYobi50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLGVuZE9mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dC5iZWdpbkNvbXB1dGVQYXNzKG4pfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXtpZighdGhpcy5jb21tYW5kRW5jb2RlcilyZXR1cm47TmUoKSx0aGlzLmVuZENvbXB1dGVQYXNzKCk7bGV0IHQ7dGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmKHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMucXVlcnlTZXQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDApLHQ9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pLHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHQsdGhpcy5wZW5kaW5nS2VybmVscyksdGhpcy5wZW5kaW5nS2VybmVscz1bXSx0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwLHQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgpKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnQubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IG49bmV3IEJpZ1VpbnQ2NEFycmF5KHQuZ2V0TWFwcGVkUmFuZ2UoKSkscj10aGlzLnBlbmRpbmdRdWVyaWVzLmdldCh0KTtmb3IobGV0IG89MDtvPG4ubGVuZ3RoLzI7bysrKXtsZXQgYT1yW29dLHM9YS5rZXJuZWxJZCxkPXRoaXMua2VybmVscy5nZXQocyksbD1kLmtlcm5lbFR5cGUscD1kLmtlcm5lbE5hbWUsZj1hLnByb2dyYW1OYW1lLGg9YS5pbnB1dFRlbnNvclZpZXdzLHk9YS5vdXRwdXRUZW5zb3JWaWV3cyxfPW5bbyoyXSxiPW5bbyoyKzFdO3R5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLnF1ZXJ5VGltZUJhc2U9Xyk7bGV0IHc9TnVtYmVyKF8tdGhpcy5xdWVyeVRpbWVCYXNlKSxTPU51bWJlcihiLXRoaXMucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHcpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoUykpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO2lmKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSl0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7dmVyc2lvbjoxLGlucHV0c01ldGFkYXRhOmgubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6X3QoJC5kYXRhVHlwZSl9KSksb3V0cHV0c01ldGFkYXRhOnkubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6X3QoJC5kYXRhVHlwZSl9KSksa2VybmVsSWQ6cyxrZXJuZWxUeXBlOmwsa2VybmVsTmFtZTpwLHByb2dyYW1OYW1lOmYsc3RhcnRUaW1lOncsZW5kVGltZTpTfSk7ZWxzZXtsZXQgJD1cIlwiO2guZm9yRWFjaCgoVCxDKT0+eyQrPWBpbnB1dFske0N9XTogWyR7VC5kaW1zfV0gfCAke190KFQuZGF0YVR5cGUpfSwgYH0pO2xldCB2PVwiXCI7eS5mb3JFYWNoKChULEMpPT57dis9YG91dHB1dFske0N9XTogWyR7VC5kaW1zfV0gfCAke190KFQuZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke3N9fCR7bH18JHtwfXwke2Z9XCIgJHskfSR7dn1leGVjdXRpb24gdGltZTogJHtTLXd9IG5zYCl9dnIoXCJHUFVcIixgJHtmfTo6JHtffTo6JHtifWApfXQudW5tYXAoKSx0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZSh0KX0pLEJlKCl9cnVuKHQsbixyLG8sYSxzKXtOZSh0Lm5hbWUpO2xldCBkPVtdO2ZvcihsZXQgVD0wO1Q8bi5sZW5ndGg7KytUKXtsZXQgQz1uW1RdLmRhdGE7aWYoQz09PTApY29udGludWU7bGV0IEE9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoQyk7aWYoIUEpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7Q31gKTtkLnB1c2goQSl9bGV0e291dHB1dHM6bCxkaXNwYXRjaEdyb3VwOnAscHJvZ3JhbVVuaWZvcm1zOmZ9PXQuZ2V0UnVuRGF0YShuKSxoPXIubGVuZ3RoPT09MD9sLm1hcCgoVCxDKT0+Qyk6cjtpZihoLmxlbmd0aCE9PWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHtoLmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke2wubGVuZ3RofS5gKTtsZXQgeT1bXSxfPVtdO2ZvcihsZXQgVD0wO1Q8bC5sZW5ndGg7KytUKXtpZighTnVtYmVyLmlzSW50ZWdlcihoW1RdKXx8aFtUXTwtM3x8aFtUXT49cyl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke2hbVF19YCk7aWYoaFtUXT09PS0zKWNvbnRpbnVlO2xldCBDPWhbVF09PT0tMSxBPWhbVF09PT0tMixrPUN8fEE/YShsW1RdLmRhdGFUeXBlLGxbVF0uZGltcyk6byhoW1RdLGxbVF0uZGF0YVR5cGUsbFtUXS5kaW1zKTtpZih5LnB1c2goayksay5kYXRhPT09MCljb250aW51ZTtsZXQgTz10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChrLmRhdGEpO2lmKCFPKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtrLmRhdGF9YCk7aWYoQyYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goTyksQSl7bGV0IE09dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO018fChNPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLE0pKSxNLnB1c2goTyl9Xy5wdXNoKE8pfWlmKGQubGVuZ3RoIT09bi5sZW5ndGh8fF8ubGVuZ3RoIT09eS5sZW5ndGgpe2lmKF8ubGVuZ3RoPT09MClyZXR1cm4gQmUodC5uYW1lKSx5O3Rocm93IG5ldyBFcnJvcihgUHJvZ3JhbSAke3QubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmApfWxldCBiO2lmKGYpe2xldCBUPTAsQz1bXTtmLmZvckVhY2goTT0+e2xldCBWPXR5cGVvZiBNLmRhdGE9PVwibnVtYmVyXCI/W00uZGF0YV06TS5kYXRhO2lmKFYubGVuZ3RoPT09MClyZXR1cm47bGV0IEY9TS50eXBlPT09MTA/Mjo0LGosbmU7TS50eXBlPT09MTA/KG5lPVYubGVuZ3RoPjQ/MTY6Vi5sZW5ndGg+Mj84OlYubGVuZ3RoKkYsaj1WLmxlbmd0aD40PzE2OkYqVi5sZW5ndGgpOihuZT1WLmxlbmd0aDw9Mj9WLmxlbmd0aCpGOjE2LGo9MTYpLFQ9TWF0aC5jZWlsKFQvbmUpKm5lLEMucHVzaChUKTtsZXQgVz1NLnR5cGU9PT0xMD84OjQ7VCs9Vi5sZW5ndGg+ND9NYXRoLmNlaWwoVi5sZW5ndGgvVykqajpWLmxlbmd0aCpGfSk7bGV0IEE9MTY7VD1NYXRoLmNlaWwoVC9BKSpBO2xldCBrPW5ldyBBcnJheUJ1ZmZlcihUKTtmLmZvckVhY2goKE0sVik9PntsZXQgRj1DW1ZdLGo9dHlwZW9mIE0uZGF0YT09XCJudW1iZXJcIj9bTS5kYXRhXTpNLmRhdGE7aWYoTS50eXBlPT09NiluZXcgSW50MzJBcnJheShrLEYsai5sZW5ndGgpLnNldChqKTtlbHNlIGlmKE0udHlwZT09PTEyKW5ldyBVaW50MzJBcnJheShrLEYsai5sZW5ndGgpLnNldChqKTtlbHNlIGlmKE0udHlwZT09PTEwKW5ldyBVaW50MTZBcnJheShrLEYsai5sZW5ndGgpLnNldChqKTtlbHNlIGlmKE0udHlwZT09PTEpbmV3IEZsb2F0MzJBcnJheShrLEYsai5sZW5ndGgpLnNldChqKTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdW5pZm9ybSB0eXBlOiAke190KE0udHlwZSl9YCl9KTtsZXQgTz10aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShULEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pO3RoaXMuZGV2aWNlLnF1ZXVlLndyaXRlQnVmZmVyKE8uYnVmZmVyLDAsaywwLFQpLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShPLmlkKSxiPXtvZmZzZXQ6MCxzaXplOlQsYnVmZmVyOk8uYnVmZmVyfX1sZXQgdz10aGlzLnByb2dyYW1NYW5hZ2VyLm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHApLFM9d1sxXT09PTEmJndbMl09PT0xLCQ9WXkodCxuLFMpLHY9dGhpcy5wcm9ncmFtTWFuYWdlci5nZXRBcnRpZmFjdCgkKTtpZih2fHwodj10aGlzLnByb2dyYW1NYW5hZ2VyLmJ1aWxkKHQsdyksdGhpcy5wcm9ncmFtTWFuYWdlci5zZXRBcnRpZmFjdCgkLHYpLG1lKFwiaW5mb1wiLCgpPT5gW2FydGlmYWN0XSBrZXk6ICR7JH0sIHByb2dyYW1OYW1lOiAke3QubmFtZX1gKSksZiYmdi51bmlmb3JtVmFyaWFibGVzSW5mbyl7aWYoZi5sZW5ndGghPT12LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGVzIGNvdW50IG1pc21hdGNoOiBleHBlY3QgJHt2LnVuaWZvcm1WYXJpYWJsZXNJbmZvLmxlbmd0aH0sIGdvdCAke2YubGVuZ3RofSBpbiBwcm9ncmFtIFwiJHt2LnByb2dyYW1JbmZvLm5hbWV9XCIuYCk7Zm9yKGxldCBUPTA7VDxmLmxlbmd0aDtUKyspe2xldCBDPWZbVF0sQT1DLnR5cGUsaz10eXBlb2YgQy5kYXRhPT1cIm51bWJlclwiPzE6Qy5kYXRhLmxlbmd0aCxbTyxNXT12LnVuaWZvcm1WYXJpYWJsZXNJbmZvW1RdO2lmKEEhPT1PfHxrIT09TSl0aHJvdyBuZXcgRXJyb3IoYFVuaWZvcm0gdmFyaWFibGUgJHtUfSBtaXNtYXRjaDogZXhwZWN0IHR5cGUgJHtPfSB3aXRoIHNpemUgJHtNfSwgZ290IHR5cGUgJHtBfSB3aXRoIHNpemUgJHtrfSBpbiBwcm9ncmFtIFwiJHt2LnByb2dyYW1JbmZvLm5hbWV9XCIuYCl9fWlmKG1lKFwiaW5mb1wiLCgpPT5gW1Byb2dyYW1NYW5hZ2VyXSBydW4gXCIke3QubmFtZX1cIiAoa2V5PSR7JH0pIHdpdGggJHt3WzBdfXgke3dbMV19eCR7d1syXX1gKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwifHx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgVD17a2VybmVsSWQ6dGhpcy5jdXJyZW50S2VybmVsSWQscHJvZ3JhbU5hbWU6di5wcm9ncmFtSW5mby5uYW1lLGlucHV0VGVuc29yVmlld3M6bixvdXRwdXRUZW5zb3JWaWV3czp5fTt0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2goVCksdGhpcy5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIiYmdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2goVCl9cmV0dXJuIHRoaXMucHJvZ3JhbU1hbmFnZXIucnVuKHYsZCxfLHcsYiksQmUodC5uYW1lKSx5fXVwbG9hZCh0LG4pe3RoaXMuZ3B1RGF0YU1hbmFnZXIudXBsb2FkKHQsbil9bWVtY3B5KHQsbil7dGhpcy5ncHVEYXRhTWFuYWdlci5tZW1jcHkodCxuKX1hc3luYyBkb3dubG9hZCh0LG4pe2F3YWl0IHRoaXMuZ3B1RGF0YU1hbmFnZXIuZG93bmxvYWQodCxuKX1hbGxvYyh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUodCkuaWR9ZnJlZSh0KXtyZXR1cm4gdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKHQpfWNyZWF0ZUtlcm5lbCh0LG4scixvKXtsZXQgYT1OYy5nZXQodCk7aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGltcGxlbWVudGVkOiAke3R9YCk7bGV0IHM9e2tlcm5lbFR5cGU6dCxrZXJuZWxOYW1lOm8sa2VybmVsRW50cnk6YVswXSxhdHRyaWJ1dGVzOlthWzFdLHJdfTt0aGlzLmtlcm5lbHMuc2V0KG4scyl9cmVsZWFzZUtlcm5lbCh0KXtsZXQgbj10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0KTtpZihuKXtmb3IobGV0IHIgb2Ygbil0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2Uoci5pZCk7dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5kZWxldGUodCl9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmRlbGV0ZSh0KSx0aGlzLmtlcm5lbHMuZGVsZXRlKHQpfWNvbXB1dGVLZXJuZWwodCxuLHIpe2xldCBvPXRoaXMua2VybmVscy5nZXQodCk7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgbm90IGNyZWF0ZWQ6ICR7dH1gKTtsZXQgYT1vLmtlcm5lbFR5cGUscz1vLmtlcm5lbE5hbWUsZD1vLmtlcm5lbEVudHJ5LGw9by5hdHRyaWJ1dGVzO2lmKHRoaXMuY3VycmVudEtlcm5lbElkIT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBcIlske2F9XSAke3N9XCIgaXMgbm90IGFsbG93ZWQgdG8gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5YCk7dGhpcy5jdXJyZW50S2VybmVsSWQ9dCxsWzBdJiYobFsxXT1sWzBdKGxbMV0pLGxbMF09dm9pZCAwKSxtZShcImluZm9cIiwoKT0+YFtXZWJHUFVdIFN0YXJ0IHRvIHJ1biBrZXJuZWwgXCJbJHthfV0gJHtzfVwiLi4uYCk7bGV0IHA9dGhpcy5lbnYuZGVidWc7dGhpcy50ZW1wb3JhcnlEYXRhPVtdO3RyeXtyZXR1cm4gcCYmdGhpcy5kZXZpY2UucHVzaEVycm9yU2NvcGUoXCJ2YWxpZGF0aW9uXCIpLGQobixsWzFdKSwwfWNhdGNoKGYpe3JldHVybiByLnB1c2goUHJvbWlzZS5yZXNvbHZlKGBbV2ViR1BVXSBLZXJuZWwgXCJbJHthfV0gJHtzfVwiIGZhaWxlZC4gJHtmfWApKSwxfWZpbmFsbHl7cCYmci5wdXNoKHRoaXMuZGV2aWNlLnBvcEVycm9yU2NvcGUoKS50aGVuKGY9PmY/YEdQVSB2YWxpZGF0aW9uIGVycm9yIGZvciBrZXJuZWwgXCJbJHthfV0gJHtzfVwiOiAke2YubWVzc2FnZX1gOm51bGwpKTtmb3IobGV0IGYgb2YgdGhpcy50ZW1wb3JhcnlEYXRhKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShmLmlkKTt0aGlzLnRlbXBvcmFyeURhdGE9W10sdGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbH19cmVnaXN0ZXJCdWZmZXIodCxuLHIsbyl7bGV0IGE9dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7YXx8KGE9bmV3IE1hcCx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLnNldCh0LGEpKTtsZXQgcz1hLmdldChuKSxkPXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihyLG8scyk7cmV0dXJuIGEuc2V0KG4sW2Qscl0pLGR9dW5yZWdpc3RlckJ1ZmZlcnModCl7bGV0IG49dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5nZXQodCk7biYmKG4uZm9yRWFjaChyPT50aGlzLmdwdURhdGFNYW5hZ2VyLnVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcihyWzBdKSksdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5kZWxldGUodCkpfWdldEJ1ZmZlcih0KXtsZXQgbj10aGlzLmdwdURhdGFNYW5hZ2VyLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBidWZmZXI6ICR7dH1gKTtyZXR1cm4gbi5idWZmZXJ9Y3JlYXRlRG93bmxvYWRlcih0LG4scil7cmV0dXJuIGFzeW5jKCk9PntsZXQgbz1hd2FpdCBubyh0aGlzLHQsbik7cmV0dXJuIE5yKG8uYnVmZmVyLHIpfX13cml0ZVRpbWVzdGFtcCh0KXt0aGlzLnF1ZXJ5VHlwZT09PVwiaW5zaWRlLXBhc3Nlc1wiJiZ0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci53cml0ZVRpbWVzdGFtcCh0aGlzLnF1ZXJ5U2V0LHQpfXNldFF1ZXJ5VHlwZSgpe3RoaXMucXVlcnlUeXBlPVwibm9uZVwiLCh0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5tb2RlPT09XCJkZWZhdWx0XCJ8fCh0eXBlb2YgdGhpcy5lbnYudHJhY2U+XCJ1XCI/dGhpcy5lbnYud2FzbS50cmFjZTp0aGlzLmVudi50cmFjZSkpJiYodGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpP3RoaXMucXVlcnlUeXBlPVwiaW5zaWRlLXBhc3Nlc1wiOnRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcInRpbWVzdGFtcC1xdWVyeVwiKSYmKHRoaXMucXVlcnlUeXBlPVwiYXQtcGFzc2VzXCIpLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnR5cGVvZiB0aGlzLnF1ZXJ5U2V0PlwidVwiJiYodGhpcy5xdWVyeVNldD10aGlzLmRldmljZS5jcmVhdGVRdWVyeVNldCh7dHlwZTpcInRpbWVzdGFtcFwiLGNvdW50OnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMn0pLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyPXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5RVUVSWV9SRVNPTFZFfSkpKX1jYXB0dXJlQmVnaW4oKXttZShcImluZm9cIixcImNhcHR1cmVCZWdpblwiKSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCl8fHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5zZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkLFtdKSx0aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiY2FwdHVyaW5nXCJ9Y2FwdHVyZUVuZCgpe21lKFwiaW5mb1wiLFwiY2FwdHVyZUVuZFwiKSx0aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwifXJlcGxheSgpe21lKFwiaW5mb1wiLFwicmVwbGF5XCIpLHRoaXMuc2Vzc2lvblN0YXR1cz1cInJlcGxheWluZ1wiO2xldCB0PXRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxuPXRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKSxyPXQubGVuZ3RoO3RoaXMucGVuZGluZ0tlcm5lbHM9W107Zm9yKGxldCBvPTA7bzxyO28rKyl7bGV0IGE9dGhpcy5nZXRDb21wdXRlUGFzc0VuY29kZXIoKSxzPXRbb107dGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKSxhLnNldFBpcGVsaW5lKHMuY29tcHV0ZVBpcGVsaW5lKSxhLnNldEJpbmRHcm91cCgwLHMuYmluZEdyb3VwKSxhLmRpc3BhdGNoV29ya2dyb3VwcyguLi5zLmRpc3BhdGNoR3JvdXApLHRoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnRoaXMucGVuZGluZ0tlcm5lbHMucHVzaChuW29dKSwodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5mbHVzaCgpfXRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5ncHVEYXRhTWFuYWdlci5vbkNyZWF0ZVNlc3Npb24oKX1vblJlbGVhc2VTZXNzaW9uKHQpe3RoaXMudW5yZWdpc3RlckJ1ZmZlcnModCksdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0Lmhhcyh0KSYmdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmRlbGV0ZSh0KSx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZGVsZXRlKHQpLHRoaXMuZ3B1RGF0YU1hbmFnZXIub25SZWxlYXNlU2Vzc2lvbih0KX1vblJ1blN0YXJ0KHQpe3RoaXMuY3VycmVudFNlc3Npb25JZD10LHRoaXMuc2V0UXVlcnlUeXBlKCl9fX0pO3ZhciBYeSxHYyxKeSxIYyxzbix1bixrbyxGYyxxYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dHQoKTtYeT0xLEdjPSgpPT5YeSsrLEp5PW5ldyBNYXAoW1tcImZsb2F0MzJcIiwzMl0sW1wiZmxvYXQxNlwiLDE2XSxbXCJpbnQzMlwiLDMyXSxbXCJ1aW50MzJcIiwzMl0sW1wiaW50NjRcIiw2NF0sW1widWludDY0XCIsNjRdLFtcImludDhcIiw4XSxbXCJ1aW50OFwiLDhdLFtcImludDRcIiw0XSxbXCJ1aW50NFwiLDRdXSksSGM9KGUsdCk9PntsZXQgbj1KeS5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlLlwiKTtyZXR1cm4gdC5sZW5ndGg+MD9NYXRoLmNlaWwodC5yZWR1Y2UoKHIsbyk9PnIqbykqbi84KTowfSxzbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlc3Npb25JZD10LnNlc3Npb25JZCx0aGlzLm1sQ29udGV4dD10LmNvbnRleHQsdGhpcy5tbFRlbnNvcj10LnRlbnNvcix0aGlzLmRhdGFUeXBlPXQuZGF0YVR5cGUsdGhpcy50ZW5zb3JTaGFwZT10LnNoYXBlfWdldCB0ZW5zb3IoKXtyZXR1cm4gdGhpcy5tbFRlbnNvcn1nZXQgdHlwZSgpe3JldHVybiB0aGlzLmRhdGFUeXBlfWdldCBzaGFwZSgpe3JldHVybiB0aGlzLnRlbnNvclNoYXBlfWdldCBieXRlTGVuZ3RoKCl7cmV0dXJuIEhjKHRoaXMuZGF0YVR5cGUsdGhpcy50ZW5zb3JTaGFwZSl9ZGVzdHJveSgpe21lKFwidmVyYm9zZVwiLCgpPT5cIltXZWJOTl0gVGVuc29yV3JhcHBlci5kZXN0cm95XCIpLHRoaXMubWxUZW5zb3IuZGVzdHJveSgpfXdyaXRlKHQpe3RoaXMubWxDb250ZXh0LndyaXRlVGVuc29yKHRoaXMubWxUZW5zb3IsdCl9YXN5bmMgcmVhZCh0KXtyZXR1cm4gdD90aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IsdCk6dGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yKX1jYW5SZXVzZVRlbnNvcih0LG4scil7cmV0dXJuIHRoaXMubWxDb250ZXh0PT09dCYmdGhpcy5kYXRhVHlwZT09PW4mJnRoaXMudGVuc29yU2hhcGUubGVuZ3RoPT09ci5sZW5ndGgmJnRoaXMudGVuc29yU2hhcGUuZXZlcnkoKG8sYSk9Pm89PT1yW2FdKX19LHVuPWNsYXNze2NvbnN0cnVjdG9yKHQsbil7dGhpcy50ZW5zb3JNYW5hZ2VyPXQ7dGhpcy53cmFwcGVyPW59Z2V0IHRlbnNvcldyYXBwZXIoKXtyZXR1cm4gdGhpcy53cmFwcGVyfXJlbGVhc2VUZW5zb3IoKXt0aGlzLnRlbnNvcldyYXBwZXImJih0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLnRlbnNvcldyYXBwZXIpLHRoaXMud3JhcHBlcj12b2lkIDApfWFzeW5jIGVuc3VyZVRlbnNvcih0LG4scixvKXtsZXQgYT10aGlzLnRlbnNvck1hbmFnZXIuZ2V0TUxDb250ZXh0KHQpO2lmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKGEsbixyKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PUhjKG4scikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgcz10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHQsbixyLHMsITAsITApLG8mJnRoaXMuYWN0aXZlVXBsb2FkJiYodGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKSx0aGlzLmFjdGl2ZVVwbG9hZD12b2lkIDApLHRoaXMud3JhcHBlci50ZW5zb3J9dXBsb2FkKHQpe2lmKHRoaXMud3JhcHBlcilpZih0LmJ5dGVMZW5ndGg9PT10aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCl7dGhpcy53cmFwcGVyLndyaXRlKHQpO3JldHVybn1lbHNlIG1lKFwidmVyYm9zZVwiLCgpPT5cIkRhdGEgc2l6ZSBkb2VzIG5vdCBtYXRjaCB0ZW5zb3Igc2l6ZS4gUmVsZWFzaW5nIHRlbnNvci5cIiksdGhpcy5yZWxlYXNlVGVuc29yKCk7dGhpcy5hY3RpdmVVcGxvYWQ/dGhpcy5hY3RpdmVVcGxvYWQuc2V0KHQpOnRoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KHQpfWFzeW5jIGRvd25sb2FkKHQpe2lmKHRoaXMuYWN0aXZlVXBsb2FkKWlmKHQpe3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9uZXcgVWludDhBcnJheSh0KS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpOm5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldCh0aGlzLmFjdGl2ZVVwbG9hZCk7cmV0dXJufWVsc2UgcmV0dXJuIHRoaXMuYWN0aXZlVXBsb2FkLmJ1ZmZlcjtpZighdGhpcy53cmFwcGVyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBoYXMgbm90IGJlZW4gY3JlYXRlZC5cIik7cmV0dXJuIHQ/dGhpcy53cmFwcGVyLnJlYWQodCk6dGhpcy53cmFwcGVyLnJlYWQoKX19LGtvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMudGVuc29yVHJhY2tlcnNCeUlkPW5ldyBNYXA7dGhpcy5mcmVlVGVuc29ycz1bXTt0aGlzLmV4dGVybmFsVGVuc29ycz1uZXcgU2V0fWdldE1MQ29udGV4dCh0KXtsZXQgbj10aGlzLmJhY2tlbmQuZ2V0TUxDb250ZXh0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIk1MQ29udGV4dCBub3QgZm91bmQgZm9yIHNlc3Npb24uXCIpO3JldHVybiBufXJlc2VydmVUZW5zb3JJZCgpe2xldCB0PUdjKCk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0LG5ldyB1bih0aGlzKSksdH1yZWxlYXNlVGVuc29ySWQodCl7bGV0IG49dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO24mJih0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5kZWxldGUodCksbi50ZW5zb3JXcmFwcGVyJiZ0aGlzLnJlbGVhc2VUZW5zb3Iobi50ZW5zb3JXcmFwcGVyKSl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8sYSl7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yIHt0ZW5zb3JJZDogJHtufSwgZGF0YVR5cGU6ICR7cn0sIHNoYXBlOiAke299LCBjb3B5T2xkOiAke2F9fWApO2xldCBzPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldChuKTtpZighcyl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gcy5lbnN1cmVUZW5zb3IodCxyLG8sYSl9dXBsb2FkKHQsbil7bGV0IHI9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3IudXBsb2FkKG4pfWFzeW5jIGRvd25sb2FkKHQsbil7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3R9LCBkc3RCdWZmZXI6ICR7bj8uYnl0ZUxlbmd0aH19YCk7bGV0IHI9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiByLmRvd25sb2FkKG4pfXJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KXtmb3IobGV0IG4gb2YgdGhpcy5mcmVlVGVuc29ycyluLnNlc3Npb25JZD09PXQmJm4uZGVzdHJveSgpO3RoaXMuZnJlZVRlbnNvcnM9dGhpcy5mcmVlVGVuc29ycy5maWx0ZXIobj0+bi5zZXNzaW9uSWQhPT10KX1yZWdpc3RlclRlbnNvcih0LG4scixvKXtsZXQgYT10aGlzLmdldE1MQ29udGV4dCh0KSxzPUdjKCksZD1uZXcgc24oe3Nlc3Npb25JZDp0LGNvbnRleHQ6YSx0ZW5zb3I6bixkYXRhVHlwZTpyLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHMsbmV3IHVuKHRoaXMsZCkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChkKSxzfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LG4scixvLGEscyl7bGV0IGQ9dGhpcy5nZXRNTENvbnRleHQodCk7Zm9yKGxldFtwLGZdb2YgdGhpcy5mcmVlVGVuc29ycy5lbnRyaWVzKCkpaWYoZi5jYW5SZXVzZVRlbnNvcihkLG4scikpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBSZXVzaW5nIHRlbnNvciB7ZGF0YVR5cGU6ICR7bn0sIHNoYXBlOiAke3J9fWApO2xldCBoPXRoaXMuZnJlZVRlbnNvcnMuc3BsaWNlKHAsMSlbMF07cmV0dXJuIGguc2Vzc2lvbklkPXQsaH1tZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gTUxDb250ZXh0LmNyZWF0ZVRlbnNvciB7ZGF0YVR5cGU6ICR7bn0sIHNoYXBlOiAke3J9fWApO2xldCBsPWF3YWl0IGQuY3JlYXRlVGVuc29yKHtkYXRhVHlwZTpuLHNoYXBlOnIsZGltZW5zaW9uczpyLHVzYWdlOm8sd3JpdGFibGU6YSxyZWFkYWJsZTpzfSk7cmV0dXJuIG5ldyBzbih7c2Vzc2lvbklkOnQsY29udGV4dDpkLHRlbnNvcjpsLGRhdGFUeXBlOm4sc2hhcGU6cn0pfXJlbGVhc2VUZW5zb3IodCl7dGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHQpJiZ0aGlzLmV4dGVybmFsVGVuc29ycy5kZWxldGUodCksdGhpcy5mcmVlVGVuc29ycy5wdXNoKHQpfX0sRmM9KC4uLmUpPT5uZXcga28oLi4uZSl9KTt2YXIgRW8sZWIsZG4sS2M9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YnQoKTtKbigpO3FjKCk7dHQoKTtFbz1uZXcgTWFwKFtbMSxcImZsb2F0MzJcIl0sWzEwLFwiZmxvYXQxNlwiXSxbNixcImludDMyXCJdLFsxMixcInVpbnQzMlwiXSxbNyxcImludDY0XCJdLFsxMyxcInVpbnQ2NFwiXSxbMjIsXCJpbnQ0XCJdLFsyMSxcInVpbnQ0XCJdLFszLFwiaW50OFwiXSxbMixcInVpbnQ4XCJdLFs5LFwidWludDhcIl1dKSxlYj0oZSx0KT0+e2lmKGU9PT10KXJldHVybiEwO2lmKGU9PT12b2lkIDB8fHQ9PT12b2lkIDApcmV0dXJuITE7bGV0IG49T2JqZWN0LmtleXMoZSkuc29ydCgpLHI9T2JqZWN0LmtleXModCkuc29ydCgpO3JldHVybiBuLmxlbmd0aD09PXIubGVuZ3RoJiZuLmV2ZXJ5KChvLGEpPT5vPT09clthXSYmZVtvXT09PXRbb10pfSxkbj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRlbnNvck1hbmFnZXI9RmModGhpcyk7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZD1uZXcgTWFwO3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0PW5ldyBNYXA7dGhpcy5tbENvbnRleHRDYWNoZT1bXTt0aGlzLnNlc3Npb25HcmFwaElucHV0cz1uZXcgTWFwO3RoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHM9W107dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzPW5ldyBNYXA7VXIodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIG9uUnVuU3RhcnQge3Nlc3Npb25JZDogJHt0fX1gKSx0aGlzLmFjdGl2ZVNlc3Npb25JZD10fW9uUnVuRW5kKHQpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBvblJ1bkVuZCB7c2Vzc2lvbklkOiAke3R9fWApO2xldCBuPXRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5nZXQodCk7aWYobil7Zm9yKGxldCByIG9mIG4pbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlbGVhc2luZyB0ZW1wb3JhcnkgdGVuc29yIHt0ZW5zb3JJZDogJHtyfX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHIpO3RoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5kZWxldGUodCksdGhpcy5hY3RpdmVTZXNzaW9uSWQ9dm9pZCAwfX1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCBuPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KHI9PmViKHIub3B0aW9ucyx0KSk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IHI9YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpyfSkscn19cmVnaXN0ZXJNTENvbnRleHQodCxuKXt0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLnNldCh0LG4pO2xldCByPXRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmdldChuKTtyfHwocj1uZXcgU2V0LHRoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LnNldChuLHIpKSxyLmFkZCh0KSx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLmxlbmd0aD4wJiYodGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuc2V0KHQsdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cyksdGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cz1bXSl9b25SZWxlYXNlU2Vzc2lvbih0KXt0aGlzLnNlc3Npb25HcmFwaElucHV0cy5kZWxldGUodCk7bGV0IG49dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIW4pcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IHI9dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG4pO2lmKHIuZGVsZXRlKHQpLHIuc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShuKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChhPT5hLm1sQ29udGV4dD09PW4pO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LG4scixvLGEpe2xldCBzPUVvLmdldChyKTtpZighcyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodD8/dGhpcy5jdXJyZW50U2Vzc2lvbklkLG4scyxvLGEpfWFzeW5jIGNyZWF0ZVRlbXBvcmFyeVRlbnNvcih0LG4scil7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIGNyZWF0ZVRlbXBvcmFyeVRlbnNvciB7b25ueERhdGFUeXBlOiAke259LCBzaGFwZTogJHtyfX1gKTtsZXQgbz1Fby5nZXQobik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtufWApO2xldCBhPXRoaXMudGVuc29yTWFuYWdlci5yZXNlcnZlVGVuc29ySWQoKTthd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQsYSxvLHIsITEpO2xldCBzPXRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5nZXQodCk7cmV0dXJuIHM/cy5wdXNoKGEpOnRoaXMudGVtcG9yYXJ5U2Vzc2lvblRlbnNvcklkcy5zZXQodCxbYV0pLGF9dXBsb2FkVGVuc29yKHQsbil7aWYoIUllKCkuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKXRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGxvYWQgdG8gYSBNTFRlbnNvciB3aGlsZSBzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgaXMgZmFsc2VcIik7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHVwbG9hZFRlbnNvciB7dGVuc29ySWQ6ICR7dH0sIGRhdGE6ICR7bi5ieXRlTGVuZ3RofX1gKSx0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHQsbil9YXN5bmMgZG93bmxvYWRUZW5zb3IodCxuKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQsbil9Y3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHQsbil7cmV0dXJuIGFzeW5jKCk9PntsZXQgcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodCk7cmV0dXJuIE5yKHIsbil9fXJlZ2lzdGVyTUxUZW5zb3IodCxuLHIsbyl7bGV0IGE9RW8uZ2V0KHIpO2lmKCFhKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7cn1gKTtsZXQgcz10aGlzLnRlbnNvck1hbmFnZXIucmVnaXN0ZXJUZW5zb3IodCxuLGEsbyk7cmV0dXJuIG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWdpc3Rlck1MVGVuc29yIHt0ZW5zb3I6ICR7bn0sIGRhdGFUeXBlOiAke2F9LCBkaW1lbnNpb25zOiAke299fSAtPiB7dGVuc29ySWQ6ICR7c319YCksc31yZWdpc3Rlck1MQ29uc3RhbnQodCxuLHIsbyxhLHMpe2lmKCFzKXRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsIG1vdW50ZWQgZmlsZXMgYXJlIG5vdCBhdmFpbGFibGUuXCIpO2xldCBkPXQ7dC5zdGFydHNXaXRoKFwiLi9cIikmJihkPXQuc3Vic3RyaW5nKDIpKTtsZXQgbD1zLmdldChkKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYEZpbGUgd2l0aCBuYW1lICR7ZH0gbm90IGZvdW5kIGluIHByZWxvYWRlZCBmaWxlcy5gKTtpZihuK3I+bC5ieXRlTGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk91dCBvZiBib3VuZHM6IGRhdGEgb2Zmc2V0IGFuZCBsZW5ndGggZXhjZWVkIHRoZSBleHRlcm5hbCBmaWxlIGRhdGEgc2l6ZS5cIik7bGV0IHA9bC5zbGljZShuLG4rcikuYnVmZmVyLGY7c3dpdGNoKGEuZGF0YVR5cGUpe2Nhc2VcImZsb2F0MzJcIjpmPW5ldyBGbG9hdDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwiZmxvYXQxNlwiOmY9bmV3IFVpbnQxNkFycmF5KHApO2JyZWFrO2Nhc2VcImludDMyXCI6Zj1uZXcgSW50MzJBcnJheShwKTticmVhaztjYXNlXCJ1aW50MzJcIjpmPW5ldyBVaW50MzJBcnJheShwKTticmVhaztjYXNlXCJpbnQ2NFwiOmY9bmV3IEJpZ0ludDY0QXJyYXkocCk7YnJlYWs7Y2FzZVwidWludDY0XCI6Zj1uZXcgQmlnVWludDY0QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50OFwiOmY9bmV3IEludDhBcnJheShwKTticmVhaztjYXNlXCJpbnQ0XCI6Y2FzZVwidWludDRcIjpjYXNlXCJ1aW50OFwiOmY9bmV3IFVpbnQ4QXJyYXkocCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHthLmRhdGFUeXBlfSBpbiBjcmVhdGluZyBXZWJOTiBDb25zdGFudCBmcm9tIGV4dGVybmFsIGRhdGEuYCl9cmV0dXJuIG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWdpc3Rlck1MQ29uc3RhbnQge2RhdGFUeXBlOiAke2EuZGF0YVR5cGV9LCBzaGFwZTogJHthLnNoYXBlfX19YCksby5jb25zdGFudChhLGYpfXJlZ2lzdGVyR3JhcGhJbnB1dCh0KXt0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzLnB1c2godCl9aXNHcmFwaElucHV0KHQsbil7bGV0IHI9dGhpcy5zZXNzaW9uR3JhcGhJbnB1dHMuZ2V0KHQpO3JldHVybiByP3IuaW5jbHVkZXMobik6ITF9Zmx1c2goKXt9fX0pO3ZhciBqYz17fTtadChqYyx7aW5pdDooKT0+dGJ9KTt2YXIgaXIsUG8sdGIsWmM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7TGMoKTt0dCgpO2FlKCk7S2MoKTtpcj1jbGFzcyBle2NvbnN0cnVjdG9yKHQsbixyLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1uO3RoaXMuZGF0YT1yO3RoaXMuZGltcz1vfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUUuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9RS5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUUuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldFVpbnQxNkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEwJiZ0aGlzLmRhdGFUeXBlIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1FLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IFVpbnQxNkFycmF5Om5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoRS5zaXplKHQpIT09RS5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sUG89Y2xhc3N7Y29uc3RydWN0b3IodCxuLHIpe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPW47dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO3RoaXMuYWRhcHRlckluZm89bi5hZGFwdGVySW5mbyx0aGlzLmRldmljZUluZm89bi5kZXZpY2VJbmZvO2xldCBvPXQuUFRSX1NJWkUsYT1yL3QuUFRSX1NJWkUscz1vPT09ND9cImkzMlwiOlwiaTY0XCI7dGhpcy5vcEtlcm5lbENvbnRleHQ9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpO2xldCBkPU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKTt0aGlzLm91dHB1dENvdW50PU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9TnVtYmVyKHQuZ2V0VmFsdWUobyphKyssXCIqXCIpKSx0aGlzLmN1c3RvbURhdGFTaXplPU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKTtsZXQgbD1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtsZXQgZj1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSksaD1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxcIipcIikpLHk9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpLF89W107Zm9yKGxldCBiPTA7Yjx5O2IrKylfLnB1c2goTnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpKTtsLnB1c2gobmV3IGlyKHQsZixoLF8pKX10aGlzLmlucHV0cz1sfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQsbil7bGV0IHI9bj8uaW5wdXRzPy5tYXAoZD0+dHlwZW9mIGQ9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbZF06ZCk/P3RoaXMuaW5wdXRzLG89bj8ub3V0cHV0cz8/W10sYT0oZCxsLHApPT5uZXcgaXIodGhpcy5tb2R1bGUsbCx0aGlzLm91dHB1dChkLHApLHApLHM9KGQsbCk9PntsZXQgcD13dChkLGwpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2R9YCk7bGV0IGY9cD4wP3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUocCkuaWQ6MDtyZXR1cm4gbmV3IGlyKHRoaXMubW9kdWxlLGQsZixsKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxyLG8sYSxzLHRoaXMub3V0cHV0Q291bnQpfW91dHB1dCh0LG4pe2xldCByPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10aGlzLm1vZHVsZS5QVFJfU0laRSxhPW89PT00P1wiaTMyXCI6XCJpNjRcIixzPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErbi5sZW5ndGgpKm8pO3RoaXMubW9kdWxlLnNldFZhbHVlKHMsbi5sZW5ndGgsYSk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspdGhpcy5tb2R1bGUuc2V0VmFsdWUocytvKihkKzEpLG5bZF0sYSk7cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQscyl9Y2F0Y2gobyl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtufV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtvfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKHIpfX19LHRiPWFzeW5jKGUsdCxuLHIpPT57bGV0IG89dC5qc2VwSW5pdDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC5cIik7aWYoZT09PVwid2ViZ3B1XCIpe2xldCBhPW5ldyBhbjthd2FpdCBhLmluaXRpYWxpemUobixyKSxvKFwid2ViZ3B1XCIsW2Escz0+YS5hbGxvYyhOdW1iZXIocykpLHM9PmEuZnJlZShzKSwocyxkLGwscD0hMSk9PntpZihwKW1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7TnVtYmVyKHMpfSwgZHN0PSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKSxhLm1lbWNweShOdW1iZXIocyksTnVtYmVyKGQpKTtlbHNle21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke051bWJlcihzKX0sIGdwdURhdGFJZD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCk7bGV0IGY9dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKHM+Pj4wKSxOdW1iZXIocz4+PjApK051bWJlcihsKSk7YS51cGxvYWQoTnVtYmVyKGQpLGYpfX0sYXN5bmMocyxkLGwpPT57bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHtzfSwgZGF0YU9mZnNldD0ke2R9LCBzaXplPSR7bH1gKSxhd2FpdCBhLmRvd25sb2FkKE51bWJlcihzKSwoKT0+dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGQpPj4+MCxOdW1iZXIoZCtsKT4+PjApKX0sKHMsZCxsKT0+YS5jcmVhdGVLZXJuZWwocyxOdW1iZXIoZCksbCx0LlVURjhUb1N0cmluZyh0Ll9Kc2VwR2V0Tm9kZU5hbWUoTnVtYmVyKGQpKSkpLHM9PmEucmVsZWFzZUtlcm5lbChzKSwocyxkLGwscCk9PnttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtsfSwga2VybmVsPSR7c30sIGNvbnRleHREYXRhT2Zmc2V0PSR7ZH1gKTtsZXQgZj1uZXcgUG8odCxhLE51bWJlcihkKSk7cmV0dXJuIGEuY29tcHV0ZUtlcm5lbChOdW1iZXIocyksZixwKX0sKCk9PmEuY2FwdHVyZUJlZ2luKCksKCk9PmEuY2FwdHVyZUVuZCgpLCgpPT5hLnJlcGxheSgpXSl9ZWxzZXtsZXQgYT1uZXcgZG4obik7byhcIndlYm5uXCIsW2EsKCk9PmEucmVzZXJ2ZVRlbnNvcklkKCkscz0+YS5yZWxlYXNlVGVuc29ySWQocyksYXN5bmMocyxkLGwscCxmKT0+YS5lbnN1cmVUZW5zb3IocyxkLGwscCxmKSwocyxkKT0+e2EudXBsb2FkVGVuc29yKHMsZCl9LGFzeW5jKHMsZCk9PmEuZG93bmxvYWRUZW5zb3IocyxkKV0pfX19KTt2YXIgcmIsQ3IsSXIsenQsbmIsWXQsQXIsa3IsUWMsRXIsUHIsenIscW49RygoKT0+e1widXNlIHN0cmljdFwiO3pzKCk7RHMoKTt0ZSgpO2J0KCk7RHIoKTtYbigpO3JiPShlLHQpPT57SWUoKS5fT3J0SW5pdChlLHQpIT09MCYmaGUoXCJDYW4ndCBpbml0aWFsaXplIG9ubnhydW50aW1lLlwiKX0sQ3I9YXN5bmMgZT0+e3JiKGUud2FzbS5udW1UaHJlYWRzLEp0KGUubG9nTGV2ZWwpKX0sSXI9YXN5bmMoZSx0KT0+e3tsZXQgbj0oWmMoKSxicihqYykpLmluaXQ7aWYodD09PVwid2ViZ3B1XCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IuZ3B1KXRocm93IG5ldyBFcnJvcihcIldlYkdQVSBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7bGV0IHI9ZS53ZWJncHUuYWRhcHRlcjtpZihyKXtpZih0eXBlb2Ygci5saW1pdHMhPVwib2JqZWN0XCJ8fHR5cGVvZiByLmZlYXR1cmVzIT1cIm9iamVjdFwifHx0eXBlb2Ygci5yZXF1ZXN0RGV2aWNlIT1cImZ1bmN0aW9uXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHUFUgYWRhcHRlciBzZXQgaW4gYGVudi53ZWJncHUuYWRhcHRlcmAuIEl0IG11c3QgYmUgYSBHUFVBZGFwdGVyIG9iamVjdC5cIil9ZWxzZXtsZXQgbz1lLndlYmdwdS5wb3dlclByZWZlcmVuY2U7aWYobyE9PXZvaWQgMCYmbyE9PVwibG93LXBvd2VyXCImJm8hPT1cImhpZ2gtcGVyZm9ybWFuY2VcIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcG93ZXJQcmVmZXJlbmNlIHNldHRpbmc6IFwiJHtvfVwiYCk7bGV0IGE9ZS53ZWJncHUuZm9yY2VGYWxsYmFja0FkYXB0ZXI7aWYoYSE9PXZvaWQgMCYmdHlwZW9mIGEhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmb3JjZUZhbGxiYWNrQWRhcHRlciBzZXR0aW5nOiBcIiR7YX1cImApO2lmKHI9YXdhaXQgbmF2aWdhdG9yLmdwdS5yZXF1ZXN0QWRhcHRlcih7cG93ZXJQcmVmZXJlbmNlOm8sZm9yY2VGYWxsYmFja0FkYXB0ZXI6YX0pLCFyKXRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBHUFUgYWRhcHRlci4gWW91IG1heSBuZWVkIHRvIGVuYWJsZSBmbGFnIFwiLS1lbmFibGUtdW5zYWZlLXdlYmdwdVwiIGlmIHlvdSBhcmUgdXNpbmcgQ2hyb21lLicpfWF3YWl0IG4oXCJ3ZWJncHVcIixJZSgpLGUscil9aWYodD09PVwid2Vibm5cIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5tbCl0aHJvdyBuZXcgRXJyb3IoXCJXZWJOTiBpcyBub3Qgc3VwcG9ydGVkIGluIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7YXdhaXQgbihcIndlYm5uXCIsSWUoKSxlKX19fSx6dD1uZXcgTWFwLG5iPWU9PntsZXQgdD1JZSgpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHI9dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKnIpO3QuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxvLG8rcikhPT0wJiZoZShcIkNhbid0IGdldCBzZXNzaW9uIGlucHV0L291dHB1dCBjb3VudC5cIik7bGV0IHM9cj09PTQ/XCJpMzJcIjpcImk2NFwiO3JldHVybltOdW1iZXIodC5nZXRWYWx1ZShvLHMpKSxOdW1iZXIodC5nZXRWYWx1ZShvK3IscykpXX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKG4pfX0sWXQ9ZT0+e2xldCB0PUllKCksbj10Ll9tYWxsb2MoZS5ieXRlTGVuZ3RoKTtpZihuPT09MCl0aHJvdyBuZXcgRXJyb3IoYENhbid0IGNyZWF0ZSBhIHNlc3Npb24uIGZhaWxlZCB0byBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBzaXplICR7ZS5ieXRlTGVuZ3RofS5gKTtyZXR1cm4gdC5IRUFQVTguc2V0KGUsbiksW24sZS5ieXRlTGVuZ3RoXX0sQXI9YXN5bmMoZSx0KT0+e2xldCBuLHIsbz1JZSgpO0FycmF5LmlzQXJyYXkoZSk/W24scl09ZTplLmJ1ZmZlcj09PW8uSEVBUFU4LmJ1ZmZlcj9bbixyXT1bZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aF06W24scl09WXQoZSk7bGV0IGE9MCxzPTAsZD0wLGw9W10scD1bXSxmPVtdO3RyeXtpZihbcyxsXT1Pcyh0KSx0Py5leHRlcm5hbERhdGEmJm8ubW91bnRFeHRlcm5hbERhdGEpe2xldCB2PVtdO2ZvcihsZXQgVCBvZiB0LmV4dGVybmFsRGF0YSl7bGV0IEM9dHlwZW9mIFQ9PVwic3RyaW5nXCI/VDpULnBhdGg7di5wdXNoKGVyKHR5cGVvZiBUPT1cInN0cmluZ1wiP1Q6VC5kYXRhKS50aGVuKEE9PntvLm1vdW50RXh0ZXJuYWxEYXRhKEMsQSl9KSl9YXdhaXQgUHJvbWlzZS5hbGwodil9Zm9yKGxldCB2IG9mIHQ/LmV4ZWN1dGlvblByb3ZpZGVycz8/W10paWYoKHR5cGVvZiB2PT1cInN0cmluZ1wiP3Y6di5uYW1lKT09PVwid2Vibm5cIil7aWYoby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITEsdHlwZW9mIHYhPVwic3RyaW5nXCIpe2xldCBDPXYsQT1DPy5jb250ZXh0LGs9Qz8uZ3B1RGV2aWNlLE89Qz8uZGV2aWNlVHlwZSxNPUM/LnBvd2VyUHJlZmVyZW5jZTtBP28uY3VycmVudENvbnRleHQ9QTprP28uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KGspOm8uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KHtkZXZpY2VUeXBlOk8scG93ZXJQcmVmZXJlbmNlOk19KX1lbHNlIG8uY3VycmVudENvbnRleHQ9YXdhaXQgby5qc2VwQ3JlYXRlTUxDb250ZXh0KCk7YnJlYWt9YT1hd2FpdCBvLl9PcnRDcmVhdGVTZXNzaW9uKG4scixzKSxhPT09MCYmaGUoXCJDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLlwiKSxvLmpzZXBPbkNyZWF0ZVNlc3Npb24/LigpLG8uY3VycmVudENvbnRleHQmJihvLmpzZXBSZWdpc3Rlck1MQ29udGV4dChhLG8uY3VycmVudENvbnRleHQpLG8uY3VycmVudENvbnRleHQ9dm9pZCAwLG8uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSEwKTtsZXRbaCx5XT1uYihhKSxfPSEhdD8uZW5hYmxlR3JhcGhDYXB0dXJlLGI9W10sdz1bXSxTPVtdO2ZvcihsZXQgdj0wO3Y8aDt2Kyspe2xldCBUPW8uX09ydEdldElucHV0TmFtZShhLHYpO1Q9PT0wJiZoZShcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxwLnB1c2goVCksYi5wdXNoKG8uVVRGOFRvU3RyaW5nKFQpKX1mb3IobGV0IHY9MDt2PHk7disrKXtsZXQgVD1vLl9PcnRHZXRPdXRwdXROYW1lKGEsdik7VD09PTAmJmhlKFwiQ2FuJ3QgZ2V0IGFuIG91dHB1dCBuYW1lLlwiKSxmLnB1c2goVCk7bGV0IEM9by5VVEY4VG9TdHJpbmcoVCk7dy5wdXNoKEMpO3tpZihfJiZ0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09PXZvaWQgMCl7Uy5wdXNoKFwiZ3B1LWJ1ZmZlclwiKTtjb250aW51ZX1sZXQgQT10eXBlb2YgdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PVwic3RyaW5nXCI/dC5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbjp0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj8uW0NdPz9cImNwdVwiO2lmKEEhPT1cImNwdVwiJiZBIT09XCJjcHUtcGlubmVkXCImJkEhPT1cImdwdS1idWZmZXJcIiYmQSE9PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uYCk7aWYoXyYmQSE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke0F9LiBPbmx5ICdncHUtYnVmZmVyJyBsb2NhdGlvbiBpcyBzdXBwb3J0ZWQgd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtTLnB1c2goQSl9fWxldCAkPW51bGw7cmV0dXJuIFMuc29tZSh2PT52PT09XCJncHUtYnVmZmVyXCJ8fHY9PT1cIm1sLXRlbnNvclwiKSYmKGQ9by5fT3J0Q3JlYXRlQmluZGluZyhhKSxkPT09MCYmaGUoXCJDYW4ndCBjcmVhdGUgSU8gYmluZGluZy5cIiksJD17aGFuZGxlOmQsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOlMsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpTLm1hcCh2PT5Zbih2KSl9KSx6dC5zZXQoYSxbYSxwLGYsJCxfLCExXSksW2EsYix3XX1jYXRjaChoKXt0aHJvdyBwLmZvckVhY2goeT0+by5fT3J0RnJlZSh5KSksZi5mb3JFYWNoKHk9Pm8uX09ydEZyZWUoeSkpLGQhPT0wJiZvLl9PcnRSZWxlYXNlQmluZGluZyhkKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKSxhIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb24oYSkhPT0wJiZoZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksaH1maW5hbGx5e28uX2ZyZWUobikscyE9PTAmJm8uX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucyhzKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLGwuZm9yRWFjaChoPT5vLl9mcmVlKGgpKSxvLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0sa3I9ZT0+e2xldCB0PUllKCksbj16dC5nZXQoZSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVsZWFzZSBzZXNzaW9uLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXRbcixvLGEscyxkXT1uO3MmJihkJiZ0Ll9PcnRDbGVhckJvdW5kT3V0cHV0cyhzLmhhbmRsZSkhPT0wJiZoZShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHQuX09ydFJlbGVhc2VCaW5kaW5nKHMuaGFuZGxlKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBJTyBiaW5kaW5nLlwiKSksdC5qc2VwT25SZWxlYXNlU2Vzc2lvbj8uKGUpLG8uZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSxhLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSksdC5fT3J0UmVsZWFzZVNlc3Npb24ocikhPT0wJiZoZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbi5cIiksenQuZGVsZXRlKGUpfSxRYz1hc3luYyhlLHQsbixyLG8sYT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgcz1JZSgpLGQ9cy5QVFJfU0laRSxsPWVbMF0scD1lWzFdLGY9ZVszXSxoPWYseSxfO2lmKGw9PT1cInN0cmluZ1wiJiYoZj09PVwiZ3B1LWJ1ZmZlclwifHxmPT09XCJtbC10ZW5zb3JcIikpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7aWYoYSYmZiE9PVwiZ3B1LWJ1ZmZlclwiKXRocm93IG5ldyBFcnJvcihgRXh0ZXJuYWwgYnVmZmVyIG11c3QgYmUgcHJvdmlkZWQgZm9yIGlucHV0L291dHB1dCBpbmRleCAke299IHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7aWYoZj09PVwiZ3B1LWJ1ZmZlclwiKXtsZXQgUz1lWzJdLmdwdUJ1ZmZlcjtfPXd0KFJ0KGwpLHApO2xldCAkPXMuanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCEkKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7eT0kKHIsbyxTLF8pfWVsc2UgaWYoZj09PVwibWwtdGVuc29yXCIpe2xldCBTPWVbMl0ubWxUZW5zb3I7Xz13dChSdChsKSxwKTtsZXQgJD1zLmpzZXBSZWdpc3Rlck1MVGVuc29yO2lmKCEkKXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO3k9JChyLFMsUnQobCkscCl9ZWxzZXtsZXQgUz1lWzJdO2lmKEFycmF5LmlzQXJyYXkoUykpe189ZCpTLmxlbmd0aCx5PXMuX21hbGxvYyhfKSxuLnB1c2goeSk7Zm9yKGxldCAkPTA7JDxTLmxlbmd0aDskKyspe2lmKHR5cGVvZiBTWyRdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7JH0gaXMgbm90IGEgc3RyaW5nYCk7cy5zZXRWYWx1ZSh5KyQqZCxQZShTWyRdLG4pLFwiKlwiKX19ZWxzZXtsZXQgJD1zLmpzZXBJc0dyYXBoSW5wdXQ7aWYobCE9PVwic3RyaW5nXCImJiQpe2xldCB2PXMuX09ydEdldElucHV0TmFtZShyLG8pLFQ9cy5VVEY4VG9TdHJpbmcodik7aWYoJChyLFQpKXtsZXQgQz1SdChsKTtfPXd0KEMscCksaD1cIm1sLXRlbnNvclwiO2xldCBBPXMuanNlcENyZWF0ZVRlbXBvcmFyeVRlbnNvcixrPXMuanNlcFVwbG9hZFRlbnNvcjtpZighQXx8IWspdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7bGV0IE89YXdhaXQgQShyLEMscCk7ayhPLG5ldyBVaW50OEFycmF5KFMuYnVmZmVyLFMuYnl0ZU9mZnNldCxTLmJ5dGVMZW5ndGgpKSx5PU99ZWxzZSBfPVMuYnl0ZUxlbmd0aCx5PXMuX21hbGxvYyhfKSxuLnB1c2goeSkscy5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KFMuYnVmZmVyLFMuYnl0ZU9mZnNldCxfKSx5KX1lbHNlIF89Uy5ieXRlTGVuZ3RoLHk9cy5fbWFsbG9jKF8pLG4ucHVzaCh5KSxzLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoUy5idWZmZXIsUy5ieXRlT2Zmc2V0LF8pLHkpfX1sZXQgYj1zLnN0YWNrU2F2ZSgpLHc9cy5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtwLmZvckVhY2goKCQsdik9PnMuc2V0VmFsdWUodyt2KmQsJCxkPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgUz1zLl9PcnRDcmVhdGVUZW5zb3IoUnQobCkseSxfLHcscC5sZW5ndGgsWW4oaCkpO1M9PT0wJiZoZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7cn0sIGluZGV4PSR7b30uYCksdC5wdXNoKFMpfWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoYil9fSxFcj1hc3luYyhlLHQsbixyLG8sYSk9PntsZXQgcz1JZSgpLGQ9cy5QVFJfU0laRSxsPXp0LmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgcD1sWzBdLGY9bFsxXSxoPWxbMl0seT1sWzNdLF89bFs0XSxiPWxbNV0sdz10Lmxlbmd0aCxTPXIubGVuZ3RoLCQ9MCx2PVtdLFQ9W10sQz1bXSxBPVtdLGs9cy5zdGFja1NhdmUoKSxPPXMuc3RhY2tBbGxvYyh3KmQpLE09cy5zdGFja0FsbG9jKHcqZCksVj1zLnN0YWNrQWxsb2MoUypkKSxGPXMuc3RhY2tBbGxvYyhTKmQpO3RyeXtbJCx2XT1QcyhhKTtmb3IobGV0IFc9MDtXPHc7VysrKWF3YWl0IFFjKG5bV10sVCxBLGUsdFtXXSxfKTtmb3IobGV0IFc9MDtXPFM7VysrKWF3YWl0IFFjKG9bV10sQyxBLGUsdytyW1ddLF8pO2ZvcihsZXQgVz0wO1c8dztXKyspcy5zZXRWYWx1ZShPK1cqZCxUW1ddLFwiKlwiKSxzLnNldFZhbHVlKE0rVypkLGZbdFtXXV0sXCIqXCIpO2ZvcihsZXQgVz0wO1c8UztXKyspcy5zZXRWYWx1ZShWK1cqZCxDW1ddLFwiKlwiKSxzLnNldFZhbHVlKEYrVypkLGhbcltXXV0sXCIqXCIpO2lmKHkmJiFiKXtsZXR7aGFuZGxlOlcsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOkosb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDp2ZX09eTtpZihmLmxlbmd0aCE9PXcpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke3d9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHtmLmxlbmd0aH0pLmApO2ZvcihsZXQgUT0wO1E8dztRKyspe2xldCBlZT10W1FdO2F3YWl0IHMuX09ydEJpbmRJbnB1dChXLGZbZWVdLFRbUV0pIT09MCYmaGUoYENhbid0IGJpbmQgaW5wdXRbJHtRfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IFE9MDtRPFM7USsrKXtsZXQgZWU9cltRXTtvW1FdPy5bM10/cy5fT3J0QmluZE91dHB1dChXLGhbZWVdLENbUV0sMCkhPT0wJiZoZShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske1F9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOnMuX09ydEJpbmRPdXRwdXQoVyxoW2VlXSwwLHZlW2VlXSkhPT0wJiZoZShgQ2FuJ3QgYmluZCBvdXRwdXRbJHtRfV0gdG8gJHtKW1FdfSBmb3Igc2Vzc2lvbj0ke2V9LmApfXp0LnNldChlLFtwLGYsaCx5LF8sITBdKX1zLmpzZXBPblJ1blN0YXJ0Py4ocCk7bGV0IGo7eT9qPWF3YWl0IHMuX09ydFJ1bldpdGhCaW5kaW5nKHAseS5oYW5kbGUsUyxWLCQpOmo9YXdhaXQgcy5fT3J0UnVuKHAsTSxPLHcsRixTLFYsJCksaiE9PTAmJmhlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCBuZT1bXTtmb3IobGV0IFc9MDtXPFM7VysrKXtsZXQgSj1OdW1iZXIocy5nZXRWYWx1ZShWK1cqZCxcIipcIikpO2lmKEo9PT1DW1ddKXtuZS5wdXNoKG9bV10pO2NvbnRpbnVlfWxldCB2ZT1zLnN0YWNrU2F2ZSgpLFE9cy5zdGFja0FsbG9jKDQqZCksZWU9ITEsbGUsWj0wO3RyeXtzLl9PcnRHZXRUZW5zb3JEYXRhKEosUSxRK2QsUSsyKmQsUSszKmQpIT09MCYmaGUoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtXfS5gKTtsZXQga2U9ZD09PTQ/XCJpMzJcIjpcImk2NFwiLFNlPU51bWJlcihzLmdldFZhbHVlKFEsa2UpKTtaPXMuZ2V0VmFsdWUoUStkLFwiKlwiKTtsZXQgRD1zLmdldFZhbHVlKFErZCoyLFwiKlwiKSxSPU51bWJlcihzLmdldFZhbHVlKFErZCozLGtlKSksWT1bXTtmb3IobGV0IHhlPTA7eGU8Ujt4ZSsrKVkucHVzaChOdW1iZXIocy5nZXRWYWx1ZShEK3hlKmQsa2UpKSk7cy5fT3J0RnJlZShEKSE9PTAmJmhlKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtsZXQgZmU9WS5yZWR1Y2UoKHhlLGJlKT0+eGUqYmUsMSk7bGU9X3QoU2UpO2xldCBGZT15Py5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbcltXXV07aWYobGU9PT1cInN0cmluZ1wiKXtpZihGZT09PVwiZ3B1LWJ1ZmZlclwifHxGZT09PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IHhlPVtdO2ZvcihsZXQgYmU9MDtiZTxmZTtiZSsrKXtsZXQgWWU9cy5nZXRWYWx1ZShaK2JlKmQsXCIqXCIpLEd0PXMuZ2V0VmFsdWUoWisoYmUrMSkqZCxcIipcIikseHQ9YmU9PT1mZS0xP3ZvaWQgMDpHdC1ZZTt4ZS5wdXNoKHMuVVRGOFRvU3RyaW5nKFllLHh0KSl9bmUucHVzaChbbGUsWSx4ZSxcImNwdVwiXSl9ZWxzZSBpZihGZT09PVwiZ3B1LWJ1ZmZlclwiJiZmZT4wKXtsZXQgeGU9cy5qc2VwR2V0QnVmZmVyO2lmKCF4ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IGJlPXhlKFopLFllPXd0KFNlLGZlKTtpZihZZT09PXZvaWQgMHx8IU1yKGxlKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtsZX1gKTtlZT0hMCxuZS5wdXNoKFtsZSxZLHtncHVCdWZmZXI6YmUsZG93bmxvYWQ6cy5qc2VwQ3JlYXRlRG93bmxvYWRlcihiZSxZZSxsZSksZGlzcG9zZTooKT0+e3MuX09ydFJlbGVhc2VUZW5zb3IoSikhPT0wJiZoZShcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZSBpZihGZT09PVwibWwtdGVuc29yXCImJmZlPjApe2xldCB4ZT1zLmpzZXBFbnN1cmVUZW5zb3I7aWYoIXhlKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7aWYod3QoU2UsZmUpPT09dm9pZCAwfHwhUnIobGUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2xlfWApO2xldCBZZT1hd2FpdCB4ZShlLFosU2UsWSwhMSk7ZWU9ITAsbmUucHVzaChbbGUsWSx7bWxUZW5zb3I6WWUsZG93bmxvYWQ6cy5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKFosbGUpLGRpc3Bvc2U6KCk9PntzLmpzZXBSZWxlYXNlVGVuc29ySWQoWikscy5fT3J0UmVsZWFzZVRlbnNvcihKKX19LFwibWwtdGVuc29yXCJdKX1lbHNle2xldCB4ZT1CcihsZSksYmU9bmV3IHhlKGZlKTtuZXcgVWludDhBcnJheShiZS5idWZmZXIsYmUuYnl0ZU9mZnNldCxiZS5ieXRlTGVuZ3RoKS5zZXQocy5IRUFQVTguc3ViYXJyYXkoWixaK2JlLmJ5dGVMZW5ndGgpKSxuZS5wdXNoKFtsZSxZLGJlLFwiY3B1XCJdKX19ZmluYWxseXtzLnN0YWNrUmVzdG9yZSh2ZSksbGU9PT1cInN0cmluZ1wiJiZaJiZzLl9mcmVlKFopLGVlfHxzLl9PcnRSZWxlYXNlVGVuc29yKEopLHMuanNlcE9uUnVuRW5kPy4ocCl9fXJldHVybiB5JiYhXyYmKHMuX09ydENsZWFyQm91bmRPdXRwdXRzKHkuaGFuZGxlKSE9PTAmJmhlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksenQuc2V0KGUsW3AsZixoLHksXywhMV0pKSxuZX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKGspLFQuZm9yRWFjaChqPT5zLl9PcnRSZWxlYXNlVGVuc29yKGopKSxDLmZvckVhY2goaj0+cy5fT3J0UmVsZWFzZVRlbnNvcihqKSksQS5mb3JFYWNoKGo9PnMuX2ZyZWUoaikpLCQhPT0wJiZzLl9PcnRSZWxlYXNlUnVuT3B0aW9ucygkKSx2LmZvckVhY2goaj0+cy5fZnJlZShqKSl9fSxQcj1lPT57bGV0IHQ9SWUoKSxuPXp0LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IHI9blswXSxvPXQuX09ydEVuZFByb2ZpbGluZyhyKTtvPT09MCYmaGUoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobyl9LHpyPWU9PntsZXQgdD1bXTtmb3IobGV0IG4gb2YgZSl7bGV0IHI9blsyXTshQXJyYXkuaXNBcnJheShyKSYmXCJidWZmZXJcImluIHImJnQucHVzaChyLmJ1ZmZlcil9cmV0dXJuIHR9fSk7dmFyIE90LEhlLGFyLGNuLHBuLGxuLHpvLE9vLFd0LEx0LGliLFljLFhjLEpjLGVwLHRwLHJwLG5wLERvPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3FuKCk7YnQoKTtTcigpO090PSgpPT4hIXdlLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIixhcj0hMSxjbj0hMSxwbj0hMSxPbz1uZXcgTWFwLFd0PShlLHQpPT57bGV0IG49T28uZ2V0KGUpO24/bi5wdXNoKHQpOk9vLnNldChlLFt0XSl9LEx0PSgpPT57aWYoYXJ8fCFjbnx8cG58fCFIZSl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxpYj1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjphcj0hMSxlLmRhdGEuZXJyPyhwbj0hMCx6b1sxXShlLmRhdGEuZXJyKSk6KGNuPSEwLHpvWzBdKCkpLGxuJiYoVVJMLnJldm9rZU9iamVjdFVSTChsbiksbG49dm9pZCAwKTticmVhaztjYXNlXCJpbml0LWVwXCI6Y2FzZVwiY29weS1mcm9tXCI6Y2FzZVwiY3JlYXRlXCI6Y2FzZVwicmVsZWFzZVwiOmNhc2VcInJ1blwiOmNhc2VcImVuZC1wcm9maWxpbmdcIjp7bGV0IHQ9T28uZ2V0KGUuZGF0YS50eXBlKTtlLmRhdGEuZXJyP3Quc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp0LnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWt9ZGVmYXVsdDp9fSxZYz1hc3luYygpPT57aWYoIWNuKXtpZihhcil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKHBuKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7aWYoYXI9ITAsT3QoKSlyZXR1cm4gbmV3IFByb21pc2UoKGUsdCk9PntIZT8udGVybWluYXRlKCksQXMoKS50aGVuKChbbixyXSk9Pnt0cnl7SGU9cixIZS5vbmVycm9yPWE9PnQoYSksSGUub25tZXNzYWdlPWliLHpvPVtlLHRdO2xldCBvPXt0eXBlOlwiaW5pdC13YXNtXCIsaW46d2V9OyFvLmluLndhc20ud2FzbVBhdGhzJiYobnx8aW1wb3J0Lm1ldGEudXJsPy5zdGFydHNXaXRoKFwiZmlsZTpcIikpJiYoby5pbi53YXNtLndhc21QYXRocz17d2FzbTpuZXcgVVJMKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIixpbXBvcnQubWV0YS51cmwpLmhyZWZ9KSxIZS5wb3N0TWVzc2FnZShvKSxsbj1ufWNhdGNoKG8pe3Qobyl9fSx0KX0pO3RyeXthd2FpdCBUcih3ZS53YXNtKSxhd2FpdCBDcih3ZSksY249ITB9Y2F0Y2goZSl7dGhyb3cgcG49ITAsZX1maW5hbGx5e2FyPSExfX19LFhjPWFzeW5jIGU9PntpZihPdCgpKXJldHVybiBMdCgpLG5ldyBQcm9taXNlKCh0LG4pPT57V3QoXCJpbml0LWVwXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwiaW5pdC1lcFwiLGluOntlcE5hbWU6ZSxlbnY6d2V9fTtIZS5wb3N0TWVzc2FnZShyKX0pO2F3YWl0IElyKHdlLGUpfSxKYz1hc3luYyBlPT5PdCgpPyhMdCgpLG5ldyBQcm9taXNlKCh0LG4pPT57V3QoXCJjb3B5LWZyb21cIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJjb3B5LWZyb21cIixpbjp7YnVmZmVyOmV9fTtIZS5wb3N0TWVzc2FnZShyLFtlLmJ1ZmZlcl0pfSkpOll0KGUpLGVwPWFzeW5jKGUsdCk9PntpZihPdCgpKXtpZih0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbil0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgobixyKT0+e1d0KFwiY3JlYXRlXCIsW24scl0pO2xldCBvPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp7Li4udH19fSxhPVtdO2UgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZhLnB1c2goZS5idWZmZXIpLEhlLnBvc3RNZXNzYWdlKG8sYSl9KX1lbHNlIHJldHVybiBBcihlLHQpfSx0cD1hc3luYyBlPT57aWYoT3QoKSlyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e1d0KFwicmVsZWFzZVwiLFt0LG5dKTtsZXQgcj17dHlwZTpcInJlbGVhc2VcIixpbjplfTtIZS5wb3N0TWVzc2FnZShyKX0pO2tyKGUpfSxycD1hc3luYyhlLHQsbixyLG8sYSk9PntpZihPdCgpKXtpZihuLnNvbWUocz0+c1szXSE9PVwiY3B1XCIpKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO2lmKG8uc29tZShzPT5zKSl0aHJvdyBuZXcgRXJyb3IoXCJwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO3JldHVybiBMdCgpLG5ldyBQcm9taXNlKChzLGQpPT57V3QoXCJydW5cIixbcyxkXSk7bGV0IGw9bixwPXt0eXBlOlwicnVuXCIsaW46e3Nlc3Npb25JZDplLGlucHV0SW5kaWNlczp0LGlucHV0czpsLG91dHB1dEluZGljZXM6cixvcHRpb25zOmF9fTtIZS5wb3N0TWVzc2FnZShwLHpyKGwpKX0pfWVsc2UgcmV0dXJuIEVyKGUsdCxuLHIsbyxhKX0sbnA9YXN5bmMgZT0+e2lmKE90KCkpcmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHQsbik9PntXdChcImVuZC1wcm9maWxpbmdcIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07SGUucG9zdE1lc3NhZ2Uocil9KTtQcihlKX19KTt2YXIgb3AsYWIsbW4saXA9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7RG8oKTt0ZSgpO3hyKCk7WG4oKTtvcD0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bZS50eXBlLGUuZGltcyxlLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHtncHVCdWZmZXI6ZS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7bWxUZW5zb3I6ZS5tbFRlbnNvcn0sXCJtbC10ZW5zb3JcIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlLmxvY2F0aW9ufSBmb3IgJHt0KCl9YCl9fSxhYj1lPT57c3dpdGNoKGVbM10pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgcWUoZVswXSxlWzJdLGVbMV0pO2Nhc2VcImdwdS1idWZmZXJcIjp7bGV0IHQ9ZVswXTtpZighTXIodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7bGV0e2dwdUJ1ZmZlcjpuLGRvd25sb2FkOnIsZGlzcG9zZTpvfT1lWzJdO3JldHVybiBxZS5mcm9tR3B1QnVmZmVyKG4se2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOnIsZGlzcG9zZTpvfSl9Y2FzZVwibWwtdGVuc29yXCI6e2xldCB0PWVbMF07aWYoIVJyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7bGV0e21sVGVuc29yOm4sZG93bmxvYWQ6cixkaXNwb3NlOm99PWVbMl07cmV0dXJuIHFlLmZyb21NTFRlbnNvcihuLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpyLGRpc3Bvc2U6b30pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LG1uPWNsYXNze2FzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpe3JldHVybiBKYyhhd2FpdCBlcih0KSl9YXN5bmMgbG9hZE1vZGVsKHQsbil7TmUoKTtsZXQgcjt0eXBlb2YgdD09XCJzdHJpbmdcIj9yPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6cj10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgZXAocixuKSxCZSgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gdHAodGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LG4scil7TmUoKTtsZXQgbz1bXSxhPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goeT0+e2xldCBfPXlbMF0sYj15WzFdLHc9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoXyk7aWYodz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtffSdgKTtvLnB1c2goYiksYS5wdXNoKHcpfSk7bGV0IHM9W10sZD1bXTtPYmplY3QuZW50cmllcyhuKS5mb3JFYWNoKHk9PntsZXQgXz15WzBdLGI9eVsxXSx3PXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihfKTtpZih3PT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtffSdgKTtzLnB1c2goYiksZC5wdXNoKHcpfSk7bGV0IGw9by5tYXAoKHksXyk9Pm9wKHksKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2FbX11dfVwiYCkpLHA9cy5tYXAoKHksXyk9Pnk/b3AoeSwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tkW19dXX1cImApOm51bGwpLGY9YXdhaXQgcnAodGhpcy5zZXNzaW9uSWQsYSxsLGQscCxyKSxoPXt9O2ZvcihsZXQgeT0wO3k8Zi5sZW5ndGg7eSsrKWhbdGhpcy5vdXRwdXROYW1lc1tkW3ldXV09c1t5XT8/YWIoZlt5XSk7cmV0dXJuIEJlKCksaH1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtucCh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBzcD17fTtadChzcCx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9PmZuLGluaXRpYWxpemVGbGFnczooKT0+YXAsd2FzbUJhY2tlbmQ6KCk9PnNifSk7dmFyIGFwLGZuLHNiLHVwPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO0RvKCk7aXAoKTthcD0oKT0+e2lmKCh0eXBlb2Ygd2Uud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8d2Uud2FzbS5pbml0VGltZW91dDwwKSYmKHdlLndhc20uaW5pdFRpbWVvdXQ9MCksd2Uud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIHdlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYod2Uud2FzbS5wcm94eT0hMSksdHlwZW9mIHdlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYod2Uud2FzbS50cmFjZT0hMSksdHlwZW9mIHdlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIod2Uud2FzbS5udW1UaHJlYWRzKXx8d2Uud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKXdlLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9ObihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTt3ZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LGZuPWNsYXNze2FzeW5jIGluaXQodCl7YXAoKSxhd2FpdCBZYygpLGF3YWl0IFhjKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQsbil7bGV0IHI9bmV3IG1uO3JldHVybiBhd2FpdCByLmxvYWRNb2RlbCh0LG4pLFByb21pc2UucmVzb2x2ZShyKX19LHNiPW5ldyBmbn0pO0dlKCk7R2UoKTtHZSgpO3ZhciBocz1cIjEuMjEuMFwiO3ZhciBsVD1Gbjt7bGV0IGU9KHVwKCksYnIoc3ApKS53YXNtQmFja2VuZDtDdChcIndlYmdwdVwiLGUsNSksQ3QoXCJ3ZWJublwiLGUsNSksQ3QoXCJjcHVcIixlLDEwKSxDdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkod2UudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6aHMsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtPZiBhcyBJbmZlcmVuY2VTZXNzaW9uLHZyIGFzIFRSQUNFLE5lIGFzIFRSQUNFX0ZVTkNfQkVHSU4sQmUgYXMgVFJBQ0VfRlVOQ19FTkQscWUgYXMgVGVuc29yLGxUIGFzIGRlZmF1bHQsd2UgYXMgZW52LEN0IGFzIHJlZ2lzdGVyQmFja2VuZH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?f243\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend-impl.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend-impl.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: () => (/* binding */ registerBackend),\n/* harmony export */   resolveBackendAndExecutionProviders: () => (/* binding */ resolveBackendAndExecutionProviders)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\nconst backends = new Map();\nconst backendsSortedByPriority = [];\n/**\n * Register a backend.\n *\n * @param name - the name as a key to lookup as an execution provider.\n * @param backend - the backend object.\n * @param priority - an integer indicating the priority of the backend. Higher number means higher priority. if priority\n * < 0, it will be considered as a 'beta' version and will not be used as a fallback backend by default.\n *\n * @ignore\n */\nconst registerBackend = (name, backend, priority) => {\n    if (backend && typeof backend.init === 'function' && typeof backend.createInferenceSessionHandler === 'function') {\n        const currentBackend = backends.get(name);\n        if (currentBackend === undefined) {\n            backends.set(name, { backend, priority });\n        }\n        else if (currentBackend.priority > priority) {\n            // same name is already registered with a higher priority. skip registeration.\n            return;\n        }\n        else if (currentBackend.priority === priority) {\n            if (currentBackend.backend !== backend) {\n                throw new Error(`cannot register backend \"${name}\" using priority ${priority}`);\n            }\n        }\n        if (priority >= 0) {\n            const i = backendsSortedByPriority.indexOf(name);\n            if (i !== -1) {\n                backendsSortedByPriority.splice(i, 1);\n            }\n            for (let i = 0; i < backendsSortedByPriority.length; i++) {\n                if (backends.get(backendsSortedByPriority[i]).priority <= priority) {\n                    backendsSortedByPriority.splice(i, 0, name);\n                    return;\n                }\n            }\n            backendsSortedByPriority.push(name);\n        }\n        return;\n    }\n    throw new TypeError('not a valid backend');\n};\n/**\n * Try to resolve and initialize a backend.\n *\n * @param backendName - the name of the backend.\n * @returns the backend instance if resolved and initialized successfully, or an error message if failed.\n */\nconst tryResolveAndInitializeBackend = async (backendName) => {\n    const backendInfo = backends.get(backendName);\n    if (!backendInfo) {\n        return 'backend not found.';\n    }\n    if (backendInfo.initialized) {\n        return backendInfo.backend;\n    }\n    else if (backendInfo.aborted) {\n        return backendInfo.error;\n    }\n    else {\n        const isInitializing = !!backendInfo.initPromise;\n        try {\n            if (!isInitializing) {\n                backendInfo.initPromise = backendInfo.backend.init(backendName);\n            }\n            await backendInfo.initPromise;\n            backendInfo.initialized = true;\n            return backendInfo.backend;\n        }\n        catch (e) {\n            if (!isInitializing) {\n                backendInfo.error = `${e}`;\n                backendInfo.aborted = true;\n            }\n            return backendInfo.error;\n        }\n        finally {\n            delete backendInfo.initPromise;\n        }\n    }\n};\n/**\n * Resolve execution providers from the specific session options.\n *\n * @param options - the session options object.\n * @returns a promise that resolves to a tuple of an initialized backend instance and a session options object with\n * filtered EP list.\n *\n * @ignore\n */\nconst resolveBackendAndExecutionProviders = async (options) => {\n    // extract backend hints from session options\n    const eps = options.executionProviders || [];\n    const backendHints = eps.map((i) => (typeof i === 'string' ? i : i.name));\n    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;\n    // try to resolve and initialize all requested backends\n    let backend;\n    const errors = [];\n    const availableBackendNames = new Set();\n    for (const backendName of backendNames) {\n        const resolveResult = await tryResolveAndInitializeBackend(backendName);\n        if (typeof resolveResult === 'string') {\n            errors.push({ name: backendName, err: resolveResult });\n        }\n        else {\n            if (!backend) {\n                backend = resolveResult;\n            }\n            if (backend === resolveResult) {\n                availableBackendNames.add(backendName);\n            }\n        }\n    }\n    // if no backend is available, throw error.\n    if (!backend) {\n        throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(', ')}`);\n    }\n    // for each explicitly requested backend, if it's not available, output warning message.\n    for (const { name, err } of errors) {\n        if (backendHints.includes(name)) {\n            // eslint-disable-next-line no-console\n            console.warn(`removing requested execution provider \"${name}\" from session options because it is not available: ${err}`);\n        }\n    }\n    const filteredEps = eps.filter((i) => availableBackendNames.has(typeof i === 'string' ? i : i.name));\n    return [\n        backend,\n        new Proxy(options, {\n            get: (target, prop) => {\n                if (prop === 'executionProviders') {\n                    return filteredEps;\n                }\n                return Reflect.get(target, prop);\n            },\n        }),\n    ];\n};\n//# sourceMappingURL=backend-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vYmFja2VuZC1pbXBsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxLQUFLLG1CQUFtQixTQUFTO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHNCQUFzQixPQUFPLElBQUksTUFBTSxjQUFjO0FBQ2pIO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0EsbUVBQW1FLEtBQUssc0RBQXNELElBQUk7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL2JhY2tlbmQtaW1wbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmNvbnN0IGJhY2tlbmRzID0gbmV3IE1hcCgpO1xuY29uc3QgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5ID0gW107XG4vKipcbiAqIFJlZ2lzdGVyIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIHRoZSBuYW1lIGFzIGEga2V5IHRvIGxvb2t1cCBhcyBhbiBleGVjdXRpb24gcHJvdmlkZXIuXG4gKiBAcGFyYW0gYmFja2VuZCAtIHRoZSBiYWNrZW5kIG9iamVjdC5cbiAqIEBwYXJhbSBwcmlvcml0eSAtIGFuIGludGVnZXIgaW5kaWNhdGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGJhY2tlbmQuIEhpZ2hlciBudW1iZXIgbWVhbnMgaGlnaGVyIHByaW9yaXR5LiBpZiBwcmlvcml0eVxuICogPCAwLCBpdCB3aWxsIGJlIGNvbnNpZGVyZWQgYXMgYSAnYmV0YScgdmVyc2lvbiBhbmQgd2lsbCBub3QgYmUgdXNlZCBhcyBhIGZhbGxiYWNrIGJhY2tlbmQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZWdpc3RlckJhY2tlbmQgPSAobmFtZSwgYmFja2VuZCwgcHJpb3JpdHkpID0+IHtcbiAgICBpZiAoYmFja2VuZCAmJiB0eXBlb2YgYmFja2VuZC5pbml0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBiYWNrZW5kLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRCYWNrZW5kID0gYmFja2VuZHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoY3VycmVudEJhY2tlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmFja2VuZHMuc2V0KG5hbWUsIHsgYmFja2VuZCwgcHJpb3JpdHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPiBwcmlvcml0eSkge1xuICAgICAgICAgICAgLy8gc2FtZSBuYW1lIGlzIGFscmVhZHkgcmVnaXN0ZXJlZCB3aXRoIGEgaGlnaGVyIHByaW9yaXR5LiBza2lwIHJlZ2lzdGVyYXRpb24uXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudEJhY2tlbmQucHJpb3JpdHkgPT09IHByaW9yaXR5KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEJhY2tlbmQuYmFja2VuZCAhPT0gYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke25hbWV9XCIgdXNpbmcgcHJpb3JpdHkgJHtwcmlvcml0eX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5pbmRleE9mKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhY2tlbmRzLmdldChiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHlbaV0pLnByaW9yaXR5IDw9IHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tlbmRzU29ydGVkQnlQcmlvcml0eS5zcGxpY2UoaSwgMCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYWNrZW5kc1NvcnRlZEJ5UHJpb3JpdHkucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIHZhbGlkIGJhY2tlbmQnKTtcbn07XG4vKipcbiAqIFRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGEgYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0gYmFja2VuZE5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYmFja2VuZC5cbiAqIEByZXR1cm5zIHRoZSBiYWNrZW5kIGluc3RhbmNlIGlmIHJlc29sdmVkIGFuZCBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHksIG9yIGFuIGVycm9yIG1lc3NhZ2UgaWYgZmFpbGVkLlxuICovXG5jb25zdCB0cnlSZXNvbHZlQW5kSW5pdGlhbGl6ZUJhY2tlbmQgPSBhc3luYyAoYmFja2VuZE5hbWUpID0+IHtcbiAgICBjb25zdCBiYWNrZW5kSW5mbyA9IGJhY2tlbmRzLmdldChiYWNrZW5kTmFtZSk7XG4gICAgaWYgKCFiYWNrZW5kSW5mbykge1xuICAgICAgICByZXR1cm4gJ2JhY2tlbmQgbm90IGZvdW5kLic7XG4gICAgfVxuICAgIGlmIChiYWNrZW5kSW5mby5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmFja2VuZEluZm8uYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZEluZm8uZXJyb3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBpc0luaXRpYWxpemluZyA9ICEhYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgICAgICAgICAgYmFja2VuZEluZm8uaW5pdFByb21pc2UgPSBiYWNrZW5kSW5mby5iYWNrZW5kLmluaXQoYmFja2VuZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgYmFja2VuZEluZm8uaW5pdFByb21pc2U7XG4gICAgICAgICAgICBiYWNrZW5kSW5mby5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYmFja2VuZEluZm8uYmFja2VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCFpc0luaXRpYWxpemluZykge1xuICAgICAgICAgICAgICAgIGJhY2tlbmRJbmZvLmVycm9yID0gYCR7ZX1gO1xuICAgICAgICAgICAgICAgIGJhY2tlbmRJbmZvLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhY2tlbmRJbmZvLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIGJhY2tlbmRJbmZvLmluaXRQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogUmVzb2x2ZSBleGVjdXRpb24gcHJvdmlkZXJzIGZyb20gdGhlIHNwZWNpZmljIHNlc3Npb24gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBzZXNzaW9uIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB0dXBsZSBvZiBhbiBpbml0aWFsaXplZCBiYWNrZW5kIGluc3RhbmNlIGFuZCBhIHNlc3Npb24gb3B0aW9ucyBvYmplY3Qgd2l0aFxuICogZmlsdGVyZWQgRVAgbGlzdC5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgLy8gZXh0cmFjdCBiYWNrZW5kIGhpbnRzIGZyb20gc2Vzc2lvbiBvcHRpb25zXG4gICAgY29uc3QgZXBzID0gb3B0aW9ucy5leGVjdXRpb25Qcm92aWRlcnMgfHwgW107XG4gICAgY29uc3QgYmFja2VuZEhpbnRzID0gZXBzLm1hcCgoaSkgPT4gKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcbiAgICBjb25zdCBiYWNrZW5kTmFtZXMgPSBiYWNrZW5kSGludHMubGVuZ3RoID09PSAwID8gYmFja2VuZHNTb3J0ZWRCeVByaW9yaXR5IDogYmFja2VuZEhpbnRzO1xuICAgIC8vIHRyeSB0byByZXNvbHZlIGFuZCBpbml0aWFsaXplIGFsbCByZXF1ZXN0ZWQgYmFja2VuZHNcbiAgICBsZXQgYmFja2VuZDtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBhdmFpbGFibGVCYWNrZW5kTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBiYWNrZW5kTmFtZSBvZiBiYWNrZW5kTmFtZXMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVJlc3VsdCA9IGF3YWl0IHRyeVJlc29sdmVBbmRJbml0aWFsaXplQmFja2VuZChiYWNrZW5kTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZVJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgbmFtZTogYmFja2VuZE5hbWUsIGVycjogcmVzb2x2ZVJlc3VsdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghYmFja2VuZCkge1xuICAgICAgICAgICAgICAgIGJhY2tlbmQgPSByZXNvbHZlUmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhY2tlbmQgPT09IHJlc29sdmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVCYWNrZW5kTmFtZXMuYWRkKGJhY2tlbmROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyBiYWNrZW5kIGlzIGF2YWlsYWJsZSwgdGhyb3cgZXJyb3IuXG4gICAgaWYgKCFiYWNrZW5kKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtlcnJvcnMubWFwKChlKSA9PiBgWyR7ZS5uYW1lfV0gJHtlLmVycn1gKS5qb2luKCcsICcpfWApO1xuICAgIH1cbiAgICAvLyBmb3IgZWFjaCBleHBsaWNpdGx5IHJlcXVlc3RlZCBiYWNrZW5kLCBpZiBpdCdzIG5vdCBhdmFpbGFibGUsIG91dHB1dCB3YXJuaW5nIG1lc3NhZ2UuXG4gICAgZm9yIChjb25zdCB7IG5hbWUsIGVyciB9IG9mIGVycm9ycykge1xuICAgICAgICBpZiAoYmFja2VuZEhpbnRzLmluY2x1ZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKGByZW1vdmluZyByZXF1ZXN0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyIFwiJHtuYW1lfVwiIGZyb20gc2Vzc2lvbiBvcHRpb25zIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZTogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRFcHMgPSBlcHMuZmlsdGVyKChpKSA9PiBhdmFpbGFibGVCYWNrZW5kTmFtZXMuaGFzKHR5cGVvZiBpID09PSAnc3RyaW5nJyA/IGkgOiBpLm5hbWUpKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBiYWNrZW5kLFxuICAgICAgICBuZXcgUHJveHkob3B0aW9ucywge1xuICAgICAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09ICdleGVjdXRpb25Qcm92aWRlcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZEVwcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICBdO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQtaW1wbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerBackend: () => (/* reexport safe */ _backend_impl_js__WEBPACK_IMPORTED_MODULE_0__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var _backend_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=backend.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vYmFja2VuZC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDb0Q7QUFDcEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vYmFja2VuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7IHJlZ2lzdGVyQmFja2VuZCB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env-impl.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env-impl.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/version.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nlet logLevelValue = 'warning';\nconst env = {\n    wasm: {},\n    webgl: {},\n    webgpu: {},\n    versions: { common: _version_js__WEBPACK_IMPORTED_MODULE_0__.version },\n    set logLevel(value) {\n        if (value === undefined) {\n            return;\n        }\n        if (typeof value !== 'string' || ['verbose', 'info', 'warning', 'error', 'fatal'].indexOf(value) === -1) {\n            throw new Error(`Unsupported logging level: ${value}`);\n        }\n        logLevelValue = value;\n    },\n    get logLevel() {\n        return logLevelValue;\n    },\n};\n// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.\nObject.defineProperty(env, 'logLevel', { enumerable: true });\n//# sourceMappingURL=env-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vZW52LWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ3VDO0FBQ3ZDO0FBQ087QUFDUCxZQUFZO0FBQ1osYUFBYTtBQUNiLGNBQWM7QUFDZCxnQkFBZ0IsUUFBUSxnREFBTyxFQUFFO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsTUFBTTtBQUNoRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vZW52LWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmxldCBsb2dMZXZlbFZhbHVlID0gJ3dhcm5pbmcnO1xuZXhwb3J0IGNvbnN0IGVudiA9IHtcbiAgICB3YXNtOiB7fSxcbiAgICB3ZWJnbDoge30sXG4gICAgd2ViZ3B1OiB7fSxcbiAgICB2ZXJzaW9uczogeyBjb21tb246IHZlcnNpb24gfSxcbiAgICBzZXQgbG9nTGV2ZWwodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBbJ3ZlcmJvc2UnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJywgJ2ZhdGFsJ10uaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nTGV2ZWxWYWx1ZSA9IHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IGxvZ0xldmVsKCkge1xuICAgICAgICByZXR1cm4gbG9nTGV2ZWxWYWx1ZTtcbiAgICB9LFxufTtcbi8vIHNldCBwcm9wZXJ0eSAnbG9nTGV2ZWwnIHNvIHRoYXQgdGhleSBjYW4gYmUgY29ycmVjdGx5IHRyYW5zZmVycmVkIHRvIHdvcmtlciBieSBgcG9zdE1lc3NhZ2UoKWAuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZW52LCAnbG9nTGV2ZWwnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnYtaW1wbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   env: () => (/* binding */ env)\n/* harmony export */ });\n/* harmony import */ var _env_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Represent a set of flags as a global singleton.\n */\nconst env = _env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env;\n//# sourceMappingURL=env.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUMrQztBQUMvQztBQUNBO0FBQ0E7QUFDTyxZQUFZLDZDQUFPO0FBQzFCIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL2Vudi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IGVudiBhcyBlbnZJbXBsIH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNldCBvZiBmbGFncyBhcyBhIGdsb2JhbCBzaW5nbGV0b24uXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBlbnZJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* reexport safe */ _inference_session_js__WEBPACK_IMPORTED_MODULE_2__.InferenceSession),\n/* harmony export */   TRACE: () => (/* reexport safe */ _trace_js__WEBPACK_IMPORTED_MODULE_6__.TRACE),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* reexport safe */ _trace_js__WEBPACK_IMPORTED_MODULE_6__.TRACE_FUNC_BEGIN),\n/* harmony export */   TRACE_FUNC_END: () => (/* reexport safe */ _trace_js__WEBPACK_IMPORTED_MODULE_6__.TRACE_FUNC_END),\n/* harmony export */   Tensor: () => (/* reexport safe */ _tensor_js__WEBPACK_IMPORTED_MODULE_3__.Tensor),\n/* harmony export */   env: () => (/* reexport safe */ _env_js__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   registerBackend: () => (/* reexport safe */ _backend_js__WEBPACK_IMPORTED_MODULE_0__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var _backend_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env.js\");\n/* harmony import */ var _inference_session_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inference-session.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session.js\");\n/* harmony import */ var _tensor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor.js\");\n/* harmony import */ var _tensor_conversion_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tensor-conversion.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js\");\n/* harmony import */ var _tensor_factory_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tensor-factory.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js\");\n/* harmony import */ var _trace_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./trace.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/trace.js\");\n/* harmony import */ var _onnx_model_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./onnx-model.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-model.js\");\n/* harmony import */ var _onnx_value_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./onnx-value.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-value.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n/**\n * # ONNX Runtime JavaScript API\n *\n * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:\n *\n * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)\n * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)\n * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)\n *\n * See also:\n * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript/)\n * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)\n *\n * @packageDocumentation\n */\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkI7QUFDSjtBQUNjO0FBQ1g7QUFDVztBQUNIO0FBQ1Q7QUFDSztBQUNBO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuLyoqXG4gKiAjIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIE9OTlggUnVudGltZSBKYXZhU2NyaXB0IEFQSSBpcyBhIHVuaWZpZWQgQVBJIGZvciBhbGwgSmF2YVNjcmlwdCB1c2FnZXMsIGluY2x1ZGluZyB0aGUgZm9sbG93aW5nIE5QTSBwYWNrYWdlczpcbiAqXG4gKiAtIFtvbm54cnVudGltZS1ub2RlXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS1ub2RlKVxuICogLSBbb25ueHJ1bnRpbWUtd2ViXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9vbm54cnVudGltZS13ZWIpXG4gKiAtIFtvbm54cnVudGltZS1yZWFjdC1uYXRpdmVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29ubnhydW50aW1lLXJlYWN0LW5hdGl2ZSlcbiAqXG4gKiBTZWUgYWxzbzpcbiAqIC0gW0dldCBTdGFydGVkXShodHRwczovL29ubnhydW50aW1lLmFpL2RvY3MvZ2V0LXN0YXJ0ZWQvd2l0aC1qYXZhc2NyaXB0LylcbiAqIC0gW0luZmVyZW5jZSBleGFtcGxlc10oaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9vbm54cnVudGltZS1pbmZlcmVuY2UtZXhhbXBsZXMvdHJlZS9tYWluL2pzKVxuICpcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICovXG5leHBvcnQgKiBmcm9tICcuL2JhY2tlbmQuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnYuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmZlcmVuY2Utc2Vzc2lvbi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3RlbnNvci1jb252ZXJzaW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdGVuc29yLWZhY3RvcnkuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL29ubngtbW9kZWwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9vbm54LXZhbHVlLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)\n/* harmony export */ });\n/* harmony import */ var _backend_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./backend-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/backend-impl.js\");\n/* harmony import */ var _tensor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor.js\");\n/* harmony import */ var _trace_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trace.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/trace.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n\n\nclass InferenceSession {\n    constructor(handler) {\n        this.handler = handler;\n    }\n    async run(feeds, arg1, arg2) {\n        (0,_trace_js__WEBPACK_IMPORTED_MODULE_2__.TRACE_FUNC_BEGIN)();\n        const fetches = {};\n        let options = {};\n        // check inputs\n        if (typeof feeds !== 'object' || feeds === null || feeds instanceof _tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor || Array.isArray(feeds)) {\n            throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n        }\n        let isFetchesEmpty = true;\n        // determine which override is being used\n        if (typeof arg1 === 'object') {\n            if (arg1 === null) {\n                throw new TypeError('Unexpected argument[1]: cannot be null.');\n            }\n            if (arg1 instanceof _tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                throw new TypeError(\"'fetches' cannot be a Tensor\");\n            }\n            if (Array.isArray(arg1)) {\n                if (arg1.length === 0) {\n                    throw new TypeError(\"'fetches' cannot be an empty array.\");\n                }\n                isFetchesEmpty = false;\n                // output names\n                for (const name of arg1) {\n                    if (typeof name !== 'string') {\n                        throw new TypeError(\"'fetches' must be a string array or an object.\");\n                    }\n                    if (this.outputNames.indexOf(name) === -1) {\n                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);\n                    }\n                    fetches[name] = null;\n                }\n                if (typeof arg2 === 'object' && arg2 !== null) {\n                    options = arg2;\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError(\"'options' must be an object.\");\n                }\n            }\n            else {\n                // decide whether arg1 is fetches or options\n                // if any output name is present and its value is valid OnnxValue, we consider it fetches\n                let isFetches = false;\n                const arg1Keys = Object.getOwnPropertyNames(arg1);\n                for (const name of this.outputNames) {\n                    if (arg1Keys.indexOf(name) !== -1) {\n                        const v = arg1[name];\n                        if (v === null || v instanceof _tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                            isFetches = true;\n                            isFetchesEmpty = false;\n                            fetches[name] = v;\n                        }\n                    }\n                }\n                if (isFetches) {\n                    if (typeof arg2 === 'object' && arg2 !== null) {\n                        options = arg2;\n                    }\n                    else if (typeof arg2 !== 'undefined') {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                }\n                else {\n                    options = arg1;\n                }\n            }\n        }\n        else if (typeof arg1 !== 'undefined') {\n            throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n        }\n        // check if all inputs are in feed\n        for (const name of this.inputNames) {\n            if (typeof feeds[name] === 'undefined') {\n                throw new Error(`input '${name}' is missing in 'feeds'.`);\n            }\n        }\n        // if no fetches is specified, we use the full output names list\n        if (isFetchesEmpty) {\n            for (const name of this.outputNames) {\n                fetches[name] = null;\n            }\n        }\n        // feeds, fetches and options are prepared\n        const results = await this.handler.run(feeds, fetches, options);\n        const returnValue = {};\n        for (const key in results) {\n            if (Object.hasOwnProperty.call(results, key)) {\n                const result = results[key];\n                if (result instanceof _tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor) {\n                    returnValue[key] = result;\n                }\n                else {\n                    returnValue[key] = new _tensor_js__WEBPACK_IMPORTED_MODULE_1__.Tensor(result.type, result.data, result.dims);\n                }\n            }\n        }\n        (0,_trace_js__WEBPACK_IMPORTED_MODULE_2__.TRACE_FUNC_END)();\n        return returnValue;\n    }\n    async release() {\n        return this.handler.dispose();\n    }\n    static async create(arg0, arg1, arg2, arg3) {\n        (0,_trace_js__WEBPACK_IMPORTED_MODULE_2__.TRACE_FUNC_BEGIN)();\n        // either load from a file or buffer\n        let filePathOrUint8Array;\n        let options = {};\n        if (typeof arg0 === 'string') {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        }\n        else if (arg0 instanceof Uint8Array) {\n            filePathOrUint8Array = arg0;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n        }\n        else if (arg0 instanceof ArrayBuffer ||\n            (typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer)) {\n            const buffer = arg0;\n            let byteOffset = 0;\n            let byteLength = arg0.byteLength;\n            if (typeof arg1 === 'object' && arg1 !== null) {\n                options = arg1;\n            }\n            else if (typeof arg1 === 'number') {\n                byteOffset = arg1;\n                if (!Number.isSafeInteger(byteOffset)) {\n                    throw new RangeError(\"'byteOffset' must be an integer.\");\n                }\n                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {\n                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);\n                }\n                byteLength = arg0.byteLength - byteOffset;\n                if (typeof arg2 === 'number') {\n                    byteLength = arg2;\n                    if (!Number.isSafeInteger(byteLength)) {\n                        throw new RangeError(\"'byteLength' must be an integer.\");\n                    }\n                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {\n                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);\n                    }\n                    if (typeof arg3 === 'object' && arg3 !== null) {\n                        options = arg3;\n                    }\n                    else if (typeof arg3 !== 'undefined') {\n                        throw new TypeError(\"'options' must be an object.\");\n                    }\n                }\n                else if (typeof arg2 !== 'undefined') {\n                    throw new TypeError(\"'byteLength' must be a number.\");\n                }\n            }\n            else if (typeof arg1 !== 'undefined') {\n                throw new TypeError(\"'options' must be an object.\");\n            }\n            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);\n        }\n        else {\n            throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n        }\n        // resolve backend, update session options with validated EPs, and create session handler\n        const [backend, optionsWithValidatedEPs] = await (0,_backend_impl_js__WEBPACK_IMPORTED_MODULE_0__.resolveBackendAndExecutionProviders)(options);\n        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);\n        (0,_trace_js__WEBPACK_IMPORTED_MODULE_2__.TRACE_FUNC_END)();\n        return new InferenceSession(handler);\n    }\n    startProfiling() {\n        this.handler.startProfiling();\n    }\n    endProfiling() {\n        this.handler.endProfiling();\n    }\n    get inputNames() {\n        return this.handler.inputNames;\n    }\n    get outputNames() {\n        return this.handler.outputNames;\n    }\n}\n//# sourceMappingURL=inference-session-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vaW5mZXJlbmNlLXNlc3Npb24taW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUN3RTtBQUNuQztBQUN5QjtBQUN2RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDhDQUFNO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsS0FBSztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOENBQU07QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDhDQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw4Q0FBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsa0JBQWtCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsK0JBQStCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxxRkFBbUM7QUFDNUY7QUFDQSxRQUFRLHlEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyByZXNvbHZlQmFja2VuZEFuZEV4ZWN1dGlvblByb3ZpZGVycyB9IGZyb20gJy4vYmFja2VuZC1pbXBsLmpzJztcbmltcG9ydCB7IFRlbnNvciB9IGZyb20gJy4vdGVuc29yLmpzJztcbmltcG9ydCB7IFRSQUNFX0ZVTkNfQkVHSU4sIFRSQUNFX0ZVTkNfRU5EIH0gZnJvbSAnLi90cmFjZS5qcyc7XG5leHBvcnQgY2xhc3MgSW5mZXJlbmNlU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIH1cbiAgICBhc3luYyBydW4oZmVlZHMsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgVFJBQ0VfRlVOQ19CRUdJTigpO1xuICAgICAgICBjb25zdCBmZXRjaGVzID0ge307XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIC8vIGNoZWNrIGlucHV0c1xuICAgICAgICBpZiAodHlwZW9mIGZlZWRzICE9PSAnb2JqZWN0JyB8fCBmZWVkcyA9PT0gbnVsbCB8fCBmZWVkcyBpbnN0YW5jZW9mIFRlbnNvciB8fCBBcnJheS5pc0FycmF5KGZlZWRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZWVkcycgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCB1c2UgaW5wdXQgbmFtZXMgYXMga2V5cyBhbmQgT25ueFZhbHVlIGFzIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNGZXRjaGVzRW1wdHkgPSB0cnVlO1xuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggb3ZlcnJpZGUgaXMgYmVpbmcgdXNlZFxuICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgYXJndW1lbnRbMV06IGNhbm5vdCBiZSBudWxsLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZzEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGFuIGVtcHR5IGFycmF5LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNGZXRjaGVzRW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXQgbmFtZXNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkgb3IgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke25hbWV9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZldGNoZXNbbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWNpZGUgd2hldGhlciBhcmcxIGlzIGZldGNoZXMgb3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBvdXRwdXQgbmFtZSBpcyBwcmVzZW50IGFuZCBpdHMgdmFsdWUgaXMgdmFsaWQgT25ueFZhbHVlLCB3ZSBjb25zaWRlciBpdCBmZXRjaGVzXG4gICAgICAgICAgICAgICAgbGV0IGlzRmV0Y2hlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZzFLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJnMSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMub3V0cHV0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzFLZXlzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gYXJnMVtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBudWxsIHx8IHYgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZldGNoZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmV0Y2hlc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRmV0Y2hlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZzIgPT09ICdvYmplY3QnICYmIGFyZzIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBtdXN0IGJlICdmZXRjaGVzJyBvciAnb3B0aW9ucycuXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIGFsbCBpbnB1dHMgYXJlIGluIGZlZWRcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIHRoaXMuaW5wdXROYW1lcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmZWVkc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke25hbWV9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbm8gZmV0Y2hlcyBpcyBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZnVsbCBvdXRwdXQgbmFtZXMgbGlzdFxuICAgICAgICBpZiAoaXNGZXRjaGVzRW1wdHkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLm91dHB1dE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgZmV0Y2hlc1tuYW1lXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmVlZHMsIGZldGNoZXMgYW5kIG9wdGlvbnMgYXJlIHByZXBhcmVkXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCB0aGlzLmhhbmRsZXIucnVuKGZlZWRzLCBmZXRjaGVzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdHMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZVtrZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWVba2V5XSA9IG5ldyBUZW5zb3IocmVzdWx0LnR5cGUsIHJlc3VsdC5kYXRhLCByZXN1bHQuZGltcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFRSQUNFX0ZVTkNfRU5EKCk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgcmVsZWFzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBUUkFDRV9GVU5DX0JFR0lOKCk7XG4gICAgICAgIC8vIGVpdGhlciBsb2FkIGZyb20gYSBmaWxlIG9yIGJ1ZmZlclxuICAgICAgICBsZXQgZmlsZVBhdGhPclVpbnQ4QXJyYXk7XG4gICAgICAgIGxldCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gYXJnMDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCcgJiYgYXJnMSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnMCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBhcmcwIGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhcmcwO1xuICAgICAgICAgICAgbGV0IGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGVMZW5ndGggPSBhcmcwLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZzEgPT09ICdvYmplY3QnICYmIGFyZzEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgPSBhcmcxO1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdieXRlT2Zmc2V0JyBpcyBvdXQgb2YgcmFuZ2UgWzAsICR7YnVmZmVyLmJ5dGVMZW5ndGh9KS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnl0ZUxlbmd0aCA9IGFyZzAuYnl0ZUxlbmd0aCAtIGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBieXRlTGVuZ3RoID0gYXJnMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihieXRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCA8PSAwIHx8IGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2J1ZmZlci5ieXRlTGVuZ3RoIC0gYnl0ZU9mZnNldH1dLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gJ29iamVjdCcgJiYgYXJnMyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZzMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnMSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbGVQYXRoT3JVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzb2x2ZSBiYWNrZW5kLCB1cGRhdGUgc2Vzc2lvbiBvcHRpb25zIHdpdGggdmFsaWRhdGVkIEVQcywgYW5kIGNyZWF0ZSBzZXNzaW9uIGhhbmRsZXJcbiAgICAgICAgY29uc3QgW2JhY2tlbmQsIG9wdGlvbnNXaXRoVmFsaWRhdGVkRVBzXSA9IGF3YWl0IHJlc29sdmVCYWNrZW5kQW5kRXhlY3V0aW9uUHJvdmlkZXJzKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXdhaXQgYmFja2VuZC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcihmaWxlUGF0aE9yVWludDhBcnJheSwgb3B0aW9uc1dpdGhWYWxpZGF0ZWRFUHMpO1xuICAgICAgICBUUkFDRV9GVU5DX0VORCgpO1xuICAgICAgICByZXR1cm4gbmV3IEluZmVyZW5jZVNlc3Npb24oaGFuZGxlcik7XG4gICAgfVxuICAgIHN0YXJ0UHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKTtcbiAgICB9XG4gICAgZW5kUHJvZmlsaW5nKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCk7XG4gICAgfVxuICAgIGdldCBpbnB1dE5hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXM7XG4gICAgfVxuICAgIGdldCBvdXRwdXROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmZlcmVuY2Utc2Vzc2lvbi1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ InferenceSession)\n/* harmony export */ });\n/* harmony import */ var _inference_session_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inference-session-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InferenceSession = _inference_session_impl_js__WEBPACK_IMPORTED_MODULE_0__.InferenceSession;\n//# sourceMappingURL=inference-session.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vaW5mZXJlbmNlLXNlc3Npb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ3VGO0FBQ3ZGO0FBQ08seUJBQXlCLHdFQUFvQjtBQUNwRCIsInNvdXJjZXMiOlsiL1VzZXJzL3NvaGFtL21vZHVsL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLWNvbW1vbi9kaXN0L2VzbS9pbmZlcmVuY2Utc2Vzc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmltcG9ydCB7IEluZmVyZW5jZVNlc3Npb24gYXMgSW5mZXJlbmNlU2Vzc2lvbkltcGwgfSBmcm9tICcuL2luZmVyZW5jZS1zZXNzaW9uLWltcGwuanMnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZXhwb3J0IGNvbnN0IEluZmVyZW5jZVNlc3Npb24gPSBJbmZlcmVuY2VTZXNzaW9uSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS1zZXNzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/inference-session.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-model.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-model.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=onnx-model.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vb25ueC1tb2RlbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vb25ueC1tb2RlbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubngtbW9kZWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-model.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-value.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-value.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=onnx-value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vb25ueC12YWx1ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNVO0FBQ1YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vb25ueC12YWx1ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ubngtdmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/onnx-value.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   tensorToDataURL: () => (/* binding */ tensorToDataURL),\n/* harmony export */   tensorToImageData: () => (/* binding */ tensorToImageData)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n/**\n * implementation of Tensor.toDataURL()\n */\nconst tensorToDataURL = (tensor, options) => {\n    const canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(1, 1);\n    canvas.width = tensor.dims[3];\n    canvas.height = tensor.dims[2];\n    const pixels2DContext = canvas.getContext('2d');\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n            width = tensor.dims[2];\n            height = tensor.dims[3];\n        }\n        else {\n            // Default layout is NCWH\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n        }\n        const inputformat = options?.format !== undefined ? options.format : 'RGB';\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [255, 255, 255, 255];\n        }\n        else {\n            if (typeof norm.mean === 'number') {\n                normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n            }\n            else {\n                normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 0];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [0, 0, 0, 0];\n        }\n        else {\n            if (typeof norm.bias === 'number') {\n                normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n            }\n            else {\n                normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        // Default pointer assignments\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === 'RGBA') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        }\n        else if (inputformat === 'RGB') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        }\n        else if (inputformat === 'RBG') {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        for (let i = 0; i < height; i++) {\n            for (let j = 0; j < width; j++) {\n                const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n                const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n                const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n                const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';\n                pixels2DContext.fillRect(j, i, 1, 1);\n            }\n        }\n        if ('toDataURL' in canvas) {\n            return canvas.toDataURL();\n        }\n        else {\n            throw new Error('toDataURL is not supported');\n        }\n    }\n    else {\n        throw new Error('Can not access image data');\n    }\n};\n/**\n * implementation of Tensor.toImageData()\n */\nconst tensorToImageData = (tensor, options) => {\n    const pixels2DContext = typeof document !== 'undefined'\n        ? document.createElement('canvas').getContext('2d')\n        : new OffscreenCanvas(1, 1).getContext('2d');\n    let image;\n    if (pixels2DContext != null) {\n        // Default values for height and width & format\n        let width;\n        let height;\n        let channels;\n        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {\n            width = tensor.dims[2];\n            height = tensor.dims[1];\n            channels = tensor.dims[3];\n        }\n        else {\n            // Default layout is NCWH\n            width = tensor.dims[3];\n            height = tensor.dims[2];\n            channels = tensor.dims[1];\n        }\n        const inputformat = options !== undefined ? (options.format !== undefined ? options.format : 'RGB') : 'RGB';\n        const norm = options?.norm;\n        let normMean;\n        let normBias;\n        if (norm === undefined || norm.mean === undefined) {\n            normMean = [255, 255, 255, 255];\n        }\n        else {\n            if (typeof norm.mean === 'number') {\n                normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n            }\n            else {\n                normMean = [norm.mean[0], norm.mean[1], norm.mean[2], 255];\n                if (norm.mean[3] !== undefined) {\n                    normMean[3] = norm.mean[3];\n                }\n            }\n        }\n        if (norm === undefined || norm.bias === undefined) {\n            normBias = [0, 0, 0, 0];\n        }\n        else {\n            if (typeof norm.bias === 'number') {\n                normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n            }\n            else {\n                normBias = [norm.bias[0], norm.bias[1], norm.bias[2], 0];\n                if (norm.bias[3] !== undefined) {\n                    normBias[3] = norm.bias[3];\n                }\n            }\n        }\n        const stride = height * width;\n        if (options !== undefined) {\n            if ((options.format !== undefined && channels === 4 && options.format !== 'RGBA') ||\n                (channels === 3 && options.format !== 'RGB' && options.format !== 'BGR')) {\n                throw new Error(\"Tensor format doesn't match input tensor dims\");\n            }\n        }\n        // Default pointer assignments\n        const step = 4;\n        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n        // Updating the pointer assignments based on the input image format\n        if (inputformat === 'RGBA') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n            aTensorPointer = stride * 3;\n        }\n        else if (inputformat === 'RGB') {\n            rTensorPointer = 0;\n            gTensorPointer = stride;\n            bTensorPointer = stride * 2;\n        }\n        else if (inputformat === 'RBG') {\n            rTensorPointer = 0;\n            bTensorPointer = stride;\n            gTensorPointer = stride * 2;\n        }\n        image = pixels2DContext.createImageData(width, height);\n        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {\n            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value\n            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value\n            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value\n            image.data[aImagePointer] =\n                aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value\n        }\n    }\n    else {\n        throw new Error('Can not access image data');\n    }\n    return image;\n};\n//# sourceMappingURL=tensor-conversion-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWNvbnZlcnNpb24taW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDLDRCQUE0QixXQUFXO0FBQ3ZDLHVGQUF1RjtBQUN2Rix1RkFBdUY7QUFDdkYsdUZBQXVGO0FBQ3ZGLHFIQUFxSDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QyxxR0FBcUc7QUFDckcscUdBQXFHO0FBQ3JHLHFHQUFxRztBQUNyRztBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RlbnNvci1jb252ZXJzaW9uLWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci50b0RhdGFVUkwoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9EYXRhVVJMID0gKHRlbnNvciwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgY2FudmFzLndpZHRoID0gdGVuc29yLmRpbXNbM107XG4gICAgY2FudmFzLmhlaWdodCA9IHRlbnNvci5kaW1zWzJdO1xuICAgIGNvbnN0IHBpeGVsczJEQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIGlmIChvcHRpb25zPy50ZW5zb3JMYXlvdXQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnRlbnNvckxheW91dCA9PT0gJ05IV0MnKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzJdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbM107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXRmb3JtYXQgPSBvcHRpb25zPy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogJ1JHQic7XG4gICAgICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zPy5ub3JtO1xuICAgICAgICBsZXQgbm9ybU1lYW47XG4gICAgICAgIGxldCBub3JtQmlhcztcbiAgICAgICAgaWYgKG5vcm0gPT09IHVuZGVmaW5lZCB8fCBub3JtLm1lYW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9ybU1lYW4gPSBbMjU1LCAyNTUsIDI1NSwgMjU1XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9ybS5tZWFuID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG5vcm1NZWFuID0gW25vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW4sIG5vcm0ubWVhbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW5bMF0sIG5vcm0ubWVhblsxXSwgbm9ybS5tZWFuWzJdLCAwXTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICAgICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIC8vIERlZmF1bHQgcG9pbnRlciBhc3NpZ25tZW50c1xuICAgICAgICBsZXQgclRlbnNvclBvaW50ZXIgPSAwLCBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSwgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyLCBhVGVuc29yUG9pbnRlciA9IC0xO1xuICAgICAgICAvLyBVcGRhdGluZyB0aGUgcG9pbnRlciBhc3NpZ25tZW50cyBiYXNlZCBvbiB0aGUgaW5wdXQgaW1hZ2UgZm9ybWF0XG4gICAgICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgYlRlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgUiA9ICh0ZW5zb3IuZGF0YVtyVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzBdKSAqIG5vcm1NZWFuWzBdOyAvLyBSIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgRyA9ICh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgQiA9ICh0ZW5zb3IuZGF0YVtiVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzJdKSAqIG5vcm1NZWFuWzJdOyAvLyBCIHZhbHVlXG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzXG4gICAgICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKCcgKyBSICsgJywnICsgRyArICcsJyArIEIgKyAnLCcgKyBBICsgJyknO1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5maWxsUmVjdChqLCBpLCAxLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJ3RvRGF0YVVSTCcgaW4gY2FudmFzKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICB9XG59O1xuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IudG9JbWFnZURhdGEoKVxuICovXG5leHBvcnQgY29uc3QgdGVuc29yVG9JbWFnZURhdGEgPSAodGVuc29yLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgOiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpLmdldENvbnRleHQoJzJkJyk7XG4gICAgbGV0IGltYWdlO1xuICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aCAmIGZvcm1hdFxuICAgICAgICBsZXQgd2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQ7XG4gICAgICAgIGxldCBjaGFubmVscztcbiAgICAgICAgaWYgKG9wdGlvbnM/LnRlbnNvckxheW91dCAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGVuc29yLmRpbXNbMl07XG4gICAgICAgICAgICBoZWlnaHQgPSB0ZW5zb3IuZGltc1sxXTtcbiAgICAgICAgICAgIGNoYW5uZWxzID0gdGVuc29yLmRpbXNbM107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0IGxheW91dCBpcyBOQ1dIXG4gICAgICAgICAgICB3aWR0aCA9IHRlbnNvci5kaW1zWzNdO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGVuc29yLmRpbXNbMl07XG4gICAgICAgICAgICBjaGFubmVscyA9IHRlbnNvci5kaW1zWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0Zm9ybWF0ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICAgICAgICBjb25zdCBub3JtID0gb3B0aW9ucz8ubm9ybTtcbiAgICAgICAgbGV0IG5vcm1NZWFuO1xuICAgICAgICBsZXQgbm9ybUJpYXM7XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5tZWFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1NZWFuID0gWzI1NSwgMjU1LCAyNTUsIDI1NV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vcm0ubWVhbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgMjU1XTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybS5tZWFuWzNdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybU1lYW5bM10gPSBub3JtLm1lYW5bM107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtID09PSB1bmRlZmluZWQgfHwgbm9ybS5iaWFzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vcm1CaWFzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBub3JtLmJpYXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzLCBub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vcm1CaWFzID0gW25vcm0uYmlhc1swXSwgbm9ybS5iaWFzWzFdLCBub3JtLmJpYXNbMl0sIDBdO1xuICAgICAgICAgICAgICAgIGlmIChub3JtLmJpYXNbM10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBub3JtQmlhc1szXSA9IG5vcm0uYmlhc1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaWRlID0gaGVpZ2h0ICogd2lkdGg7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBjaGFubmVscyA9PT0gNCAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQkEnKSB8fFxuICAgICAgICAgICAgICAgIChjaGFubmVscyA9PT0gMyAmJiBvcHRpb25zLmZvcm1hdCAhPT0gJ1JHQicgJiYgb3B0aW9ucy5mb3JtYXQgIT09ICdCR1InKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICAgICAgY29uc3Qgc3RlcCA9IDQ7XG4gICAgICAgIGxldCBySW1hZ2VQb2ludGVyID0gMCwgZ0ltYWdlUG9pbnRlciA9IDEsIGJJbWFnZVBvaW50ZXIgPSAyLCBhSW1hZ2VQb2ludGVyID0gMztcbiAgICAgICAgbGV0IHJUZW5zb3JQb2ludGVyID0gMCwgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUsIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMiwgYVRlbnNvclBvaW50ZXIgPSAtMTtcbiAgICAgICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgICAgICBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0JBJykge1xuICAgICAgICAgICAgclRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGU7XG4gICAgICAgICAgICBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgICAgICAgICBhVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXRmb3JtYXQgPT09ICdSR0InKSB7XG4gICAgICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JCRycpIHtcbiAgICAgICAgICAgIHJUZW5zb3JQb2ludGVyID0gMDtcbiAgICAgICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICAgICAgZ1RlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gcGl4ZWxzMkRDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQgKiB3aWR0aDsgckltYWdlUG9pbnRlciArPSBzdGVwLCBnSW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgYUltYWdlUG9pbnRlciArPSBzdGVwLCBpKyspIHtcbiAgICAgICAgICAgIGltYWdlLmRhdGFbckltYWdlUG9pbnRlcl0gPSAodGVuc29yLmRhdGFbclRlbnNvclBvaW50ZXIrK10gLSBub3JtQmlhc1swXSkgKiBub3JtTWVhblswXTsgLy8gUiB2YWx1ZVxuICAgICAgICAgICAgaW1hZ2UuZGF0YVtnSW1hZ2VQb2ludGVyXSA9ICh0ZW5zb3IuZGF0YVtnVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzFdKSAqIG5vcm1NZWFuWzFdOyAvLyBHIHZhbHVlXG4gICAgICAgICAgICBpbWFnZS5kYXRhW2JJbWFnZVBvaW50ZXJdID0gKHRlbnNvci5kYXRhW2JUZW5zb3JQb2ludGVyKytdIC0gbm9ybUJpYXNbMl0pICogbm9ybU1lYW5bMl07IC8vIEIgdmFsdWVcbiAgICAgICAgICAgIGltYWdlLmRhdGFbYUltYWdlUG9pbnRlcl0gPVxuICAgICAgICAgICAgICAgIGFUZW5zb3JQb2ludGVyID09PSAtMSA/IDI1NSA6ICh0ZW5zb3IuZGF0YVthVGVuc29yUG9pbnRlcisrXSAtIG5vcm1CaWFzWzNdKSAqIG5vcm1NZWFuWzNdOyAvLyBBIHZhbHVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgIH1cbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLWNvbnZlcnNpb24taW1wbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=tensor-conversion.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWNvbnZlcnNpb24uanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDVTtBQUNWIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RlbnNvci1jb252ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLWNvbnZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bufferToTensor: () => (/* binding */ bufferToTensor),\n/* harmony export */   tensorFromGpuBuffer: () => (/* binding */ tensorFromGpuBuffer),\n/* harmony export */   tensorFromImage: () => (/* binding */ tensorFromImage),\n/* harmony export */   tensorFromMLTensor: () => (/* binding */ tensorFromMLTensor),\n/* harmony export */   tensorFromPinnedBuffer: () => (/* binding */ tensorFromPinnedBuffer),\n/* harmony export */   tensorFromTexture: () => (/* binding */ tensorFromTexture)\n/* harmony export */ });\n/* harmony import */ var _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Create a new tensor object from image object\n *\n * @param buffer - Extracted image buffer data - assuming RGBA format\n * @param imageFormat - input image configuration - required configurations height, width, format\n * @param tensorFormat - output tensor configuration - Default is RGB format\n */\nconst bufferToTensor = (buffer, options) => {\n    if (buffer === undefined) {\n        throw new Error('Image buffer must be defined');\n    }\n    if (options.height === undefined || options.width === undefined) {\n        throw new Error('Image height and width must be defined');\n    }\n    if (options.tensorLayout === 'NHWC') {\n        throw new Error('NHWC Tensor layout is not supported yet');\n    }\n    const { height, width } = options;\n    const norm = options.norm ?? { mean: 255, bias: 0 };\n    let normMean;\n    let normBias;\n    if (typeof norm.mean === 'number') {\n        normMean = [norm.mean, norm.mean, norm.mean, norm.mean];\n    }\n    else {\n        normMean = [norm.mean[0], norm.mean[1], norm.mean[2], norm.mean[3] ?? 255];\n    }\n    if (typeof norm.bias === 'number') {\n        normBias = [norm.bias, norm.bias, norm.bias, norm.bias];\n    }\n    else {\n        normBias = [norm.bias[0], norm.bias[1], norm.bias[2], norm.bias[3] ?? 0];\n    }\n    const inputformat = options.format !== undefined ? options.format : 'RGBA';\n    // default value is RGBA since imagedata and HTMLImageElement uses it\n    const outputformat = options.tensorFormat !== undefined ? (options.tensorFormat !== undefined ? options.tensorFormat : 'RGB') : 'RGB';\n    const stride = height * width;\n    const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);\n    // Default pointer assignments\n    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;\n    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;\n    // Updating the pointer assignments based on the input image format\n    if (inputformat === 'RGB') {\n        step = 3;\n        rImagePointer = 0;\n        gImagePointer = 1;\n        bImagePointer = 2;\n        aImagePointer = -1;\n    }\n    // Updating the pointer assignments based on the output tensor format\n    if (outputformat === 'RGBA') {\n        aTensorPointer = stride * 3;\n    }\n    else if (outputformat === 'RBG') {\n        rTensorPointer = 0;\n        bTensorPointer = stride;\n        gTensorPointer = stride * 2;\n    }\n    else if (outputformat === 'BGR') {\n        bTensorPointer = 0;\n        gTensorPointer = stride;\n        rTensorPointer = stride * 2;\n    }\n    for (let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {\n        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];\n        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];\n        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];\n        if (aTensorPointer !== -1 && aImagePointer !== -1) {\n            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];\n        }\n    }\n    // Float32Array -> ort.Tensor\n    const outputTensor = outputformat === 'RGBA'\n        ? new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor('float32', float32Data, [1, 4, height, width])\n        : new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor('float32', float32Data, [1, 3, height, width]);\n    return outputTensor;\n};\n/**\n * implementation of Tensor.fromImage().\n */\nconst tensorFromImage = async (image, options) => {\n    // checking the type of image object\n    const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;\n    const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;\n    const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;\n    const isString = typeof image === 'string';\n    let data;\n    let bufferToTensorOptions = options ?? {};\n    const createCanvas = () => {\n        if (typeof document !== 'undefined') {\n            return document.createElement('canvas');\n        }\n        else if (typeof OffscreenCanvas !== 'undefined') {\n            return new OffscreenCanvas(1, 1);\n        }\n        else {\n            throw new Error('Canvas is not supported');\n        }\n    };\n    const createCanvasContext = (canvas) => {\n        if (typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement) {\n            return canvas.getContext('2d');\n        }\n        else if (canvas instanceof OffscreenCanvas) {\n            return canvas.getContext('2d');\n        }\n        else {\n            return null;\n        }\n    };\n    // filling and checking image configuration options\n    if (isHTMLImageEle) {\n        // HTMLImageElement - image object - format is RGBA by default\n        const canvas = createCanvas();\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = createCanvasContext(canvas);\n        if (pixels2DContext != null) {\n            let height = image.height;\n            let width = image.width;\n            if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {\n                height = options.resizedHeight;\n                width = options.resizedWidth;\n            }\n            if (options !== undefined) {\n                bufferToTensorOptions = options;\n                if (options.tensorFormat !== undefined) {\n                    throw new Error('Image input config format must be RGBA for HTMLImageElement');\n                }\n                else {\n                    bufferToTensorOptions.tensorFormat = 'RGBA';\n                }\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            }\n            else {\n                bufferToTensorOptions.tensorFormat = 'RGBA';\n                bufferToTensorOptions.height = height;\n                bufferToTensorOptions.width = width;\n            }\n            pixels2DContext.drawImage(image, 0, 0);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n        }\n        else {\n            throw new Error('Can not access image data');\n        }\n    }\n    else if (isImageDataEle) {\n        let height;\n        let width;\n        if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {\n            height = options.resizedHeight;\n            width = options.resizedWidth;\n        }\n        else {\n            height = image.height;\n            width = image.width;\n        }\n        if (options !== undefined) {\n            bufferToTensorOptions = options;\n        }\n        bufferToTensorOptions.format = 'RGBA';\n        bufferToTensorOptions.height = height;\n        bufferToTensorOptions.width = width;\n        if (options !== undefined) {\n            const tempCanvas = createCanvas();\n            tempCanvas.width = width;\n            tempCanvas.height = height;\n            const pixels2DContext = createCanvasContext(tempCanvas);\n            if (pixels2DContext != null) {\n                pixels2DContext.putImageData(image, 0, 0);\n                data = pixels2DContext.getImageData(0, 0, width, height).data;\n            }\n            else {\n                throw new Error('Can not access image data');\n            }\n        }\n        else {\n            data = image.data;\n        }\n    }\n    else if (isImageBitmap) {\n        // ImageBitmap - image object - format must be provided by user\n        if (options === undefined) {\n            throw new Error('Please provide image config with format for Imagebitmap');\n        }\n        const canvas = createCanvas();\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const pixels2DContext = createCanvasContext(canvas);\n        if (pixels2DContext != null) {\n            const height = image.height;\n            const width = image.width;\n            pixels2DContext.drawImage(image, 0, 0, width, height);\n            data = pixels2DContext.getImageData(0, 0, width, height).data;\n            bufferToTensorOptions.height = height;\n            bufferToTensorOptions.width = width;\n            return bufferToTensor(data, bufferToTensorOptions);\n        }\n        else {\n            throw new Error('Can not access image data');\n        }\n    }\n    else if (isString) {\n        return new Promise((resolve, reject) => {\n            const canvas = createCanvas();\n            const context = createCanvasContext(canvas);\n            if (!image || !context) {\n                return reject();\n            }\n            const newImage = new Image();\n            newImage.crossOrigin = 'Anonymous';\n            newImage.src = image;\n            newImage.onload = () => {\n                canvas.width = newImage.width;\n                canvas.height = newImage.height;\n                context.drawImage(newImage, 0, 0, canvas.width, canvas.height);\n                const img = context.getImageData(0, 0, canvas.width, canvas.height);\n                bufferToTensorOptions.height = canvas.height;\n                bufferToTensorOptions.width = canvas.width;\n                resolve(bufferToTensor(img.data, bufferToTensorOptions));\n            };\n        });\n    }\n    else {\n        throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n    if (data !== undefined) {\n        return bufferToTensor(data, bufferToTensorOptions);\n    }\n    else {\n        throw new Error('Input data provided is not supported - aborted tensor creation');\n    }\n};\n/**\n * implementation of Tensor.fromTexture().\n */\nconst tensorFromTexture = (texture, options) => {\n    const { width, height, download, dispose } = options;\n    // Always assume RGBAF32. TODO: support different texture format\n    const dims = [1, height, width, 4];\n    return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({ location: 'texture', type: 'float32', texture, dims, download, dispose });\n};\n/**\n * implementation of Tensor.fromGpuBuffer().\n */\nconst tensorFromGpuBuffer = (gpuBuffer, options) => {\n    const { dataType, dims, download, dispose } = options;\n    return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({ location: 'gpu-buffer', type: dataType ?? 'float32', gpuBuffer, dims, download, dispose });\n};\n/**\n * implementation of Tensor.fromMLTensor().\n */\nconst tensorFromMLTensor = (mlTensor, options) => {\n    const { dataType, dims, download, dispose } = options;\n    return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({ location: 'ml-tensor', type: dataType ?? 'float32', mlTensor, dims, download, dispose });\n};\n/**\n * implementation of Tensor.fromPinnedBuffer().\n */\nconst tensorFromPinnedBuffer = (type, buffer, dims) => new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({ location: 'cpu-pinned', type, data: buffer, dims: dims ?? [buffer.length] });\n//# sourceMappingURL=tensor-factory-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWZhY3RvcnktaW1wbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1EQUFNO0FBQ3BCLGNBQWMsbURBQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQSxlQUFlLG1EQUFNLEdBQUcsd0VBQXdFO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG9DQUFvQztBQUNoRCxlQUFlLG1EQUFNLEdBQUcseUZBQXlGO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG9DQUFvQztBQUNoRCxlQUFlLG1EQUFNLEdBQUcsdUZBQXVGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkRBQTJELG1EQUFNLEdBQUcsMkVBQTJFO0FBQ3RKIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RlbnNvci1mYWN0b3J5LWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHRlbnNvciBvYmplY3QgZnJvbSBpbWFnZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIC0gRXh0cmFjdGVkIGltYWdlIGJ1ZmZlciBkYXRhIC0gYXNzdW1pbmcgUkdCQSBmb3JtYXRcbiAqIEBwYXJhbSBpbWFnZUZvcm1hdCAtIGlucHV0IGltYWdlIGNvbmZpZ3VyYXRpb24gLSByZXF1aXJlZCBjb25maWd1cmF0aW9ucyBoZWlnaHQsIHdpZHRoLCBmb3JtYXRcbiAqIEBwYXJhbSB0ZW5zb3JGb3JtYXQgLSBvdXRwdXQgdGVuc29yIGNvbmZpZ3VyYXRpb24gLSBEZWZhdWx0IGlzIFJHQiBmb3JtYXRcbiAqL1xuZXhwb3J0IGNvbnN0IGJ1ZmZlclRvVGVuc29yID0gKGJ1ZmZlciwgb3B0aW9ucykgPT4ge1xuICAgIGlmIChidWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVpZ2h0ID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGVuc29yTGF5b3V0ID09PSAnTkhXQycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG5vcm0gPSBvcHRpb25zLm5vcm0gPz8geyBtZWFuOiAyNTUsIGJpYXM6IDAgfTtcbiAgICBsZXQgbm9ybU1lYW47XG4gICAgbGV0IG5vcm1CaWFzO1xuICAgIGlmICh0eXBlb2Ygbm9ybS5tZWFuID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtTWVhbiA9IFtub3JtLm1lYW4sIG5vcm0ubWVhbiwgbm9ybS5tZWFuLCBub3JtLm1lYW5dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9ybU1lYW4gPSBbbm9ybS5tZWFuWzBdLCBub3JtLm1lYW5bMV0sIG5vcm0ubWVhblsyXSwgbm9ybS5tZWFuWzNdID8/IDI1NV07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygbm9ybS5iaWFzID09PSAnbnVtYmVyJykge1xuICAgICAgICBub3JtQmlhcyA9IFtub3JtLmJpYXMsIG5vcm0uYmlhcywgbm9ybS5iaWFzLCBub3JtLmJpYXNdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9ybUJpYXMgPSBbbm9ybS5iaWFzWzBdLCBub3JtLmJpYXNbMV0sIG5vcm0uYmlhc1syXSwgbm9ybS5iaWFzWzNdID8/IDBdO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZvcm1hdCA6ICdSR0JBJztcbiAgICAvLyBkZWZhdWx0IHZhbHVlIGlzIFJHQkEgc2luY2UgaW1hZ2VkYXRhIGFuZCBIVE1MSW1hZ2VFbGVtZW50IHVzZXMgaXRcbiAgICBjb25zdCBvdXRwdXRmb3JtYXQgPSBvcHRpb25zLnRlbnNvckZvcm1hdCAhPT0gdW5kZWZpbmVkID8gKG9wdGlvbnMudGVuc29yRm9ybWF0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRlbnNvckZvcm1hdCA6ICdSR0InKSA6ICdSR0InO1xuICAgIGNvbnN0IHN0cmlkZSA9IGhlaWdodCAqIHdpZHRoO1xuICAgIGNvbnN0IGZsb2F0MzJEYXRhID0gb3V0cHV0Zm9ybWF0ID09PSAnUkdCQScgPyBuZXcgRmxvYXQzMkFycmF5KHN0cmlkZSAqIDQpIDogbmV3IEZsb2F0MzJBcnJheShzdHJpZGUgKiAzKTtcbiAgICAvLyBEZWZhdWx0IHBvaW50ZXIgYXNzaWdubWVudHNcbiAgICBsZXQgc3RlcCA9IDQsIHJJbWFnZVBvaW50ZXIgPSAwLCBnSW1hZ2VQb2ludGVyID0gMSwgYkltYWdlUG9pbnRlciA9IDIsIGFJbWFnZVBvaW50ZXIgPSAzO1xuICAgIGxldCByVGVuc29yUG9pbnRlciA9IDAsIGdUZW5zb3JQb2ludGVyID0gc3RyaWRlLCBiVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDIsIGFUZW5zb3JQb2ludGVyID0gLTE7XG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIGlucHV0IGltYWdlIGZvcm1hdFxuICAgIGlmIChpbnB1dGZvcm1hdCA9PT0gJ1JHQicpIHtcbiAgICAgICAgc3RlcCA9IDM7XG4gICAgICAgIHJJbWFnZVBvaW50ZXIgPSAwO1xuICAgICAgICBnSW1hZ2VQb2ludGVyID0gMTtcbiAgICAgICAgYkltYWdlUG9pbnRlciA9IDI7XG4gICAgICAgIGFJbWFnZVBvaW50ZXIgPSAtMTtcbiAgICB9XG4gICAgLy8gVXBkYXRpbmcgdGhlIHBvaW50ZXIgYXNzaWdubWVudHMgYmFzZWQgb24gdGhlIG91dHB1dCB0ZW5zb3IgZm9ybWF0XG4gICAgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ1JHQkEnKSB7XG4gICAgICAgIGFUZW5zb3JQb2ludGVyID0gc3RyaWRlICogMztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0cHV0Zm9ybWF0ID09PSAnUkJHJykge1xuICAgICAgICByVGVuc29yUG9pbnRlciA9IDA7XG4gICAgICAgIGJUZW5zb3JQb2ludGVyID0gc3RyaWRlO1xuICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZSAqIDI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dHB1dGZvcm1hdCA9PT0gJ0JHUicpIHtcbiAgICAgICAgYlRlbnNvclBvaW50ZXIgPSAwO1xuICAgICAgICBnVGVuc29yUG9pbnRlciA9IHN0cmlkZTtcbiAgICAgICAgclRlbnNvclBvaW50ZXIgPSBzdHJpZGUgKiAyO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSsrLCBySW1hZ2VQb2ludGVyICs9IHN0ZXAsIGJJbWFnZVBvaW50ZXIgKz0gc3RlcCwgZ0ltYWdlUG9pbnRlciArPSBzdGVwLCBhSW1hZ2VQb2ludGVyICs9IHN0ZXApIHtcbiAgICAgICAgZmxvYXQzMkRhdGFbclRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW3JJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbMF0pIC8gbm9ybU1lYW5bMF07XG4gICAgICAgIGZsb2F0MzJEYXRhW2dUZW5zb3JQb2ludGVyKytdID0gKGJ1ZmZlcltnSW1hZ2VQb2ludGVyXSArIG5vcm1CaWFzWzFdKSAvIG5vcm1NZWFuWzFdO1xuICAgICAgICBmbG9hdDMyRGF0YVtiVGVuc29yUG9pbnRlcisrXSA9IChidWZmZXJbYkltYWdlUG9pbnRlcl0gKyBub3JtQmlhc1syXSkgLyBub3JtTWVhblsyXTtcbiAgICAgICAgaWYgKGFUZW5zb3JQb2ludGVyICE9PSAtMSAmJiBhSW1hZ2VQb2ludGVyICE9PSAtMSkge1xuICAgICAgICAgICAgZmxvYXQzMkRhdGFbYVRlbnNvclBvaW50ZXIrK10gPSAoYnVmZmVyW2FJbWFnZVBvaW50ZXJdICsgbm9ybUJpYXNbM10pIC8gbm9ybU1lYW5bM107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmxvYXQzMkFycmF5IC0+IG9ydC5UZW5zb3JcbiAgICBjb25zdCBvdXRwdXRUZW5zb3IgPSBvdXRwdXRmb3JtYXQgPT09ICdSR0JBJ1xuICAgICAgICA/IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDQsIGhlaWdodCwgd2lkdGhdKVxuICAgICAgICA6IG5ldyBUZW5zb3IoJ2Zsb2F0MzInLCBmbG9hdDMyRGF0YSwgWzEsIDMsIGhlaWdodCwgd2lkdGhdKTtcbiAgICByZXR1cm4gb3V0cHV0VGVuc29yO1xufTtcbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21JbWFnZSgpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUltYWdlID0gYXN5bmMgKGltYWdlLCBvcHRpb25zKSA9PiB7XG4gICAgLy8gY2hlY2tpbmcgdGhlIHR5cGUgb2YgaW1hZ2Ugb2JqZWN0XG4gICAgY29uc3QgaXNIVE1MSW1hZ2VFbGUgPSB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50O1xuICAgIGNvbnN0IGlzSW1hZ2VEYXRhRWxlID0gdHlwZW9mIEltYWdlRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGE7XG4gICAgY29uc3QgaXNJbWFnZUJpdG1hcCA9IHR5cGVvZiBJbWFnZUJpdG1hcCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcDtcbiAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBpbWFnZSA9PT0gJ3N0cmluZyc7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnMgPz8ge307XG4gICAgY29uc3QgY3JlYXRlQ2FudmFzID0gKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY3JlYXRlQ2FudmFzQ29udGV4dCA9IChjYW52YXMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBmaWxsaW5nIGFuZCBjaGVja2luZyBpbWFnZSBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICBpZiAoaXNIVE1MSW1hZ2VFbGUpIHtcbiAgICAgICAgLy8gSFRNTEltYWdlRWxlbWVudCAtIGltYWdlIG9iamVjdCAtIGZvcm1hdCBpcyBSR0JBIGJ5IGRlZmF1bHRcbiAgICAgICAgY29uc3QgY2FudmFzID0gY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb25zdCBwaXhlbHMyRENvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGxldCB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRIZWlnaHQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLnJlc2l6ZWRXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gb3B0aW9ucy5yZXNpemVkSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy50ZW5zb3JGb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMudGVuc29yRm9ybWF0ID0gJ1JHQkEnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLnRlbnNvckZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGl4ZWxzMkRDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgICAgICAgICBkYXRhID0gcGl4ZWxzMkRDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbWFnZURhdGFFbGUpIHtcbiAgICAgICAgbGV0IGhlaWdodDtcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVzaXplZFdpZHRoICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5yZXNpemVkSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG9wdGlvbnMucmVzaXplZEhlaWdodDtcbiAgICAgICAgICAgIHdpZHRoID0gb3B0aW9ucy5yZXNpemVkV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmZvcm1hdCA9ICdSR0JBJztcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dCh0ZW1wQ2FudmFzKTtcbiAgICAgICAgICAgIGlmIChwaXhlbHMyRENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBpeGVsczJEQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgYWNjZXNzIGltYWdlIGRhdGEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSBpbWFnZS5kYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgLy8gSW1hZ2VCaXRtYXAgLSBpbWFnZSBvYmplY3QgLSBmb3JtYXQgbXVzdCBiZSBwcm92aWRlZCBieSB1c2VyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgaW1hZ2UgY29uZmlnIHdpdGggZm9ybWF0IGZvciBJbWFnZWJpdG1hcCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNyZWF0ZUNhbnZhcygpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgY29uc3QgcGl4ZWxzMkRDb250ZXh0ID0gY3JlYXRlQ2FudmFzQ29udGV4dChjYW52YXMpO1xuICAgICAgICBpZiAocGl4ZWxzMkRDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBwaXhlbHMyRENvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGRhdGEgPSBwaXhlbHMyRENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XG4gICAgICAgICAgICBidWZmZXJUb1RlbnNvck9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyVG9UZW5zb3IoZGF0YSwgYnVmZmVyVG9UZW5zb3JPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBjcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDYW52YXNDb250ZXh0KGNhbnZhcyk7XG4gICAgICAgICAgICBpZiAoIWltYWdlIHx8ICFjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3SW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIG5ld0ltYWdlLmNyb3NzT3JpZ2luID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICBuZXdJbWFnZS5zcmMgPSBpbWFnZTtcbiAgICAgICAgICAgIG5ld0ltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBuZXdJbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKG5ld0ltYWdlLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltZyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyVG9UZW5zb3JPcHRpb25zLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYnVmZmVyVG9UZW5zb3IoaW1nLmRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gICAgfVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclRvVGVuc29yKGRhdGEsIGJ1ZmZlclRvVGVuc29yT3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uJyk7XG4gICAgfVxufTtcbi8qKlxuICogaW1wbGVtZW50YXRpb24gb2YgVGVuc29yLmZyb21UZXh0dXJlKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tVGV4dHVyZSA9ICh0ZXh0dXJlLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgICAvLyBBbHdheXMgYXNzdW1lIFJHQkFGMzIuIFRPRE86IHN1cHBvcnQgZGlmZmVyZW50IHRleHR1cmUgZm9ybWF0XG4gICAgY29uc3QgZGltcyA9IFsxLCBoZWlnaHQsIHdpZHRoLCA0XTtcbiAgICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAndGV4dHVyZScsIHR5cGU6ICdmbG9hdDMyJywgdGV4dHVyZSwgZGltcywgZG93bmxvYWQsIGRpc3Bvc2UgfSk7XG59O1xuLyoqXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiBUZW5zb3IuZnJvbUdwdUJ1ZmZlcigpLlxuICovXG5leHBvcnQgY29uc3QgdGVuc29yRnJvbUdwdUJ1ZmZlciA9IChncHVCdWZmZXIsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGRhdGFUeXBlLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnZ3B1LWJ1ZmZlcicsIHR5cGU6IGRhdGFUeXBlID8/ICdmbG9hdDMyJywgZ3B1QnVmZmVyLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tTUxUZW5zb3IoKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvckZyb21NTFRlbnNvciA9IChtbFRlbnNvciwgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YVR5cGUsIGRpbXMsIGRvd25sb2FkLCBkaXNwb3NlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBuZXcgVGVuc29yKHsgbG9jYXRpb246ICdtbC10ZW5zb3InLCB0eXBlOiBkYXRhVHlwZSA/PyAnZmxvYXQzMicsIG1sVGVuc29yLCBkaW1zLCBkb3dubG9hZCwgZGlzcG9zZSB9KTtcbn07XG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5mcm9tUGlubmVkQnVmZmVyKCkuXG4gKi9cbmV4cG9ydCBjb25zdCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyID0gKHR5cGUsIGJ1ZmZlciwgZGltcykgPT4gbmV3IFRlbnNvcih7IGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsIHR5cGUsIGRhdGE6IGJ1ZmZlciwgZGltczogZGltcyA/PyBbYnVmZmVyLmxlbmd0aF0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItZmFjdG9yeS1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n//# sourceMappingURL=tensor-factory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWZhY3RvcnkuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDVTtBQUNWIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RlbnNvci1mYWN0b3J5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuZXhwb3J0IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLWZhY3RvcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP: () => (/* binding */ NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP),\n/* harmony export */   NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP: () => (/* binding */ NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP),\n/* harmony export */   checkTypedArray: () => (/* binding */ checkTypedArray)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([\n    ['float32', Float32Array],\n    ['uint8', Uint8Array],\n    ['int8', Int8Array],\n    ['uint16', Uint16Array],\n    ['int16', Int16Array],\n    ['int32', Int32Array],\n    ['bool', Uint8Array],\n    ['float64', Float64Array],\n    ['uint32', Uint32Array],\n    ['int4', Uint8Array],\n    ['uint4', Uint8Array],\n]);\n// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.\nconst NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([\n    [Float32Array, 'float32'],\n    [Uint8Array, 'uint8'],\n    [Int8Array, 'int8'],\n    [Uint16Array, 'uint16'],\n    [Int16Array, 'int16'],\n    [Int32Array, 'int32'],\n    [Float64Array, 'float64'],\n    [Uint32Array, 'uint32'],\n]);\n// the following code allows delaying execution of BigInt/Float16Array checking. This allows lazy initialization for\n// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt/Float16Array\n// polyfill if available.\nlet isTypedArrayChecked = false;\nconst checkTypedArray = () => {\n    if (!isTypedArrayChecked) {\n        isTypedArrayChecked = true;\n        const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && BigInt64Array.from;\n        const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && BigUint64Array.from;\n        // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-explicit-any\n        const Float16Array = globalThis.Float16Array;\n        const isFloat16ArrayAvailable = typeof Float16Array !== 'undefined' && Float16Array.from;\n        if (isBigInt64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');\n        }\n        if (isBigUint64ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');\n        }\n        if (isFloat16ArrayAvailable) {\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Float16Array);\n            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, 'float16');\n        }\n        else {\n            // if Float16Array is not available, use 'Uint16Array' to store the data.\n            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Uint16Array);\n        }\n    }\n};\n//# sourceMappingURL=tensor-impl-type-mapping.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RlbnNvci1pbXBsLXR5cGUtbWFwcGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbi8vIGEgcnVudGltZSBtYXAgdGhhdCBtYXBzIHR5cGUgc3RyaW5nIHRvIFR5cGVkQXJyYXkgY29uc3RydWN0b3IuIFNob3VsZCBtYXRjaCBUZW5zb3IuRGF0YVR5cGVNYXAuXG5leHBvcnQgY29uc3QgTlVNRVJJQ19URU5TT1JfVFlQRV9UT19UWVBFREFSUkFZX01BUCA9IG5ldyBNYXAoW1xuICAgIFsnZmxvYXQzMicsIEZsb2F0MzJBcnJheV0sXG4gICAgWyd1aW50OCcsIFVpbnQ4QXJyYXldLFxuICAgIFsnaW50OCcsIEludDhBcnJheV0sXG4gICAgWyd1aW50MTYnLCBVaW50MTZBcnJheV0sXG4gICAgWydpbnQxNicsIEludDE2QXJyYXldLFxuICAgIFsnaW50MzInLCBJbnQzMkFycmF5XSxcbiAgICBbJ2Jvb2wnLCBVaW50OEFycmF5XSxcbiAgICBbJ2Zsb2F0NjQnLCBGbG9hdDY0QXJyYXldLFxuICAgIFsndWludDMyJywgVWludDMyQXJyYXldLFxuICAgIFsnaW50NCcsIFVpbnQ4QXJyYXldLFxuICAgIFsndWludDQnLCBVaW50OEFycmF5XSxcbl0pO1xuLy8gYSBydW50aW1lIG1hcCB0aGF0IG1hcHMgdHlwZSBzdHJpbmcgdG8gVHlwZWRBcnJheSBjb25zdHJ1Y3Rvci4gU2hvdWxkIG1hdGNoIFRlbnNvci5EYXRhVHlwZU1hcC5cbmV4cG9ydCBjb25zdCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQID0gbmV3IE1hcChbXG4gICAgW0Zsb2F0MzJBcnJheSwgJ2Zsb2F0MzInXSxcbiAgICBbVWludDhBcnJheSwgJ3VpbnQ4J10sXG4gICAgW0ludDhBcnJheSwgJ2ludDgnXSxcbiAgICBbVWludDE2QXJyYXksICd1aW50MTYnXSxcbiAgICBbSW50MTZBcnJheSwgJ2ludDE2J10sXG4gICAgW0ludDMyQXJyYXksICdpbnQzMiddLFxuICAgIFtGbG9hdDY0QXJyYXksICdmbG9hdDY0J10sXG4gICAgW1VpbnQzMkFycmF5LCAndWludDMyJ10sXG5dKTtcbi8vIHRoZSBmb2xsb3dpbmcgY29kZSBhbGxvd3MgZGVsYXlpbmcgZXhlY3V0aW9uIG9mIEJpZ0ludC9GbG9hdDE2QXJyYXkgY2hlY2tpbmcuIFRoaXMgYWxsb3dzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yXG4vLyBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQIGFuZCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB3aGljaCBhbGxvd3MgQmlnSW50L0Zsb2F0MTZBcnJheVxuLy8gcG9seWZpbGwgaWYgYXZhaWxhYmxlLlxubGV0IGlzVHlwZWRBcnJheUNoZWNrZWQgPSBmYWxzZTtcbmV4cG9ydCBjb25zdCBjaGVja1R5cGVkQXJyYXkgPSAoKSA9PiB7XG4gICAgaWYgKCFpc1R5cGVkQXJyYXlDaGVja2VkKSB7XG4gICAgICAgIGlzVHlwZWRBcnJheUNoZWNrZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc0JpZ0ludDY0QXJyYXlBdmFpbGFibGUgPSB0eXBlb2YgQmlnSW50NjRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgQmlnSW50NjRBcnJheS5mcm9tO1xuICAgICAgICBjb25zdCBpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlID0gdHlwZW9mIEJpZ1VpbnQ2NEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBCaWdVaW50NjRBcnJheS5mcm9tO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IEZsb2F0MTZBcnJheSA9IGdsb2JhbFRoaXMuRmxvYXQxNkFycmF5O1xuICAgICAgICBjb25zdCBpc0Zsb2F0MTZBcnJheUF2YWlsYWJsZSA9IHR5cGVvZiBGbG9hdDE2QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEZsb2F0MTZBcnJheS5mcm9tO1xuICAgICAgICBpZiAoaXNCaWdJbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgnaW50NjQnLCBCaWdJbnQ2NEFycmF5KTtcbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEJpZ0ludDY0QXJyYXksICdpbnQ2NCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JpZ1VpbnQ2NEFycmF5QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLnNldCgndWludDY0JywgQmlnVWludDY0QXJyYXkpO1xuICAgICAgICAgICAgTlVNRVJJQ19URU5TT1JfVFlQRURBUlJBWV9UT19UWVBFX01BUC5zZXQoQmlnVWludDY0QXJyYXksICd1aW50NjQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGbG9hdDE2QXJyYXlBdmFpbGFibGUpIHtcbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgRmxvYXQxNkFycmF5KTtcbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVEQVJSQVlfVE9fVFlQRV9NQVAuc2V0KEZsb2F0MTZBcnJheSwgJ2Zsb2F0MTYnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIEZsb2F0MTZBcnJheSBpcyBub3QgYXZhaWxhYmxlLCB1c2UgJ1VpbnQxNkFycmF5JyB0byBzdG9yZSB0aGUgZGF0YS5cbiAgICAgICAgICAgIE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuc2V0KCdmbG9hdDE2JywgVWludDE2QXJyYXkpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci1pbXBsLXR5cGUtbWFwcGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: () => (/* binding */ Tensor)\n/* harmony export */ });\n/* harmony import */ var _tensor_conversion_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-conversion-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js\");\n/* harmony import */ var _tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tensor-factory-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js\");\n/* harmony import */ var _tensor_impl_type_mapping_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tensor-impl-type-mapping.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js\");\n/* harmony import */ var _tensor_utils_impl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tensor-utils-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n\n\n\n/**\n * the implementation of Tensor interface.\n *\n * @ignore\n */\nclass Tensor {\n    /**\n     * implementation.\n     */\n    constructor(arg0, arg1, arg2) {\n        // perform one-time check for BigInt/Float16Array support\n        (0,_tensor_impl_type_mapping_js__WEBPACK_IMPORTED_MODULE_2__.checkTypedArray)();\n        let type;\n        let dims;\n        if (typeof arg0 === 'object' && 'location' in arg0) {\n            //\n            // constructing tensor from specific location\n            //\n            this.dataLocation = arg0.location;\n            type = arg0.type;\n            dims = arg0.dims;\n            switch (arg0.location) {\n                case 'cpu-pinned': {\n                    const expectedTypedArrayConstructor = _tensor_impl_type_mapping_js__WEBPACK_IMPORTED_MODULE_2__.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(type);\n                    if (!expectedTypedArrayConstructor) {\n                        throw new TypeError(`unsupported type \"${type}\" to create tensor from pinned buffer`);\n                    }\n                    if (!(arg0.data instanceof expectedTypedArrayConstructor)) {\n                        throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);\n                    }\n                    this.cpuData = arg0.data;\n                    break;\n                }\n                case 'texture': {\n                    if (type !== 'float32') {\n                        throw new TypeError(`unsupported type \"${type}\" to create tensor from texture`);\n                    }\n                    this.gpuTextureData = arg0.texture;\n                    this.downloader = arg0.download;\n                    this.disposer = arg0.dispose;\n                    break;\n                }\n                case 'gpu-buffer': {\n                    if (type !== 'float32' &&\n                        type !== 'float16' &&\n                        type !== 'int32' &&\n                        type !== 'int64' &&\n                        type !== 'uint32' &&\n                        type !== 'uint8' &&\n                        type !== 'bool' &&\n                        type !== 'uint4' &&\n                        type !== 'int4') {\n                        throw new TypeError(`unsupported type \"${type}\" to create tensor from gpu buffer`);\n                    }\n                    this.gpuBufferData = arg0.gpuBuffer;\n                    this.downloader = arg0.download;\n                    this.disposer = arg0.dispose;\n                    break;\n                }\n                case 'ml-tensor': {\n                    if (type !== 'float32' &&\n                        type !== 'float16' &&\n                        type !== 'int32' &&\n                        type !== 'int64' &&\n                        type !== 'uint32' &&\n                        type !== 'uint64' &&\n                        type !== 'int8' &&\n                        type !== 'uint8' &&\n                        type !== 'bool' &&\n                        type !== 'uint4' &&\n                        type !== 'int4') {\n                        throw new TypeError(`unsupported type \"${type}\" to create tensor from MLTensor`);\n                    }\n                    this.mlTensorData = arg0.mlTensor;\n                    this.downloader = arg0.download;\n                    this.disposer = arg0.dispose;\n                    break;\n                }\n                default:\n                    throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n            }\n        }\n        else {\n            //\n            // constructing tensor of location 'cpu'\n            //\n            let data;\n            let maybeDims;\n            // check whether arg0 is type or data\n            if (typeof arg0 === 'string') {\n                //\n                // Override: constructor(type, data, ...)\n                //\n                type = arg0;\n                maybeDims = arg2;\n                if (arg0 === 'string') {\n                    // string tensor\n                    if (!Array.isArray(arg1)) {\n                        throw new TypeError(\"A string tensor's data must be a string array.\");\n                    }\n                    // we don't check whether every element in the array is string; this is too slow. we assume it's correct and\n                    // error will be populated at inference\n                    data = arg1;\n                }\n                else {\n                    // numeric tensor\n                    const typedArrayConstructor = _tensor_impl_type_mapping_js__WEBPACK_IMPORTED_MODULE_2__.NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);\n                    if (typedArrayConstructor === undefined) {\n                        throw new TypeError(`Unsupported tensor type: ${arg0}.`);\n                    }\n                    if (Array.isArray(arg1)) {\n                        if ((arg0 === 'float16' && typedArrayConstructor === Uint16Array) || arg0 === 'uint4' || arg0 === 'int4') {\n                            // - 'float16':\n                            //   When no Float16Array polyfill is used, we cannot create 'float16' tensor from number array.\n                            //\n                            //   Throw error here because when user try to use number array as data,\n                            //   e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call\n                            //   Uint16Array.from(arg1) which generates wrong data.\n                            //\n                            // - 'uint4' and 'int4':\n                            //   Uint8Array.from(arg1) will generate wrong data for 'uint4' and 'int4' tensor.\n                            //\n                            throw new TypeError(`Creating a ${arg0} tensor from number array is not supported. Please use ${typedArrayConstructor.name} as data.`);\n                        }\n                        else if (arg0 === 'uint64' || arg0 === 'int64') {\n                            // use 'as any' here because:\n                            // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.\n                            // see https://github.com/microsoft/TypeScript/issues/17002\n                            // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()'\n                            // does not accept parameter mapFn.\n                            // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union\n                            // type.\n                            // assume 'arg1' is of type \"readonly number[]|readonly bigint[]\" here.\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data = typedArrayConstructor.from(arg1, BigInt);\n                        }\n                        else {\n                            // assume 'arg1' is of type \"readonly number[]\" here.\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data = typedArrayConstructor.from(arg1);\n                        }\n                    }\n                    else if (arg1 instanceof typedArrayConstructor) {\n                        data = arg1;\n                    }\n                    else if (arg1 instanceof Uint8ClampedArray) {\n                        if (arg0 === 'uint8') {\n                            data = Uint8Array.from(arg1);\n                        }\n                        else {\n                            throw new TypeError(`A Uint8ClampedArray tensor's data must be type of uint8`);\n                        }\n                    }\n                    else if (arg0 === 'float16' && arg1 instanceof Uint16Array && typedArrayConstructor !== Uint16Array) {\n                        // when Float16Array is available and data is of type Uint16Array.\n                        // We allow Uint16Array to be passed in as data for 'float16' tensor until Float16Array is generally\n                        // supported in JavaScript environment.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = new globalThis.Float16Array(arg1.buffer, arg1.byteOffset, arg1.length);\n                    }\n                    else {\n                        throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);\n                    }\n                }\n            }\n            else {\n                //\n                // Override: constructor(data, ...)\n                //\n                maybeDims = arg1;\n                if (Array.isArray(arg0)) {\n                    // only boolean[] and string[] is supported\n                    if (arg0.length === 0) {\n                        throw new TypeError('Tensor type cannot be inferred from an empty array.');\n                    }\n                    const firstElementType = typeof arg0[0];\n                    if (firstElementType === 'string') {\n                        type = 'string';\n                        data = arg0;\n                    }\n                    else if (firstElementType === 'boolean') {\n                        type = 'bool';\n                        // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is\n                        // wrong type. We use 'as any' to make it happy.\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        data = Uint8Array.from(arg0);\n                    }\n                    else {\n                        throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);\n                    }\n                }\n                else if (arg0 instanceof Uint8ClampedArray) {\n                    type = 'uint8';\n                    data = Uint8Array.from(arg0);\n                }\n                else {\n                    // get tensor type from TypedArray\n                    const mappedType = _tensor_impl_type_mapping_js__WEBPACK_IMPORTED_MODULE_2__.NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);\n                    if (mappedType === undefined) {\n                        throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);\n                    }\n                    type = mappedType;\n                    data = arg0;\n                }\n            }\n            // type and data is processed, now processing dims\n            if (maybeDims === undefined) {\n                // assume 1-D tensor if dims omitted\n                maybeDims = [data.length];\n            }\n            else if (!Array.isArray(maybeDims)) {\n                throw new TypeError(\"A tensor's dims must be a number array\");\n            }\n            dims = maybeDims;\n            this.cpuData = data;\n            this.dataLocation = 'cpu';\n        }\n        // perform check on dims\n        const size = (0,_tensor_utils_impl_js__WEBPACK_IMPORTED_MODULE_3__.calculateSize)(dims);\n        // if data is on CPU, check whether data length matches tensor size\n        if (this.cpuData && size !== this.cpuData.length) {\n            if ((type === 'uint4' || type === 'int4') && Math.ceil(size / 2) === this.cpuData.length) {\n                // for (u)int4, the data length is half of the tensor size. So we check this special case when size is odd.\n            }\n            else {\n                throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);\n            }\n        }\n        this.type = type;\n        this.dims = dims;\n        this.size = size;\n    }\n    // #endregion\n    // #region factory\n    static async fromImage(image, options) {\n        return (0,_tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__.tensorFromImage)(image, options);\n    }\n    static fromTexture(texture, options) {\n        return (0,_tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__.tensorFromTexture)(texture, options);\n    }\n    static fromGpuBuffer(gpuBuffer, options) {\n        return (0,_tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__.tensorFromGpuBuffer)(gpuBuffer, options);\n    }\n    static fromMLTensor(mlTensor, options) {\n        return (0,_tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__.tensorFromMLTensor)(mlTensor, options);\n    }\n    static fromPinnedBuffer(type, buffer, dims) {\n        return (0,_tensor_factory_impl_js__WEBPACK_IMPORTED_MODULE_1__.tensorFromPinnedBuffer)(type, buffer, dims);\n    }\n    // #endregion\n    // #region conversions\n    toDataURL(options) {\n        return (0,_tensor_conversion_impl_js__WEBPACK_IMPORTED_MODULE_0__.tensorToDataURL)(this, options);\n    }\n    toImageData(options) {\n        return (0,_tensor_conversion_impl_js__WEBPACK_IMPORTED_MODULE_0__.tensorToImageData)(this, options);\n    }\n    // #endregion\n    // #region properties\n    get data() {\n        this.ensureValid();\n        if (!this.cpuData) {\n            throw new Error('The data is not on CPU. Use `getData()` to download GPU data to CPU, ' +\n                'or use `texture` or `gpuBuffer` property to access the GPU data directly.');\n        }\n        return this.cpuData;\n    }\n    get location() {\n        return this.dataLocation;\n    }\n    get texture() {\n        this.ensureValid();\n        if (!this.gpuTextureData) {\n            throw new Error('The data is not stored as a WebGL texture.');\n        }\n        return this.gpuTextureData;\n    }\n    get gpuBuffer() {\n        this.ensureValid();\n        if (!this.gpuBufferData) {\n            throw new Error('The data is not stored as a WebGPU buffer.');\n        }\n        return this.gpuBufferData;\n    }\n    get mlTensor() {\n        this.ensureValid();\n        if (!this.mlTensorData) {\n            throw new Error('The data is not stored as a WebNN MLTensor.');\n        }\n        return this.mlTensorData;\n    }\n    // #endregion\n    // #region methods\n    async getData(releaseData) {\n        this.ensureValid();\n        switch (this.dataLocation) {\n            case 'cpu':\n            case 'cpu-pinned':\n                return this.data;\n            case 'texture':\n            case 'gpu-buffer':\n            case 'ml-tensor': {\n                if (!this.downloader) {\n                    throw new Error('The current tensor is not created with a specified data downloader.');\n                }\n                if (this.isDownloading) {\n                    throw new Error('The current tensor is being downloaded.');\n                }\n                try {\n                    this.isDownloading = true;\n                    const data = await this.downloader();\n                    this.downloader = undefined;\n                    this.dataLocation = 'cpu';\n                    this.cpuData = data;\n                    if (releaseData && this.disposer) {\n                        this.disposer();\n                        this.disposer = undefined;\n                    }\n                    return data;\n                }\n                finally {\n                    this.isDownloading = false;\n                }\n            }\n            default:\n                throw new Error(`cannot get data from location: ${this.dataLocation}`);\n        }\n    }\n    dispose() {\n        if (this.isDownloading) {\n            throw new Error('The current tensor is being downloaded.');\n        }\n        if (this.disposer) {\n            this.disposer();\n            this.disposer = undefined;\n        }\n        this.cpuData = undefined;\n        this.gpuTextureData = undefined;\n        this.gpuBufferData = undefined;\n        this.mlTensorData = undefined;\n        this.downloader = undefined;\n        this.isDownloading = undefined;\n        this.dataLocation = 'none';\n    }\n    // #endregion\n    // #region tensor utilities\n    ensureValid() {\n        if (this.dataLocation === 'none') {\n            throw new Error('The tensor is disposed.');\n        }\n    }\n    reshape(dims) {\n        this.ensureValid();\n        if (this.downloader || this.disposer) {\n            throw new Error('Cannot reshape a tensor that owns GPU resource.');\n        }\n        return (0,_tensor_utils_impl_js__WEBPACK_IMPORTED_MODULE_3__.tensorReshape)(this, dims);\n    }\n}\n//# sourceMappingURL=tensor-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ2lGO0FBQytEO0FBQ0Q7QUFDekU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwrRkFBcUM7QUFDL0Y7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0Esd0VBQXdFLG1DQUFtQztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxLQUFLO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGtCQUFrQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsK0ZBQXFDO0FBQ3ZGO0FBQ0Esd0VBQXdFLEtBQUs7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTSx3REFBd0QsNEJBQTRCO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsTUFBTSxnQ0FBZ0Msc0JBQXNCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsaUJBQWlCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0ZBQXFDO0FBQzVFO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0VBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUssK0JBQStCLG9CQUFvQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUFlO0FBQzlCO0FBQ0E7QUFDQSxlQUFlLDBFQUFpQjtBQUNoQztBQUNBO0FBQ0EsZUFBZSw0RUFBbUI7QUFDbEM7QUFDQTtBQUNBLGVBQWUsMkVBQWtCO0FBQ2pDO0FBQ0E7QUFDQSxlQUFlLCtFQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkVBQWU7QUFDOUI7QUFDQTtBQUNBLGVBQWUsNkVBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBYTtBQUM1QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyB0ZW5zb3JUb0RhdGFVUkwsIHRlbnNvclRvSW1hZ2VEYXRhIH0gZnJvbSAnLi90ZW5zb3ItY29udmVyc2lvbi1pbXBsLmpzJztcbmltcG9ydCB7IHRlbnNvckZyb21HcHVCdWZmZXIsIHRlbnNvckZyb21JbWFnZSwgdGVuc29yRnJvbU1MVGVuc29yLCB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyLCB0ZW5zb3JGcm9tVGV4dHVyZSwgfSBmcm9tICcuL3RlbnNvci1mYWN0b3J5LWltcGwuanMnO1xuaW1wb3J0IHsgY2hlY2tUeXBlZEFycmF5LCBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLCBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLCB9IGZyb20gJy4vdGVuc29yLWltcGwtdHlwZS1tYXBwaW5nLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNpemUsIHRlbnNvclJlc2hhcGUgfSBmcm9tICcuL3RlbnNvci11dGlscy1pbXBsLmpzJztcbi8qKlxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvciBpbnRlcmZhY2UuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY2xhc3MgVGVuc29yIHtcbiAgICAvKipcbiAgICAgKiBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcmcwLCBhcmcxLCBhcmcyKSB7XG4gICAgICAgIC8vIHBlcmZvcm0gb25lLXRpbWUgY2hlY2sgZm9yIEJpZ0ludC9GbG9hdDE2QXJyYXkgc3VwcG9ydFxuICAgICAgICBjaGVja1R5cGVkQXJyYXkoKTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGxldCBkaW1zO1xuICAgICAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdvYmplY3QnICYmICdsb2NhdGlvbicgaW4gYXJnMCkge1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdGluZyB0ZW5zb3IgZnJvbSBzcGVjaWZpYyBsb2NhdGlvblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gYXJnMC5sb2NhdGlvbjtcbiAgICAgICAgICAgIHR5cGUgPSBhcmcwLnR5cGU7XG4gICAgICAgICAgICBkaW1zID0gYXJnMC5kaW1zO1xuICAgICAgICAgICAgc3dpdGNoIChhcmcwLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOVU1FUklDX1RFTlNPUl9UWVBFX1RPX1RZUEVEQVJSQVlfTUFQLmdldCh0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFleHBlY3RlZFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7dHlwZX1cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGFyZzAuZGF0YSBpbnN0YW5jZW9mIGV4cGVjdGVkVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlZEFycmF5Q29uc3RydWN0b3IubmFtZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNwdURhdGEgPSBhcmcwLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0dXJlJzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSB0ZXh0dXJlYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncHVUZXh0dXJlRGF0YSA9IGFyZzAudGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gYXJnMC5kb3dubG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2dwdS1idWZmZXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncHVCdWZmZXJEYXRhID0gYXJnMC5ncHVCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG93bmxvYWRlciA9IGFyZzAuZG93bmxvYWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSBhcmcwLmRpc3Bvc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSAnZmxvYXQzMicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICdmbG9hdDE2JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDMyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDY0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQzMicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICd1aW50NjQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlICE9PSAnaW50OCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICd1aW50OCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgIT09ICdib29sJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ3VpbnQ0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAhPT0gJ2ludDQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHt0eXBlfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBNTFRlbnNvcmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWxUZW5zb3JEYXRhID0gYXJnMC5tbFRlbnNvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb3dubG9hZGVyID0gYXJnMC5kb3dubG9hZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlciA9IGFyZzAuZGlzcG9zZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gY29uc3RydWN0aW5nIHRlbnNvciBvZiBsb2NhdGlvbiAnY3B1J1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgbGV0IG1heWJlRGltcztcbiAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgYXJnMCBpcyB0eXBlIG9yIGRhdGFcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlOiBjb25zdHJ1Y3Rvcih0eXBlLCBkYXRhLCAuLi4pXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB0eXBlID0gYXJnMDtcbiAgICAgICAgICAgICAgICBtYXliZURpbXMgPSBhcmcyO1xuICAgICAgICAgICAgICAgIGlmIChhcmcwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcgdGVuc29yXG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmcxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgc3RyaW5nIHRlbnNvcidzIGRhdGEgbXVzdCBiZSBhIHN0cmluZyBhcnJheS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY2hlY2sgd2hldGhlciBldmVyeSBlbGVtZW50IGluIHRoZSBhcnJheSBpcyBzdHJpbmc7IHRoaXMgaXMgdG9vIHNsb3cuIHdlIGFzc3VtZSBpdCdzIGNvcnJlY3QgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGVycm9yIHdpbGwgYmUgcG9wdWxhdGVkIGF0IGluZmVyZW5jZVxuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG51bWVyaWMgdGVuc29yXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IE5VTUVSSUNfVEVOU09SX1RZUEVfVE9fVFlQRURBUlJBWV9NQVAuZ2V0KGFyZzApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZWRBcnJheUNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke2FyZzB9LmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGFyZzAgPT09ICdmbG9hdDE2JyAmJiB0eXBlZEFycmF5Q29uc3RydWN0b3IgPT09IFVpbnQxNkFycmF5KSB8fCBhcmcwID09PSAndWludDQnIHx8IGFyZzAgPT09ICdpbnQ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gJ2Zsb2F0MTYnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgV2hlbiBubyBGbG9hdDE2QXJyYXkgcG9seWZpbGwgaXMgdXNlZCwgd2UgY2Fubm90IGNyZWF0ZSAnZmxvYXQxNicgdGVuc29yIGZyb20gbnVtYmVyIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBUaHJvdyBlcnJvciBoZXJlIGJlY2F1c2Ugd2hlbiB1c2VyIHRyeSB0byB1c2UgbnVtYmVyIGFycmF5IGFzIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlLmcuIG5ldyBUZW5zb3IoJ2Zsb2F0MTYnLCBbMSwgMiwgMywgNF0sIGRpbXMpKSwgaXQgd2lsbCBhY3R1YWxseSBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBVaW50MTZBcnJheS5mcm9tKGFyZzEpIHdoaWNoIGdlbmVyYXRlcyB3cm9uZyBkYXRhLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSAndWludDQnIGFuZCAnaW50NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBVaW50OEFycmF5LmZyb20oYXJnMSkgd2lsbCBnZW5lcmF0ZSB3cm9uZyBkYXRhIGZvciAndWludDQnIGFuZCAnaW50NCcgdGVuc29yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke2FyZzB9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7dHlwZWRBcnJheUNvbnN0cnVjdG9yLm5hbWV9IGFzIGRhdGEuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcwID09PSAndWludDY0JyB8fCBhcmcwID09PSAnaW50NjQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlICdhcyBhbnknIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLiBUeXBlU2NyaXB0J3MgY2hlY2sgb24gdHlwZSBvZiAnQXJyYXkuaXNBcnJheSgpJyBkb2VzIG5vdCB3b3JrIHdpdGggcmVhZG9ubHkgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3MDAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMi4gVHlwZVNjcmlwdCdzIGNoZWNrIG9uIHVuaW9uIHR5cGUgb2YgJyhCaWdJbnQ2NEFycmF5Q29uc3RydWN0b3J8QmlnVWludDY0QXJyYXlDb25zdHJ1Y3RvcikuZnJvbSgpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXIgbWFwRm4uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMy4gcGFyYW1ldGVycyBvZiAnU3VwcG9ydGVkVHlwZWRBcnJheUNvbnN0cnVjdG9ycy5mcm9tKCknIGRvZXMgbm90IG1hdGNoIHRoZSByZXF1aXJlbWVudCBvZiB0aGUgdW5pb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFzc3VtZSAnYXJnMScgaXMgb2YgdHlwZSBcInJlYWRvbmx5IG51bWJlcltdfHJlYWRvbmx5IGJpZ2ludFtdXCIgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZnJvbShhcmcxLCBCaWdJbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lICdhcmcxJyBpcyBvZiB0eXBlIFwicmVhZG9ubHkgbnVtYmVyW11cIiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiB0eXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZzEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZzAgPT09ICd1aW50OCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSBVaW50OENsYW1wZWRBcnJheSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiB1aW50OGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZzAgPT09ICdmbG9hdDE2JyAmJiBhcmcxIGluc3RhbmNlb2YgVWludDE2QXJyYXkgJiYgdHlwZWRBcnJheUNvbnN0cnVjdG9yICE9PSBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBGbG9hdDE2QXJyYXkgaXMgYXZhaWxhYmxlIGFuZCBkYXRhIGlzIG9mIHR5cGUgVWludDE2QXJyYXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhbGxvdyBVaW50MTZBcnJheSB0byBiZSBwYXNzZWQgaW4gYXMgZGF0YSBmb3IgJ2Zsb2F0MTYnIHRlbnNvciB1bnRpbCBGbG9hdDE2QXJyYXkgaXMgZ2VuZXJhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ZWQgaW4gSmF2YVNjcmlwdCBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IGdsb2JhbFRoaXMuRmxvYXQxNkFycmF5KGFyZzEuYnVmZmVyLCBhcmcxLmJ5dGVPZmZzZXQsIGFyZzEubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgJHt0eXBlfSB0ZW5zb3IncyBkYXRhIG11c3QgYmUgdHlwZSBvZiAke3R5cGVkQXJyYXlDb25zdHJ1Y3Rvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGU6IGNvbnN0cnVjdG9yKGRhdGEsIC4uLilcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIG1heWJlRGltcyA9IGFyZzE7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSBib29sZWFuW10gYW5kIHN0cmluZ1tdIGlzIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnMC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWxlbWVudFR5cGUgPSB0eXBlb2YgYXJnMFswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXJnMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmaXJzdEVsZW1lbnRUeXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnYm9vbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAnYXJnMCcgaXMgb2YgdHlwZSAnYm9vbGVhbltdJy4gVWludDhBcnJheS5mcm9tKGJvb2xlYW5bXSkgYWN0dWFsbHkgd29ya3MsIGJ1dCB0eXBlc2NyaXB0IHRoaW5rcyB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3cm9uZyB0eXBlLiBXZSB1c2UgJ2FzIGFueScgdG8gbWFrZSBpdCBoYXBweS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gVWludDhBcnJheS5mcm9tKGFyZzApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbGVtZW50IHR5cGUgb2YgZGF0YSBhcnJheTogJHtmaXJzdEVsZW1lbnRUeXBlfS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhcmcwIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICd1aW50OCc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oYXJnMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGVuc29yIHR5cGUgZnJvbSBUeXBlZEFycmF5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcHBlZFR5cGUgPSBOVU1FUklDX1RFTlNPUl9UWVBFREFSUkFZX1RPX1RZUEVfTUFQLmdldChhcmcwLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7YXJnMC5jb25zdHJ1Y3Rvcn0uYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IG1hcHBlZFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhcmcwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHR5cGUgYW5kIGRhdGEgaXMgcHJvY2Vzc2VkLCBub3cgcHJvY2Vzc2luZyBkaW1zXG4gICAgICAgICAgICBpZiAobWF5YmVEaW1zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUgMS1EIHRlbnNvciBpZiBkaW1zIG9taXR0ZWRcbiAgICAgICAgICAgICAgICBtYXliZURpbXMgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWF5YmVEaW1zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpbXMgPSBtYXliZURpbXM7XG4gICAgICAgICAgICB0aGlzLmNwdURhdGEgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnY3B1JztcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoZWNrIG9uIGRpbXNcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGNhbGN1bGF0ZVNpemUoZGltcyk7XG4gICAgICAgIC8vIGlmIGRhdGEgaXMgb24gQ1BVLCBjaGVjayB3aGV0aGVyIGRhdGEgbGVuZ3RoIG1hdGNoZXMgdGVuc29yIHNpemVcbiAgICAgICAgaWYgKHRoaXMuY3B1RGF0YSAmJiBzaXplICE9PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKHR5cGUgPT09ICd1aW50NCcgfHwgdHlwZSA9PT0gJ2ludDQnKSAmJiBNYXRoLmNlaWwoc2l6ZSAvIDIpID09PSB0aGlzLmNwdURhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yICh1KWludDQsIHRoZSBkYXRhIGxlbmd0aCBpcyBoYWxmIG9mIHRoZSB0ZW5zb3Igc2l6ZS4gU28gd2UgY2hlY2sgdGhpcyBzcGVjaWFsIGNhc2Ugd2hlbiBzaXplIGlzIG9kZC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke3NpemV9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmRpbXMgPSBkaW1zO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICAvLyAjZW5kcmVnaW9uXG4gICAgLy8gI3JlZ2lvbiBmYWN0b3J5XG4gICAgc3RhdGljIGFzeW5jIGZyb21JbWFnZShpbWFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGVuc29yRnJvbUltYWdlKGltYWdlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21UZXh0dXJlKHRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvckZyb21UZXh0dXJlKHRleHR1cmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUdwdUJ1ZmZlcihncHVCdWZmZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvckZyb21HcHVCdWZmZXIoZ3B1QnVmZmVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NTFRlbnNvcihtbFRlbnNvciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGVuc29yRnJvbU1MVGVuc29yKG1sVGVuc29yLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21QaW5uZWRCdWZmZXIodHlwZSwgYnVmZmVyLCBkaW1zKSB7XG4gICAgICAgIHJldHVybiB0ZW5zb3JGcm9tUGlubmVkQnVmZmVyKHR5cGUsIGJ1ZmZlciwgZGltcyk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIGNvbnZlcnNpb25zXG4gICAgdG9EYXRhVVJMKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvclRvRGF0YVVSTCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdG9JbWFnZURhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGVuc29yVG9JbWFnZURhdGEodGhpcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIHByb3BlcnRpZXNcbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgICAgICBpZiAoIXRoaXMuY3B1RGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCAnICtcbiAgICAgICAgICAgICAgICAnb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNwdURhdGE7XG4gICAgfVxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgICAgICBpZiAoIXRoaXMuZ3B1VGV4dHVyZURhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdMIHRleHR1cmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGE7XG4gICAgfVxuICAgIGdldCBncHVCdWZmZXIoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmdwdUJ1ZmZlckRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3B1QnVmZmVyRGF0YTtcbiAgICB9XG4gICAgZ2V0IG1sVGVuc29yKCkge1xuICAgICAgICB0aGlzLmVuc3VyZVZhbGlkKCk7XG4gICAgICAgIGlmICghdGhpcy5tbFRlbnNvckRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1sVGVuc29yRGF0YTtcbiAgICB9XG4gICAgLy8gI2VuZHJlZ2lvblxuICAgIC8vICNyZWdpb24gbWV0aG9kc1xuICAgIGFzeW5jIGdldERhdGEocmVsZWFzZURhdGEpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZGF0YUxvY2F0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICdjcHUnOlxuICAgICAgICAgICAgY2FzZSAnY3B1LXBpbm5lZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGNhc2UgJ3RleHR1cmUnOlxuICAgICAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICAgICAgICBjYXNlICdtbC10ZW5zb3InOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvd25sb2FkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgbm90IGNyZWF0ZWQgd2l0aCBhIHNwZWNpZmllZCBkYXRhIGRvd25sb2FkZXIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VycmVudCB0ZW5zb3IgaXMgYmVpbmcgZG93bmxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZG93bmxvYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUxvY2F0aW9uID0gJ2NwdSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3B1RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxlYXNlRGF0YSAmJiB0aGlzLmRpc3Bvc2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0Rvd25sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRG93bmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcHVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmdwdVRleHR1cmVEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmdwdUJ1ZmZlckRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWxUZW5zb3JEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRvd25sb2FkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaXNEb3dubG9hZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kYXRhTG9jYXRpb24gPSAnbm9uZSc7XG4gICAgfVxuICAgIC8vICNlbmRyZWdpb25cbiAgICAvLyAjcmVnaW9uIHRlbnNvciB1dGlsaXRpZXNcbiAgICBlbnN1cmVWYWxpZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUxvY2F0aW9uID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHRlbnNvciBpcyBkaXNwb3NlZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNoYXBlKGRpbXMpIHtcbiAgICAgICAgdGhpcy5lbnN1cmVWYWxpZCgpO1xuICAgICAgICBpZiAodGhpcy5kb3dubG9hZGVyIHx8IHRoaXMuZGlzcG9zZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yUmVzaGFwZSh0aGlzLCBkaW1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW5zb3ItaW1wbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   tensorReshape: () => (/* binding */ tensorReshape)\n/* harmony export */ });\n/* harmony import */ var _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * calculate size from dims.\n *\n * @param dims the dims array. May be an illegal input.\n */\nconst calculateSize = (dims) => {\n    let size = 1;\n    for (let i = 0; i < dims.length; i++) {\n        const dim = dims[i];\n        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {\n            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);\n        }\n        if (dim < 0) {\n            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);\n        }\n        size *= dim;\n    }\n    return size;\n};\n/**\n * implementation of Tensor.reshape()\n */\nconst tensorReshape = (tensor, dims) => {\n    switch (tensor.location) {\n        case 'cpu':\n            return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor(tensor.type, tensor.data, dims);\n        case 'cpu-pinned':\n            return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({\n                location: 'cpu-pinned',\n                data: tensor.data,\n                type: tensor.type,\n                dims,\n            });\n        case 'texture':\n            return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({\n                location: 'texture',\n                texture: tensor.texture,\n                type: tensor.type,\n                dims,\n            });\n        case 'gpu-buffer':\n            return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({\n                location: 'gpu-buffer',\n                gpuBuffer: tensor.gpuBuffer,\n                type: tensor.type,\n                dims,\n            });\n        case 'ml-tensor':\n            return new _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor({\n                location: 'ml-tensor',\n                mlTensor: tensor.mlTensor,\n                type: tensor.type,\n                dims,\n            });\n        default:\n            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);\n    }\n};\n//# sourceMappingURL=tensor-utils-impl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLXV0aWxzLWltcGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLDZCQUE2QixJQUFJO0FBQzNFO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRSx5Q0FBeUMsSUFBSTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLG1EQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOERBQThELGlCQUFpQjtBQUMvRTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLXV0aWxzLWltcGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG5pbXBvcnQgeyBUZW5zb3IgfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbi8qKlxuICogY2FsY3VsYXRlIHNpemUgZnJvbSBkaW1zLlxuICpcbiAqIEBwYXJhbSBkaW1zIHRoZSBkaW1zIGFycmF5LiBNYXkgYmUgYW4gaWxsZWdhbCBpbnB1dC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGN1bGF0ZVNpemUgPSAoZGltcykgPT4ge1xuICAgIGxldCBzaXplID0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGltID0gZGltc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBkaW0gIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNTYWZlSW50ZWdlcihkaW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7aX1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke2RpbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYGRpbXNbJHtpfV0gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBnb3Q6ICR7ZGltfWApO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgKj0gZGltO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn07XG4vKipcbiAqIGltcGxlbWVudGF0aW9uIG9mIFRlbnNvci5yZXNoYXBlKClcbiAqL1xuZXhwb3J0IGNvbnN0IHRlbnNvclJlc2hhcGUgPSAodGVuc29yLCBkaW1zKSA9PiB7XG4gICAgc3dpdGNoICh0ZW5zb3IubG9jYXRpb24pIHtcbiAgICAgICAgY2FzZSAnY3B1JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHRlbnNvci50eXBlLCB0ZW5zb3IuZGF0YSwgZGltcyk7XG4gICAgICAgIGNhc2UgJ2NwdS1waW5uZWQnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnY3B1LXBpbm5lZCcsXG4gICAgICAgICAgICAgICAgZGF0YTogdGVuc29yLmRhdGEsXG4gICAgICAgICAgICAgICAgdHlwZTogdGVuc29yLnR5cGUsXG4gICAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICd0ZXh0dXJlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGVuc29yKHtcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogJ3RleHR1cmUnLFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHRlbnNvci50ZXh0dXJlLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRlbnNvci50eXBlLFxuICAgICAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAnZ3B1LWJ1ZmZlcic6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRlbnNvcih7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246ICdncHUtYnVmZmVyJyxcbiAgICAgICAgICAgICAgICBncHVCdWZmZXI6IHRlbnNvci5ncHVCdWZmZXIsXG4gICAgICAgICAgICAgICAgdHlwZTogdGVuc29yLnR5cGUsXG4gICAgICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlICdtbC10ZW5zb3InOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZW5zb3Ioe1xuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAnbWwtdGVuc29yJyxcbiAgICAgICAgICAgICAgICBtbFRlbnNvcjogdGVuc29yLm1sVGVuc29yLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRlbnNvci50eXBlLFxuICAgICAgICAgICAgICAgIGRpbXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdGVuc29yUmVzaGFwZTogdGVuc29yIGxvY2F0aW9uICR7dGVuc29yLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbnNvci11dGlscy1pbXBsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tensor: () => (/* binding */ Tensor)\n/* harmony export */ });\n/* harmony import */ var _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tensor-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tensor = _tensor_impl_js__WEBPACK_IMPORTED_MODULE_0__.Tensor;\n//# sourceMappingURL=tensor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUN3RDtBQUN4RDtBQUNPLGVBQWUsbURBQVU7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9zb2hhbS9tb2R1bC9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdGVuc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgVGVuc29yIGFzIFRlbnNvckltcGwgfSBmcm9tICcuL3RlbnNvci1pbXBsLmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmV4cG9ydCBjb25zdCBUZW5zb3IgPSBUZW5zb3JJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVuc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/tensor.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/trace.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/trace.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRACE: () => (/* binding */ TRACE),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ TRACE_FUNC_BEGIN),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ TRACE_FUNC_END)\n/* harmony export */ });\n/* harmony import */ var _env_impl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env-impl.js */ \"(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/env-impl.js\");\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * @ignore\n */\nconst TRACE = (deviceType, label) => {\n    if (typeof _env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace === 'undefined' ? !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.wasm.trace : !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.timeStamp(`${deviceType}::ORT::${label}`);\n};\nconst TRACE_FUNC = (msg, extraMsg) => {\n    const stack = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [];\n    let hasTraceFunc = false;\n    for (let i = 0; i < stack.length; i++) {\n        if (hasTraceFunc && !stack[i].includes('TRACE_FUNC')) {\n            let label = `FUNC_${msg}::${stack[i].trim().split(' ')[1]}`;\n            if (extraMsg) {\n                label += `::${extraMsg}`;\n            }\n            TRACE('CPU', label);\n            return;\n        }\n        if (stack[i].includes('TRACE_FUNC')) {\n            hasTraceFunc = true;\n        }\n    }\n};\n/**\n * @ignore\n */\nconst TRACE_FUNC_BEGIN = (extraMsg) => {\n    if (typeof _env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace === 'undefined' ? !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.wasm.trace : !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace) {\n        return;\n    }\n    TRACE_FUNC('BEGIN', extraMsg);\n};\n/**\n * @ignore\n */\nconst TRACE_FUNC_END = (extraMsg) => {\n    if (typeof _env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace === 'undefined' ? !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.wasm.trace : !_env_impl_js__WEBPACK_IMPORTED_MODULE_0__.env.trace) {\n        return;\n    }\n    TRACE_FUNC('END', extraMsg);\n};\n//# sourceMappingURL=trace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdHJhY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLDZDQUFHLDBCQUEwQiw2Q0FBRyxlQUFlLDZDQUFHO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXLFNBQVMsTUFBTTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxnQ0FBZ0MsSUFBSSxJQUFJLDhCQUE4QjtBQUN0RTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSw2Q0FBRywwQkFBMEIsNkNBQUcsZUFBZSw2Q0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSw2Q0FBRywwQkFBMEIsNkNBQUcsZUFBZSw2Q0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3RyYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi9lbnYtaW1wbC5qcyc7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFID0gKGRldmljZVR5cGUsIGxhYmVsKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS50aW1lU3RhbXAoYCR7ZGV2aWNlVHlwZX06Ok9SVDo6JHtsYWJlbH1gKTtcbn07XG5jb25zdCBUUkFDRV9GVU5DID0gKG1zZywgZXh0cmFNc2cpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZykgfHwgW107XG4gICAgbGV0IGhhc1RyYWNlRnVuYyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc1RyYWNlRnVuYyAmJiAhc3RhY2tbaV0uaW5jbHVkZXMoJ1RSQUNFX0ZVTkMnKSkge1xuICAgICAgICAgICAgbGV0IGxhYmVsID0gYEZVTkNfJHttc2d9Ojoke3N0YWNrW2ldLnRyaW0oKS5zcGxpdCgnICcpWzFdfWA7XG4gICAgICAgICAgICBpZiAoZXh0cmFNc2cpIHtcbiAgICAgICAgICAgICAgICBsYWJlbCArPSBgOjoke2V4dHJhTXNnfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUUkFDRSgnQ1BVJywgbGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFja1tpXS5pbmNsdWRlcygnVFJBQ0VfRlVOQycpKSB7XG4gICAgICAgICAgICBoYXNUcmFjZUZ1bmMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8qKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgY29uc3QgVFJBQ0VfRlVOQ19CRUdJTiA9IChleHRyYU1zZykgPT4ge1xuICAgIGlmICh0eXBlb2YgZW52LnRyYWNlID09PSAndW5kZWZpbmVkJyA/ICFlbnYud2FzbS50cmFjZSA6ICFlbnYudHJhY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBUUkFDRV9GVU5DKCdCRUdJTicsIGV4dHJhTXNnKTtcbn07XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGNvbnN0IFRSQUNFX0ZVTkNfRU5EID0gKGV4dHJhTXNnKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbnYudHJhY2UgPT09ICd1bmRlZmluZWQnID8gIWVudi53YXNtLnRyYWNlIDogIWVudi50cmFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFRSQUNFX0ZVTkMoJ0VORCcsIGV4dHJhTXNnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/trace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/version.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/version.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n// This file is generated by /js/scripts/update-version.ts\n// Do not modify file content manually.\nconst version = '1.21.0';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS1jb21tb24vZGlzdC9lc20vdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL29ubnhydW50aW1lLXdlYi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtY29tbW9uL2Rpc3QvZXNtL3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4vLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IC9qcy9zY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLnRzXG4vLyBEbyBub3QgbW9kaWZ5IGZpbGUgY29udGVudCBtYW51YWxseS5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzEuMjEuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/node_modules/onnxruntime-common/dist/esm/version.js\n");

/***/ })

};
;