"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist";
exports.ids = ["vendor-chunks/pdfjs-dist"];
exports.modules = {

/***/ "(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs":
/*!***********************************************!*\
  !*** ./node_modules/pdfjs-dist/build/pdf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortException: () => (/* binding */ AbortException),\n/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),\n/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),\n/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),\n/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),\n/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),\n/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),\n/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),\n/* harmony export */   CSSConstants: () => (/* binding */ CSSConstants),\n/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),\n/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),\n/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),\n/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),\n/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),\n/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),\n/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),\n/* harmony export */   MathClamp: () => (/* binding */ MathClamp),\n/* harmony export */   OPS: () => (/* binding */ OPS),\n/* harmony export */   OutputScale: () => (/* binding */ OutputScale),\n/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),\n/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),\n/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),\n/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),\n/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),\n/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),\n/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),\n/* harmony export */   ResponseException: () => (/* binding */ ResponseException),\n/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),\n/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),\n/* harmony export */   TextLayer: () => (/* binding */ TextLayer),\n/* harmony export */   TouchManager: () => (/* binding */ TouchManager),\n/* harmony export */   Util: () => (/* binding */ Util),\n/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),\n/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),\n/* harmony export */   applyOpacity: () => (/* binding */ applyOpacity),\n/* harmony export */   build: () => (/* binding */ build),\n/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   findContrastColor: () => (/* binding */ findContrastColor),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),\n/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),\n/* harmony export */   getRGB: () => (/* binding */ getRGB),\n/* harmony export */   getUuid: () => (/* binding */ getUuid),\n/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),\n/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),\n/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),\n/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),\n/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),\n/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),\n/* harmony export */   renderRichText: () => (/* binding */ renderRichText),\n/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),\n/* harmony export */   shadow: () => (/* binding */ shadow),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2024 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n/**\n * pdfjsVersion = 5.4.449\n * pdfjsBuild = f44e5f0e6\n */\n/******/ // The require scope\n/******/ var __nested_webpack_require_899__ = {};\n/******/ \n/************************************************************************/\n/******/ /* webpack/runtime/define property getters */\n/******/ (() => {\n/******/ \t// define getter functions for harmony exports\n/******/ \t__nested_webpack_require_899__.d = (exports, definition) => {\n/******/ \t\tfor(var key in definition) {\n/******/ \t\t\tif(__nested_webpack_require_899__.o(definition, key) && !__nested_webpack_require_899__.o(exports, key)) {\n/******/ \t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t}\n/******/ \t\t}\n/******/ \t};\n/******/ })();\n/******/ \n/******/ /* webpack/runtime/hasOwnProperty shorthand */\n/******/ (() => {\n/******/ \t__nested_webpack_require_899__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ })();\n/******/ \n/************************************************************************/\nvar __webpack_exports__ = {};\n\n;// ./src/shared/util.js\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nconst LINE_FACTOR = 1.35;\nconst LINE_DESCENT_FACTOR = 0.35;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  IS_EDITING: 0x80,\n  OPLIST: 0x100\n};\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  HIGHLIGHT: 9,\n  STAMP: 13,\n  INK: 15,\n  POPUP: 16,\n  SIGNATURE: 101,\n  COMMENT: 102\n};\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23,\n  HIGHLIGHT_COLOR: 31,\n  HIGHLIGHT_THICKNESS: 32,\n  HIGHLIGHT_FREE: 33,\n  HIGHLIGHT_SHOW_ALL: 34,\n  DRAW_STEP: 41\n};\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nconst MeshFigureType = {\n  TRIANGLES: 1,\n  LATTICE: 2,\n  PATCH: 3\n};\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nconst util_ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91,\n  setStrokeTransparent: 92,\n  setFillTransparent: 93,\n  rawFillPath: 94\n};\nconst DrawOPS = {\n  moveTo: 0,\n  lineTo: 1,\n  curveTo: 2,\n  quadraticCurveTo: 3,\n  closePath: 4\n};\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.info(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.warn(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url, baseUrl = null, options = null) {\n  if (!url) {\n    return null;\n  }\n  if (options && typeof url === \"string\") {\n    if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n      const dots = url.match(/\\./g);\n      if (dots?.length >= 2) {\n        url = `http://${url}`;\n      }\n    }\n    if (options.tryConvertEncoding) {\n      try {\n        url = stringToUTF8String(url);\n      } catch {}\n    }\n  }\n  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;\n}\nfunction updateUrlHash(url, hash, allowRel = false) {\n  const res = URL.parse(url);\n  if (res) {\n    res.hash = hash;\n    return res.href;\n  }\n  if (allowRel && createValidAbsoluteUrl(url, \"http://example.com\")) {\n    return url.split(\"#\", 1)[0] + `${hash ? `#${hash}` : \"\"}`;\n  }\n  return \"\";\n}\nfunction shadow(obj, prop, value, nonSerializable = false) {\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nclass ResponseException extends BaseException {\n  constructor(msg, status, missing) {\n    super(msg, \"ResponseException\");\n    this.status = status;\n    this.missing = missing;\n  }\n}\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass util_FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get isImageDecoderSupported() {\n    return shadow(this, \"isImageDecoderSupported\", typeof ImageDecoder !== \"undefined\");\n  }\n  static get isFloat16ArraySupported() {\n    return shadow(this, \"isFloat16ArraySupported\", typeof Float16Array !== \"undefined\");\n  }\n  static get isSanitizerSupported() {\n    return shadow(this, \"isSanitizerSupported\", typeof Sanitizer !== \"undefined\");\n  }\n  static get platform() {\n    const {\n      platform,\n      userAgent\n    } = navigator;\n    return shadow(this, \"platform\", {\n      isAndroid: userAgent.includes(\"Android\"),\n      isLinux: platform.includes(\"Linux\"),\n      isMac: platform.includes(\"Mac\"),\n      isWindows: platform.includes(\"Win\"),\n      isFirefox: userAgent.includes(\"Firefox\")\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nconst hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static domMatrixToTransform(dm) {\n    return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[2] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[1];\n      minMax[1] = temp;\n      temp = minMax[2];\n      minMax[2] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[1];\n        minMax[1] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[1] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[2];\n        minMax[2] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[2] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[5];\n    minMax[2] += transform[4];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static multiplyByDOMMatrix(m, md) {\n    return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];\n  }\n  static applyTransform(p, m, pos = 0) {\n    const p0 = p[pos];\n    const p1 = p[pos + 1];\n    p[pos] = p0 * m[0] + p1 * m[2] + m[4];\n    p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];\n  }\n  static applyTransformToBezier(p, transform, pos = 0) {\n    const m0 = transform[0];\n    const m1 = transform[1];\n    const m2 = transform[2];\n    const m3 = transform[3];\n    const m4 = transform[4];\n    const m5 = transform[5];\n    for (let i = 0; i < 6; i += 2) {\n      const pI = p[pos + i];\n      const pI1 = p[pos + i + 1];\n      p[pos + i] = pI * m0 + pI1 * m2 + m4;\n      p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;\n    }\n  }\n  static applyInverseTransform(p, m) {\n    const p0 = p[0];\n    const p1 = p[1];\n    const d = m[0] * m[3] - m[1] * m[2];\n    p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n  }\n  static axialAlignedBoundingBox(rect, transform, output) {\n    const m0 = transform[0];\n    const m1 = transform[1];\n    const m2 = transform[2];\n    const m3 = transform[3];\n    const m4 = transform[4];\n    const m5 = transform[5];\n    const r0 = rect[0];\n    const r1 = rect[1];\n    const r2 = rect[2];\n    const r3 = rect[3];\n    let a0 = m0 * r0 + m4;\n    let a2 = a0;\n    let a1 = m0 * r2 + m4;\n    let a3 = a1;\n    let b0 = m3 * r1 + m5;\n    let b2 = b0;\n    let b1 = m3 * r3 + m5;\n    let b3 = b1;\n    if (m1 !== 0 || m2 !== 0) {\n      const m1r0 = m1 * r0;\n      const m1r2 = m1 * r2;\n      const m2r1 = m2 * r1;\n      const m2r3 = m2 * r3;\n      a0 += m2r1;\n      a3 += m2r1;\n      a1 += m2r3;\n      a2 += m2r3;\n      b0 += m1r0;\n      b3 += m1r0;\n      b1 += m1r2;\n      b2 += m1r2;\n    }\n    output[0] = Math.min(output[0], a0, a1, a2, a3);\n    output[1] = Math.min(output[1], b0, b1, b2, b3);\n    output[2] = Math.max(output[2], a0, a1, a2, a3);\n    output[3] = Math.max(output[3], b0, b1, b2, b3);\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(matrix, output) {\n    const m0 = matrix[0];\n    const m1 = matrix[1];\n    const m2 = matrix[2];\n    const m3 = matrix[3];\n    const a = m0 ** 2 + m1 ** 2;\n    const b = m0 * m2 + m1 * m3;\n    const c = m2 ** 2 + m3 ** 2;\n    const first = (a + c) / 2;\n    const second = Math.sqrt(first ** 2 - (a * c - b ** 2));\n    output[0] = Math.sqrt(first + second || 1);\n    output[1] = Math.sqrt(first - second || 1);\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static pointBoundingBox(x, y, minMax) {\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static rectBoundingBox(x0, y0, x1, y1, minMax) {\n    minMax[0] = Math.min(minMax[0], x0, x1);\n    minMax[1] = Math.min(minMax[1], y0, y1);\n    minMax[2] = Math.max(minMax[2], x0, x1);\n    minMax[3] = Math.max(minMax[3], y0, y1);\n  }\n  static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {\n    if (t <= 0 || t >= 1) {\n      return;\n    }\n    const mt = 1 - t;\n    const tt = t * t;\n    const ttt = tt * t;\n    const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;\n    const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;\n    minMax[0] = Math.min(minMax[0], x);\n    minMax[1] = Math.min(minMax[1], y);\n    minMax[2] = Math.max(minMax[2], x);\n    minMax[3] = Math.max(minMax[3], y);\n  }\n  static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {\n    if (Math.abs(a) < 1e-12) {\n      if (Math.abs(b) >= 1e-12) {\n        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);\n      }\n      return;\n    }\n    const delta = b ** 2 - 4 * c * a;\n    if (delta < 0) {\n      return;\n    }\n    const sqrtDelta = Math.sqrt(delta);\n    const a2 = 2 * a;\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);\n    this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    minMax[0] = Math.min(minMax[0], x0, x3);\n    minMax[1] = Math.min(minMax[1], y0, y3);\n    minMax[2] = Math.max(minMax[2], x0, x3);\n    minMax[3] = Math.max(minMax[3], y0, y3);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);\n    this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);\n  }\n}\nconst PDFStringTranslateTable = (/* unused pure expression or super */ null && (0));\nfunction stringToPDFString(str, keepEscapeSequence = false) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n      if (str.length % 2 === 1) {\n        str = str.slice(0, -1);\n      }\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        const decoded = decoder.decode(buffer);\n        if (keepEscapeSequence || !decoded.includes(\"\\x1b\")) {\n          return decoded;\n        }\n        return decoded.replaceAll(/\\x1b[^\\x1b]*(?:\\x1b|$)/g, \"\");\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const charCode = str.charCodeAt(i);\n    if (!keepEscapeSequence && charCode === 0x1b) {\n      while (++i < ii && str.charCodeAt(i) !== 0x1b) {}\n      continue;\n    }\n    const code = PDFStringTranslateTable[charCode];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate(date = new Date()) {\n  if (!(date instanceof Date)) {\n    date = new Date(date);\n  }\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"ﬅ\", \"ſt\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2));\n}\nfunction getUuid() {\n  if (typeof crypto.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  crypto.getRandomValues(buf);\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nfunction _isValidExplicitDest(validRef, validName, dest) {\n  if (!Array.isArray(dest) || dest.length < 2) {\n    return false;\n  }\n  const [page, zoom, ...args] = dest;\n  if (!validRef(page) && !Number.isInteger(page)) {\n    return false;\n  }\n  if (!validName(zoom)) {\n    return false;\n  }\n  const argsLen = args.length;\n  let allowNull = true;\n  switch (zoom.name) {\n    case \"XYZ\":\n      if (argsLen < 2 || argsLen > 3) {\n        return false;\n      }\n      break;\n    case \"Fit\":\n    case \"FitB\":\n      return argsLen === 0;\n    case \"FitH\":\n    case \"FitBH\":\n    case \"FitV\":\n    case \"FitBV\":\n      if (argsLen > 1) {\n        return false;\n      }\n      break;\n    case \"FitR\":\n      if (argsLen !== 4) {\n        return false;\n      }\n      allowNull = false;\n      break;\n    default:\n      return false;\n  }\n  for (const arg of args) {\n    if (typeof arg === \"number\" || allowNull && arg === null) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\nfunction MathClamp(v, min, max) {\n  return Math.min(Math.max(v, min), max);\n}\nfunction toHexUtil(arr) {\n  if (Uint8Array.prototype.toHex) {\n    return arr.toHex();\n  }\n  return Array.from(arr, num => hexNumbers[num]).join(\"\");\n}\nfunction toBase64Util(arr) {\n  if (Uint8Array.prototype.toBase64) {\n    return arr.toBase64();\n  }\n  return btoa(bytesToString(arr));\n}\nfunction fromBase64Util(str) {\n  if (Uint8Array.fromBase64) {\n    return Uint8Array.fromBase64(str);\n  }\n  return stringToBytes(atob(str));\n}\nif (typeof Promise.try !== \"function\") {\n  Promise.try = function (fn, ...args) {\n    return new Promise(resolve => {\n      resolve(fn(...args));\n    });\n  };\n}\nif (typeof Math.sumPrecise !== \"function\") {\n  Math.sumPrecise = function (numbers) {\n    return numbers.reduce((a, b) => a + b, 0);\n  };\n}\n\n;// ./src/display/xfa_text.js\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n}\n\n;// ./src/display/xfa_layer.js\n\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          html.setAttribute(\"value\", storedData.value);\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            } else if (option.attributes.hasOwnProperty(\"selected\")) {\n              delete option.attributes.selected;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n  static setAttributes({\n    html,\n    element,\n    storage = null,\n    intent,\n    linkService\n  }) {\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n          break;\n        case \"dataId\":\n          break;\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n        case \"textContent\":\n          html.textContent = value;\n          break;\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n      }\n    }\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n    const isNotForRichText = intent !== \"richText\";\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n    if (isNotForRichText) {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n    const textDivs = [];\n    if (root.children.length === 0) {\n      if (root.value) {\n        const node = document.createTextNode(root.value);\n        rootHtml.append(node);\n        if (isNotForRichText && XfaText.shouldBuildText(root.name)) {\n          textDivs.push(node);\n        }\n      }\n      return {\n        textDivs\n      };\n    }\n    const stack = [[root, -1, rootHtml]];\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = parent.children[++stack.at(-1)[1]];\n      if (child === null) {\n        continue;\n      }\n      const {\n        name\n      } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n      html.append(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n      if (child.children?.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (isNotForRichText && XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.append(node);\n      }\n    }\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n    return {\n      textDivs\n    };\n  }\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\n\n;// ./src/display/display_utils.js\n\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\nasync function fetchData(url, type = \"text\") {\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    switch (type) {\n      case \"arraybuffer\":\n        return response.arrayBuffer();\n      case \"blob\":\n        return response.blob();\n      case \"json\":\n        return response.json();\n    }\n    return response.text();\n  }\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    request.responseType = type;\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        switch (type) {\n          case \"arraybuffer\":\n          case \"blob\":\n          case \"json\":\n            resolve(request.response);\n            return;\n        }\n        resolve(request.responseText);\n        return;\n      }\n      reject(new Error(request.statusText));\n    };\n    request.send(null);\n  });\n}\nclass PageViewport {\n  constructor({\n    viewBox,\n    userUnit,\n    scale,\n    rotation,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  }) {\n    this.viewBox = viewBox;\n    this.userUnit = userUnit;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    scale *= userUnit;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = (viewBox[3] - viewBox[1]) * scale;\n      height = (viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = (viewBox[2] - viewBox[0]) * scale;\n      height = (viewBox[3] - viewBox[1]) * scale;\n    }\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n  get rawDims() {\n    const dims = this.viewBox;\n    return shadow(this, \"rawDims\", {\n      pageWidth: dims[2] - dims[0],\n      pageHeight: dims[3] - dims[1],\n      pageX: dims[0],\n      pageY: dims[1]\n    });\n  }\n  clone({\n    scale = this.scale,\n    rotation = this.rotation,\n    offsetX = this.offsetX,\n    offsetY = this.offsetY,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      userUnit: this.userUnit,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  convertToViewportPoint(x, y) {\n    const p = [x, y];\n    Util.applyTransform(p, this.transform);\n    return p;\n  }\n  convertToViewportRectangle(rect) {\n    const topLeft = [rect[0], rect[1]];\n    Util.applyTransform(topLeft, this.transform);\n    const bottomRight = [rect[2], rect[3]];\n    Util.applyTransform(bottomRight, this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n  convertToPdfPoint(x, y) {\n    const p = [x, y];\n    Util.applyInverseTransform(p, this.transform);\n    return p;\n  }\n}\nclass RenderingCancelledException extends BaseException {\n  constructor(msg, extraDelay = 0) {\n    super(msg, \"RenderingCancelledException\");\n    this.extraDelay = extraDelay;\n  }\n}\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n  [url] = url.split(/[#?]/, 1);\n  return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url, defaultFilename = \"document.pdf\") {\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    warn('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const getURL = urlString => {\n    try {\n      return new URL(urlString);\n    } catch {\n      try {\n        return new URL(decodeURIComponent(urlString));\n      } catch {\n        try {\n          return new URL(urlString, \"https://foo.bar\");\n        } catch {\n          try {\n            return new URL(decodeURIComponent(urlString), \"https://foo.bar\");\n          } catch {\n            return null;\n          }\n        }\n      }\n    }\n  };\n  const newURL = getURL(url);\n  if (!newURL) {\n    return defaultFilename;\n  }\n  const decode = name => {\n    try {\n      let decoded = decodeURIComponent(name);\n      if (decoded.includes(\"/\")) {\n        decoded = decoded.split(\"/\").at(-1);\n        if (decoded.test(/^\\.pdf$/i)) {\n          return decoded;\n        }\n        return name;\n      }\n      return decoded;\n    } catch {\n      return name;\n    }\n  };\n  const pdfRegex = /\\.pdf$/i;\n  const filename = newURL.pathname.split(\"/\").at(-1);\n  if (pdfRegex.test(filename)) {\n    return decode(filename);\n  }\n  if (newURL.searchParams.size > 0) {\n    const values = Array.from(newURL.searchParams.values()).reverse();\n    for (const value of values) {\n      if (pdfRegex.test(value)) {\n        return decode(value);\n      }\n    }\n    const keys = Array.from(newURL.searchParams.keys()).reverse();\n    for (const key of keys) {\n      if (pdfRegex.test(key)) {\n        return decode(key);\n      }\n    }\n  }\n  if (newURL.hash) {\n    const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n    const hashFilename = reFilename.exec(newURL.hash);\n    if (hashFilename) {\n      return decode(hashFilename[0]);\n    }\n  }\n  return defaultFilename;\n}\nclass StatTimer {\n  started = Object.create(null);\n  times = [];\n  time(name) {\n    if (name in this.started) {\n      warn(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      warn(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n    for (const {\n      name\n    } of this.times) {\n      longest = Math.max(name.length, longest);\n    }\n    for (const {\n      name,\n      start,\n      end\n    } of this.times) {\n      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\nfunction isValidFetchUrl(url, baseUrl) {\n  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);\n  return res?.protocol === \"http:\" || res?.protocol === \"https:\";\n}\nfunction noContextMenu(e) {\n  e.preventDefault();\n}\nfunction stopEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n}\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\nclass PDFDateString {\n  static #regex;\n  static toDateObject(input) {\n    if (input instanceof Date) {\n      return input;\n    }\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n    this.#regex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    const matches = this.#regex.exec(input);\n    if (!matches) {\n      return null;\n    }\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\nfunction getXfaPageViewport(xfaPage, {\n  scale = 1,\n  rotation = 0\n}) {\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    userUnit: 1,\n    scale,\n    rotation\n  });\n}\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n  warn(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  span.style.colorScheme = \"only light\";\n  document.body.append(span);\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n  span.remove();\n}\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\nfunction setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {\n  if (viewport instanceof PageViewport) {\n    const {\n      pageWidth,\n      pageHeight\n    } = viewport.rawDims;\n    const {\n      style\n    } = div;\n    const useRound = util_FeatureTest.isCSSRoundSupported;\n    const w = `var(--total-scale-factor) * ${pageWidth}px`,\n      h = `var(--total-scale-factor) * ${pageHeight}px`;\n    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`,\n      heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;\n    if (!mustFlip || viewport.rotation % 180 === 0) {\n      style.width = widthStr;\n      style.height = heightStr;\n    } else {\n      style.width = heightStr;\n      style.height = widthStr;\n    }\n  }\n  if (mustRotate) {\n    div.setAttribute(\"data-main-rotation\", viewport.rotation);\n  }\n}\nclass OutputScale {\n  constructor() {\n    const {\n      pixelRatio\n    } = OutputScale;\n    this.sx = pixelRatio;\n    this.sy = pixelRatio;\n  }\n  get scaled() {\n    return this.sx !== 1 || this.sy !== 1;\n  }\n  get symmetric() {\n    return this.sx === this.sy;\n  }\n  limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {\n    let maxAreaScale = Infinity,\n      maxWidthScale = Infinity,\n      maxHeightScale = Infinity;\n    maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);\n    if (maxPixels > 0) {\n      maxAreaScale = Math.sqrt(maxPixels / (width * height));\n    }\n    if (maxDim !== -1) {\n      maxWidthScale = maxDim / width;\n      maxHeightScale = maxDim / height;\n    }\n    const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);\n    if (this.sx > maxScale || this.sy > maxScale) {\n      this.sx = maxScale;\n      this.sy = maxScale;\n      return true;\n    }\n    return false;\n  }\n  static get pixelRatio() {\n    return globalThis.devicePixelRatio || 1;\n  }\n  static capPixels(maxPixels, capAreaFactor) {\n    if (capAreaFactor >= 0) {\n      const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));\n      return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;\n    }\n    return maxPixels;\n  }\n}\nconst SupportedImageMimeTypes = [\"image/apng\", \"image/avif\", \"image/bmp\", \"image/gif\", \"image/jpeg\", \"image/png\", \"image/svg+xml\", \"image/webp\", \"image/x-icon\"];\nclass ColorScheme {\n  static get isDarkMode() {\n    return shadow(this, \"isDarkMode\", !!window?.matchMedia?.(\"(prefers-color-scheme: dark)\").matches);\n  }\n}\nclass CSSConstants {\n  static get commentForegroundColor() {\n    const element = document.createElement(\"span\");\n    element.classList.add(\"comment\", \"sidebar\");\n    const {\n      style\n    } = element;\n    style.width = style.height = \"0\";\n    style.display = \"none\";\n    style.color = \"var(--comment-fg-color)\";\n    document.body.append(element);\n    const {\n      color\n    } = window.getComputedStyle(element);\n    element.remove();\n    return shadow(this, \"commentForegroundColor\", getRGB(color));\n  }\n}\nfunction applyOpacity(r, g, b, opacity) {\n  opacity = Math.min(Math.max(opacity ?? 1, 0), 1);\n  const white = 255 * (1 - opacity);\n  r = Math.round(r * opacity + white);\n  g = Math.round(g * opacity + white);\n  b = Math.round(b * opacity + white);\n  return [r, g, b];\n}\nfunction RGBToHSL(rgb, output) {\n  const r = rgb[0] / 255;\n  const g = rgb[1] / 255;\n  const b = rgb[2] / 255;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  if (max === min) {\n    output[0] = output[1] = 0;\n  } else {\n    const d = max - min;\n    output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);\n    switch (max) {\n      case r:\n        output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;\n        break;\n      case g:\n        output[0] = ((b - r) / d + 2) * 60;\n        break;\n      case b:\n        output[0] = ((r - g) / d + 4) * 60;\n        break;\n    }\n  }\n  output[2] = l;\n}\nfunction HSLToRGB(hsl, output) {\n  const h = hsl[0];\n  const s = hsl[1];\n  const l = hsl[2];\n  const c = (1 - Math.abs(2 * l - 1)) * s;\n  const x = c * (1 - Math.abs(h / 60 % 2 - 1));\n  const m = l - c / 2;\n  switch (Math.floor(h / 60)) {\n    case 0:\n      output[0] = c + m;\n      output[1] = x + m;\n      output[2] = m;\n      break;\n    case 1:\n      output[0] = x + m;\n      output[1] = c + m;\n      output[2] = m;\n      break;\n    case 2:\n      output[0] = m;\n      output[1] = c + m;\n      output[2] = x + m;\n      break;\n    case 3:\n      output[0] = m;\n      output[1] = x + m;\n      output[2] = c + m;\n      break;\n    case 4:\n      output[0] = x + m;\n      output[1] = m;\n      output[2] = c + m;\n      break;\n    case 5:\n    case 6:\n      output[0] = c + m;\n      output[1] = m;\n      output[2] = x + m;\n      break;\n  }\n}\nfunction computeLuminance(x) {\n  return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n}\nfunction contrastRatio(hsl1, hsl2, output) {\n  HSLToRGB(hsl1, output);\n  output.map(computeLuminance);\n  const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n  HSLToRGB(hsl2, output);\n  output.map(computeLuminance);\n  const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];\n  return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);\n}\nconst contrastCache = new Map();\nfunction findContrastColor(baseColor, fixedColor) {\n  const key = baseColor[0] + baseColor[1] * 0x100 + baseColor[2] * 0x10000 + fixedColor[0] * 0x1000000 + fixedColor[1] * 0x100000000 + fixedColor[2] * 0x10000000000;\n  let cachedValue = contrastCache.get(key);\n  if (cachedValue) {\n    return cachedValue;\n  }\n  const array = new Float32Array(9);\n  const output = array.subarray(0, 3);\n  const baseHSL = array.subarray(3, 6);\n  RGBToHSL(baseColor, baseHSL);\n  const fixedHSL = array.subarray(6, 9);\n  RGBToHSL(fixedColor, fixedHSL);\n  const isFixedColorDark = fixedHSL[2] < 0.5;\n  const minContrast = isFixedColorDark ? 12 : 4.5;\n  baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);\n  if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n    let start, end;\n    if (isFixedColorDark) {\n      start = baseHSL[2];\n      end = 1;\n    } else {\n      start = 0;\n      end = baseHSL[2];\n    }\n    const PRECISION = 0.005;\n    while (end - start > PRECISION) {\n      const mid = baseHSL[2] = (start + end) / 2;\n      if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {\n        start = mid;\n      } else {\n        end = mid;\n      }\n    }\n    baseHSL[2] = isFixedColorDark ? end : start;\n  }\n  HSLToRGB(baseHSL, output);\n  cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));\n  contrastCache.set(key, cachedValue);\n  return cachedValue;\n}\nfunction renderRichText({\n  html,\n  dir,\n  className\n}, container) {\n  const fragment = document.createDocumentFragment();\n  if (typeof html === \"string\") {\n    const p = document.createElement(\"p\");\n    p.dir = dir || \"auto\";\n    const lines = html.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n    fragment.append(p);\n  } else {\n    XfaLayer.render({\n      xfaHtml: html,\n      div: fragment,\n      intent: \"richText\"\n    });\n  }\n  fragment.firstElementChild.classList.add(\"richText\", className);\n  container.append(fragment);\n}\nfunction makePathFromDrawOPS(data) {\n  const path = new Path2D();\n  if (!data) {\n    return path;\n  }\n  for (let i = 0, ii = data.length; i < ii;) {\n    switch (data[i++]) {\n      case DrawOPS.moveTo:\n        path.moveTo(data[i++], data[i++]);\n        break;\n      case DrawOPS.lineTo:\n        path.lineTo(data[i++], data[i++]);\n        break;\n      case DrawOPS.curveTo:\n        path.bezierCurveTo(data[i++], data[i++], data[i++], data[i++], data[i++], data[i++]);\n        break;\n      case DrawOPS.quadraticCurveTo:\n        path.quadraticCurveTo(data[i++], data[i++], data[i++], data[i++]);\n        break;\n      case DrawOPS.closePath:\n        path.closePath();\n        break;\n      default:\n        warn(`Unrecognized drawing path operator: ${data[i - 1]}`);\n        break;\n    }\n  }\n  return path;\n}\n\n;// ./src/display/editor/toolbar.js\n\nclass EditorToolbar {\n  #toolbar = null;\n  #colorPicker = null;\n  #editor;\n  #buttons = null;\n  #altText = null;\n  #comment = null;\n  #commentButtonDivider = null;\n  #signatureDescriptionButton = null;\n  static #l10nRemove = null;\n  constructor(editor) {\n    this.#editor = editor;\n    EditorToolbar.#l10nRemove ||= Object.freeze({\n      freetext: \"pdfjs-editor-remove-freetext-button\",\n      highlight: \"pdfjs-editor-remove-highlight-button\",\n      ink: \"pdfjs-editor-remove-ink-button\",\n      stamp: \"pdfjs-editor-remove-stamp-button\",\n      signature: \"pdfjs-editor-remove-signature-button\"\n    });\n  }\n  render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.classList.add(\"editToolbar\", \"hidden\");\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    const signal = this.#editor._uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      editToolbar.addEventListener(\"pointerdown\", EditorToolbar.#pointerDown, {\n        signal\n      });\n    }\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    const position = this.#editor.toolbarPosition;\n    if (position) {\n      const {\n        style\n      } = editToolbar;\n      const x = this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0];\n      style.insetInlineEnd = `${100 * x}%`;\n      style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;\n    }\n    return editToolbar;\n  }\n  get div() {\n    return this.#toolbar;\n  }\n  static #pointerDown(e) {\n    e.stopPropagation();\n  }\n  #focusIn(e) {\n    this.#editor._focusEventsAllowed = false;\n    stopEvent(e);\n  }\n  #focusOut(e) {\n    this.#editor._focusEventsAllowed = true;\n    stopEvent(e);\n  }\n  #addListenersToElement(element) {\n    const signal = this.#editor._uiManager._signal;\n    if (!(signal instanceof AbortSignal) || signal.aborted) {\n      return false;\n    }\n    element.addEventListener(\"focusin\", this.#focusIn.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"focusout\", this.#focusOut.bind(this), {\n      capture: true,\n      signal\n    });\n    element.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    return true;\n  }\n  hide() {\n    this.#toolbar.classList.add(\"hidden\");\n    this.#colorPicker?.hideDropdown();\n  }\n  show() {\n    this.#toolbar.classList.remove(\"hidden\");\n    this.#altText?.shown();\n    this.#comment?.shown();\n  }\n  addDeleteButton() {\n    const {\n      editorType,\n      _uiManager\n    } = this.#editor;\n    const button = document.createElement(\"button\");\n    button.classList.add(\"basic\", \"deleteButton\");\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", EditorToolbar.#l10nRemove[editorType]);\n    if (this.#addListenersToElement(button)) {\n      button.addEventListener(\"click\", e => {\n        _uiManager.delete();\n      }, {\n        signal: _uiManager._signal\n      });\n    }\n    this.#buttons.append(button);\n  }\n  get #divider() {\n    const divider = document.createElement(\"div\");\n    divider.className = \"divider\";\n    return divider;\n  }\n  async addAltText(altText) {\n    const button = await altText.render();\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n    this.#altText = altText;\n  }\n  addComment(comment, beforeElement = null) {\n    if (this.#comment) {\n      return;\n    }\n    const button = comment.renderForToolbar();\n    if (!button) {\n      return;\n    }\n    this.#addListenersToElement(button);\n    const divider = this.#commentButtonDivider = this.#divider;\n    if (!beforeElement) {\n      this.#buttons.append(button, divider);\n    } else {\n      this.#buttons.insertBefore(button, beforeElement);\n      this.#buttons.insertBefore(divider, beforeElement);\n    }\n    this.#comment = comment;\n    comment.toolbar = this;\n  }\n  addColorPicker(colorPicker) {\n    if (this.#colorPicker) {\n      return;\n    }\n    this.#colorPicker = colorPicker;\n    const button = colorPicker.renderButton();\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n  }\n  async addEditSignatureButton(signatureManager) {\n    const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);\n    this.#addListenersToElement(button);\n    this.#buttons.append(button, this.#divider);\n  }\n  removeButton(name) {\n    switch (name) {\n      case \"comment\":\n        this.#comment?.removeToolbarCommentButton();\n        this.#comment = null;\n        this.#commentButtonDivider?.remove();\n        this.#commentButtonDivider = null;\n        break;\n    }\n  }\n  async addButton(name, tool) {\n    switch (name) {\n      case \"colorPicker\":\n        if (tool) {\n          this.addColorPicker(tool);\n        }\n        break;\n      case \"altText\":\n        if (tool) {\n          await this.addAltText(tool);\n        }\n        break;\n      case \"editSignature\":\n        if (tool) {\n          await this.addEditSignatureButton(tool);\n        }\n        break;\n      case \"delete\":\n        this.addDeleteButton();\n        break;\n      case \"comment\":\n        if (tool) {\n          this.addComment(tool);\n        }\n        break;\n    }\n  }\n  async addButtonBefore(name, tool, beforeSelector) {\n    if (!tool && name === \"comment\") {\n      return;\n    }\n    const beforeElement = this.#buttons.querySelector(beforeSelector);\n    if (!beforeElement) {\n      return;\n    }\n    if (name === \"comment\") {\n      this.addComment(tool, beforeElement);\n    }\n  }\n  updateEditSignatureButton(description) {\n    if (this.#signatureDescriptionButton) {\n      this.#signatureDescriptionButton.title = description;\n    }\n  }\n  remove() {\n    this.#toolbar.remove();\n    this.#colorPicker?.destroy();\n    this.#colorPicker = null;\n  }\n}\nclass FloatingToolbar {\n  #buttons = null;\n  #toolbar = null;\n  #uiManager;\n  constructor(uiManager) {\n    this.#uiManager = uiManager;\n  }\n  #render() {\n    const editToolbar = this.#toolbar = document.createElement(\"div\");\n    editToolbar.className = \"editToolbar\";\n    editToolbar.setAttribute(\"role\", \"toolbar\");\n    const signal = this.#uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      editToolbar.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n    }\n    const buttons = this.#buttons = document.createElement(\"div\");\n    buttons.className = \"buttons\";\n    editToolbar.append(buttons);\n    if (this.#uiManager.hasCommentManager()) {\n      this.#makeButton(\"commentButton\", `pdfjs-comment-floating-button`, \"pdfjs-comment-floating-button-label\", () => {\n        this.#uiManager.commentSelection(\"floating_button\");\n      });\n    }\n    this.#makeButton(\"highlightButton\", `pdfjs-highlight-floating-button1`, \"pdfjs-highlight-floating-button-label\", () => {\n      this.#uiManager.highlightSelection(\"floating_button\");\n    });\n    return editToolbar;\n  }\n  #getLastPoint(boxes, isLTR) {\n    let lastY = 0;\n    let lastX = 0;\n    for (const box of boxes) {\n      const y = box.y + box.height;\n      if (y < lastY) {\n        continue;\n      }\n      const x = box.x + (isLTR ? box.width : 0);\n      if (y > lastY) {\n        lastX = x;\n        lastY = y;\n        continue;\n      }\n      if (isLTR) {\n        if (x > lastX) {\n          lastX = x;\n        }\n      } else if (x < lastX) {\n        lastX = x;\n      }\n    }\n    return [isLTR ? 1 - lastX : lastX, lastY];\n  }\n  show(parent, boxes, isLTR) {\n    const [x, y] = this.#getLastPoint(boxes, isLTR);\n    const {\n      style\n    } = this.#toolbar ||= this.#render();\n    parent.append(this.#toolbar);\n    style.insetInlineEnd = `${100 * x}%`;\n    style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;\n  }\n  hide() {\n    this.#toolbar.remove();\n  }\n  #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {\n    const button = document.createElement(\"button\");\n    button.classList.add(\"basic\", buttonClass);\n    button.tabIndex = 0;\n    button.setAttribute(\"data-l10n-id\", l10nId);\n    const span = document.createElement(\"span\");\n    button.append(span);\n    span.className = \"visuallyHidden\";\n    span.setAttribute(\"data-l10n-id\", labelL10nId);\n    const signal = this.#uiManager._signal;\n    if (signal instanceof AbortSignal && !signal.aborted) {\n      button.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      button.addEventListener(\"click\", clickHandler, {\n        signal\n      });\n    }\n    this.#buttons.append(button);\n  }\n}\n\n;// ./src/display/editor/tools.js\n\n\n\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\nclass CurrentPointers {\n  static #pointerId = NaN;\n  static #pointerIds = null;\n  static #moveTimestamp = NaN;\n  static #pointerType = null;\n  static initializeAndAddPointerId(pointerId) {\n    (CurrentPointers.#pointerIds ||= new Set()).add(pointerId);\n  }\n  static setPointer(pointerType, pointerId) {\n    CurrentPointers.#pointerId ||= pointerId;\n    CurrentPointers.#pointerType ??= pointerType;\n  }\n  static setTimeStamp(timeStamp) {\n    CurrentPointers.#moveTimestamp = timeStamp;\n  }\n  static isSamePointerId(pointerId) {\n    return CurrentPointers.#pointerId === pointerId;\n  }\n  static isSamePointerIdOrRemove(pointerId) {\n    if (CurrentPointers.#pointerId === pointerId) {\n      return true;\n    }\n    CurrentPointers.#pointerIds?.delete(pointerId);\n    return false;\n  }\n  static isSamePointerType(pointerType) {\n    return CurrentPointers.#pointerType === pointerType;\n  }\n  static isInitializedAndDifferentPointerType(pointerType) {\n    return CurrentPointers.#pointerType !== null && !CurrentPointers.isSamePointerType(pointerType);\n  }\n  static isSameTimeStamp(timeStamp) {\n    return CurrentPointers.#moveTimestamp === timeStamp;\n  }\n  static isUsingMultiplePointers() {\n    return CurrentPointers.#pointerIds?.size >= 1;\n  }\n  static clearPointerType() {\n    CurrentPointers.#pointerType = null;\n  }\n  static clearPointerIds() {\n    CurrentPointers.#pointerId = NaN;\n    CurrentPointers.#pointerIds = null;\n  }\n  static clearTimeStamp() {\n    CurrentPointers.#moveTimestamp = NaN;\n  }\n}\nclass IdManager {\n  #id = 0;\n  get id() {\n    return `${AnnotationEditorPrefix}${this.#id++}`;\n  }\n}\nclass ImageManager {\n  #baseId = getUuid();\n  #id = 0;\n  #cache = null;\n  static get _isSVGFittingCanvas() {\n    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n    const canvas = new OffscreenCanvas(1, 3);\n    const ctx = canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    const image = new Image();\n    image.src = svg;\n    const promise = image.decode().then(() => {\n      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n    });\n    return shadow(this, \"_isSVGFittingCanvas\", promise);\n  }\n  async #get(key, rawData) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(key);\n    if (data === null) {\n      return null;\n    }\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    try {\n      data ||= {\n        bitmap: null,\n        id: `image_${this.#baseId}_${this.#id++}`,\n        refCounter: 0,\n        isSvg: false\n      };\n      let image;\n      if (typeof rawData === \"string\") {\n        data.url = rawData;\n        image = await fetchData(rawData, \"blob\");\n      } else if (rawData instanceof File) {\n        image = data.file = rawData;\n      } else if (rawData instanceof Blob) {\n        image = rawData;\n      }\n      if (image.type === \"image/svg+xml\") {\n        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n        const fileReader = new FileReader();\n        const imageElement = new Image();\n        const imagePromise = new Promise((resolve, reject) => {\n          imageElement.onload = () => {\n            data.bitmap = imageElement;\n            data.isSvg = true;\n            resolve();\n          };\n          fileReader.onload = async () => {\n            const url = data.svgUrl = fileReader.result;\n            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;\n          };\n          imageElement.onerror = fileReader.onerror = reject;\n        });\n        fileReader.readAsDataURL(image);\n        await imagePromise;\n      } else {\n        data.bitmap = await createImageBitmap(image);\n      }\n      data.refCounter = 1;\n    } catch (e) {\n      warn(e);\n      data = null;\n    }\n    this.#cache.set(key, data);\n    if (data) {\n      this.#cache.set(data.id, data);\n    }\n    return data;\n  }\n  async getFromFile(file) {\n    const {\n      lastModified,\n      name,\n      size,\n      type\n    } = file;\n    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n  }\n  async getFromUrl(url) {\n    return this.#get(url, url);\n  }\n  async getFromBlob(id, blobPromise) {\n    const blob = await blobPromise;\n    return this.#get(id, blob);\n  }\n  async getFromId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return null;\n    }\n    if (data.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    if (data.file) {\n      return this.getFromFile(data.file);\n    }\n    if (data.blobPromise) {\n      const {\n        blobPromise\n      } = data;\n      delete data.blobPromise;\n      return this.getFromBlob(data.id, blobPromise);\n    }\n    return this.getFromUrl(data.url);\n  }\n  getFromCanvas(id, canvas) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(id);\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    const offscreen = new OffscreenCanvas(canvas.width, canvas.height);\n    const ctx = offscreen.getContext(\"2d\");\n    ctx.drawImage(canvas, 0, 0);\n    data = {\n      bitmap: offscreen.transferToImageBitmap(),\n      id: `image_${this.#baseId}_${this.#id++}`,\n      refCounter: 1,\n      isSvg: false\n    };\n    this.#cache.set(id, data);\n    this.#cache.set(data.id, data);\n    return data;\n  }\n  getSvgUrl(id) {\n    const data = this.#cache.get(id);\n    if (!data?.isSvg) {\n      return null;\n    }\n    return data.svgUrl;\n  }\n  deleteId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return;\n    }\n    data.refCounter -= 1;\n    if (data.refCounter !== 0) {\n      return;\n    }\n    const {\n      bitmap\n    } = data;\n    if (!data.url && !data.file) {\n      const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);\n      const ctx = canvas.getContext(\"bitmaprenderer\");\n      ctx.transferFromImageBitmap(bitmap);\n      data.blobPromise = canvas.convertToBlob();\n    }\n    bitmap.close?.();\n    data.bitmap = null;\n  }\n  isValidId(id) {\n    return id.startsWith(`image_${this.#baseId}_`);\n  }\n}\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n  constructor(maxSize = 128) {\n    this.#maxSize = maxSize;\n  }\n  add({\n    cmd,\n    undo,\n    post,\n    mustExec,\n    type = NaN,\n    overwriteIfSameType = false,\n    keepUndo = false\n  }) {\n    if (mustExec) {\n      cmd();\n    }\n    if (this.#locked) {\n      return;\n    }\n    const save = {\n      cmd,\n      undo,\n      post,\n      type\n    };\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n      this.#commands[this.#position] = save;\n      return;\n    }\n    const next = this.#position + 1;\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n    this.#commands.push(save);\n  }\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n    this.#locked = true;\n    const {\n      undo,\n      post\n    } = this.#commands[this.#position];\n    undo();\n    post?.();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      const {\n        cmd,\n        post\n      } = this.#commands[this.#position];\n      cmd();\n      post?.();\n      this.#locked = false;\n    }\n  }\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n  cleanType(type) {\n    if (this.#position === -1) {\n      return;\n    }\n    for (let i = this.#position; i >= 0; i--) {\n      if (this.#commands[i].type !== type) {\n        this.#commands.splice(i + 1, this.#position - i);\n        this.#position = i;\n        return;\n      }\n    }\n    this.#commands.length = 0;\n    this.#position = -1;\n  }\n  destroy() {\n    this.#commands = null;\n  }\n}\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    for (const [keys, callback, options = {}] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n    const info = this.callbacks.get(this.#serialize(event));\n    if (!info) {\n      return;\n    }\n    const {\n      callback,\n      options: {\n        bubbles = false,\n        args = [],\n        checker = null\n      }\n    } = info;\n    if (checker && !checker(self, event)) {\n      return;\n    }\n    callback.bind(self, ...args, event)();\n    if (!bubbles) {\n      stopEvent(event);\n    }\n  }\n}\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    getColorValues(colors);\n    return shadow(this, \"_colors\", colors);\n  }\n  convert(color) {\n    const rgb = getRGB(color);\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n    return rgb;\n  }\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n    if (!rgb) {\n      return name;\n    }\n    return Util.makeHexColor(...rgb);\n  }\n}\nclass AnnotationEditorUIManager {\n  #abortController = new AbortController();\n  #activeEditor = null;\n  #allEditableAnnotations = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #altTextManager = null;\n  #annotationStorage = null;\n  #changedExistingAnnotations = null;\n  #commandManager = new CommandManager();\n  #commentManager = null;\n  #copyPasteAC = null;\n  #currentDrawingSession = null;\n  #currentPageIndex = 0;\n  #deletedAnnotationsElementIds = new Set();\n  #draggingEditors = null;\n  #editorTypes = null;\n  #editorsToRescale = new Set();\n  _editorUndoBar = null;\n  #enableHighlightFloatingButton = false;\n  #enableUpdatedAddImage = false;\n  #enableNewAltTextWhenAddingImage = false;\n  #filterFactory = null;\n  #focusMainContainerTimeoutId = null;\n  #focusManagerAC = null;\n  #highlightColors = null;\n  #highlightWhenShiftUp = false;\n  #floatingToolbar = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #isPointerDown = false;\n  #isWaiting = false;\n  #keyboardManagerAC = null;\n  #lastActiveElement = null;\n  #mainHighlightColorPicker = null;\n  #missingCanvases = null;\n  #mlManager = null;\n  #mode = AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #selectedTextNode = null;\n  #signatureManager = null;\n  #pageColors = null;\n  #showAllStates = null;\n  #pdfDocument = null;\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false,\n    hasSelectedText: false\n  };\n  #translation = [0, 0];\n  #translationTimeoutId = null;\n  #container = null;\n  #viewer = null;\n  #viewerAlert = null;\n  #updateModeCapability = null;\n  static TRANSLATE_SMALL = 1;\n  static TRANSLATE_BIG = 10;\n  static get _keyboardManager() {\n    const proto = AnnotationEditorUIManager.prototype;\n    const arrowChecker = self => self.#container.contains(document.activeElement) && document.activeElement.tagName !== \"BUTTON\" && self.hasSomethingToControl();\n    const textInputChecker = (_self, {\n      target: el\n    }) => {\n      if (el instanceof HTMLInputElement) {\n        const {\n          type\n        } = el;\n        return type !== \"text\" && type !== \"number\";\n      }\n      return true;\n    };\n    const small = this.TRANSLATE_SMALL;\n    const big = this.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], proto.selectAll, {\n      checker: textInputChecker\n    }], [[\"ctrl+z\", \"mac+meta+z\"], proto.undo, {\n      checker: textInputChecker\n    }], [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], proto.redo, {\n      checker: textInputChecker\n    }], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"], proto.delete, {\n      checker: textInputChecker\n    }], [[\"Enter\", \"mac+Enter\"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled\n    }], [[\" \", \"mac+ \"], proto.addNewEditorFromKeyboard, {\n      checker: (self, {\n        target: el\n      }) => !(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)\n    }], [[\"Escape\", \"mac+Escape\"], proto.unselectAll], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {\n    const signal = this._signal = this.#abortController.signal;\n    this.#container = container;\n    this.#viewer = viewer;\n    this.#viewerAlert = viewerAlert;\n    this.#altTextManager = altTextManager;\n    this.#commentManager = commentManager;\n    this.#signatureManager = signatureManager;\n    this.#pdfDocument = pdfDocument;\n    this._eventBus = eventBus;\n    eventBus._on(\"editingaction\", this.onEditingAction.bind(this), {\n      signal\n    });\n    eventBus._on(\"pagechanging\", this.onPageChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"scalechanging\", this.onScaleChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"rotationchanging\", this.onRotationChanging.bind(this), {\n      signal\n    });\n    eventBus._on(\"setpreference\", this.onSetPreference.bind(this), {\n      signal\n    });\n    eventBus._on(\"switchannotationeditorparams\", evt => this.updateParams(evt.type, evt.value), {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", () => {\n      this.#isPointerDown = true;\n    }, {\n      capture: true,\n      signal\n    });\n    window.addEventListener(\"pointerup\", () => {\n      this.#isPointerDown = false;\n    }, {\n      capture: true,\n      signal\n    });\n    this.#addSelectionListener();\n    this.#addDragAndDropListeners();\n    this.#addKeyboardManager();\n    this.#annotationStorage = pdfDocument.annotationStorage;\n    this.#filterFactory = pdfDocument.filterFactory;\n    this.#pageColors = pageColors;\n    this.#highlightColors = highlightColors || null;\n    this.#enableHighlightFloatingButton = enableHighlightFloatingButton;\n    this.#enableUpdatedAddImage = enableUpdatedAddImage;\n    this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;\n    this.#mlManager = mlManager || null;\n    this.viewParameters = {\n      realScale: PixelsPerInch.PDF_TO_CSS_UNITS,\n      rotation: 0\n    };\n    this.isShiftKeyDown = false;\n    this._editorUndoBar = editorUndoBar || null;\n    this._supportsPinchToZoom = supportsPinchToZoom !== false;\n    commentManager?.setSidebarUiManager(this);\n  }\n  destroy() {\n    this.#updateModeCapability?.resolve();\n    this.#updateModeCapability = null;\n    this.#abortController?.abort();\n    this.#abortController = null;\n    this._signal = null;\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#editorsToRescale.clear();\n    this.#missingCanvases?.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#commandManager.destroy();\n    this.#altTextManager?.destroy();\n    this.#commentManager?.destroy();\n    this.#signatureManager?.destroy();\n    this.#floatingToolbar?.hide();\n    this.#floatingToolbar = null;\n    this.#mainHighlightColorPicker?.destroy();\n    this.#mainHighlightColorPicker = null;\n    this.#allEditableAnnotations = null;\n    if (this.#focusMainContainerTimeoutId) {\n      clearTimeout(this.#focusMainContainerTimeoutId);\n      this.#focusMainContainerTimeoutId = null;\n    }\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n      this.#translationTimeoutId = null;\n    }\n    this._editorUndoBar?.destroy();\n    this.#pdfDocument = null;\n  }\n  combinedSignal(ac) {\n    return AbortSignal.any([this._signal, ac.signal]);\n  }\n  get mlManager() {\n    return this.#mlManager;\n  }\n  get useNewAltTextFlow() {\n    return this.#enableUpdatedAddImage;\n  }\n  get useNewAltTextWhenAddingImage() {\n    return this.#enableNewAltTextWhenAddingImage;\n  }\n  get hcmFilter() {\n    return shadow(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n  }\n  get direction() {\n    return shadow(this, \"direction\", getComputedStyle(this.#container).direction);\n  }\n  get _highlightColors() {\n    return shadow(this, \"_highlightColors\", this.#highlightColors ? new Map(this.#highlightColors.split(\",\").map(pair => {\n      pair = pair.split(\"=\").map(x => x.trim());\n      pair[1] = pair[1].toUpperCase();\n      return pair;\n    })) : null);\n  }\n  get highlightColors() {\n    const {\n      _highlightColors\n    } = this;\n    if (!_highlightColors) {\n      return shadow(this, \"highlightColors\", null);\n    }\n    const map = new Map();\n    const hasHCM = !!this.#pageColors;\n    for (const [name, color] of _highlightColors) {\n      const isNameForHCM = name.endsWith(\"_HCM\");\n      if (hasHCM && isNameForHCM) {\n        map.set(name.replace(\"_HCM\", \"\"), color);\n        continue;\n      }\n      if (!hasHCM && !isNameForHCM) {\n        map.set(name, color);\n      }\n    }\n    return shadow(this, \"highlightColors\", map);\n  }\n  get highlightColorNames() {\n    return shadow(this, \"highlightColorNames\", this.highlightColors ? new Map(Array.from(this.highlightColors, e => e.reverse())) : null);\n  }\n  getNonHCMColor(color) {\n    if (!this._highlightColors) {\n      return color;\n    }\n    const colorName = this.highlightColorNames.get(color);\n    return this._highlightColors.get(colorName) || color;\n  }\n  getNonHCMColorName(color) {\n    return this.highlightColorNames.get(color) || color;\n  }\n  setCurrentDrawingSession(layer) {\n    if (layer) {\n      this.unselectAll();\n      this.disableUserSelect(true);\n    } else {\n      this.disableUserSelect(false);\n    }\n    this.#currentDrawingSession = layer;\n  }\n  setMainHighlightColorPicker(colorPicker) {\n    this.#mainHighlightColorPicker = colorPicker;\n  }\n  editAltText(editor, firstTime = false) {\n    this.#altTextManager?.editAltText(this, editor, firstTime);\n  }\n  hasCommentManager() {\n    return !!this.#commentManager;\n  }\n  editComment(editor, posX, posY, options) {\n    this.#commentManager?.showDialog(this, editor, posX, posY, options);\n  }\n  selectComment(pageIndex, uid) {\n    const layer = this.#allLayers.get(pageIndex);\n    const editor = layer?.getEditorByUID(uid);\n    editor?.toggleComment(true, true);\n  }\n  updateComment(editor) {\n    this.#commentManager?.updateComment(editor.getData());\n  }\n  updatePopupColor(editor) {\n    this.#commentManager?.updatePopupColor(editor);\n  }\n  removeComment(editor) {\n    this.#commentManager?.removeComments([editor.uid]);\n  }\n  toggleComment(editor, isSelected, visibility = undefined) {\n    this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);\n  }\n  makeCommentColor(color, opacity) {\n    return color && this.#commentManager?.makeCommentColor(color, opacity) || null;\n  }\n  getCommentDialogElement() {\n    return this.#commentManager?.dialogElement || null;\n  }\n  async waitForEditorsRendered(pageNumber) {\n    if (this.#allLayers.has(pageNumber - 1)) {\n      return;\n    }\n    const {\n      resolve,\n      promise\n    } = Promise.withResolvers();\n    const onEditorsRendered = evt => {\n      if (evt.pageNumber === pageNumber) {\n        this._eventBus._off(\"editorsrendered\", onEditorsRendered);\n        resolve();\n      }\n    };\n    this._eventBus.on(\"editorsrendered\", onEditorsRendered);\n    await promise;\n  }\n  getSignature(editor) {\n    this.#signatureManager?.getSignature({\n      uiManager: this,\n      editor\n    });\n  }\n  get signatureManager() {\n    return this.#signatureManager;\n  }\n  switchToMode(mode, callback) {\n    this._eventBus.on(\"annotationeditormodechanged\", callback, {\n      once: true,\n      signal: this._signal\n    });\n    this._eventBus.dispatch(\"showannotationeditorui\", {\n      source: this,\n      mode\n    });\n  }\n  setPreference(name, value) {\n    this._eventBus.dispatch(\"setpreference\", {\n      source: this,\n      name,\n      value\n    });\n  }\n  onSetPreference({\n    name,\n    value\n  }) {\n    switch (name) {\n      case \"enableNewAltTextWhenAddingImage\":\n        this.#enableNewAltTextWhenAddingImage = value;\n        break;\n    }\n  }\n  onPageChanging({\n    pageNumber\n  }) {\n    this.#currentPageIndex = pageNumber - 1;\n  }\n  focusMainContainer() {\n    this.#container.focus();\n  }\n  findParent(x, y) {\n    for (const layer of this.#allLayers.values()) {\n      const {\n        x: layerX,\n        y: layerY,\n        width,\n        height\n      } = layer.div.getBoundingClientRect();\n      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  disableUserSelect(value = false) {\n    this.#viewer.classList.toggle(\"noUserSelect\", value);\n  }\n  addShouldRescale(editor) {\n    this.#editorsToRescale.add(editor);\n  }\n  removeShouldRescale(editor) {\n    this.#editorsToRescale.delete(editor);\n  }\n  onScaleChanging({\n    scale\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;\n    for (const editor of this.#editorsToRescale) {\n      editor.onScaleChanging();\n    }\n    this.#currentDrawingSession?.onScaleChanging();\n  }\n  onRotationChanging({\n    pagesRotation\n  }) {\n    this.commitOrRemove();\n    this.viewParameters.rotation = pagesRotation;\n  }\n  #getAnchorElementForSelection({\n    anchorNode\n  }) {\n    return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;\n  }\n  #getLayerForTextLayer(textLayer) {\n    const {\n      currentLayer\n    } = this;\n    if (currentLayer.hasTextLayer(textLayer)) {\n      return currentLayer;\n    }\n    for (const layer of this.#allLayers.values()) {\n      if (layer.hasTextLayer(textLayer)) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  highlightSelection(methodOfCreation = \"\", comment = false) {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset\n    } = selection;\n    const text = selection.toString();\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    selection.empty();\n    const layer = this.#getLayerForTextLayer(textLayer);\n    const isNoneMode = this.#mode === AnnotationEditorType.NONE;\n    const callback = () => {\n      const editor = layer?.createAndAddNewEditor({\n        x: 0,\n        y: 0\n      }, false, {\n        methodOfCreation,\n        boxes,\n        anchorNode,\n        anchorOffset,\n        focusNode,\n        focusOffset,\n        text\n      });\n      if (isNoneMode) {\n        this.showAllEditors(\"highlight\", true, true);\n      }\n      if (comment) {\n        editor?.editComment();\n      }\n    };\n    if (isNoneMode) {\n      this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);\n      return;\n    }\n    callback();\n  }\n  commentSelection(methodOfCreation = \"\") {\n    this.highlightSelection(methodOfCreation, true);\n  }\n  #displayFloatingToolbar() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    const boxes = this.getSelectionBoxes(textLayer);\n    if (!boxes) {\n      return;\n    }\n    this.#floatingToolbar ||= new FloatingToolbar(this);\n    this.#floatingToolbar.show(textLayer, boxes, this.direction === \"ltr\");\n  }\n  getAndRemoveDataFromAnnotationStorage(annotationId) {\n    if (!this.#annotationStorage) {\n      return null;\n    }\n    const key = `${AnnotationEditorPrefix}${annotationId}`;\n    const storedValue = this.#annotationStorage.getRawValue(key);\n    if (storedValue) {\n      this.#annotationStorage.remove(key);\n    }\n    return storedValue;\n  }\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n      this.#annotationStorage.setValue(editor.id, editor);\n    }\n  }\n  a11yAlert(messageId, args = null) {\n    const viewerAlert = this.#viewerAlert;\n    if (!viewerAlert) {\n      return;\n    }\n    viewerAlert.setAttribute(\"data-l10n-id\", messageId);\n    if (args) {\n      viewerAlert.setAttribute(\"data-l10n-args\", JSON.stringify(args));\n    } else {\n      viewerAlert.removeAttribute(\"data-l10n-args\");\n    }\n  }\n  #selectionChange() {\n    const selection = document.getSelection();\n    if (!selection || selection.isCollapsed) {\n      if (this.#selectedTextNode) {\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    const {\n      anchorNode\n    } = selection;\n    if (anchorNode === this.#selectedTextNode) {\n      return;\n    }\n    const anchorElement = this.#getAnchorElementForSelection(selection);\n    const textLayer = anchorElement.closest(\".textLayer\");\n    if (!textLayer) {\n      if (this.#selectedTextNode) {\n        this.#floatingToolbar?.hide();\n        this.#selectedTextNode = null;\n        this.#dispatchUpdateStates({\n          hasSelectedText: false\n        });\n      }\n      return;\n    }\n    this.#floatingToolbar?.hide();\n    this.#selectedTextNode = anchorNode;\n    this.#dispatchUpdateStates({\n      hasSelectedText: true\n    });\n    if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.showAllEditors(\"highlight\", true, true);\n    }\n    this.#highlightWhenShiftUp = this.isShiftKeyDown;\n    if (!this.isShiftKeyDown) {\n      const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;\n      activeLayer?.toggleDrawing();\n      if (this.#isPointerDown) {\n        const ac = new AbortController();\n        const signal = this.combinedSignal(ac);\n        const pointerup = e => {\n          if (e.type === \"pointerup\" && e.button !== 0) {\n            return;\n          }\n          ac.abort();\n          activeLayer?.toggleDrawing(true);\n          if (e.type === \"pointerup\") {\n            this.#onSelectEnd(\"main_toolbar\");\n          }\n        };\n        window.addEventListener(\"pointerup\", pointerup, {\n          signal\n        });\n        window.addEventListener(\"blur\", pointerup, {\n          signal\n        });\n      } else {\n        activeLayer?.toggleDrawing(true);\n        this.#onSelectEnd(\"main_toolbar\");\n      }\n    }\n  }\n  #onSelectEnd(methodOfCreation = \"\") {\n    if (this.#mode === AnnotationEditorType.HIGHLIGHT) {\n      this.highlightSelection(methodOfCreation);\n    } else if (this.#enableHighlightFloatingButton) {\n      this.#displayFloatingToolbar();\n    }\n  }\n  #addSelectionListener() {\n    document.addEventListener(\"selectionchange\", this.#selectionChange.bind(this), {\n      signal: this._signal\n    });\n  }\n  #addFocusManager() {\n    if (this.#focusManagerAC) {\n      return;\n    }\n    this.#focusManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#focusManagerAC);\n    window.addEventListener(\"focus\", this.focus.bind(this), {\n      signal\n    });\n    window.addEventListener(\"blur\", this.blur.bind(this), {\n      signal\n    });\n  }\n  #removeFocusManager() {\n    this.#focusManagerAC?.abort();\n    this.#focusManagerAC = null;\n  }\n  blur() {\n    this.isShiftKeyDown = false;\n    if (this.#highlightWhenShiftUp) {\n      this.#highlightWhenShiftUp = false;\n      this.#onSelectEnd(\"main_toolbar\");\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    for (const editor of this.#selectedEditors) {\n      if (editor.div.contains(activeElement)) {\n        this.#lastActiveElement = [editor, activeElement];\n        editor._focusEventsAllowed = false;\n        break;\n      }\n    }\n  }\n  focus() {\n    if (!this.#lastActiveElement) {\n      return;\n    }\n    const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n    this.#lastActiveElement = null;\n    lastActiveElement.addEventListener(\"focusin\", () => {\n      lastEditor._focusEventsAllowed = true;\n    }, {\n      once: true,\n      signal: this._signal\n    });\n    lastActiveElement.focus();\n  }\n  #addKeyboardManager() {\n    if (this.#keyboardManagerAC) {\n      return;\n    }\n    this.#keyboardManagerAC = new AbortController();\n    const signal = this.combinedSignal(this.#keyboardManagerAC);\n    window.addEventListener(\"keydown\", this.keydown.bind(this), {\n      signal\n    });\n    window.addEventListener(\"keyup\", this.keyup.bind(this), {\n      signal\n    });\n  }\n  #removeKeyboardManager() {\n    this.#keyboardManagerAC?.abort();\n    this.#keyboardManagerAC = null;\n  }\n  #addCopyPasteListeners() {\n    if (this.#copyPasteAC) {\n      return;\n    }\n    this.#copyPasteAC = new AbortController();\n    const signal = this.combinedSignal(this.#copyPasteAC);\n    document.addEventListener(\"copy\", this.copy.bind(this), {\n      signal\n    });\n    document.addEventListener(\"cut\", this.cut.bind(this), {\n      signal\n    });\n    document.addEventListener(\"paste\", this.paste.bind(this), {\n      signal\n    });\n  }\n  #removeCopyPasteListeners() {\n    this.#copyPasteAC?.abort();\n    this.#copyPasteAC = null;\n  }\n  #addDragAndDropListeners() {\n    const signal = this._signal;\n    document.addEventListener(\"dragover\", this.dragOver.bind(this), {\n      signal\n    });\n    document.addEventListener(\"drop\", this.drop.bind(this), {\n      signal\n    });\n  }\n  addEditListeners() {\n    this.#addKeyboardManager();\n    this.setEditingState(true);\n  }\n  removeEditListeners() {\n    this.#removeKeyboardManager();\n    this.setEditingState(false);\n  }\n  dragOver(event) {\n    for (const {\n      type\n    } of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(type)) {\n          event.dataTransfer.dropEffect = \"copy\";\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  drop(event) {\n    for (const item of event.dataTransfer.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          event.preventDefault();\n          return;\n        }\n      }\n    }\n  }\n  copy(event) {\n    event.preventDefault();\n    this.#activeEditor?.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [];\n    for (const editor of this.#selectedEditors) {\n      const serialized = editor.serialize(true);\n      if (serialized) {\n        editors.push(serialized);\n      }\n    }\n    if (editors.length === 0) {\n      return;\n    }\n    event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n  }\n  cut(event) {\n    this.copy(event);\n    this.delete();\n  }\n  async paste(event) {\n    event.preventDefault();\n    const {\n      clipboardData\n    } = event;\n    for (const item of clipboardData.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          return;\n        }\n      }\n    }\n    let data = clipboardData.getData(\"application/pdfjs\");\n    if (!data) {\n      return;\n    }\n    try {\n      data = JSON.parse(data);\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n      return;\n    }\n    if (!Array.isArray(data)) {\n      return;\n    }\n    this.unselectAll();\n    const layer = this.currentLayer;\n    try {\n      const newEditors = [];\n      for (const editor of data) {\n        const deserializedEditor = await layer.deserialize(editor);\n        if (!deserializedEditor) {\n          return;\n        }\n        newEditors.push(deserializedEditor);\n      }\n      const cmd = () => {\n        for (const editor of newEditors) {\n          this.#addEditorToLayer(editor);\n        }\n        this.#selectEditors(newEditors);\n      };\n      const undo = () => {\n        for (const editor of newEditors) {\n          editor.remove();\n        }\n      };\n      this.addCommands({\n        cmd,\n        undo,\n        mustExec: true\n      });\n    } catch (ex) {\n      warn(`paste: \"${ex.message}\".`);\n    }\n  }\n  keydown(event) {\n    if (!this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = true;\n    }\n    if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n  keyup(event) {\n    if (this.isShiftKeyDown && event.key === \"Shift\") {\n      this.isShiftKeyDown = false;\n      if (this.#highlightWhenShiftUp) {\n        this.#highlightWhenShiftUp = false;\n        this.#onSelectEnd(\"main_toolbar\");\n      }\n    }\n  }\n  onEditingAction({\n    name\n  }) {\n    switch (name) {\n      case \"undo\":\n      case \"redo\":\n      case \"delete\":\n      case \"selectAll\":\n        this[name]();\n        break;\n      case \"highlightSelection\":\n        this.highlightSelection(\"context_menu\");\n        break;\n      case \"commentSelection\":\n        this.commentSelection(\"context_menu\");\n        break;\n    }\n  }\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);\n    if (hasChanged) {\n      this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n      if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {\n        this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);\n      }\n    }\n  }\n  #dispatchUpdateUI(details) {\n    this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addFocusManager();\n      this.#addCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false\n      });\n    } else {\n      this.#removeFocusManager();\n      this.#removeCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n      this.disableUserSelect(false);\n    }\n  }\n  registerEditorTypes(types) {\n    if (this.#editorTypes) {\n      return;\n    }\n    this.#editorTypes = types;\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n  getId() {\n    return this.#idManager.id;\n  }\n  get currentLayer() {\n    return this.#allLayers.get(this.#currentPageIndex);\n  }\n  getLayer(pageIndex) {\n    return this.#allLayers.get(pageIndex);\n  }\n  get currentPageIndex() {\n    return this.#currentPageIndex;\n  }\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n  async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {\n    if (this.#mode === mode) {\n      return;\n    }\n    if (this.#updateModeCapability) {\n      await this.#updateModeCapability.promise;\n      if (!this.#updateModeCapability) {\n        return;\n      }\n    }\n    this.#updateModeCapability = Promise.withResolvers();\n    this.#currentDrawingSession?.commitOrRemove();\n    if (this.#mode === AnnotationEditorType.POPUP) {\n      this.#commentManager?.hideSidebar();\n    }\n    this.#commentManager?.destroyPopup();\n    this.#mode = mode;\n    if (mode === AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n      for (const editor of this.#allEditors.values()) {\n        editor.hideStandaloneCommentButton();\n      }\n      this._editorUndoBar?.hide();\n      this.toggleComment(null);\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      editor.addStandaloneCommentButton();\n    }\n    if (mode === AnnotationEditorType.SIGNATURE) {\n      await this.#signatureManager?.loadSignatures();\n    }\n    this.setEditingState(true);\n    await this.#enableAll();\n    this.unselectAll();\n    for (const layer of this.#allLayers.values()) {\n      layer.updateMode(mode);\n    }\n    if (mode === AnnotationEditorType.POPUP) {\n      this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map(editorClass => editorClass._editorType)));\n      const elementIds = new Set();\n      const allComments = [];\n      for (const editor of this.#allEditors.values()) {\n        const {\n          annotationElementId,\n          hasComment,\n          deleted\n        } = editor;\n        if (annotationElementId) {\n          elementIds.add(annotationElementId);\n        }\n        if (hasComment && !deleted) {\n          allComments.push(editor.getData());\n        }\n      }\n      for (const annotation of this.#allEditableAnnotations) {\n        const {\n          id,\n          popupRef,\n          contentsObj\n        } = annotation;\n        if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {\n          allComments.push(annotation);\n        }\n      }\n      this.#commentManager?.showSidebar(allComments);\n    }\n    if (!editId) {\n      if (isFromKeyboard) {\n        this.addNewEditorFromKeyboard();\n      }\n      this.#updateModeCapability.resolve();\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      if (editor.uid === editId) {\n        this.setSelected(editor);\n        if (editComment) {\n          editor.editComment();\n        } else if (mustEnterInEditMode) {\n          editor.enterInEditMode();\n        } else {\n          editor.focus();\n        }\n      } else {\n        editor.unselect();\n      }\n    }\n    this.#updateModeCapability.resolve();\n  }\n  addNewEditorFromKeyboard() {\n    if (this.currentLayer.canCreateNewEmptyEditor()) {\n      this.currentLayer.addNewEditor();\n    }\n  }\n  updateToolbar(options) {\n    if (options.mode === this.#mode) {\n      return;\n    }\n    this._eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      ...options\n    });\n  }\n  updateParams(type, value) {\n    if (!this.#editorTypes) {\n      return;\n    }\n    switch (type) {\n      case AnnotationEditorParamsType.CREATE:\n        this.currentLayer.addNewEditor(value);\n        return;\n      case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:\n        this._eventBus.dispatch(\"reporttelemetry\", {\n          source: this,\n          details: {\n            type: \"editing\",\n            data: {\n              type: \"highlight\",\n              action: \"toggle_visibility\"\n            }\n          }\n        });\n        (this.#showAllStates ||= new Map()).set(type, value);\n        this.showAllEditors(\"highlight\", value);\n        break;\n    }\n    if (this.hasSelection) {\n      for (const editor of this.#selectedEditors) {\n        editor.updateParams(type, value);\n      }\n    } else {\n      for (const editorType of this.#editorTypes) {\n        editorType.updateDefaultParams(type, value);\n      }\n    }\n  }\n  showAllEditors(type, visible, updateButton = false) {\n    for (const editor of this.#allEditors.values()) {\n      if (editor.editorType === type) {\n        editor.show(visible);\n      }\n    }\n    const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;\n    if (state !== visible) {\n      this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);\n    }\n  }\n  enableWaiting(mustWait = false) {\n    if (this.#isWaiting === mustWait) {\n      return;\n    }\n    this.#isWaiting = mustWait;\n    for (const layer of this.#allLayers.values()) {\n      if (mustWait) {\n        layer.disableClick();\n      } else {\n        layer.enableClick();\n      }\n      layer.div.classList.toggle(\"waiting\", mustWait);\n    }\n  }\n  async #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n      const promises = [];\n      for (const layer of this.#allLayers.values()) {\n        promises.push(layer.enable());\n      }\n      await Promise.all(promises);\n      for (const editor of this.#allEditors.values()) {\n        editor.enable();\n      }\n    }\n  }\n  #disableAll() {\n    this.unselectAll();\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n      for (const editor of this.#allEditors.values()) {\n        editor.disable();\n      }\n    }\n  }\n  *getEditors(pageIndex) {\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        yield editor;\n      }\n    }\n  }\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n  removeEditor(editor) {\n    if (editor.div.contains(document.activeElement)) {\n      if (this.#focusMainContainerTimeoutId) {\n        clearTimeout(this.#focusMainContainerTimeoutId);\n      }\n      this.#focusMainContainerTimeoutId = setTimeout(() => {\n        this.focusMainContainer();\n        this.#focusMainContainerTimeoutId = null;\n      }, 0);\n    }\n    this.#allEditors.delete(editor.id);\n    if (editor.annotationElementId) {\n      this.#missingCanvases?.delete(editor.annotationElementId);\n    }\n    this.unselect(editor);\n    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n      this.#annotationStorage?.remove(editor.id);\n    }\n  }\n  addDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n    this.addChangedExistingAnnotation(editor);\n    editor.deleted = true;\n  }\n  isDeletedAnnotationElement(annotationElementId) {\n    return this.#deletedAnnotationsElementIds.has(annotationElementId);\n  }\n  removeDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n    this.removeChangedExistingAnnotation(editor);\n    editor.deleted = false;\n  }\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n      this.addToAnnotationStorage(editor);\n    }\n  }\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n    this.#activeEditor = editor;\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  get #lastSelectedEditor() {\n    let ed = null;\n    for (ed of this.#selectedEditors) {}\n    return ed;\n  }\n  updateUI(editor) {\n    if (this.#lastSelectedEditor === editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  updateUIForDefaultProperties(editorType) {\n    this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n  }\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  setSelected(editor) {\n    this.updateToolbar({\n      mode: editor.mode,\n      editId: editor.uid\n    });\n    this.#currentDrawingSession?.commitOrRemove();\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n  get firstSelectedEditor() {\n    return this.#selectedEditors.values().next().value;\n  }\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n  get isEnterHandled() {\n    return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;\n  }\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n    this._editorUndoBar?.hide();\n  }\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  cleanUndoStack(type) {\n    this.#commandManager.cleanType(type);\n  }\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n    return false;\n  }\n  delete() {\n    this.commitOrRemove();\n    const drawingEditor = this.currentLayer?.endDrawingSession(true);\n    if (!this.hasSelection && !drawingEditor) {\n      return;\n    }\n    const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];\n    const cmd = () => {\n      this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  commitOrRemove() {\n    this.#activeEditor?.commitOrRemove();\n  }\n  hasSomethingToControl() {\n    return this.#activeEditor || this.hasSelection;\n  }\n  #selectEditors(editors) {\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n    this.#selectEditors(this.#allEditors.values());\n  }\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      if (this.#mode !== AnnotationEditorType.NONE) {\n        return;\n      }\n    }\n    if (this.#currentDrawingSession?.commitOrRemove()) {\n      return;\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n  translateSelectedEditors(x, y, noCommit = false) {\n    if (!noCommit) {\n      this.commitOrRemove();\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    this.#translation[0] += x;\n    this.#translation[1] += y;\n    const [totalX, totalY] = this.#translation;\n    const editors = [...this.#selectedEditors];\n    const TIME_TO_WAIT = 1000;\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n    }\n    this.#translationTimeoutId = setTimeout(() => {\n      this.#translationTimeoutId = null;\n      this.#translation[0] = this.#translation[1] = 0;\n      this.addCommands({\n        cmd: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(totalX, totalY);\n              editor.translationDone();\n            }\n          }\n        },\n        undo: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(-totalX, -totalY);\n              editor.translationDone();\n            }\n          }\n        },\n        mustExec: false\n      });\n    }, TIME_TO_WAIT);\n    for (const editor of editors) {\n      editor.translateInPage(x, y);\n      editor.translationDone();\n    }\n  }\n  setUpDragSession() {\n    if (!this.hasSelection) {\n      return;\n    }\n    this.disableUserSelect(true);\n    this.#draggingEditors = new Map();\n    for (const editor of this.#selectedEditors) {\n      this.#draggingEditors.set(editor, {\n        savedX: editor.x,\n        savedY: editor.y,\n        savedPageIndex: editor.pageIndex,\n        newX: 0,\n        newY: 0,\n        newPageIndex: -1\n      });\n    }\n  }\n  endDragSession() {\n    if (!this.#draggingEditors) {\n      return false;\n    }\n    this.disableUserSelect(false);\n    const map = this.#draggingEditors;\n    this.#draggingEditors = null;\n    let mustBeAddedInUndoStack = false;\n    for (const [{\n      x,\n      y,\n      pageIndex\n    }, value] of map) {\n      value.newX = x;\n      value.newY = y;\n      value.newPageIndex = pageIndex;\n      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n    }\n    if (!mustBeAddedInUndoStack) {\n      return false;\n    }\n    const move = (editor, x, y, pageIndex) => {\n      if (this.#allEditors.has(editor.id)) {\n        const parent = this.#allLayers.get(pageIndex);\n        if (parent) {\n          editor._setParentAndPosition(parent, x, y);\n        } else {\n          editor.pageIndex = pageIndex;\n          editor.x = x;\n          editor.y = y;\n        }\n      }\n    };\n    this.addCommands({\n      cmd: () => {\n        for (const [editor, {\n          newX,\n          newY,\n          newPageIndex\n        }] of map) {\n          move(editor, newX, newY, newPageIndex);\n        }\n      },\n      undo: () => {\n        for (const [editor, {\n          savedX,\n          savedY,\n          savedPageIndex\n        }] of map) {\n          move(editor, savedX, savedY, savedPageIndex);\n        }\n      },\n      mustExec: true\n    });\n    return true;\n  }\n  dragSelectedEditors(tx, ty) {\n    if (!this.#draggingEditors) {\n      return;\n    }\n    for (const editor of this.#draggingEditors.keys()) {\n      editor.drag(tx, ty);\n    }\n  }\n  rebuild(editor) {\n    if (editor.parent === null) {\n      const parent = this.getLayer(editor.pageIndex);\n      if (parent) {\n        parent.changeParent(editor);\n        parent.addOrRebuild(editor);\n      } else {\n        this.addEditor(editor);\n        this.addToAnnotationStorage(editor);\n        editor.rebuild();\n      }\n    } else {\n      editor.parent.addOrRebuild(editor);\n    }\n  }\n  get isEditorHandlingKeyboard() {\n    return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();\n  }\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n  getActive() {\n    return this.#activeEditor;\n  }\n  getMode() {\n    return this.#mode;\n  }\n  isEditingMode() {\n    return this.#mode !== AnnotationEditorType.NONE;\n  }\n  get imageManager() {\n    return shadow(this, \"imageManager\", new ImageManager());\n  }\n  getSelectionBoxes(textLayer) {\n    if (!textLayer) {\n      return null;\n    }\n    const selection = document.getSelection();\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {\n        return null;\n      }\n    }\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    let rotator;\n    switch (textLayer.getAttribute(\"data-main-rotation\")) {\n      case \"90\":\n        rotator = (x, y, w, h) => ({\n          x: (y - layerY) / parentHeight,\n          y: 1 - (x + w - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      case \"180\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (x + w - layerX) / parentWidth,\n          y: 1 - (y + h - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n      case \"270\":\n        rotator = (x, y, w, h) => ({\n          x: 1 - (y + h - layerY) / parentHeight,\n          y: (x - layerX) / parentWidth,\n          width: h / parentHeight,\n          height: w / parentWidth\n        });\n        break;\n      default:\n        rotator = (x, y, w, h) => ({\n          x: (x - layerX) / parentWidth,\n          y: (y - layerY) / parentHeight,\n          width: w / parentWidth,\n          height: h / parentHeight\n        });\n        break;\n    }\n    const boxes = [];\n    for (let i = 0, ii = selection.rangeCount; i < ii; i++) {\n      const range = selection.getRangeAt(i);\n      if (range.collapsed) {\n        continue;\n      }\n      for (const {\n        x,\n        y,\n        width,\n        height\n      } of range.getClientRects()) {\n        if (width === 0 || height === 0) {\n          continue;\n        }\n        boxes.push(rotator(x, y, width, height));\n      }\n    }\n    return boxes.length === 0 ? null : boxes;\n  }\n  addChangedExistingAnnotation({\n    annotationElementId,\n    id\n  }) {\n    (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);\n  }\n  removeChangedExistingAnnotation({\n    annotationElementId\n  }) {\n    this.#changedExistingAnnotations?.delete(annotationElementId);\n  }\n  renderAnnotationElement(annotation) {\n    const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);\n    if (!editorId) {\n      return;\n    }\n    const editor = this.#annotationStorage.getRawValue(editorId);\n    if (!editor) {\n      return;\n    }\n    if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {\n      return;\n    }\n    editor.renderAnnotationElement(annotation);\n  }\n  setMissingCanvas(annotationId, annotationElementId, canvas) {\n    const editor = this.#missingCanvases?.get(annotationId);\n    if (!editor) {\n      return;\n    }\n    editor.setCanvas(annotationElementId, canvas);\n    this.#missingCanvases.delete(annotationId);\n  }\n  addMissingCanvas(annotationId, editor) {\n    (this.#missingCanvases ||= new Map()).set(annotationId, editor);\n  }\n}\n\n;// ./src/display/editor/alt_text.js\n\nclass AltText {\n  #altText = null;\n  #altTextDecorative = false;\n  #altTextButton = null;\n  #altTextButtonLabel = null;\n  #altTextTooltip = null;\n  #altTextTooltipTimeout = null;\n  #altTextWasFromKeyBoard = false;\n  #badge = null;\n  #editor = null;\n  #guessedText = null;\n  #textWithDisclaimer = null;\n  #useNewAltTextFlow = false;\n  static #l10nNewButton = null;\n  static _l10n = null;\n  constructor(editor) {\n    this.#editor = editor;\n    this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;\n    AltText.#l10nNewButton ||= Object.freeze({\n      added: \"pdfjs-editor-new-alt-text-added-button\",\n      \"added-label\": \"pdfjs-editor-new-alt-text-added-button-label\",\n      missing: \"pdfjs-editor-new-alt-text-missing-button\",\n      \"missing-label\": \"pdfjs-editor-new-alt-text-missing-button-label\",\n      review: \"pdfjs-editor-new-alt-text-to-review-button\",\n      \"review-label\": \"pdfjs-editor-new-alt-text-to-review-button-label\"\n    });\n  }\n  static initialize(l10n) {\n    AltText._l10n ??= l10n;\n  }\n  async render() {\n    const altText = this.#altTextButton = document.createElement(\"button\");\n    altText.className = \"altText\";\n    altText.tabIndex = \"0\";\n    const label = this.#altTextButtonLabel = document.createElement(\"span\");\n    altText.append(label);\n    if (this.#useNewAltTextFlow) {\n      altText.classList.add(\"new\");\n      altText.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton.missing);\n      label.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[\"missing-label\"]);\n    } else {\n      altText.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button\");\n      label.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-button-label\");\n    }\n    const signal = this.#editor._uiManager._signal;\n    altText.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    altText.addEventListener(\"pointerdown\", event => event.stopPropagation(), {\n      signal\n    });\n    const onClick = event => {\n      event.preventDefault();\n      this.#editor._uiManager.editAltText(this.#editor);\n      if (this.#useNewAltTextFlow) {\n        this.#editor._reportTelemetry({\n          action: \"pdfjs.image.alt_text.image_status_label_clicked\",\n          data: {\n            label: this.#label\n          }\n        });\n      }\n    };\n    altText.addEventListener(\"click\", onClick, {\n      capture: true,\n      signal\n    });\n    altText.addEventListener(\"keydown\", event => {\n      if (event.target === altText && event.key === \"Enter\") {\n        this.#altTextWasFromKeyBoard = true;\n        onClick(event);\n      }\n    }, {\n      signal\n    });\n    await this.#setState();\n    return altText;\n  }\n  get #label() {\n    return this.#altText && \"added\" || this.#altText === null && this.guessedText && \"review\" || \"missing\";\n  }\n  finish() {\n    if (!this.#altTextButton) {\n      return;\n    }\n    this.#altTextButton.focus({\n      focusVisible: this.#altTextWasFromKeyBoard\n    });\n    this.#altTextWasFromKeyBoard = false;\n  }\n  isEmpty() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText === null;\n    }\n    return !this.#altText && !this.#altTextDecorative;\n  }\n  hasData() {\n    if (this.#useNewAltTextFlow) {\n      return this.#altText !== null || !!this.#guessedText;\n    }\n    return this.isEmpty();\n  }\n  get guessedText() {\n    return this.#guessedText;\n  }\n  async setGuessedText(guessedText) {\n    if (this.#altText !== null) {\n      return;\n    }\n    this.#guessedText = guessedText;\n    this.#textWithDisclaimer = await AltText._l10n.get(\"pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer\", {\n      generatedAltText: guessedText\n    });\n    this.#setState();\n  }\n  toggleAltTextBadge(visibility = false) {\n    if (!this.#useNewAltTextFlow || this.#altText) {\n      this.#badge?.remove();\n      this.#badge = null;\n      return;\n    }\n    if (!this.#badge) {\n      const badge = this.#badge = document.createElement(\"div\");\n      badge.className = \"noAltTextBadge\";\n      this.#editor.div.append(badge);\n    }\n    this.#badge.classList.toggle(\"hidden\", !visibility);\n  }\n  serialize(isForCopying) {\n    let altText = this.#altText;\n    if (!isForCopying && this.#guessedText === altText) {\n      altText = this.#textWithDisclaimer;\n    }\n    return {\n      altText,\n      decorative: this.#altTextDecorative,\n      guessedText: this.#guessedText,\n      textWithDisclaimer: this.#textWithDisclaimer\n    };\n  }\n  get data() {\n    return {\n      altText: this.#altText,\n      decorative: this.#altTextDecorative\n    };\n  }\n  set data({\n    altText,\n    decorative,\n    guessedText,\n    textWithDisclaimer,\n    cancel = false\n  }) {\n    if (guessedText) {\n      this.#guessedText = guessedText;\n      this.#textWithDisclaimer = textWithDisclaimer;\n    }\n    if (this.#altText === altText && this.#altTextDecorative === decorative) {\n      return;\n    }\n    if (!cancel) {\n      this.#altText = altText;\n      this.#altTextDecorative = decorative;\n    }\n    this.#setState();\n  }\n  toggle(enabled = false) {\n    if (!this.#altTextButton) {\n      return;\n    }\n    if (!enabled && this.#altTextTooltipTimeout) {\n      clearTimeout(this.#altTextTooltipTimeout);\n      this.#altTextTooltipTimeout = null;\n    }\n    this.#altTextButton.disabled = !enabled;\n  }\n  shown() {\n    this.#editor._reportTelemetry({\n      action: \"pdfjs.image.alt_text.image_status_label_displayed\",\n      data: {\n        label: this.#label\n      }\n    });\n  }\n  destroy() {\n    this.#altTextButton?.remove();\n    this.#altTextButton = null;\n    this.#altTextButtonLabel = null;\n    this.#altTextTooltip = null;\n    this.#badge?.remove();\n    this.#badge = null;\n  }\n  async #setState() {\n    const button = this.#altTextButton;\n    if (!button) {\n      return;\n    }\n    if (this.#useNewAltTextFlow) {\n      button.classList.toggle(\"done\", !!this.#altText);\n      button.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[this.#label]);\n      this.#altTextButtonLabel?.setAttribute(\"data-l10n-id\", AltText.#l10nNewButton[`${this.#label}-label`]);\n      if (!this.#altText) {\n        this.#altTextTooltip?.remove();\n        return;\n      }\n    } else {\n      if (!this.#altText && !this.#altTextDecorative) {\n        button.classList.remove(\"done\");\n        this.#altTextTooltip?.remove();\n        return;\n      }\n      button.classList.add(\"done\");\n      button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-edit-button\");\n    }\n    let tooltip = this.#altTextTooltip;\n    if (!tooltip) {\n      this.#altTextTooltip = tooltip = document.createElement(\"span\");\n      tooltip.className = \"tooltip\";\n      tooltip.setAttribute(\"role\", \"tooltip\");\n      tooltip.id = `alt-text-tooltip-${this.#editor.id}`;\n      const DELAY_TO_SHOW_TOOLTIP = 100;\n      const signal = this.#editor._uiManager._signal;\n      signal.addEventListener(\"abort\", () => {\n        clearTimeout(this.#altTextTooltipTimeout);\n        this.#altTextTooltipTimeout = null;\n      }, {\n        once: true\n      });\n      button.addEventListener(\"mouseenter\", () => {\n        this.#altTextTooltipTimeout = setTimeout(() => {\n          this.#altTextTooltipTimeout = null;\n          this.#altTextTooltip.classList.add(\"show\");\n          this.#editor._reportTelemetry({\n            action: \"alt_text_tooltip\"\n          });\n        }, DELAY_TO_SHOW_TOOLTIP);\n      }, {\n        signal\n      });\n      button.addEventListener(\"mouseleave\", () => {\n        if (this.#altTextTooltipTimeout) {\n          clearTimeout(this.#altTextTooltipTimeout);\n          this.#altTextTooltipTimeout = null;\n        }\n        this.#altTextTooltip?.classList.remove(\"show\");\n      }, {\n        signal\n      });\n    }\n    if (this.#altTextDecorative) {\n      tooltip.setAttribute(\"data-l10n-id\", \"pdfjs-editor-alt-text-decorative-tooltip\");\n    } else {\n      tooltip.removeAttribute(\"data-l10n-id\");\n      tooltip.textContent = this.#altText;\n    }\n    if (!tooltip.parentNode) {\n      button.append(tooltip);\n    }\n    const element = this.#editor.getElementForAltText();\n    element?.setAttribute(\"aria-describedby\", tooltip.id);\n  }\n}\n\n;// ./src/display/editor/comment.js\n\nclass Comment {\n  #commentStandaloneButton = null;\n  #commentToolbarButton = null;\n  #commentWasFromKeyBoard = false;\n  #editor = null;\n  #initialText = null;\n  #richText = null;\n  #text = null;\n  #date = null;\n  #deleted = false;\n  #popupPosition = null;\n  constructor(editor) {\n    this.#editor = editor;\n  }\n  renderForToolbar() {\n    const button = this.#commentToolbarButton = document.createElement(\"button\");\n    button.className = \"comment\";\n    return this.#render(button, false);\n  }\n  renderForStandalone() {\n    const button = this.#commentStandaloneButton = document.createElement(\"button\");\n    button.className = \"annotationCommentButton\";\n    const position = this.#editor.commentButtonPosition;\n    if (position) {\n      const {\n        style\n      } = button;\n      style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === \"ltr\" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;\n      style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;\n      const color = this.#editor.commentButtonColor;\n      if (color) {\n        style.backgroundColor = color;\n      }\n    }\n    return this.#render(button, true);\n  }\n  focusButton() {\n    setTimeout(() => {\n      (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();\n    }, 0);\n  }\n  onUpdatedColor() {\n    if (!this.#commentStandaloneButton) {\n      return;\n    }\n    const color = this.#editor.commentButtonColor;\n    if (color) {\n      this.#commentStandaloneButton.style.backgroundColor = color;\n    }\n    this.#editor._uiManager.updatePopupColor(this.#editor);\n  }\n  get commentButtonWidth() {\n    return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;\n  }\n  get commentPopupPositionInLayer() {\n    if (this.#popupPosition) {\n      return this.#popupPosition;\n    }\n    if (!this.#commentStandaloneButton) {\n      return null;\n    }\n    const {\n      x,\n      y,\n      height\n    } = this.#commentStandaloneButton.getBoundingClientRect();\n    const {\n      x: parentX,\n      y: parentY,\n      width: parentWidth,\n      height: parentHeight\n    } = this.#editor.parent.boundingClientRect;\n    return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];\n  }\n  set commentPopupPositionInLayer(pos) {\n    this.#popupPosition = pos;\n  }\n  hasDefaultPopupPosition() {\n    return this.#popupPosition === null;\n  }\n  removeStandaloneCommentButton() {\n    this.#commentStandaloneButton?.remove();\n    this.#commentStandaloneButton = null;\n  }\n  removeToolbarCommentButton() {\n    this.#commentToolbarButton?.remove();\n    this.#commentToolbarButton = null;\n  }\n  setCommentButtonStates({\n    selected,\n    hasPopup\n  }) {\n    if (!this.#commentStandaloneButton) {\n      return;\n    }\n    this.#commentStandaloneButton.classList.toggle(\"selected\", selected);\n    this.#commentStandaloneButton.ariaExpanded = hasPopup;\n  }\n  #render(comment, isStandalone) {\n    if (!this.#editor._uiManager.hasCommentManager()) {\n      return null;\n    }\n    comment.tabIndex = \"0\";\n    comment.ariaHasPopup = \"dialog\";\n    if (isStandalone) {\n      comment.ariaControls = \"commentPopup\";\n      comment.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n    } else {\n      comment.ariaControlsElements = [this.#editor._uiManager.getCommentDialogElement()];\n      comment.setAttribute(\"data-l10n-id\", \"pdfjs-editor-add-comment-button\");\n    }\n    const signal = this.#editor._uiManager._signal;\n    if (!(signal instanceof AbortSignal) || signal.aborted) {\n      return comment;\n    }\n    comment.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    if (isStandalone) {\n      comment.addEventListener(\"focusin\", e => {\n        this.#editor._focusEventsAllowed = false;\n        stopEvent(e);\n      }, {\n        capture: true,\n        signal\n      });\n      comment.addEventListener(\"focusout\", e => {\n        this.#editor._focusEventsAllowed = true;\n        stopEvent(e);\n      }, {\n        capture: true,\n        signal\n      });\n    }\n    comment.addEventListener(\"pointerdown\", event => event.stopPropagation(), {\n      signal\n    });\n    const onClick = event => {\n      event.preventDefault();\n      if (comment === this.#commentToolbarButton) {\n        this.edit();\n      } else {\n        this.#editor.toggleComment(true);\n      }\n    };\n    comment.addEventListener(\"click\", onClick, {\n      capture: true,\n      signal\n    });\n    comment.addEventListener(\"keydown\", event => {\n      if (event.target === comment && event.key === \"Enter\") {\n        this.#commentWasFromKeyBoard = true;\n        onClick(event);\n      }\n    }, {\n      signal\n    });\n    comment.addEventListener(\"pointerenter\", () => {\n      this.#editor.toggleComment(false, true);\n    }, {\n      signal\n    });\n    comment.addEventListener(\"pointerleave\", () => {\n      this.#editor.toggleComment(false, false);\n    }, {\n      signal\n    });\n    return comment;\n  }\n  edit(options) {\n    const position = this.commentPopupPositionInLayer;\n    let posX, posY;\n    if (position) {\n      [posX, posY] = position;\n    } else {\n      [posX, posY] = this.#editor.commentButtonPosition;\n      const {\n        width,\n        height,\n        x,\n        y\n      } = this.#editor;\n      posX = x + posX * width;\n      posY = y + posY * height;\n    }\n    const parentDimensions = this.#editor.parent.boundingClientRect;\n    const {\n      x: parentX,\n      y: parentY,\n      width: parentWidth,\n      height: parentHeight\n    } = parentDimensions;\n    this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n      ...options,\n      parentDimensions\n    });\n  }\n  finish() {\n    if (!this.#commentToolbarButton) {\n      return;\n    }\n    this.#commentToolbarButton.focus({\n      focusVisible: this.#commentWasFromKeyBoard\n    });\n    this.#commentWasFromKeyBoard = false;\n  }\n  isDeleted() {\n    return this.#deleted || this.#text === \"\";\n  }\n  isEmpty() {\n    return this.#text === null;\n  }\n  hasBeenEdited() {\n    return this.isDeleted() || this.#text !== this.#initialText;\n  }\n  serialize() {\n    return this.data;\n  }\n  get data() {\n    return {\n      text: this.#text,\n      richText: this.#richText,\n      date: this.#date,\n      deleted: this.isDeleted()\n    };\n  }\n  set data(text) {\n    if (text !== this.#text) {\n      this.#richText = null;\n    }\n    if (text === null) {\n      this.#text = \"\";\n      this.#deleted = true;\n      return;\n    }\n    this.#text = text;\n    this.#date = new Date();\n    this.#deleted = false;\n  }\n  setInitialText(text, richText = null) {\n    this.#initialText = text;\n    this.data = text;\n    this.#date = null;\n    this.#richText = richText;\n  }\n  shown() {}\n  destroy() {\n    this.#commentToolbarButton?.remove();\n    this.#commentToolbarButton = null;\n    this.#commentStandaloneButton?.remove();\n    this.#commentStandaloneButton = null;\n    this.#text = \"\";\n    this.#richText = null;\n    this.#date = null;\n    this.#editor = null;\n    this.#commentWasFromKeyBoard = false;\n    this.#deleted = false;\n  }\n}\n\n;// ./src/display/touch_manager.js\n\nclass TouchManager {\n  #container;\n  #isPinching = false;\n  #isPinchingStopped = null;\n  #isPinchingDisabled;\n  #onPinchStart;\n  #onPinching;\n  #onPinchEnd;\n  #pointerDownAC = null;\n  #signal;\n  #touchInfo = null;\n  #touchManagerAC;\n  #touchMoveAC = null;\n  constructor({\n    container,\n    isPinchingDisabled = null,\n    isPinchingStopped = null,\n    onPinchStart = null,\n    onPinching = null,\n    onPinchEnd = null,\n    signal\n  }) {\n    this.#container = container;\n    this.#isPinchingStopped = isPinchingStopped;\n    this.#isPinchingDisabled = isPinchingDisabled;\n    this.#onPinchStart = onPinchStart;\n    this.#onPinching = onPinching;\n    this.#onPinchEnd = onPinchEnd;\n    this.#touchManagerAC = new AbortController();\n    this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);\n    container.addEventListener(\"touchstart\", this.#onTouchStart.bind(this), {\n      passive: false,\n      signal: this.#signal\n    });\n  }\n  get MIN_TOUCH_DISTANCE_TO_PINCH() {\n    return 35 / OutputScale.pixelRatio;\n  }\n  #onTouchStart(evt) {\n    if (this.#isPinchingDisabled?.()) {\n      return;\n    }\n    if (evt.touches.length === 1) {\n      if (this.#pointerDownAC) {\n        return;\n      }\n      const pointerDownAC = this.#pointerDownAC = new AbortController();\n      const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);\n      const container = this.#container;\n      const opts = {\n        capture: true,\n        signal,\n        passive: false\n      };\n      const cancelPointerDown = e => {\n        if (e.pointerType === \"touch\") {\n          this.#pointerDownAC?.abort();\n          this.#pointerDownAC = null;\n        }\n      };\n      container.addEventListener(\"pointerdown\", e => {\n        if (e.pointerType === \"touch\") {\n          stopEvent(e);\n          cancelPointerDown(e);\n        }\n      }, opts);\n      container.addEventListener(\"pointerup\", cancelPointerDown, opts);\n      container.addEventListener(\"pointercancel\", cancelPointerDown, opts);\n      return;\n    }\n    if (!this.#touchMoveAC) {\n      this.#touchMoveAC = new AbortController();\n      const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);\n      const container = this.#container;\n      const opt = {\n        signal,\n        capture: false,\n        passive: false\n      };\n      container.addEventListener(\"touchmove\", this.#onTouchMove.bind(this), opt);\n      const onTouchEnd = this.#onTouchEnd.bind(this);\n      container.addEventListener(\"touchend\", onTouchEnd, opt);\n      container.addEventListener(\"touchcancel\", onTouchEnd, opt);\n      opt.capture = true;\n      container.addEventListener(\"pointerdown\", stopEvent, opt);\n      container.addEventListener(\"pointermove\", stopEvent, opt);\n      container.addEventListener(\"pointercancel\", stopEvent, opt);\n      container.addEventListener(\"pointerup\", stopEvent, opt);\n      this.#onPinchStart?.();\n    }\n    stopEvent(evt);\n    if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {\n      this.#touchInfo = null;\n      return;\n    }\n    let [touch0, touch1] = evt.touches;\n    if (touch0.identifier > touch1.identifier) {\n      [touch0, touch1] = [touch1, touch0];\n    }\n    this.#touchInfo = {\n      touch0X: touch0.screenX,\n      touch0Y: touch0.screenY,\n      touch1X: touch1.screenX,\n      touch1Y: touch1.screenY\n    };\n  }\n  #onTouchMove(evt) {\n    if (!this.#touchInfo || evt.touches.length !== 2) {\n      return;\n    }\n    stopEvent(evt);\n    let [touch0, touch1] = evt.touches;\n    if (touch0.identifier > touch1.identifier) {\n      [touch0, touch1] = [touch1, touch0];\n    }\n    const {\n      screenX: screen0X,\n      screenY: screen0Y\n    } = touch0;\n    const {\n      screenX: screen1X,\n      screenY: screen1Y\n    } = touch1;\n    const touchInfo = this.#touchInfo;\n    const {\n      touch0X: pTouch0X,\n      touch0Y: pTouch0Y,\n      touch1X: pTouch1X,\n      touch1Y: pTouch1Y\n    } = touchInfo;\n    const prevGapX = pTouch1X - pTouch0X;\n    const prevGapY = pTouch1Y - pTouch0Y;\n    const currGapX = screen1X - screen0X;\n    const currGapY = screen1Y - screen0Y;\n    const distance = Math.hypot(currGapX, currGapY) || 1;\n    const pDistance = Math.hypot(prevGapX, prevGapY) || 1;\n    if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {\n      return;\n    }\n    touchInfo.touch0X = screen0X;\n    touchInfo.touch0Y = screen0Y;\n    touchInfo.touch1X = screen1X;\n    touchInfo.touch1Y = screen1Y;\n    if (!this.#isPinching) {\n      this.#isPinching = true;\n      return;\n    }\n    const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];\n    this.#onPinching?.(origin, pDistance, distance);\n  }\n  #onTouchEnd(evt) {\n    if (evt.touches.length >= 2) {\n      return;\n    }\n    if (this.#touchMoveAC) {\n      this.#touchMoveAC.abort();\n      this.#touchMoveAC = null;\n      this.#onPinchEnd?.();\n    }\n    if (!this.#touchInfo) {\n      return;\n    }\n    stopEvent(evt);\n    this.#touchInfo = null;\n    this.#isPinching = false;\n  }\n  destroy() {\n    this.#touchManagerAC?.abort();\n    this.#touchManagerAC = null;\n    this.#pointerDownAC?.abort();\n    this.#pointerDownAC = null;\n  }\n}\n\n;// ./src/display/editor/editor.js\n\n\n\n\n\n\n\nclass AnnotationEditor {\n  #accessibilityData = null;\n  #allResizerDivs = null;\n  #altText = null;\n  #comment = null;\n  #commentStandaloneButton = null;\n  #disabled = false;\n  #dragPointerId = null;\n  #dragPointerType = \"\";\n  #resizersDiv = null;\n  #lastPointerCoords = null;\n  #savedDimensions = null;\n  #fakeAnnotation = null;\n  #focusAC = null;\n  #focusedResizerName = \"\";\n  #hasBeenClicked = false;\n  #initialRect = null;\n  #isEditing = false;\n  #isInEditMode = false;\n  #isResizerEnabledForKeyboard = false;\n  #moveInDOMTimeout = null;\n  #prevDragX = 0;\n  #prevDragY = 0;\n  #telemetryTimeouts = null;\n  #touchManager = null;\n  isSelected = false;\n  _isCopy = false;\n  _editToolbar = null;\n  _initialOptions = Object.create(null);\n  _initialData = null;\n  _isVisible = true;\n  _uiManager = null;\n  _focusEventsAllowed = true;\n  static _l10n = null;\n  static _l10nResizer = null;\n  #isDraggable = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _borderLineWidth = -1;\n  static _colorManager = new ColorManager();\n  static _zIndex = 1;\n  static _telemetryTimeout = 1000;\n  static get _resizerKeyboardManager() {\n    const resize = AnnotationEditor.prototype._resizeWithKeyboard;\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_resizerKeyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], resize, {\n      args: [-small, 0]\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], resize, {\n      args: [-big, 0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], resize, {\n      args: [small, 0]\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], resize, {\n      args: [big, 0]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], resize, {\n      args: [0, -small]\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], resize, {\n      args: [0, -big]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], resize, {\n      args: [0, small]\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], resize, {\n      args: [0, big]\n    }], [[\"Escape\", \"mac+Escape\"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));\n  }\n  constructor(parameters) {\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    this._uiManager = parameters.uiManager;\n    this.annotationElementId = null;\n    this._willKeepAspectRatio = false;\n    this._initialOptions.isCentered = parameters.isCentered;\n    this._structTreeParentId = null;\n    this.annotationElementId = parameters.annotationElementId || null;\n    this.creationDate = parameters.creationDate || new Date();\n    this.modificationDate = parameters.modificationDate || null;\n    this.canAddComment = true;\n    const {\n      rotation,\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = this.parent.viewport;\n    this.rotation = rotation;\n    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n    this.pageDimensions = [pageWidth, pageHeight];\n    this.pageTranslation = [pageX, pageY];\n    const [width, height] = this.parentDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.isAttachedToDOM = false;\n    this.deleted = false;\n  }\n  get editorType() {\n    return Object.getPrototypeOf(this).constructor._type;\n  }\n  get mode() {\n    return Object.getPrototypeOf(this).constructor._editorType;\n  }\n  static get isDrawer() {\n    return false;\n  }\n  static get _defaultLineColor() {\n    return shadow(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n  static deleteAnnotationElement(editor) {\n    const fakeEditor = new FakeEditor({\n      id: editor.parent.getNextId(),\n      parent: editor.parent,\n      uiManager: editor._uiManager\n    });\n    fakeEditor.annotationElementId = editor.annotationElementId;\n    fakeEditor.deleted = true;\n    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n  }\n  static initialize(l10n, _uiManager) {\n    AnnotationEditor._l10n ??= l10n;\n    AnnotationEditor._l10nResizer ||= Object.freeze({\n      topLeft: \"pdfjs-editor-resizer-top-left\",\n      topMiddle: \"pdfjs-editor-resizer-top-middle\",\n      topRight: \"pdfjs-editor-resizer-top-right\",\n      middleRight: \"pdfjs-editor-resizer-middle-right\",\n      bottomRight: \"pdfjs-editor-resizer-bottom-right\",\n      bottomMiddle: \"pdfjs-editor-resizer-bottom-middle\",\n      bottomLeft: \"pdfjs-editor-resizer-bottom-left\",\n      middleLeft: \"pdfjs-editor-resizer-middle-left\"\n    });\n    if (AnnotationEditor._borderLineWidth !== -1) {\n      return;\n    }\n    const style = getComputedStyle(document.documentElement);\n    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n  }\n  static updateDefaultParams(_type, _value) {}\n  static get defaultPropertiesToUpdate() {\n    return [];\n  }\n  static isHandlingMimeForPasting(mime) {\n    return false;\n  }\n  static paste(item, parent) {\n    unreachable(\"Not implemented\");\n  }\n  get propertiesToUpdate() {\n    return [];\n  }\n  get _isDraggable() {\n    return this.#isDraggable;\n  }\n  set _isDraggable(value) {\n    this.#isDraggable = value;\n    this.div?.classList.toggle(\"draggable\", value);\n  }\n  get uid() {\n    return this.annotationElementId || this.id;\n  }\n  get isEnterHandled() {\n    return true;\n  }\n  center() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    switch (this.parentRotation) {\n      case 90:\n        this.x -= this.height * pageHeight / (pageWidth * 2);\n        this.y += this.width * pageWidth / (pageHeight * 2);\n        break;\n      case 180:\n        this.x += this.width / 2;\n        this.y += this.height / 2;\n        break;\n      case 270:\n        this.x += this.height * pageHeight / (pageWidth * 2);\n        this.y -= this.width * pageWidth / (pageHeight * 2);\n        break;\n      default:\n        this.x -= this.width / 2;\n        this.y -= this.height / 2;\n        break;\n    }\n    this.fixAndSetPosition();\n  }\n  addCommands(params) {\n    this._uiManager.addCommands(params);\n  }\n  get currentLayer() {\n    return this._uiManager.currentLayer;\n  }\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n  setParent(parent) {\n    if (parent !== null) {\n      this.pageIndex = parent.pageIndex;\n      this.pageDimensions = parent.pageDimensions;\n    } else {\n      this.#stopResizing();\n      this.#fakeAnnotation?.remove();\n      this.#fakeAnnotation = null;\n    }\n    this.parent = parent;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.#hasBeenClicked) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenClicked = false;\n    }\n  }\n  focusout(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n    const target = event.relatedTarget;\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n    event.preventDefault();\n    if (!this.parent?.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    this.addToAnnotationStorage();\n  }\n  addToAnnotationStorage() {\n    this._uiManager.addToAnnotationStorage(this);\n  }\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parentDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.fixAndSetPosition();\n  }\n  _moveAfterPaste(baseX, baseY) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n    this._onTranslated();\n  }\n  #translate([width, height], x, y) {\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this._onTranslating(this.x, this.y);\n    this.fixAndSetPosition();\n  }\n  translate(x, y) {\n    this.#translate(this.parentDimensions, x, y);\n  }\n  translateInPage(x, y) {\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    this.#translate(this.pageDimensions, x, y);\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  translationDone() {\n    this._onTranslated(this.x, this.y);\n  }\n  drag(tx, ty) {\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    const {\n      div,\n      parentDimensions: [parentWidth, parentHeight]\n    } = this;\n    this.x += tx / parentWidth;\n    this.y += ty / parentHeight;\n    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n      const {\n        x,\n        y\n      } = this.div.getBoundingClientRect();\n      if (this.parent.findNewParent(this, x, y)) {\n        this.x -= Math.floor(this.x);\n        this.y -= Math.floor(this.y);\n      }\n    }\n    let {\n      x,\n      y\n    } = this;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    const {\n      style\n    } = div;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this._onTranslating(x, y);\n    div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  _onTranslating(x, y) {}\n  _onTranslated(x, y) {}\n  get _hasBeenMoved() {\n    return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);\n  }\n  get _hasBeenResized() {\n    return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);\n  }\n  getBaseTranslation() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      _borderLineWidth\n    } = AnnotationEditor;\n    const x = _borderLineWidth / parentWidth;\n    const y = _borderLineWidth / parentHeight;\n    switch (this.rotation) {\n      case 90:\n        return [-x, y];\n      case 180:\n        return [x, y];\n      case 270:\n        return [x, -y];\n      default:\n        return [-x, -y];\n    }\n  }\n  get _mustFixPosition() {\n    return true;\n  }\n  fixAndSetPosition(rotation = this.rotation) {\n    const {\n      div: {\n        style\n      },\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    let {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    width *= pageWidth;\n    height *= pageHeight;\n    x *= pageWidth;\n    y *= pageHeight;\n    if (this._mustFixPosition) {\n      switch (rotation) {\n        case 0:\n          x = MathClamp(x, 0, pageWidth - width);\n          y = MathClamp(y, 0, pageHeight - height);\n          break;\n        case 90:\n          x = MathClamp(x, 0, pageWidth - height);\n          y = MathClamp(y, width, pageHeight);\n          break;\n        case 180:\n          x = MathClamp(x, width, pageWidth);\n          y = MathClamp(y, height, pageHeight);\n          break;\n        case 270:\n          x = MathClamp(x, height, pageWidth);\n          y = MathClamp(y, 0, pageHeight - width);\n          break;\n      }\n    }\n    this.x = x /= pageWidth;\n    this.y = y /= pageHeight;\n    const [bx, by] = this.getBaseTranslation();\n    x += bx;\n    y += by;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this.moveInDOM();\n  }\n  static #rotatePoint(x, y, angle) {\n    switch (angle) {\n      case 90:\n        return [y, -x];\n      case 180:\n        return [-x, -y];\n      case 270:\n        return [-y, x];\n      default:\n        return [x, y];\n    }\n  }\n  screenToPageTranslation(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n  }\n  pageTranslationToScreen(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n  }\n  #getRotationMatrix(rotation) {\n    switch (rotation) {\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];\n        }\n      case 180:\n        return [-1, 0, 0, -1];\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];\n        }\n      default:\n        return [1, 0, 0, 1];\n    }\n  }\n  get parentScale() {\n    return this._uiManager.viewParameters.realScale;\n  }\n  get parentRotation() {\n    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n  }\n  get parentDimensions() {\n    const {\n      parentScale,\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    return [pageWidth * parentScale, pageHeight * parentScale];\n  }\n  setDims() {\n    const {\n      div: {\n        style\n      },\n      width,\n      height\n    } = this;\n    style.width = `${(100 * width).toFixed(2)}%`;\n    style.height = `${(100 * height).toFixed(2)}%`;\n  }\n  getInitialTranslation() {\n    return [0, 0];\n  }\n  #createResizers() {\n    if (this.#resizersDiv) {\n      return;\n    }\n    this.#resizersDiv = document.createElement(\"div\");\n    this.#resizersDiv.classList.add(\"resizers\");\n    const classes = this._willKeepAspectRatio ? [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"] : [\"topLeft\", \"topMiddle\", \"topRight\", \"middleRight\", \"bottomRight\", \"bottomMiddle\", \"bottomLeft\", \"middleLeft\"];\n    const signal = this._uiManager._signal;\n    for (const name of classes) {\n      const div = document.createElement(\"div\");\n      this.#resizersDiv.append(div);\n      div.classList.add(\"resizer\", name);\n      div.setAttribute(\"data-resizer-name\", name);\n      div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name), {\n        signal\n      });\n      div.addEventListener(\"contextmenu\", noContextMenu, {\n        signal\n      });\n      div.tabIndex = -1;\n    }\n    this.div.prepend(this.#resizersDiv);\n  }\n  #resizerPointerdown(name, event) {\n    event.preventDefault();\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    this.#altText?.toggle(false);\n    const savedDraggable = this._isDraggable;\n    this._isDraggable = false;\n    this.#lastPointerCoords = [event.screenX, event.screenY];\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    this.parent.togglePointerEvents(false);\n    window.addEventListener(\"pointermove\", this.#resizerPointermove.bind(this, name), {\n      passive: true,\n      capture: true,\n      signal\n    });\n    window.addEventListener(\"touchmove\", stopEvent, {\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    const savedParentCursor = this.parent.div.style.cursor;\n    const savedCursor = this.div.style.cursor;\n    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n    const pointerUpCallback = () => {\n      ac.abort();\n      this.parent.togglePointerEvents(true);\n      this.#altText?.toggle(true);\n      this._isDraggable = savedDraggable;\n      this.parent.div.style.cursor = savedParentCursor;\n      this.div.style.cursor = savedCursor;\n      this.#addResizeToUndoStack();\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  #resize(x, y, width, height) {\n    this.width = width;\n    this.height = height;\n    this.x = x;\n    this.y = y;\n    this.setDims();\n    this.fixAndSetPosition();\n    this._onResized();\n  }\n  _onResized() {}\n  #addResizeToUndoStack() {\n    if (!this.#savedDimensions) {\n      return;\n    }\n    const {\n      savedX,\n      savedY,\n      savedWidth,\n      savedHeight\n    } = this.#savedDimensions;\n    this.#savedDimensions = null;\n    const newX = this.x;\n    const newY = this.y;\n    const newWidth = this.width;\n    const newHeight = this.height;\n    if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n      return;\n    }\n    this.addCommands({\n      cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),\n      undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),\n      mustExec: true\n    });\n  }\n  static _round(x) {\n    return Math.round(x * 10000) / 10000;\n  }\n  #resizerPointermove(name, event) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];\n    let getPoint;\n    let getOpposite;\n    let isDiagonal = false;\n    let isHorizontal = false;\n    switch (name) {\n      case \"topLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, 0];\n        getOpposite = (w, h) => [w, h];\n        break;\n      case \"topMiddle\":\n        getPoint = (w, h) => [w / 2, 0];\n        getOpposite = (w, h) => [w / 2, h];\n        break;\n      case \"topRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, 0];\n        getOpposite = (w, h) => [0, h];\n        break;\n      case \"middleRight\":\n        isHorizontal = true;\n        getPoint = (w, h) => [w, h / 2];\n        getOpposite = (w, h) => [0, h / 2];\n        break;\n      case \"bottomRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, h];\n        getOpposite = (w, h) => [0, 0];\n        break;\n      case \"bottomMiddle\":\n        getPoint = (w, h) => [w / 2, h];\n        getOpposite = (w, h) => [w / 2, 0];\n        break;\n      case \"bottomLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, h];\n        getOpposite = (w, h) => [w, 0];\n        break;\n      case \"middleLeft\":\n        isHorizontal = true;\n        getPoint = (w, h) => [0, h / 2];\n        getOpposite = (w, h) => [w, h / 2];\n        break;\n    }\n    const point = getPoint(savedWidth, savedHeight);\n    const oppositePoint = getOpposite(savedWidth, savedHeight);\n    let transfOppositePoint = transf(...oppositePoint);\n    const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);\n    const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);\n    let ratioX = 1;\n    let ratioY = 1;\n    let deltaX, deltaY;\n    if (!event.fromKeyboard) {\n      const {\n        screenX,\n        screenY\n      } = event;\n      const [lastScreenX, lastScreenY] = this.#lastPointerCoords;\n      [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);\n      this.#lastPointerCoords[0] = screenX;\n      this.#lastPointerCoords[1] = screenY;\n    } else {\n      ({\n        deltaX,\n        deltaY\n      } = event);\n    }\n    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n    if (isDiagonal) {\n      const oldDiag = Math.hypot(savedWidth, savedHeight);\n      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    } else if (isHorizontal) {\n      ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;\n    } else {\n      ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;\n    }\n    const newWidth = AnnotationEditor._round(savedWidth * ratioX);\n    const newHeight = AnnotationEditor._round(savedHeight * ratioY);\n    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n    const newX = oppositeX - transfOppositePoint[0];\n    const newY = oppositeY - transfOppositePoint[1];\n    this.#initialRect ||= [this.x, this.y, this.width, this.height];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.x = newX;\n    this.y = newY;\n    this.setDims();\n    this.fixAndSetPosition();\n    this._onResizing();\n  }\n  _onResizing() {}\n  altTextFinish() {\n    this.#altText?.finish();\n  }\n  get toolbarButtons() {\n    return null;\n  }\n  async addEditToolbar() {\n    if (this._editToolbar || this.#isInEditMode) {\n      return this._editToolbar;\n    }\n    this._editToolbar = new EditorToolbar(this);\n    this.div.append(this._editToolbar.render());\n    const {\n      toolbarButtons\n    } = this;\n    if (toolbarButtons) {\n      for (const [name, tool] of toolbarButtons) {\n        await this._editToolbar.addButton(name, tool);\n      }\n    }\n    if (!this.hasComment) {\n      this._editToolbar.addButton(\"comment\", this.addCommentButton());\n    }\n    this._editToolbar.addButton(\"delete\");\n    return this._editToolbar;\n  }\n  addCommentButtonInToolbar() {\n    this._editToolbar?.addButtonBefore(\"comment\", this.addCommentButton(), \".deleteButton\");\n  }\n  removeCommentButtonFromToolbar() {\n    this._editToolbar?.removeButton(\"comment\");\n  }\n  removeEditToolbar() {\n    this._editToolbar?.remove();\n    this._editToolbar = null;\n    this.#altText?.destroy();\n  }\n  addContainer(container) {\n    const editToolbarDiv = this._editToolbar?.div;\n    if (editToolbarDiv) {\n      editToolbarDiv.before(container);\n    } else {\n      this.div.append(container);\n    }\n  }\n  getClientDimensions() {\n    return this.div.getBoundingClientRect();\n  }\n  createAltText() {\n    if (!this.#altText) {\n      AltText.initialize(AnnotationEditor._l10n);\n      this.#altText = new AltText(this);\n      if (this.#accessibilityData) {\n        this.#altText.data = this.#accessibilityData;\n        this.#accessibilityData = null;\n      }\n    }\n    return this.#altText;\n  }\n  get altTextData() {\n    return this.#altText?.data;\n  }\n  set altTextData(data) {\n    if (!this.#altText) {\n      return;\n    }\n    this.#altText.data = data;\n  }\n  get guessedAltText() {\n    return this.#altText?.guessedText;\n  }\n  async setGuessedAltText(text) {\n    await this.#altText?.setGuessedText(text);\n  }\n  serializeAltText(isForCopying) {\n    return this.#altText?.serialize(isForCopying);\n  }\n  hasAltText() {\n    return !!this.#altText && !this.#altText.isEmpty();\n  }\n  hasAltTextData() {\n    return this.#altText?.hasData() ?? false;\n  }\n  focusCommentButton() {\n    this.#comment?.focusButton();\n  }\n  addCommentButton() {\n    return this.canAddComment ? this.#comment ||= new Comment(this) : null;\n  }\n  addStandaloneCommentButton() {\n    if (!this._uiManager.hasCommentManager()) {\n      return;\n    }\n    if (this.#commentStandaloneButton) {\n      if (this._uiManager.isEditingMode()) {\n        this.#commentStandaloneButton.classList.remove(\"hidden\");\n      }\n      return;\n    }\n    if (!this.hasComment) {\n      return;\n    }\n    this.#commentStandaloneButton = this.#comment.renderForStandalone();\n    this.div.append(this.#commentStandaloneButton);\n  }\n  removeStandaloneCommentButton() {\n    this.#comment.removeStandaloneCommentButton();\n    this.#commentStandaloneButton = null;\n  }\n  hideStandaloneCommentButton() {\n    this.#commentStandaloneButton?.classList.add(\"hidden\");\n  }\n  get comment() {\n    const {\n      data: {\n        richText,\n        text,\n        date,\n        deleted\n      }\n    } = this.#comment;\n    return {\n      text,\n      richText,\n      date,\n      deleted,\n      color: this.getNonHCMColor(),\n      opacity: this.opacity ?? 1\n    };\n  }\n  set comment(text) {\n    this.#comment ||= new Comment(this);\n    this.#comment.data = text;\n    if (this.hasComment) {\n      this.removeCommentButtonFromToolbar();\n      this.addStandaloneCommentButton();\n      this._uiManager.updateComment(this);\n    } else {\n      this.addCommentButtonInToolbar();\n      this.removeStandaloneCommentButton();\n      this._uiManager.removeComment(this);\n    }\n  }\n  setCommentData({\n    comment,\n    popupRef,\n    richText\n  }) {\n    if (!popupRef) {\n      return;\n    }\n    this.#comment ||= new Comment(this);\n    this.#comment.setInitialText(comment, richText);\n    if (!this.annotationElementId) {\n      return;\n    }\n    const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);\n    if (storedData) {\n      this.updateFromAnnotationLayer(storedData);\n    }\n  }\n  get hasEditedComment() {\n    return this.#comment?.hasBeenEdited();\n  }\n  get hasDeletedComment() {\n    return this.#comment?.isDeleted();\n  }\n  get hasComment() {\n    return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();\n  }\n  async editComment(options) {\n    this.#comment ||= new Comment(this);\n    this.#comment.edit(options);\n  }\n  toggleComment(isSelected, visibility = undefined) {\n    if (this.hasComment) {\n      this._uiManager.toggleComment(this, isSelected, visibility);\n    }\n  }\n  setSelectedCommentButton(selected) {\n    this.#comment.setSelectedButton(selected);\n  }\n  addComment(serialized) {\n    if (this.hasEditedComment) {\n      const DEFAULT_POPUP_WIDTH = 180;\n      const DEFAULT_POPUP_HEIGHT = 100;\n      const [,,, trY] = serialized.rect;\n      const [pageWidth] = this.pageDimensions;\n      const [pageX] = this.pageTranslation;\n      const blX = pageX + pageWidth + 1;\n      const blY = trY - DEFAULT_POPUP_HEIGHT;\n      const trX = blX + DEFAULT_POPUP_WIDTH;\n      serialized.popup = {\n        contents: this.comment.text,\n        deleted: this.comment.deleted,\n        rect: [blX, blY, trX, trY]\n      };\n    }\n  }\n  updateFromAnnotationLayer({\n    popup: {\n      contents,\n      deleted\n    }\n  }) {\n    this.#comment.data = deleted ? null : contents;\n  }\n  get parentBoundingClientRect() {\n    return this.parent.boundingClientRect;\n  }\n  render() {\n    const div = this.div = document.createElement(\"div\");\n    div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    div.className = this.name;\n    div.setAttribute(\"id\", this.id);\n    div.tabIndex = this.#disabled ? -1 : 0;\n    div.setAttribute(\"role\", \"application\");\n    if (this.defaultL10nId) {\n      div.setAttribute(\"data-l10n-id\", this.defaultL10nId);\n    }\n    if (!this._isVisible) {\n      div.classList.add(\"hidden\");\n    }\n    this.setInForeground();\n    this.#addFocusListeners();\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (this.parentRotation % 180 !== 0) {\n      div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n      div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n    }\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    bindEvents(this, div, [\"keydown\", \"pointerdown\", \"dblclick\"]);\n    if (this.isResizable && this._uiManager._supportsPinchToZoom) {\n      this.#touchManager ||= new TouchManager({\n        container: div,\n        isPinchingDisabled: () => !this.isSelected,\n        onPinchStart: this.#touchPinchStartCallback.bind(this),\n        onPinching: this.#touchPinchCallback.bind(this),\n        onPinchEnd: this.#touchPinchEndCallback.bind(this),\n        signal: this._uiManager._signal\n      });\n    }\n    this.addStandaloneCommentButton();\n    this._uiManager._editorUndoBar?.hide();\n    return div;\n  }\n  #touchPinchStartCallback() {\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    this.#altText?.toggle(false);\n    this.parent.togglePointerEvents(false);\n  }\n  #touchPinchCallback(_origin, prevDistance, distance) {\n    const slowDownFactor = 0.7;\n    let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;\n    if (factor === 1) {\n      return;\n    }\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    const newWidth = AnnotationEditor._round(savedWidth * factor);\n    const newHeight = AnnotationEditor._round(savedHeight * factor);\n    if (newWidth === savedWidth && newHeight === savedHeight) {\n      return;\n    }\n    this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];\n    const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);\n    const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);\n    const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);\n    const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);\n    this.x = centerX - newTransfCenterPoint[0];\n    this.y = centerY - newTransfCenterPoint[1];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.setDims();\n    this.fixAndSetPosition();\n    this._onResizing();\n  }\n  #touchPinchEndCallback() {\n    this.#altText?.toggle(true);\n    this.parent.togglePointerEvents(true);\n    this.#addResizeToUndoStack();\n  }\n  pointerdown(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n    this.#hasBeenClicked = true;\n    if (this._isDraggable) {\n      this.#setUpDragSession(event);\n      return;\n    }\n    this.#selectOnPointerEvent(event);\n  }\n  #selectOnPointerEvent(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n      this.parent.toggleSelected(this);\n    } else {\n      this.parent.setSelected(this);\n    }\n  }\n  #setUpDragSession(event) {\n    const {\n      isSelected\n    } = this;\n    this._uiManager.setUpDragSession();\n    let hasDraggingStarted = false;\n    const ac = new AbortController();\n    const signal = this._uiManager.combinedSignal(ac);\n    const opts = {\n      capture: true,\n      passive: false,\n      signal\n    };\n    const cancelDrag = e => {\n      ac.abort();\n      this.#dragPointerId = null;\n      this.#hasBeenClicked = false;\n      if (!this._uiManager.endDragSession()) {\n        this.#selectOnPointerEvent(e);\n      }\n      if (hasDraggingStarted) {\n        this._onStopDragging();\n      }\n    };\n    if (isSelected) {\n      this.#prevDragX = event.clientX;\n      this.#prevDragY = event.clientY;\n      this.#dragPointerId = event.pointerId;\n      this.#dragPointerType = event.pointerType;\n      window.addEventListener(\"pointermove\", e => {\n        if (!hasDraggingStarted) {\n          hasDraggingStarted = true;\n          this._uiManager.toggleComment(this, true, false);\n          this._onStartDragging();\n        }\n        const {\n          clientX: x,\n          clientY: y,\n          pointerId\n        } = e;\n        if (pointerId !== this.#dragPointerId) {\n          stopEvent(e);\n          return;\n        }\n        const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);\n        this.#prevDragX = x;\n        this.#prevDragY = y;\n        this._uiManager.dragSelectedEditors(tx, ty);\n      }, opts);\n      window.addEventListener(\"touchmove\", stopEvent, opts);\n      window.addEventListener(\"pointerdown\", e => {\n        if (e.pointerType === this.#dragPointerType) {\n          if (this.#touchManager || e.isPrimary) {\n            cancelDrag(e);\n          }\n        }\n        stopEvent(e);\n      }, opts);\n    }\n    const pointerUpCallback = e => {\n      if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {\n        cancelDrag(e);\n        return;\n      }\n      stopEvent(e);\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n  }\n  _onStartDragging() {}\n  _onStopDragging() {}\n  moveInDOM() {\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n    }\n    this.#moveInDOMTimeout = setTimeout(() => {\n      this.#moveInDOMTimeout = null;\n      this.parent?.moveEditorInDOM(this);\n    }, 0);\n  }\n  _setParentAndPosition(parent, x, y) {\n    parent.changeParent(this);\n    this.x = x;\n    this.y = y;\n    this.fixAndSetPosition();\n    this._onTranslated();\n  }\n  getRect(tx, ty, rotation = this.rotation) {\n    const scale = this.parentScale;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const shiftX = tx / scale;\n    const shiftY = ty / scale;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n    switch (rotation) {\n      case 0:\n        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n      case 90:\n        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n      case 180:\n        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n      case 270:\n        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getPDFRect() {\n    return this.getRect(0, 0);\n  }\n  getNonHCMColor() {\n    return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n  }\n  onUpdatedColor() {\n    this.#comment?.onUpdatedColor();\n  }\n  getData() {\n    const {\n      comment: {\n        text: str,\n        color,\n        date,\n        opacity,\n        deleted,\n        richText\n      },\n      uid: id,\n      pageIndex,\n      creationDate,\n      modificationDate\n    } = this;\n    return {\n      id,\n      pageIndex,\n      rect: this.getPDFRect(),\n      richText,\n      contentsObj: {\n        str\n      },\n      creationDate,\n      modificationDate: date || modificationDate,\n      popupRef: !deleted,\n      color,\n      opacity\n    };\n  }\n  onceAdded(focus) {}\n  isEmpty() {\n    return false;\n  }\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return false;\n    }\n    this.parent.setEditingState(false);\n    this.#isInEditMode = true;\n    return true;\n  }\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return false;\n    }\n    this.parent.setEditingState(true);\n    this.#isInEditMode = false;\n    return true;\n  }\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n  shouldGetKeyboardEvents() {\n    return this.#isResizerEnabledForKeyboard;\n  }\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n  get isOnScreen() {\n    const {\n      top,\n      left,\n      bottom,\n      right\n    } = this.getClientDimensions();\n    const {\n      innerHeight,\n      innerWidth\n    } = window;\n    return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;\n  }\n  #addFocusListeners() {\n    if (this.#focusAC || !this.div) {\n      return;\n    }\n    this.#focusAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#focusAC);\n    this.div.addEventListener(\"focusin\", this.focusin.bind(this), {\n      signal\n    });\n    this.div.addEventListener(\"focusout\", this.focusout.bind(this), {\n      signal\n    });\n  }\n  rebuild() {\n    this.#addFocusListeners();\n  }\n  rotate(_angle) {}\n  resize() {}\n  serializeDeleted() {\n    return {\n      id: this.annotationElementId,\n      deleted: true,\n      pageIndex: this.pageIndex,\n      popupRef: this._initialData?.popupRef || \"\"\n    };\n  }\n  serialize(isForCopying = false, context = null) {\n    return {\n      annotationType: this.mode,\n      pageIndex: this.pageIndex,\n      rect: this.getPDFRect(),\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId,\n      popupRef: this._initialData?.popupRef || \"\"\n    };\n  }\n  static async deserialize(data, parent, uiManager) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId(),\n      uiManager,\n      annotationElementId: data.annotationElementId,\n      creationDate: data.creationDate,\n      modificationDate: data.modificationDate\n    });\n    editor.rotation = data.rotation;\n    editor.#accessibilityData = data.accessibilityData;\n    editor._isCopy = data.isCopy || false;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n  get hasBeenModified() {\n    return !!this.annotationElementId && (this.deleted || this.serialize() !== null);\n  }\n  remove() {\n    this.#focusAC?.abort();\n    this.#focusAC = null;\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    if (this.parent) {\n      this.parent.remove(this);\n    } else {\n      this._uiManager.removeEditor(this);\n    }\n    this.hideCommentPopup();\n    if (this.#moveInDOMTimeout) {\n      clearTimeout(this.#moveInDOMTimeout);\n      this.#moveInDOMTimeout = null;\n    }\n    this.#stopResizing();\n    this.removeEditToolbar();\n    if (this.#telemetryTimeouts) {\n      for (const timeout of this.#telemetryTimeouts.values()) {\n        clearTimeout(timeout);\n      }\n      this.#telemetryTimeouts = null;\n    }\n    this.parent = null;\n    this.#touchManager?.destroy();\n    this.#touchManager = null;\n    this.#fakeAnnotation?.remove();\n    this.#fakeAnnotation = null;\n  }\n  get isResizable() {\n    return false;\n  }\n  makeResizable() {\n    if (this.isResizable) {\n      this.#createResizers();\n      this.#resizersDiv.classList.remove(\"hidden\");\n    }\n  }\n  get toolbarPosition() {\n    return null;\n  }\n  get commentButtonPosition() {\n    return this._uiManager.direction === \"ltr\" ? [1, 0] : [0, 0];\n  }\n  get commentButtonPositionInPage() {\n    const {\n      commentButtonPosition: [posX, posY]\n    } = this;\n    const [blX, blY, trX, trY] = this.getPDFRect();\n    return [AnnotationEditor._round(blX + (trX - blX) * posX), AnnotationEditor._round(blY + (trY - blY) * (1 - posY))];\n  }\n  get commentButtonColor() {\n    return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);\n  }\n  get commentPopupPosition() {\n    return this.#comment.commentPopupPositionInLayer;\n  }\n  set commentPopupPosition(pos) {\n    this.#comment.commentPopupPositionInLayer = pos;\n  }\n  hasDefaultPopupPosition() {\n    return this.#comment.hasDefaultPopupPosition();\n  }\n  get commentButtonWidth() {\n    return this.#comment.commentButtonWidth;\n  }\n  get elementBeforePopup() {\n    return this.div;\n  }\n  setCommentButtonStates(options) {\n    this.#comment?.setCommentButtonStates(options);\n  }\n  keydown(event) {\n    if (!this.isResizable || event.target !== this.div || event.key !== \"Enter\") {\n      return;\n    }\n    this._uiManager.setSelected(this);\n    this.#savedDimensions = {\n      savedX: this.x,\n      savedY: this.y,\n      savedWidth: this.width,\n      savedHeight: this.height\n    };\n    const children = this.#resizersDiv.children;\n    if (!this.#allResizerDivs) {\n      this.#allResizerDivs = Array.from(children);\n      const boundResizerKeydown = this.#resizerKeydown.bind(this);\n      const boundResizerBlur = this.#resizerBlur.bind(this);\n      const signal = this._uiManager._signal;\n      for (const div of this.#allResizerDivs) {\n        const name = div.getAttribute(\"data-resizer-name\");\n        div.setAttribute(\"role\", \"spinbutton\");\n        div.addEventListener(\"keydown\", boundResizerKeydown, {\n          signal\n        });\n        div.addEventListener(\"blur\", boundResizerBlur, {\n          signal\n        });\n        div.addEventListener(\"focus\", this.#resizerFocus.bind(this, name), {\n          signal\n        });\n        div.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    const first = this.#allResizerDivs[0];\n    let firstPosition = 0;\n    for (const div of children) {\n      if (div === first) {\n        break;\n      }\n      firstPosition++;\n    }\n    const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);\n    if (nextFirstPosition !== firstPosition) {\n      if (nextFirstPosition < firstPosition) {\n        for (let i = 0; i < firstPosition - nextFirstPosition; i++) {\n          this.#resizersDiv.append(this.#resizersDiv.firstElementChild);\n        }\n      } else if (nextFirstPosition > firstPosition) {\n        for (let i = 0; i < nextFirstPosition - firstPosition; i++) {\n          this.#resizersDiv.firstElementChild.before(this.#resizersDiv.lastElementChild);\n        }\n      }\n      let i = 0;\n      for (const child of children) {\n        const div = this.#allResizerDivs[i++];\n        const name = div.getAttribute(\"data-resizer-name\");\n        child.setAttribute(\"data-l10n-id\", AnnotationEditor._l10nResizer[name]);\n      }\n    }\n    this.#setResizerTabIndex(0);\n    this.#isResizerEnabledForKeyboard = true;\n    this.#resizersDiv.firstElementChild.focus({\n      focusVisible: true\n    });\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n  #resizerKeydown(event) {\n    AnnotationEditor._resizerKeyboardManager.exec(this, event);\n  }\n  #resizerBlur(event) {\n    if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {\n      this.#stopResizing();\n    }\n  }\n  #resizerFocus(name) {\n    this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : \"\";\n  }\n  #setResizerTabIndex(value) {\n    if (!this.#allResizerDivs) {\n      return;\n    }\n    for (const div of this.#allResizerDivs) {\n      div.tabIndex = value;\n    }\n  }\n  _resizeWithKeyboard(x, y) {\n    if (!this.#isResizerEnabledForKeyboard) {\n      return;\n    }\n    this.#resizerPointermove(this.#focusedResizerName, {\n      deltaX: x,\n      deltaY: y,\n      fromKeyboard: true\n    });\n  }\n  #stopResizing() {\n    this.#isResizerEnabledForKeyboard = false;\n    this.#setResizerTabIndex(-1);\n    this.#addResizeToUndoStack();\n  }\n  _stopResizingWithKeyboard() {\n    this.#stopResizing();\n    this.div.focus();\n  }\n  select() {\n    if (this.isSelected && this._editToolbar) {\n      this._editToolbar.show();\n      return;\n    }\n    this.isSelected = true;\n    this.makeResizable();\n    this.div?.classList.add(\"selectedEditor\");\n    if (!this._editToolbar) {\n      this.addEditToolbar().then(() => {\n        if (this.div?.classList.contains(\"selectedEditor\")) {\n          this._editToolbar?.show();\n        }\n      });\n      return;\n    }\n    this._editToolbar?.show();\n    this.#altText?.toggleAltTextBadge(false);\n  }\n  focus() {\n    if (this.div && !this.div.contains(document.activeElement)) {\n      setTimeout(() => this.div?.focus({\n        preventScroll: true\n      }), 0);\n    }\n  }\n  unselect() {\n    if (!this.isSelected) {\n      return;\n    }\n    this.isSelected = false;\n    this.#resizersDiv?.classList.add(\"hidden\");\n    this.div?.classList.remove(\"selectedEditor\");\n    if (this.div?.contains(document.activeElement)) {\n      this._uiManager.currentLayer.div.focus({\n        preventScroll: true\n      });\n    }\n    this._editToolbar?.hide();\n    this.#altText?.toggleAltTextBadge(true);\n    this.hideCommentPopup();\n  }\n  hideCommentPopup() {\n    if (this.hasComment) {\n      this._uiManager.toggleComment(null);\n    }\n  }\n  updateParams(type, value) {}\n  disableEditing() {}\n  enableEditing() {}\n  get canChangeContent() {\n    return false;\n  }\n  enterInEditMode() {\n    if (!this.canChangeContent) {\n      return;\n    }\n    this.enableEditMode();\n    this.div.focus();\n  }\n  dblclick(event) {\n    if (event.target.nodeName === \"BUTTON\") {\n      return;\n    }\n    this.enterInEditMode();\n    this.parent.updateToolbar({\n      mode: this.constructor._editorType,\n      editId: this.uid\n    });\n  }\n  getElementForAltText() {\n    return this.div;\n  }\n  get contentDiv() {\n    return this.div;\n  }\n  get isEditing() {\n    return this.#isEditing;\n  }\n  set isEditing(value) {\n    this.#isEditing = value;\n    if (!this.parent) {\n      return;\n    }\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n  static get MIN_SIZE() {\n    return 16;\n  }\n  static canCreateNewEmptyEditor() {\n    return true;\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\"\n    };\n  }\n  get telemetryFinalData() {\n    return null;\n  }\n  _reportTelemetry(data, mustWait = false) {\n    if (mustWait) {\n      this.#telemetryTimeouts ||= new Map();\n      const {\n        action\n      } = data;\n      let timeout = this.#telemetryTimeouts.get(action);\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n      timeout = setTimeout(() => {\n        this._reportTelemetry(data);\n        this.#telemetryTimeouts.delete(action);\n        if (this.#telemetryTimeouts.size === 0) {\n          this.#telemetryTimeouts = null;\n        }\n      }, AnnotationEditor._telemetryTimeout);\n      this.#telemetryTimeouts.set(action, timeout);\n      return;\n    }\n    data.type ||= this.editorType;\n    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n      source: this,\n      details: {\n        type: \"editing\",\n        data\n      }\n    });\n  }\n  show(visible = this._isVisible) {\n    this.div.classList.toggle(\"hidden\", !visible);\n    this._isVisible = visible;\n  }\n  enable() {\n    if (this.div) {\n      this.div.tabIndex = 0;\n    }\n    this.#disabled = false;\n  }\n  disable() {\n    if (this.div) {\n      this.div.tabIndex = -1;\n    }\n    this.#disabled = true;\n  }\n  updateFakeAnnotationElement(annotationLayer) {\n    if (!this.#fakeAnnotation && !this.deleted) {\n      this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);\n      return;\n    }\n    if (this.deleted) {\n      this.#fakeAnnotation.remove();\n      this.#fakeAnnotation = null;\n      return;\n    }\n    if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {\n      this.#fakeAnnotation.updateEdited({\n        rect: this.getPDFRect(),\n        popup: this.comment\n      });\n    }\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    let content = annotation.container.querySelector(\".annotationContent\");\n    if (!content) {\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      annotation.container.prepend(content);\n    } else if (content.nodeName === \"CANVAS\") {\n      const canvas = content;\n      content = document.createElement(\"div\");\n      content.classList.add(\"annotationContent\", this.editorType);\n      canvas.before(content);\n    }\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    const {\n      firstElementChild\n    } = annotation.container;\n    if (firstElementChild?.nodeName === \"DIV\" && firstElementChild.classList.contains(\"annotationContent\")) {\n      firstElementChild.remove();\n    }\n  }\n}\nclass FakeEditor extends AnnotationEditor {\n  constructor(params) {\n    super(params);\n    this.annotationElementId = params.annotationElementId;\n    this.deleted = true;\n  }\n  serialize() {\n    return this.serializeDeleted();\n  }\n}\n\n;// ./src/shared/murmurhash3.js\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if (ArrayBuffer.isView(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Invalid data format, must be a string or TypedArray.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\n\n;// ./src/display/annotation_storage.js\n\n\n\nconst SerializableEmpty = Object.freeze({\n  map: null,\n  hash: \"\",\n  transfer: undefined\n});\nclass AnnotationStorage {\n  #modified = false;\n  #modifiedIds = null;\n  #editorsMap = null;\n  #storage = new Map();\n  constructor() {\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n  getValue(key, defaultValue) {\n    const value = this.#storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n    return Object.assign(defaultValue, value);\n  }\n  getRawValue(key) {\n    return this.#storage.get(key);\n  }\n  remove(key) {\n    const storedValue = this.#storage.get(key);\n    if (storedValue === undefined) {\n      return;\n    }\n    if (storedValue instanceof AnnotationEditor) {\n      this.#editorsMap.delete(storedValue.annotationElementId);\n    }\n    this.#storage.delete(key);\n    if (this.#storage.size === 0) {\n      this.resetModified();\n    }\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this.#storage.values()) {\n        if (value instanceof AnnotationEditor) {\n          return;\n        }\n      }\n      this.onAnnotationEditor(null);\n    }\n  }\n  setValue(key, value) {\n    const obj = this.#storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this.#storage.set(key, value);\n    }\n    if (modified) {\n      this.#setModified();\n    }\n    if (value instanceof AnnotationEditor) {\n      (this.#editorsMap ||= new Map()).set(value.annotationElementId, value);\n      if (typeof this.onAnnotationEditor === \"function\") {\n        this.onAnnotationEditor(value.constructor._type);\n      }\n    }\n  }\n  has(key) {\n    return this.#storage.has(key);\n  }\n  get size() {\n    return this.#storage.size;\n  }\n  #setModified() {\n    if (!this.#modified) {\n      this.#modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n  resetModified() {\n    if (this.#modified) {\n      this.#modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n  get serializable() {\n    if (this.#storage.size === 0) {\n      return SerializableEmpty;\n    }\n    const map = new Map(),\n      hash = new MurmurHash3_64(),\n      transfer = [];\n    const context = Object.create(null);\n    let hasBitmap = false;\n    for (const [key, val] of this.#storage) {\n      const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;\n      if (serialized) {\n        map.set(key, serialized);\n        hash.update(`${key}:${JSON.stringify(serialized)}`);\n        hasBitmap ||= !!serialized.bitmap;\n      }\n    }\n    if (hasBitmap) {\n      for (const value of map.values()) {\n        if (value.bitmap) {\n          transfer.push(value.bitmap);\n        }\n      }\n    }\n    return map.size > 0 ? {\n      map,\n      hash: hash.hexdigest(),\n      transfer\n    } : SerializableEmpty;\n  }\n  get editorStats() {\n    let stats = null;\n    const typeToEditor = new Map();\n    let numberOfEditedComments = 0;\n    let numberOfDeletedComments = 0;\n    for (const value of this.#storage.values()) {\n      if (!(value instanceof AnnotationEditor)) {\n        if (value.popup) {\n          if (value.popup.deleted) {\n            numberOfDeletedComments += 1;\n          } else {\n            numberOfEditedComments += 1;\n          }\n        }\n        continue;\n      }\n      if (value.isCommentDeleted) {\n        numberOfDeletedComments += 1;\n      } else if (value.hasEditedComment) {\n        numberOfEditedComments += 1;\n      }\n      const editorStats = value.telemetryFinalData;\n      if (!editorStats) {\n        continue;\n      }\n      const {\n        type\n      } = editorStats;\n      if (!typeToEditor.has(type)) {\n        typeToEditor.set(type, Object.getPrototypeOf(value).constructor);\n      }\n      stats ||= Object.create(null);\n      const map = stats[type] ||= new Map();\n      for (const [key, val] of Object.entries(editorStats)) {\n        if (key === \"type\") {\n          continue;\n        }\n        let counters = map.get(key);\n        if (!counters) {\n          counters = new Map();\n          map.set(key, counters);\n        }\n        const count = counters.get(val) ?? 0;\n        counters.set(val, count + 1);\n      }\n    }\n    if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {\n      stats ||= Object.create(null);\n      stats.comments = {\n        deleted: numberOfDeletedComments,\n        edited: numberOfEditedComments\n      };\n    }\n    if (!stats) {\n      return null;\n    }\n    for (const [type, editor] of typeToEditor) {\n      stats[type] = editor.computeTelemetryFinalData(stats[type]);\n    }\n    return stats;\n  }\n  resetModifiedIds() {\n    this.#modifiedIds = null;\n  }\n  updateEditor(annotationId, data) {\n    const value = this.#editorsMap?.get(annotationId);\n    if (value) {\n      value.updateFromAnnotationLayer(data);\n      return true;\n    }\n    return false;\n  }\n  getEditor(annotationId) {\n    return this.#editorsMap?.get(annotationId) || null;\n  }\n  get modifiedIds() {\n    if (this.#modifiedIds) {\n      return this.#modifiedIds;\n    }\n    const ids = [];\n    if (this.#editorsMap) {\n      for (const value of this.#editorsMap.values()) {\n        if (!value.serialize()) {\n          continue;\n        }\n        ids.push(value.annotationElementId);\n      }\n    }\n    return this.#modifiedIds = {\n      ids: new Set(ids),\n      hash: ids.join(\",\")\n    };\n  }\n  [Symbol.iterator]() {\n    return this.#storage.entries();\n  }\n}\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable;\n  constructor(parent) {\n    super();\n    const {\n      map,\n      hash,\n      transfer\n    } = parent.serializable;\n    const clone = structuredClone(map, transfer ? {\n      transfer\n    } : null);\n    this.#serializable = {\n      map: clone,\n      hash,\n      transfer\n    };\n  }\n  get print() {\n    unreachable(\"Should not call PrintAnnotationStorage.print\");\n  }\n  get serializable() {\n    return this.#serializable;\n  }\n  get modifiedIds() {\n    return shadow(this, \"modifiedIds\", {\n      ids: new Set(),\n      hash: \"\"\n    });\n  }\n}\n\n;// ./src/display/font_loader.js\n\n\nclass FontLoader {\n  #systemFonts = new Set();\n  constructor({\n    ownerDocument = globalThis.document,\n    styleElement = null\n  }) {\n    this._document = ownerDocument;\n    this.nativeFontFaces = new Set();\n    this.styleElement = null;\n    this.loadingRequests = [];\n    this.loadTestFontId = 0;\n  }\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.add(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n  removeNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.delete(nativeFontFace);\n    this._document.fonts.delete(nativeFontFace);\n  }\n  insertRule(rule) {\n    if (!this.styleElement) {\n      this.styleElement = this._document.createElement(\"style\");\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n    }\n    const styleSheet = this.styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.clear();\n    this.#systemFonts.clear();\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n  async loadSystemFont({\n    systemFontInfo: info,\n    disableFontFace,\n    _inspectFont\n  }) {\n    if (!info || this.#systemFonts.has(info.loadedName)) {\n      return;\n    }\n    assert(!disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n    if (this.isFontLoadingAPISupported) {\n      const {\n        loadedName,\n        src,\n        style\n      } = info;\n      const fontFace = new FontFace(loadedName, src, style);\n      this.addNativeFontFace(fontFace);\n      try {\n        await fontFace.load();\n        this.#systemFonts.add(loadedName);\n        _inspectFont?.(info);\n      } catch {\n        warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n        this.removeNativeFontFace(fontFace);\n      }\n      return;\n    }\n    unreachable(\"Not implemented: loadSystemFont without the Font Loading API.\");\n  }\n  async bind(font) {\n    if (font.attached || font.missingFile && !font.systemFontInfo) {\n      return;\n    }\n    font.attached = true;\n    if (font.systemFontInfo) {\n      await this.loadSystemFont(font);\n      return;\n    }\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return;\n    }\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent(font, request);\n      });\n    }\n  }\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return shadow(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n  get isSyncFontLoadingSupported() {\n    return shadow(this, \"isSyncFontLoadingSupported\", isNodeJS || util_FeatureTest.platform.isFirefox);\n  }\n  _queueLoadingCallback(callback) {\n    function completeRequest() {\n      assert(!request.done, \"completeRequest() cannot be called twice.\");\n      request.done = true;\n      while (loadingRequests.length > 0 && loadingRequests[0].done) {\n        const otherRequest = loadingRequests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n    const {\n      loadingRequests\n    } = this;\n    const request = {\n      done: false,\n      complete: completeRequest,\n      callback\n    };\n    loadingRequests.push(request);\n    return request;\n  }\n  get _loadTestFont() {\n    const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n    return shadow(this, \"_loadTestFont\", testFont);\n  }\n  _prepareFontLoadEvent(font, request) {\n    function int32(data, offset) {\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n    }\n    function spliceString(s, offset, remove, insert) {\n      const chunk1 = s.substring(0, offset);\n      const chunk2 = s.substring(offset + remove);\n      return chunk1 + insert + chunk2;\n    }\n    let i, ii;\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    let called = 0;\n    function isFontReady(name, callback) {\n      if (++called > 30) {\n        warn(\"Load test font never loaded.\");\n        callback();\n        return;\n      }\n      ctx.font = \"30px \" + name;\n      ctx.fillText(\".\", 0, 20);\n      const imageData = ctx.getImageData(0, 0, 1, 1);\n      if (imageData.data[3] > 0) {\n        callback();\n        return;\n      }\n      setTimeout(isFontReady.bind(null, name, callback));\n    }\n    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n    let data = this._loadTestFont;\n    const COMMENT_OFFSET = 976;\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n    const CFF_CHECKSUM_OFFSET = 16;\n    const XXXX_VALUE = 0x58585858;\n    let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n    }\n    if (i < loadTestFontId.length) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n    }\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));\n    const url = `url(data:font/opentype;base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n    this.insertRule(rule);\n    const div = this._document.createElement(\"div\");\n    div.style.visibility = \"hidden\";\n    div.style.width = div.style.height = \"10px\";\n    div.style.position = \"absolute\";\n    div.style.top = div.style.left = \"0px\";\n    for (const name of [font.loadedName, loadTestFontId]) {\n      const span = this._document.createElement(\"span\");\n      span.textContent = \"Hi\";\n      span.style.fontFamily = name;\n      div.append(span);\n    }\n    this._document.body.append(div);\n    isFontReady(loadTestFontId, () => {\n      div.remove();\n      request.complete();\n    });\n  }\n}\nclass FontFaceObject {\n  #fontData;\n  constructor(translatedData, inspectFont = null, extra, charProcOperatorList) {\n    this.compiledGlyphs = Object.create(null);\n    this.#fontData = translatedData;\n    this._inspectFont = inspectFont;\n    if (extra) {\n      Object.assign(this, extra);\n    }\n    if (charProcOperatorList) {\n      this.charProcOperatorList = charProcOperatorList;\n    }\n  }\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n    this._inspectFont?.(this);\n    return nativeFontFace;\n  }\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n    this._inspectFont?.(this, url);\n    return rule;\n  }\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n    const objId = this.loadedName + \"_path_\" + character;\n    let cmds;\n    try {\n      cmds = objs.get(objId);\n    } catch (ex) {\n      warn(`getPathGenerator - ignoring character: \"${ex}\".`);\n    }\n    const path = makePathFromDrawOPS(cmds);\n    if (!this.fontExtraProperties) {\n      objs.delete(objId);\n    }\n    return this.compiledGlyphs[character] = path;\n  }\n  get black() {\n    return this.#fontData.black;\n  }\n  get bold() {\n    return this.#fontData.bold;\n  }\n  get disableFontFace() {\n    return this.#fontData.disableFontFace ?? false;\n  }\n  set disableFontFace(value) {\n    shadow(this, \"disableFontFace\", !!value);\n  }\n  get fontExtraProperties() {\n    return this.#fontData.fontExtraProperties ?? false;\n  }\n  get isInvalidPDFjsFont() {\n    return this.#fontData.isInvalidPDFjsFont;\n  }\n  get isType3Font() {\n    return this.#fontData.isType3Font;\n  }\n  get italic() {\n    return this.#fontData.italic;\n  }\n  get missingFile() {\n    return this.#fontData.missingFile;\n  }\n  get remeasure() {\n    return this.#fontData.remeasure;\n  }\n  get vertical() {\n    return this.#fontData.vertical;\n  }\n  get ascent() {\n    return this.#fontData.ascent;\n  }\n  get defaultWidth() {\n    return this.#fontData.defaultWidth;\n  }\n  get descent() {\n    return this.#fontData.descent;\n  }\n  get bbox() {\n    return this.#fontData.bbox;\n  }\n  set bbox(bbox) {\n    shadow(this, \"bbox\", bbox);\n  }\n  get fontMatrix() {\n    return this.#fontData.fontMatrix;\n  }\n  get fallbackName() {\n    return this.#fontData.fallbackName;\n  }\n  get loadedName() {\n    return this.#fontData.loadedName;\n  }\n  get mimetype() {\n    return this.#fontData.mimetype;\n  }\n  get name() {\n    return this.#fontData.name;\n  }\n  get data() {\n    return this.#fontData.data;\n  }\n  clearData() {\n    this.#fontData.clearData();\n  }\n  get cssFontInfo() {\n    return this.#fontData.cssFontInfo;\n  }\n  get systemFontInfo() {\n    return this.#fontData.systemFontInfo;\n  }\n  get defaultVMetrics() {\n    return this.#fontData.defaultVMetrics;\n  }\n}\n\n;// ./src/shared/obj-bin-transform.js\n\nclass CssFontInfo {\n  #buffer;\n  #view;\n  #decoder;\n  static strings = [\"fontFamily\", \"fontWeight\", \"italicAngle\"];\n  static write(info) {\n    const encoder = new TextEncoder();\n    const encodedStrings = {};\n    let stringsLength = 0;\n    for (const prop of CssFontInfo.strings) {\n      const encoded = encoder.encode(info[prop]);\n      encodedStrings[prop] = encoded;\n      stringsLength += 4 + encoded.length;\n    }\n    const buffer = new ArrayBuffer(stringsLength);\n    const data = new Uint8Array(buffer);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (const prop of CssFontInfo.strings) {\n      const encoded = encodedStrings[prop];\n      const length = encoded.length;\n      view.setUint32(offset, length);\n      data.set(encoded, offset + 4);\n      offset += 4 + length;\n    }\n    assert(offset === buffer.byteLength, \"CssFontInfo.write: Buffer overflow\");\n    return buffer;\n  }\n  constructor(buffer) {\n    this.#buffer = buffer;\n    this.#view = new DataView(this.#buffer);\n    this.#decoder = new TextDecoder();\n  }\n  #readString(index) {\n    assert(index < CssFontInfo.strings.length, \"Invalid string index\");\n    let offset = 0;\n    for (let i = 0; i < index; i++) {\n      offset += this.#view.getUint32(offset) + 4;\n    }\n    const length = this.#view.getUint32(offset);\n    return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n  }\n  get fontFamily() {\n    return this.#readString(0);\n  }\n  get fontWeight() {\n    return this.#readString(1);\n  }\n  get italicAngle() {\n    return this.#readString(2);\n  }\n}\nclass SystemFontInfo {\n  #buffer;\n  #view;\n  #decoder;\n  static strings = [\"css\", \"loadedName\", \"baseFontName\", \"src\"];\n  static write(info) {\n    const encoder = new TextEncoder();\n    const encodedStrings = {};\n    let stringsLength = 0;\n    for (const prop of SystemFontInfo.strings) {\n      const encoded = encoder.encode(info[prop]);\n      encodedStrings[prop] = encoded;\n      stringsLength += 4 + encoded.length;\n    }\n    stringsLength += 4;\n    let encodedStyleStyle,\n      encodedStyleWeight,\n      lengthEstimate = 1 + stringsLength;\n    if (info.style) {\n      encodedStyleStyle = encoder.encode(info.style.style);\n      encodedStyleWeight = encoder.encode(info.style.weight);\n      lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;\n    }\n    const buffer = new ArrayBuffer(lengthEstimate);\n    const data = new Uint8Array(buffer);\n    const view = new DataView(buffer);\n    let offset = 0;\n    view.setUint8(offset++, info.guessFallback ? 1 : 0);\n    view.setUint32(offset, 0);\n    offset += 4;\n    stringsLength = 0;\n    for (const prop of SystemFontInfo.strings) {\n      const encoded = encodedStrings[prop];\n      const length = encoded.length;\n      stringsLength += 4 + length;\n      view.setUint32(offset, length);\n      data.set(encoded, offset + 4);\n      offset += 4 + length;\n    }\n    view.setUint32(offset - stringsLength - 4, stringsLength);\n    if (info.style) {\n      view.setUint32(offset, encodedStyleStyle.length);\n      data.set(encodedStyleStyle, offset + 4);\n      offset += 4 + encodedStyleStyle.length;\n      view.setUint32(offset, encodedStyleWeight.length);\n      data.set(encodedStyleWeight, offset + 4);\n      offset += 4 + encodedStyleWeight.length;\n    }\n    assert(offset <= buffer.byteLength, \"SubstitionInfo.write: Buffer overflow\");\n    return buffer.transferToFixedLength(offset);\n  }\n  constructor(buffer) {\n    this.#buffer = buffer;\n    this.#view = new DataView(this.#buffer);\n    this.#decoder = new TextDecoder();\n  }\n  get guessFallback() {\n    return this.#view.getUint8(0) !== 0;\n  }\n  #readString(index) {\n    assert(index < SystemFontInfo.strings.length, \"Invalid string index\");\n    let offset = 5;\n    for (let i = 0; i < index; i++) {\n      offset += this.#view.getUint32(offset) + 4;\n    }\n    const length = this.#view.getUint32(offset);\n    return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));\n  }\n  get css() {\n    return this.#readString(0);\n  }\n  get loadedName() {\n    return this.#readString(1);\n  }\n  get baseFontName() {\n    return this.#readString(2);\n  }\n  get src() {\n    return this.#readString(3);\n  }\n  get style() {\n    let offset = 1;\n    offset += 4 + this.#view.getUint32(offset);\n    const styleLength = this.#view.getUint32(offset);\n    const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));\n    offset += 4 + styleLength;\n    const weightLength = this.#view.getUint32(offset);\n    const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));\n    return {\n      style,\n      weight\n    };\n  }\n}\nclass FontInfo {\n  static bools = [\"black\", \"bold\", \"disableFontFace\", \"fontExtraProperties\", \"isInvalidPDFjsFont\", \"isType3Font\", \"italic\", \"missingFile\", \"remeasure\", \"vertical\"];\n  static numbers = [\"ascent\", \"defaultWidth\", \"descent\"];\n  static strings = [\"fallbackName\", \"loadedName\", \"mimetype\", \"name\"];\n  static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);\n  static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;\n  static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;\n  static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;\n  static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;\n  #buffer;\n  #decoder;\n  #view;\n  constructor({\n    data,\n    extra\n  }) {\n    this.#buffer = data;\n    this.#decoder = new TextDecoder();\n    this.#view = new DataView(this.#buffer);\n    if (extra) {\n      Object.assign(this, extra);\n    }\n  }\n  #readBoolean(index) {\n    assert(index < FontInfo.bools.length, \"Invalid boolean index\");\n    const byteOffset = Math.floor(index / 4);\n    const bitOffset = index * 2 % 8;\n    const value = this.#view.getUint8(byteOffset) >> bitOffset & 0x03;\n    return value === 0x00 ? undefined : value === 0x02;\n  }\n  get black() {\n    return this.#readBoolean(0);\n  }\n  get bold() {\n    return this.#readBoolean(1);\n  }\n  get disableFontFace() {\n    return this.#readBoolean(2);\n  }\n  get fontExtraProperties() {\n    return this.#readBoolean(3);\n  }\n  get isInvalidPDFjsFont() {\n    return this.#readBoolean(4);\n  }\n  get isType3Font() {\n    return this.#readBoolean(5);\n  }\n  get italic() {\n    return this.#readBoolean(6);\n  }\n  get missingFile() {\n    return this.#readBoolean(7);\n  }\n  get remeasure() {\n    return this.#readBoolean(8);\n  }\n  get vertical() {\n    return this.#readBoolean(9);\n  }\n  #readNumber(index) {\n    assert(index < FontInfo.numbers.length, \"Invalid number index\");\n    return this.#view.getFloat64(FontInfo.#OFFSET_NUMBERS + index * 8);\n  }\n  get ascent() {\n    return this.#readNumber(0);\n  }\n  get defaultWidth() {\n    return this.#readNumber(1);\n  }\n  get descent() {\n    return this.#readNumber(2);\n  }\n  get bbox() {\n    let offset = FontInfo.#OFFSET_BBOX;\n    const numCoords = this.#view.getUint8(offset);\n    if (numCoords === 0) {\n      return undefined;\n    }\n    offset += 1;\n    const bbox = [];\n    for (let i = 0; i < 4; i++) {\n      bbox.push(this.#view.getInt16(offset, true));\n      offset += 2;\n    }\n    return bbox;\n  }\n  get fontMatrix() {\n    let offset = FontInfo.#OFFSET_FONT_MATRIX;\n    const numPoints = this.#view.getUint8(offset);\n    if (numPoints === 0) {\n      return undefined;\n    }\n    offset += 1;\n    const fontMatrix = [];\n    for (let i = 0; i < 6; i++) {\n      fontMatrix.push(this.#view.getFloat64(offset, true));\n      offset += 8;\n    }\n    return fontMatrix;\n  }\n  get defaultVMetrics() {\n    let offset = FontInfo.#OFFSET_DEFAULT_VMETRICS;\n    const numMetrics = this.#view.getUint8(offset);\n    if (numMetrics === 0) {\n      return undefined;\n    }\n    offset += 1;\n    const defaultVMetrics = [];\n    for (let i = 0; i < 3; i++) {\n      defaultVMetrics.push(this.#view.getInt16(offset, true));\n      offset += 2;\n    }\n    return defaultVMetrics;\n  }\n  #readString(index) {\n    assert(index < FontInfo.strings.length, \"Invalid string index\");\n    let offset = FontInfo.#OFFSET_STRINGS + 4;\n    for (let i = 0; i < index; i++) {\n      offset += this.#view.getUint32(offset) + 4;\n    }\n    const length = this.#view.getUint32(offset);\n    const stringData = new Uint8Array(length);\n    stringData.set(new Uint8Array(this.#buffer, offset + 4, length));\n    return this.#decoder.decode(stringData);\n  }\n  get fallbackName() {\n    return this.#readString(0);\n  }\n  get loadedName() {\n    return this.#readString(1);\n  }\n  get mimetype() {\n    return this.#readString(2);\n  }\n  get name() {\n    return this.#readString(3);\n  }\n  get data() {\n    let offset = FontInfo.#OFFSET_STRINGS;\n    const stringsLength = this.#view.getUint32(offset);\n    offset += 4 + stringsLength;\n    const systemFontInfoLength = this.#view.getUint32(offset);\n    offset += 4 + systemFontInfoLength;\n    const cssFontInfoLength = this.#view.getUint32(offset);\n    offset += 4 + cssFontInfoLength;\n    const length = this.#view.getUint32(offset);\n    if (length === 0) {\n      return undefined;\n    }\n    return new Uint8Array(this.#buffer, offset + 4, length);\n  }\n  clearData() {\n    let offset = FontInfo.#OFFSET_STRINGS;\n    const stringsLength = this.#view.getUint32(offset);\n    offset += 4 + stringsLength;\n    const systemFontInfoLength = this.#view.getUint32(offset);\n    offset += 4 + systemFontInfoLength;\n    const cssFontInfoLength = this.#view.getUint32(offset);\n    offset += 4 + cssFontInfoLength;\n    const length = this.#view.getUint32(offset);\n    const data = new Uint8Array(this.#buffer, offset + 4, length);\n    data.fill(0);\n    this.#view.setUint32(offset, 0);\n  }\n  get cssFontInfo() {\n    let offset = FontInfo.#OFFSET_STRINGS;\n    const stringsLength = this.#view.getUint32(offset);\n    offset += 4 + stringsLength;\n    const systemFontInfoLength = this.#view.getUint32(offset);\n    offset += 4 + systemFontInfoLength;\n    const cssFontInfoLength = this.#view.getUint32(offset);\n    if (cssFontInfoLength === 0) {\n      return null;\n    }\n    const cssFontInfoData = new Uint8Array(cssFontInfoLength);\n    cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));\n    return new CssFontInfo(cssFontInfoData.buffer);\n  }\n  get systemFontInfo() {\n    let offset = FontInfo.#OFFSET_STRINGS;\n    const stringsLength = this.#view.getUint32(offset);\n    offset += 4 + stringsLength;\n    const systemFontInfoLength = this.#view.getUint32(offset);\n    if (systemFontInfoLength === 0) {\n      return null;\n    }\n    const systemFontInfoData = new Uint8Array(systemFontInfoLength);\n    systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));\n    return new SystemFontInfo(systemFontInfoData.buffer);\n  }\n  static write(font) {\n    const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;\n    const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;\n    const encoder = new TextEncoder();\n    const encodedStrings = {};\n    let stringsLength = 0;\n    for (const prop of FontInfo.strings) {\n      encodedStrings[prop] = encoder.encode(font[prop]);\n      stringsLength += 4 + encodedStrings[prop].length;\n    }\n    const lengthEstimate = FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);\n    const buffer = new ArrayBuffer(lengthEstimate);\n    const data = new Uint8Array(buffer);\n    const view = new DataView(buffer);\n    let offset = 0;\n    const numBools = FontInfo.bools.length;\n    let boolByte = 0,\n      boolBit = 0;\n    for (let i = 0; i < numBools; i++) {\n      const value = font[FontInfo.bools[i]];\n      const bits = value === undefined ? 0x00 : value ? 0x02 : 0x01;\n      boolByte |= bits << boolBit;\n      boolBit += 2;\n      if (boolBit === 8 || i === numBools - 1) {\n        view.setUint8(offset++, boolByte);\n        boolByte = 0;\n        boolBit = 0;\n      }\n    }\n    assert(offset === FontInfo.#OFFSET_NUMBERS, \"FontInfo.write: Boolean properties offset mismatch\");\n    for (const prop of FontInfo.numbers) {\n      view.setFloat64(offset, font[prop]);\n      offset += 8;\n    }\n    assert(offset === FontInfo.#OFFSET_BBOX, \"FontInfo.write: Number properties offset mismatch\");\n    if (font.bbox) {\n      view.setUint8(offset++, 4);\n      for (const coord of font.bbox) {\n        view.setInt16(offset, coord, true);\n        offset += 2;\n      }\n    } else {\n      view.setUint8(offset++, 0);\n      offset += 2 * 4;\n    }\n    assert(offset === FontInfo.#OFFSET_FONT_MATRIX, \"FontInfo.write: BBox properties offset mismatch\");\n    if (font.fontMatrix) {\n      view.setUint8(offset++, 6);\n      for (const point of font.fontMatrix) {\n        view.setFloat64(offset, point, true);\n        offset += 8;\n      }\n    } else {\n      view.setUint8(offset++, 0);\n      offset += 8 * 6;\n    }\n    assert(offset === FontInfo.#OFFSET_DEFAULT_VMETRICS, \"FontInfo.write: FontMatrix properties offset mismatch\");\n    if (font.defaultVMetrics) {\n      view.setUint8(offset++, 1);\n      for (const metric of font.defaultVMetrics) {\n        view.setInt16(offset, metric, true);\n        offset += 2;\n      }\n    } else {\n      view.setUint8(offset++, 0);\n      offset += 3 * 2;\n    }\n    assert(offset === FontInfo.#OFFSET_STRINGS, \"FontInfo.write: DefaultVMetrics properties offset mismatch\");\n    view.setUint32(FontInfo.#OFFSET_STRINGS, 0);\n    offset += 4;\n    for (const prop of FontInfo.strings) {\n      const encoded = encodedStrings[prop];\n      const length = encoded.length;\n      view.setUint32(offset, length);\n      data.set(encoded, offset + 4);\n      offset += 4 + length;\n    }\n    view.setUint32(FontInfo.#OFFSET_STRINGS, offset - FontInfo.#OFFSET_STRINGS - 4);\n    if (!systemFontInfoBuffer) {\n      view.setUint32(offset, 0);\n      offset += 4;\n    } else {\n      const length = systemFontInfoBuffer.byteLength;\n      view.setUint32(offset, length);\n      assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at systemFontInfo\");\n      data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);\n      offset += 4 + length;\n    }\n    if (!cssFontInfoBuffer) {\n      view.setUint32(offset, 0);\n      offset += 4;\n    } else {\n      const length = cssFontInfoBuffer.byteLength;\n      view.setUint32(offset, length);\n      assert(offset + 4 + length <= buffer.byteLength, \"FontInfo.write: Buffer overflow at cssFontInfo\");\n      data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);\n      offset += 4 + length;\n    }\n    if (font.data === undefined) {\n      view.setUint32(offset, 0);\n      offset += 4;\n    } else {\n      view.setUint32(offset, font.data.length);\n      data.set(font.data, offset + 4);\n      offset += 4 + font.data.length;\n    }\n    assert(offset <= buffer.byteLength, \"FontInfo.write: Buffer overflow\");\n    return buffer.transferToFixedLength(offset);\n  }\n}\nclass PatternInfo {\n  static #KIND = 0;\n  static #HAS_BBOX = 1;\n  static #HAS_BACKGROUND = 2;\n  static #SHADING_TYPE = 3;\n  static #N_COORD = 4;\n  static #N_COLOR = 8;\n  static #N_STOP = 12;\n  static #N_FIGURES = 16;\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.view = new DataView(buffer);\n    this.data = new Uint8Array(buffer);\n  }\n  static write(ir) {\n    let kind,\n      bbox = null,\n      coords = [],\n      colors = [],\n      colorStops = [],\n      figures = [],\n      shadingType = null,\n      background = null;\n    switch (ir[0]) {\n      case \"RadialAxial\":\n        kind = ir[1] === \"axial\" ? 1 : 2;\n        bbox = ir[2];\n        colorStops = ir[3];\n        if (kind === 1) {\n          coords.push(...ir[4], ...ir[5]);\n        } else {\n          coords.push(ir[4][0], ir[4][1], ir[6], ir[5][0], ir[5][1], ir[7]);\n        }\n        break;\n      case \"Mesh\":\n        kind = 3;\n        shadingType = ir[1];\n        coords = ir[2];\n        colors = ir[3];\n        figures = ir[4] || [];\n        bbox = ir[6];\n        background = ir[7];\n        break;\n      default:\n        throw new Error(`Unsupported pattern type: ${ir[0]}`);\n    }\n    const nCoord = Math.floor(coords.length / 2);\n    const nColor = Math.floor(colors.length / 3);\n    const nStop = colorStops.length;\n    const nFigures = figures.length;\n    let figuresSize = 0;\n    for (const figure of figures) {\n      figuresSize += 1;\n      figuresSize = Math.ceil(figuresSize / 4) * 4;\n      figuresSize += 4 + figure.coords.length * 4;\n      figuresSize += 4 + figure.colors.length * 4;\n      if (figure.verticesPerRow !== undefined) {\n        figuresSize += 4;\n      }\n    }\n    const byteLen = 20 + nCoord * 8 + nColor * 3 + nStop * 8 + (bbox ? 16 : 0) + (background ? 3 : 0) + figuresSize;\n    const buffer = new ArrayBuffer(byteLen);\n    const dataView = new DataView(buffer);\n    const u8data = new Uint8Array(buffer);\n    dataView.setUint8(PatternInfo.#KIND, kind);\n    dataView.setUint8(PatternInfo.#HAS_BBOX, bbox ? 1 : 0);\n    dataView.setUint8(PatternInfo.#HAS_BACKGROUND, background ? 1 : 0);\n    dataView.setUint8(PatternInfo.#SHADING_TYPE, shadingType);\n    dataView.setUint32(PatternInfo.#N_COORD, nCoord, true);\n    dataView.setUint32(PatternInfo.#N_COLOR, nColor, true);\n    dataView.setUint32(PatternInfo.#N_STOP, nStop, true);\n    dataView.setUint32(PatternInfo.#N_FIGURES, nFigures, true);\n    let offset = 20;\n    const coordsView = new Float32Array(buffer, offset, nCoord * 2);\n    coordsView.set(coords);\n    offset += nCoord * 8;\n    u8data.set(colors, offset);\n    offset += nColor * 3;\n    for (const [pos, hex] of colorStops) {\n      dataView.setFloat32(offset, pos, true);\n      offset += 4;\n      dataView.setUint32(offset, parseInt(hex.slice(1), 16), true);\n      offset += 4;\n    }\n    if (bbox) {\n      for (const v of bbox) {\n        dataView.setFloat32(offset, v, true);\n        offset += 4;\n      }\n    }\n    if (background) {\n      u8data.set(background, offset);\n      offset += 3;\n    }\n    for (let i = 0; i < figures.length; i++) {\n      const figure = figures[i];\n      dataView.setUint8(offset, figure.type);\n      offset += 1;\n      offset = Math.ceil(offset / 4) * 4;\n      dataView.setUint32(offset, figure.coords.length, true);\n      offset += 4;\n      const figureCoordsView = new Int32Array(buffer, offset, figure.coords.length);\n      figureCoordsView.set(figure.coords);\n      offset += figure.coords.length * 4;\n      dataView.setUint32(offset, figure.colors.length, true);\n      offset += 4;\n      const colorsView = new Int32Array(buffer, offset, figure.colors.length);\n      colorsView.set(figure.colors);\n      offset += figure.colors.length * 4;\n      if (figure.verticesPerRow !== undefined) {\n        dataView.setUint32(offset, figure.verticesPerRow, true);\n        offset += 4;\n      }\n    }\n    return buffer;\n  }\n  getIR() {\n    const dataView = this.view;\n    const kind = this.data[PatternInfo.#KIND];\n    const hasBBox = !!this.data[PatternInfo.#HAS_BBOX];\n    const hasBackground = !!this.data[PatternInfo.#HAS_BACKGROUND];\n    const nCoord = dataView.getUint32(PatternInfo.#N_COORD, true);\n    const nColor = dataView.getUint32(PatternInfo.#N_COLOR, true);\n    const nStop = dataView.getUint32(PatternInfo.#N_STOP, true);\n    const nFigures = dataView.getUint32(PatternInfo.#N_FIGURES, true);\n    let offset = 20;\n    const coords = new Float32Array(this.buffer, offset, nCoord * 2);\n    offset += nCoord * 8;\n    const colors = new Uint8Array(this.buffer, offset, nColor * 3);\n    offset += nColor * 3;\n    const stops = [];\n    for (let i = 0; i < nStop; ++i) {\n      const p = dataView.getFloat32(offset, true);\n      offset += 4;\n      const rgb = dataView.getUint32(offset, true);\n      offset += 4;\n      stops.push([p, `#${rgb.toString(16).padStart(6, \"0\")}`]);\n    }\n    let bbox = null;\n    if (hasBBox) {\n      bbox = [];\n      for (let i = 0; i < 4; ++i) {\n        bbox.push(dataView.getFloat32(offset, true));\n        offset += 4;\n      }\n    }\n    let background = null;\n    if (hasBackground) {\n      background = new Uint8Array(this.buffer, offset, 3);\n      offset += 3;\n    }\n    const figures = [];\n    for (let i = 0; i < nFigures; ++i) {\n      const type = dataView.getUint8(offset);\n      offset += 1;\n      offset = Math.ceil(offset / 4) * 4;\n      const coordsLength = dataView.getUint32(offset, true);\n      offset += 4;\n      const figureCoords = new Int32Array(this.buffer, offset, coordsLength);\n      offset += coordsLength * 4;\n      const colorsLength = dataView.getUint32(offset, true);\n      offset += 4;\n      const figureColors = new Int32Array(this.buffer, offset, colorsLength);\n      offset += colorsLength * 4;\n      const figure = {\n        type,\n        coords: figureCoords,\n        colors: figureColors\n      };\n      if (type === MeshFigureType.LATTICE) {\n        figure.verticesPerRow = dataView.getUint32(offset, true);\n        offset += 4;\n      }\n      figures.push(figure);\n    }\n    if (kind === 1) {\n      return [\"RadialAxial\", \"axial\", bbox, stops, Array.from(coords.slice(0, 2)), Array.from(coords.slice(2, 4)), null, null];\n    }\n    if (kind === 2) {\n      return [\"RadialAxial\", \"radial\", bbox, stops, [coords[0], coords[1]], [coords[3], coords[4]], coords[2], coords[5]];\n    }\n    if (kind === 3) {\n      const shadingType = this.data[PatternInfo.#SHADING_TYPE];\n      let bounds = null;\n      if (coords.length > 0) {\n        let minX = coords[0],\n          maxX = coords[0];\n        let minY = coords[1],\n          maxY = coords[1];\n        for (let i = 0; i < coords.length; i += 2) {\n          const x = coords[i],\n            y = coords[i + 1];\n          minX = minX > x ? x : minX;\n          minY = minY > y ? y : minY;\n          maxX = maxX < x ? x : maxX;\n          maxY = maxY < y ? y : maxY;\n        }\n        bounds = [minX, minY, maxX, maxY];\n      }\n      return [\"Mesh\", shadingType, coords, colors, figures, bounds, bbox, background];\n    }\n    throw new Error(`Unsupported pattern kind: ${kind}`);\n  }\n}\n\n;// ./src/display/api_utils.js\n\nfunction getUrlProp(val) {\n  if (val instanceof URL) {\n    return val.href;\n  }\n  if (typeof val === \"string\") {\n    if (isNodeJS) {\n      return val;\n    }\n    const url = URL.parse(val, window.location);\n    if (url) {\n      return url.href;\n    }\n  }\n  throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n  if (isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n  }\n  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    return stringToBytes(val);\n  }\n  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === \"object\" && !isNaN(val?.length)) {\n    return new Uint8Array(val);\n  }\n  throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nfunction getFactoryUrlProp(val) {\n  if (typeof val !== \"string\") {\n    return null;\n  }\n  if (val.endsWith(\"/\")) {\n    return val;\n  }\n  throw new Error(`Invalid factory url: \"${val}\" must include trailing slash.`);\n}\nconst isRefProxy = v => typeof v === \"object\" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;\nconst isNameProxy = v => typeof v === \"object\" && typeof v?.name === \"string\";\nconst isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);\nclass LoopbackPort {\n  #listeners = new Map();\n  #deferred = Promise.resolve();\n  postMessage(obj, transfer) {\n    const event = {\n      data: structuredClone(obj, transfer ? {\n        transfer\n      } : null)\n    };\n    this.#deferred.then(() => {\n      for (const [listener] of this.#listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n  addEventListener(name, listener, options = null) {\n    let rmAbort = null;\n    if (options?.signal instanceof AbortSignal) {\n      const {\n        signal\n      } = options;\n      if (signal.aborted) {\n        warn(\"LoopbackPort - cannot use an `aborted` signal.\");\n        return;\n      }\n      const onAbort = () => this.removeEventListener(name, listener);\n      rmAbort = () => signal.removeEventListener(\"abort\", onAbort);\n      signal.addEventListener(\"abort\", onAbort);\n    }\n    this.#listeners.set(listener, rmAbort);\n  }\n  removeEventListener(name, listener) {\n    const rmAbort = this.#listeners.get(listener);\n    rmAbort?.();\n    this.#listeners.delete(listener);\n  }\n  terminate() {\n    for (const [, rmAbort] of this.#listeners) {\n      rmAbort?.();\n    }\n    this.#listeners.clear();\n  }\n}\n\n;// ./src/shared/message_handler.js\n\nconst CallbackKind = {\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction onFn() {}\nfunction wrapReason(ex) {\n  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {\n    return ex;\n  }\n  if (!(ex instanceof Error || typeof ex === \"object\" && ex !== null)) {\n    unreachable('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (ex.name) {\n    case \"AbortException\":\n      return new AbortException(ex.message);\n    case \"InvalidPDFException\":\n      return new InvalidPDFException(ex.message);\n    case \"PasswordException\":\n      return new PasswordException(ex.message, ex.code);\n    case \"ResponseException\":\n      return new ResponseException(ex.message, ex.status, ex.missing);\n    case \"UnknownErrorException\":\n      return new UnknownErrorException(ex.message, ex.details);\n  }\n  return new UnknownErrorException(ex.message, ex.toString());\n}\nclass MessageHandler {\n  #messageAC = new AbortController();\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    comObj.addEventListener(\"message\", this.#onMessage.bind(this), {\n      signal: this.#messageAC.signal\n    });\n  }\n  #onMessage({\n    data\n  }) {\n    if (data.targetName !== this.sourceName) {\n      return;\n    }\n    if (data.stream) {\n      this.#processStreamMessage(data);\n      return;\n    }\n    if (data.callback) {\n      const callbackId = data.callbackId;\n      const capability = this.callbackCapabilities[callbackId];\n      if (!capability) {\n        throw new Error(`Cannot resolve callback ${callbackId}`);\n      }\n      delete this.callbackCapabilities[callbackId];\n      if (data.callback === CallbackKind.DATA) {\n        capability.resolve(data.data);\n      } else if (data.callback === CallbackKind.ERROR) {\n        capability.reject(wrapReason(data.reason));\n      } else {\n        throw new Error(\"Unexpected callback case\");\n      }\n      return;\n    }\n    const action = this.actionHandler[data.action];\n    if (!action) {\n      throw new Error(`Unknown action from worker: ${data.action}`);\n    }\n    if (data.callbackId) {\n      const sourceName = this.sourceName,\n        targetName = data.sourceName,\n        comObj = this.comObj;\n      Promise.try(action, data.data).then(function (result) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.DATA,\n          callbackId: data.callbackId,\n          data: result\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          callback: CallbackKind.ERROR,\n          callbackId: data.callbackId,\n          reason: wrapReason(reason)\n        });\n      });\n      return;\n    }\n    if (data.streamId) {\n      this.#createStreamSink(data);\n      return;\n    }\n    action(data.data);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = Promise.withResolvers();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = Promise.withResolvers();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = Promise.withResolvers();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        assert(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = Promise.withResolvers();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk, size = 1, transfers) {\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = Promise.withResolvers();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        assert(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: Promise.withResolvers(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    Promise.try(action, data.data, streamSink).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        Promise.try(streamSink.onPull || onFn).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        assert(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        assert(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        assert(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        const dataReason = wrapReason(data.reason);\n        Promise.try(streamSink.onCancel || onFn, dataReason).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(dataReason);\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.#messageAC?.abort();\n    this.#messageAC = null;\n  }\n}\n\n;// ./src/display/canvas_factory.js\n\nclass BaseCanvasFactory {\n  #enableHWA = false;\n  constructor({\n    enableHWA = false\n  }) {\n    this.#enableHWA = enableHWA;\n  }\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\", {\n        willReadFrequently: !this.#enableHWA\n      })\n    };\n  }\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n  _createCanvas(width, height) {\n    unreachable(\"Abstract method `_createCanvas` called.\");\n  }\n}\nclass DOMCanvasFactory extends BaseCanvasFactory {\n  constructor({\n    ownerDocument = globalThis.document,\n    enableHWA = false\n  }) {\n    super({\n      enableHWA\n    });\n    this._document = ownerDocument;\n  }\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\n\n;// ./src/display/cmap_reader_factory.js\n\n\nclass BaseCMapReaderFactory {\n  constructor({\n    baseUrl = null,\n    isCompressed = true\n  }) {\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n  async fetch({\n    name\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.\");\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    return this._fetch(url).then(cMapData => ({\n      cMapData,\n      isCompressed: this.isCompressed\n    })).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, this.isCompressed ? \"arraybuffer\" : \"text\");\n    return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);\n  }\n}\n\n;// ./src/display/filter_factory.js\n\n\nclass BaseFilterFactory {\n  addFilter(maps) {\n    return \"none\";\n  }\n  addHCMFilter(fgColor, bgColor) {\n    return \"none\";\n  }\n  addAlphaFilter(map) {\n    return \"none\";\n  }\n  addLuminosityFilter(map) {\n    return \"none\";\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    return \"none\";\n  }\n  destroy(keepHCM = false) {}\n}\nclass DOMFilterFactory extends BaseFilterFactory {\n  #baseUrl;\n  #_cache;\n  #_defs;\n  #docId;\n  #document;\n  #_hcmCache;\n  #id = 0;\n  constructor({\n    docId,\n    ownerDocument = globalThis.document\n  }) {\n    super();\n    this.#docId = docId;\n    this.#document = ownerDocument;\n  }\n  get #cache() {\n    return this.#_cache ||= new Map();\n  }\n  get #hcmCache() {\n    return this.#_hcmCache ||= new Map();\n  }\n  get #defs() {\n    if (!this.#_defs) {\n      const div = this.#document.createElement(\"div\");\n      const {\n        style\n      } = div;\n      style.visibility = \"hidden\";\n      style.contain = \"strict\";\n      style.width = style.height = 0;\n      style.position = \"absolute\";\n      style.top = style.left = 0;\n      style.zIndex = -1;\n      const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"width\", 0);\n      svg.setAttribute(\"height\", 0);\n      this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n      div.append(svg);\n      svg.append(this.#_defs);\n      this.#document.body.append(div);\n    }\n    return this.#_defs;\n  }\n  #createTables(maps) {\n    if (maps.length === 1) {\n      const mapR = maps[0];\n      const buffer = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        buffer[i] = mapR[i] / 255;\n      }\n      const table = buffer.join(\",\");\n      return [table, table, table];\n    }\n    const [mapR, mapG, mapB] = maps;\n    const bufferR = new Array(256);\n    const bufferG = new Array(256);\n    const bufferB = new Array(256);\n    for (let i = 0; i < 256; i++) {\n      bufferR[i] = mapR[i] / 255;\n      bufferG[i] = mapG[i] / 255;\n      bufferB[i] = mapB[i] / 255;\n    }\n    return [bufferR.join(\",\"), bufferG.join(\",\"), bufferB.join(\",\")];\n  }\n  #createUrl(id) {\n    if (this.#baseUrl === undefined) {\n      this.#baseUrl = \"\";\n      const url = this.#document.URL;\n      if (url !== this.#document.baseURI) {\n        if (isDataScheme(url)) {\n          warn('#createUrl: ignore \"data:\"-URL for performance reasons.');\n        } else {\n          this.#baseUrl = updateUrlHash(url, \"\");\n        }\n      }\n    }\n    return `url(${this.#baseUrl}#${id})`;\n  }\n  addFilter(maps) {\n    if (!maps) {\n      return \"none\";\n    }\n    let value = this.#cache.get(maps);\n    if (value) {\n      return value;\n    }\n    const [tableR, tableG, tableB] = this.#createTables(maps);\n    const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(maps, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(maps, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n    return url;\n  }\n  addHCMFilter(fgColor, bgColor) {\n    const key = `${fgColor}-${bgColor}`;\n    const filterName = \"base\";\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const fgRGB = this.#getRGB(fgColor);\n    fgColor = Util.makeHexColor(...fgRGB);\n    const bgRGB = this.#getRGB(bgColor);\n    bgColor = Util.makeHexColor(...bgRGB);\n    this.#defs.style.color = \"\";\n    if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n      return info.url;\n    }\n    const map = new Array(256);\n    for (let i = 0; i <= 255; i++) {\n      const x = i / 255;\n      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n    }\n    const table = map.join(\",\");\n    const id = `g_${this.#docId}_hcm_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addTransferMapConversion(table, table, table, filter);\n    this.#addGrayConversion(filter);\n    const getSteps = (c, n) => {\n      const start = fgRGB[c] / 255;\n      const end = bgRGB[c] / 255;\n      const arr = new Array(n + 1);\n      for (let i = 0; i <= n; i++) {\n        arr[i] = start + i / n * (end - start);\n      }\n      return arr.join(\",\");\n    };\n    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  addAlphaFilter(map) {\n    let value = this.#cache.get(map);\n    if (value) {\n      return value;\n    }\n    const [tableA] = this.#createTables([map]);\n    const key = `alpha_${tableA}`;\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_alpha_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapAlphaConversion(tableA, filter);\n    return url;\n  }\n  addLuminosityFilter(map) {\n    let value = this.#cache.get(map || \"luminosity\");\n    if (value) {\n      return value;\n    }\n    let tableA, key;\n    if (map) {\n      [tableA] = this.#createTables([map]);\n      key = `luminosity_${tableA}`;\n    } else {\n      key = \"luminosity\";\n    }\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(map, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;\n    const url = this.#createUrl(id);\n    this.#cache.set(map, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addLuminosityConversion(filter);\n    if (map) {\n      this.#addTransferMapAlphaConversion(tableA, filter);\n    }\n    return url;\n  }\n  addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {\n    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n    let info = this.#hcmCache.get(filterName);\n    if (info?.key === key) {\n      return info.url;\n    }\n    if (info) {\n      info.filter?.remove();\n      info.key = key;\n      info.url = \"none\";\n      info.filter = null;\n    } else {\n      info = {\n        key,\n        url: \"none\",\n        filter: null\n      };\n      this.#hcmCache.set(filterName, info);\n    }\n    if (!fgColor || !bgColor) {\n      return info.url;\n    }\n    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));\n    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));\n    if (bgGray < fgGray) {\n      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];\n    }\n    this.#defs.style.color = \"\";\n    const getSteps = (fg, bg, n) => {\n      const arr = new Array(256);\n      const step = (bgGray - fgGray) / n;\n      const newStart = fg / 255;\n      const newStep = (bg - fg) / (255 * n);\n      let prev = 0;\n      for (let i = 0; i <= n; i++) {\n        const k = Math.round(fgGray + i * step);\n        const value = newStart + i * newStep;\n        for (let j = prev; j <= k; j++) {\n          arr[j] = value;\n        }\n        prev = k + 1;\n      }\n      for (let i = prev; i < 256; i++) {\n        arr[i] = arr[prev - 1];\n      }\n      return arr.join(\",\");\n    };\n    const id = `g_${this.#docId}_hcm_${filterName}_filter`;\n    const filter = info.filter = this.#createFilter(id);\n    this.#addGrayConversion(filter);\n    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n    info.url = this.#createUrl(id);\n    return info.url;\n  }\n  destroy(keepHCM = false) {\n    if (keepHCM && this.#_hcmCache?.size) {\n      return;\n    }\n    this.#_defs?.parentNode.parentNode.remove();\n    this.#_defs = null;\n    this.#_cache?.clear();\n    this.#_cache = null;\n    this.#_hcmCache?.clear();\n    this.#_hcmCache = null;\n    this.#id = 0;\n  }\n  #addLuminosityConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0\");\n    filter.append(feColorMatrix);\n  }\n  #addGrayConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n    filter.append(feColorMatrix);\n  }\n  #createFilter(id) {\n    const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n    filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n    filter.setAttribute(\"id\", id);\n    this.#defs.append(filter);\n    return filter;\n  }\n  #appendFeFunc(feComponentTransfer, func, table) {\n    const feFunc = this.#document.createElementNS(SVG_NS, func);\n    feFunc.setAttribute(\"type\", \"discrete\");\n    feFunc.setAttribute(\"tableValues\", table);\n    feComponentTransfer.append(feFunc);\n  }\n  #addTransferMapConversion(rTable, gTable, bTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n  }\n  #addTransferMapAlphaConversion(aTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncA\", aTable);\n  }\n  #getRGB(color) {\n    this.#defs.style.color = color;\n    return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n  }\n}\n\n;// ./src/display/standard_fontdata_factory.js\n\n\nclass BaseStandardFontDataFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `standardFontDataUrl` API parameter is provided.\");\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetch(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, \"arraybuffer\");\n    return new Uint8Array(data);\n  }\n}\n\n;// ./src/display/wasm_factory.js\n\n\nclass BaseWasmFactory {\n  constructor({\n    baseUrl = null\n  }) {\n    this.baseUrl = baseUrl;\n  }\n  async fetch({\n    filename\n  }) {\n    if (!this.baseUrl) {\n      throw new Error(\"Ensure that the `wasmUrl` API parameter is provided.\");\n    }\n    if (!filename) {\n      throw new Error(\"Wasm filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetch(url).catch(reason => {\n      throw new Error(`Unable to load wasm data at: ${url}`);\n    });\n  }\n  async _fetch(url) {\n    unreachable(\"Abstract method `_fetch` called.\");\n  }\n}\nclass DOMWasmFactory extends BaseWasmFactory {\n  async _fetch(url) {\n    const data = await fetchData(url, \"arraybuffer\");\n    return new Uint8Array(data);\n  }\n}\n\n;// ./src/display/node_utils.js\n\n\n\n\n\n\nif (isNodeJS) {\n  warn(\"Please use the `legacy` build in Node.js environments.\");\n}\nasync function node_utils_fetchData(url) {\n  const fs = process.getBuiltinModule(\"fs\");\n  const data = await fs.promises.readFile(url);\n  return new Uint8Array(data);\n}\nclass NodeFilterFactory extends BaseFilterFactory {}\nclass NodeCanvasFactory extends BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const require = process.getBuiltinModule(\"module\").createRequire(\"file:///Users/soham/modul/node_modules/pdfjs-dist/build/pdf.mjs\");\n    const canvas = require(\"@napi-rs/canvas\");\n    return canvas.createCanvas(width, height);\n  }\n}\nclass NodeCMapReaderFactory extends BaseCMapReaderFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\nclass NodeStandardFontDataFactory extends BaseStandardFontDataFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\nclass NodeWasmFactory extends BaseWasmFactory {\n  async _fetch(url) {\n    return node_utils_fetchData(url);\n  }\n}\n\n;// ./src/display/canvas_dependency_tracker.js\n\nconst FORCED_DEPENDENCY_LABEL = \"__forcedDependency\";\nconst {\n  floor,\n  ceil\n} = Math;\nfunction expandBBox(array, index, minX, minY, maxX, maxY) {\n  array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);\n  array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);\n  array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);\n  array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);\n}\nconst EMPTY_BBOX = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];\nclass BBoxReader {\n  #bboxes;\n  #coords;\n  constructor(bboxes, coords) {\n    this.#bboxes = bboxes;\n    this.#coords = coords;\n  }\n  get length() {\n    return this.#bboxes.length;\n  }\n  isEmpty(i) {\n    return this.#bboxes[i] === EMPTY_BBOX;\n  }\n  minX(i) {\n    return this.#coords[i * 4 + 0] / 256;\n  }\n  minY(i) {\n    return this.#coords[i * 4 + 1] / 256;\n  }\n  maxX(i) {\n    return (this.#coords[i * 4 + 2] + 1) / 256;\n  }\n  maxY(i) {\n    return (this.#coords[i * 4 + 3] + 1) / 256;\n  }\n}\nconst ensureDebugMetadata = (map, key) => {\n  if (!map) {\n    return undefined;\n  }\n  let value = map.get(key);\n  if (!value) {\n    value = {\n      dependencies: new Set(),\n      isRenderingOperation: false\n    };\n    map.set(key, value);\n  }\n  return value;\n};\nclass CanvasDependencyTracker {\n  #simple = {\n    __proto__: null\n  };\n  #incremental = {\n    __proto__: null,\n    transform: [],\n    moveText: [],\n    sameLineText: [],\n    [FORCED_DEPENDENCY_LABEL]: []\n  };\n  #namedDependencies = new Map();\n  #savesStack = [];\n  #markedContentStack = [];\n  #baseTransformStack = [[1, 0, 0, 1, 0, 0]];\n  #clipBox = [-Infinity, -Infinity, Infinity, Infinity];\n  #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);\n  #pendingBBoxIdx = -1;\n  #pendingDependencies = new Set();\n  #operations = new Map();\n  #fontBBoxTrustworthy = new Map();\n  #canvasWidth;\n  #canvasHeight;\n  #bboxesCoords;\n  #bboxes;\n  #debugMetadata;\n  constructor(canvas, operationsCount, recordDebugMetadata = false) {\n    this.#canvasWidth = canvas.width;\n    this.#canvasHeight = canvas.height;\n    this.#initializeBBoxes(operationsCount);\n    if (recordDebugMetadata) {\n      this.#debugMetadata = new Map();\n    }\n  }\n  growOperationsCount(operationsCount) {\n    if (operationsCount >= this.#bboxes.length) {\n      this.#initializeBBoxes(operationsCount, this.#bboxes);\n    }\n  }\n  #initializeBBoxes(operationsCount, oldBBoxes) {\n    const buffer = new ArrayBuffer(operationsCount * 4);\n    this.#bboxesCoords = new Uint8ClampedArray(buffer);\n    this.#bboxes = new Uint32Array(buffer);\n    if (oldBBoxes && oldBBoxes.length > 0) {\n      this.#bboxes.set(oldBBoxes);\n      this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);\n    } else {\n      this.#bboxes.fill(EMPTY_BBOX);\n    }\n  }\n  save(opIdx) {\n    this.#simple = {\n      __proto__: this.#simple\n    };\n    this.#incremental = {\n      __proto__: this.#incremental,\n      transform: {\n        __proto__: this.#incremental.transform\n      },\n      moveText: {\n        __proto__: this.#incremental.moveText\n      },\n      sameLineText: {\n        __proto__: this.#incremental.sameLineText\n      },\n      [FORCED_DEPENDENCY_LABEL]: {\n        __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]\n      }\n    };\n    this.#clipBox = {\n      __proto__: this.#clipBox\n    };\n    this.#savesStack.push(opIdx);\n    return this;\n  }\n  restore(opIdx) {\n    const previous = Object.getPrototypeOf(this.#simple);\n    if (previous === null) {\n      return this;\n    }\n    this.#simple = previous;\n    this.#incremental = Object.getPrototypeOf(this.#incremental);\n    this.#clipBox = Object.getPrototypeOf(this.#clipBox);\n    const lastSave = this.#savesStack.pop();\n    if (lastSave !== undefined) {\n      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n      this.#bboxes[opIdx] = this.#bboxes[lastSave];\n    }\n    return this;\n  }\n  recordOpenMarker(idx) {\n    this.#savesStack.push(idx);\n    return this;\n  }\n  getOpenMarker() {\n    if (this.#savesStack.length === 0) {\n      return null;\n    }\n    return this.#savesStack.at(-1);\n  }\n  recordCloseMarker(opIdx) {\n    const lastSave = this.#savesStack.pop();\n    if (lastSave !== undefined) {\n      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n      this.#bboxes[opIdx] = this.#bboxes[lastSave];\n    }\n    return this;\n  }\n  beginMarkedContent(opIdx) {\n    this.#markedContentStack.push(opIdx);\n    return this;\n  }\n  endMarkedContent(opIdx) {\n    const lastSave = this.#markedContentStack.pop();\n    if (lastSave !== undefined) {\n      ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);\n      this.#bboxes[opIdx] = this.#bboxes[lastSave];\n    }\n    return this;\n  }\n  pushBaseTransform(ctx) {\n    this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));\n    return this;\n  }\n  popBaseTransform() {\n    if (this.#baseTransformStack.length > 1) {\n      this.#baseTransformStack.pop();\n    }\n    return this;\n  }\n  recordSimpleData(name, idx) {\n    this.#simple[name] = idx;\n    return this;\n  }\n  recordIncrementalData(name, idx) {\n    this.#incremental[name].push(idx);\n    return this;\n  }\n  resetIncrementalData(name, idx) {\n    this.#incremental[name].length = 0;\n    return this;\n  }\n  recordNamedData(name, idx) {\n    this.#namedDependencies.set(name, idx);\n    return this;\n  }\n  recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n    this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;\n  }\n  recordFutureForcedDependency(name, idx) {\n    this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);\n    return this;\n  }\n  inheritSimpleDataAsFutureForcedDependencies(names) {\n    for (const name of names) {\n      if (name in this.#simple) {\n        this.recordFutureForcedDependency(name, this.#simple[name]);\n      }\n    }\n    return this;\n  }\n  inheritPendingDependenciesAsFutureForcedDependencies() {\n    for (const dep of this.#pendingDependencies) {\n      this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);\n    }\n    return this;\n  }\n  resetBBox(idx) {\n    if (this.#pendingBBoxIdx !== idx) {\n      this.#pendingBBoxIdx = idx;\n      this.#pendingBBox[0] = Infinity;\n      this.#pendingBBox[1] = Infinity;\n      this.#pendingBBox[2] = -Infinity;\n      this.#pendingBBox[3] = -Infinity;\n    }\n    return this;\n  }\n  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n    const clipBox = [Infinity, Infinity, -Infinity, -Infinity];\n    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);\n    const intersection = Util.intersect(this.#clipBox, clipBox);\n    if (intersection) {\n      this.#clipBox[0] = intersection[0];\n      this.#clipBox[1] = intersection[1];\n      this.#clipBox[2] = intersection[2];\n      this.#clipBox[3] = intersection[3];\n    } else {\n      this.#clipBox[0] = this.#clipBox[1] = Infinity;\n      this.#clipBox[2] = this.#clipBox[3] = -Infinity;\n    }\n    return this;\n  }\n  recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n    const clipBox = this.#clipBox;\n    if (clipBox[0] === Infinity) {\n      return this;\n    }\n    const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());\n    if (clipBox[0] === -Infinity) {\n      Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);\n      return this;\n    }\n    const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n    Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);\n    this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));\n    this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));\n    this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));\n    this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));\n    return this;\n  }\n  recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {\n    const fontBBox = font.bbox;\n    let isBBoxTrustworthy;\n    let computedBBox;\n    if (fontBBox) {\n      isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);\n      if (isBBoxTrustworthy !== false) {\n        computedBBox = [0, 0, 0, 0];\n        Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);\n        if (scale !== 1 || x !== 0 || y !== 0) {\n          Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);\n        }\n        if (isBBoxTrustworthy) {\n          return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n        }\n      }\n    }\n    if (!getMeasure) {\n      return this.recordFullPageBBox(idx);\n    }\n    const measure = getMeasure();\n    if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {\n      isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;\n      this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);\n      if (isBBoxTrustworthy) {\n        return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);\n      }\n    }\n    return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);\n  }\n  recordFullPageBBox(idx) {\n    this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);\n    this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);\n    this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);\n    this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);\n    return this;\n  }\n  getSimpleIndex(dependencyName) {\n    return this.#simple[dependencyName];\n  }\n  recordDependencies(idx, dependencyNames) {\n    const pendingDependencies = this.#pendingDependencies;\n    const simple = this.#simple;\n    const incremental = this.#incremental;\n    for (const name of dependencyNames) {\n      if (name in this.#simple) {\n        pendingDependencies.add(simple[name]);\n      } else if (name in incremental) {\n        incremental[name].forEach(pendingDependencies.add, pendingDependencies);\n      }\n    }\n    return this;\n  }\n  recordNamedDependency(idx, name) {\n    if (this.#namedDependencies.has(name)) {\n      this.#pendingDependencies.add(this.#namedDependencies.get(name));\n    }\n    return this;\n  }\n  recordOperation(idx, preserve = false) {\n    this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);\n    if (this.#debugMetadata) {\n      const metadata = ensureDebugMetadata(this.#debugMetadata, idx);\n      const {\n        dependencies\n      } = metadata;\n      this.#pendingDependencies.forEach(dependencies.add, dependencies);\n      this.#savesStack.forEach(dependencies.add, dependencies);\n      this.#markedContentStack.forEach(dependencies.add, dependencies);\n      dependencies.delete(idx);\n      metadata.isRenderingOperation = true;\n    }\n    if (this.#pendingBBoxIdx === idx) {\n      const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);\n      const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);\n      const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);\n      const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);\n      expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);\n      for (const depIdx of this.#pendingDependencies) {\n        if (depIdx !== idx) {\n          expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);\n        }\n      }\n      for (const saveIdx of this.#savesStack) {\n        if (saveIdx !== idx) {\n          expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n        }\n      }\n      for (const saveIdx of this.#markedContentStack) {\n        if (saveIdx !== idx) {\n          expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);\n        }\n      }\n      if (!preserve) {\n        this.#pendingDependencies.clear();\n        this.#pendingBBoxIdx = -1;\n      }\n    }\n    return this;\n  }\n  recordShowTextOperation(idx, preserve = false) {\n    const deps = Array.from(this.#pendingDependencies);\n    this.recordOperation(idx, preserve);\n    this.recordIncrementalData(\"sameLineText\", idx);\n    for (const dep of deps) {\n      this.recordIncrementalData(\"sameLineText\", dep);\n    }\n    return this;\n  }\n  bboxToClipBoxDropOperation(idx, preserve = false) {\n    if (this.#pendingBBoxIdx === idx) {\n      this.#pendingBBoxIdx = -1;\n      this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);\n      this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);\n      this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);\n      this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);\n      if (!preserve) {\n        this.#pendingDependencies.clear();\n      }\n    }\n    return this;\n  }\n  _takePendingDependencies() {\n    const pendingDependencies = this.#pendingDependencies;\n    this.#pendingDependencies = new Set();\n    return pendingDependencies;\n  }\n  _extractOperation(idx) {\n    const operation = this.#operations.get(idx);\n    this.#operations.delete(idx);\n    return operation;\n  }\n  _pushPendingDependencies(dependencies) {\n    for (const dep of dependencies) {\n      this.#pendingDependencies.add(dep);\n    }\n  }\n  take() {\n    this.#fontBBoxTrustworthy.clear();\n    return new BBoxReader(this.#bboxes, this.#bboxesCoords);\n  }\n  takeDebugMetadata() {\n    return this.#debugMetadata;\n  }\n}\nclass CanvasNestedDependencyTracker {\n  #dependencyTracker;\n  #opIdx;\n  #ignoreBBoxes;\n  #nestingLevel = 0;\n  #savesLevel = 0;\n  constructor(dependencyTracker, opIdx, ignoreBBoxes) {\n    if (dependencyTracker instanceof CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {\n      return dependencyTracker;\n    }\n    this.#dependencyTracker = dependencyTracker;\n    this.#opIdx = opIdx;\n    this.#ignoreBBoxes = !!ignoreBBoxes;\n  }\n  growOperationsCount() {\n    throw new Error(\"Unreachable\");\n  }\n  save(opIdx) {\n    this.#savesLevel++;\n    this.#dependencyTracker.save(this.#opIdx);\n    return this;\n  }\n  restore(opIdx) {\n    if (this.#savesLevel > 0) {\n      this.#dependencyTracker.restore(this.#opIdx);\n      this.#savesLevel--;\n    }\n    return this;\n  }\n  recordOpenMarker(idx) {\n    this.#nestingLevel++;\n    return this;\n  }\n  getOpenMarker() {\n    return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();\n  }\n  recordCloseMarker(idx) {\n    this.#nestingLevel--;\n    return this;\n  }\n  beginMarkedContent(opIdx) {\n    return this;\n  }\n  endMarkedContent(opIdx) {\n    return this;\n  }\n  pushBaseTransform(ctx) {\n    this.#dependencyTracker.pushBaseTransform(ctx);\n    return this;\n  }\n  popBaseTransform() {\n    this.#dependencyTracker.popBaseTransform();\n    return this;\n  }\n  recordSimpleData(name, idx) {\n    this.#dependencyTracker.recordSimpleData(name, this.#opIdx);\n    return this;\n  }\n  recordIncrementalData(name, idx) {\n    this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);\n    return this;\n  }\n  resetIncrementalData(name, idx) {\n    this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);\n    return this;\n  }\n  recordNamedData(name, idx) {\n    return this;\n  }\n  recordSimpleDataFromNamed(name, depName, fallbackIdx) {\n    this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);\n    return this;\n  }\n  recordFutureForcedDependency(name, idx) {\n    this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);\n    return this;\n  }\n  inheritSimpleDataAsFutureForcedDependencies(names) {\n    this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);\n    return this;\n  }\n  inheritPendingDependenciesAsFutureForcedDependencies() {\n    this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();\n    return this;\n  }\n  resetBBox(idx) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.resetBBox(this.#opIdx);\n    }\n    return this;\n  }\n  recordClipBox(idx, ctx, minX, maxX, minY, maxY) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n    }\n    return this;\n  }\n  recordBBox(idx, ctx, minX, maxX, minY, maxY) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);\n    }\n    return this;\n  }\n  recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);\n    }\n    return this;\n  }\n  recordFullPageBBox(idx) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.recordFullPageBBox(this.#opIdx);\n    }\n    return this;\n  }\n  getSimpleIndex(dependencyName) {\n    return this.#dependencyTracker.getSimpleIndex(dependencyName);\n  }\n  recordDependencies(idx, dependencyNames) {\n    this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);\n    return this;\n  }\n  recordNamedDependency(idx, name) {\n    this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);\n    return this;\n  }\n  recordOperation(idx) {\n    this.#dependencyTracker.recordOperation(this.#opIdx, true);\n    return this;\n  }\n  recordShowTextOperation(idx) {\n    this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);\n    return this;\n  }\n  bboxToClipBoxDropOperation(idx) {\n    if (!this.#ignoreBBoxes) {\n      this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);\n    }\n    return this;\n  }\n  take() {\n    throw new Error(\"Unreachable\");\n  }\n  takeDebugMetadata() {\n    throw new Error(\"Unreachable\");\n  }\n}\nconst Dependencies = {\n  stroke: [\"path\", \"transform\", \"filter\", \"strokeColor\", \"strokeAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"dash\"],\n  fill: [\"path\", \"transform\", \"filter\", \"fillColor\", \"fillAlpha\", \"globalCompositeOperation\", \"SMask\"],\n  imageXObject: [\"transform\", \"SMask\", \"filter\", \"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\"],\n  rawFillPath: [\"filter\", \"fillColor\", \"fillAlpha\"],\n  showText: [\"transform\", \"leading\", \"charSpacing\", \"wordSpacing\", \"hScale\", \"textRise\", \"moveText\", \"textMatrix\", \"font\", \"fontObj\", \"filter\", \"fillColor\", \"textRenderingMode\", \"SMask\", \"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\", \"sameLineText\"],\n  transform: [\"transform\"],\n  transformAndFill: [\"transform\", \"fillColor\"]\n};\n\n;// ./src/display/pattern_helper.js\n\n\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox) {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\nclass BaseShadingPattern {\n  isModifyingCurrentTransform() {\n    return false;\n  }\n  getPattern() {\n    unreachable(\"Abstract method `getPattern` called.\");\n  }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      pattern.setTransform(domMatrix);\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case MeshFigureType.LATTICE:\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n      break;\n    case MeshFigureType.TRIANGLES:\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[6];\n    this._background = IR[7];\n    this.matrix = null;\n  }\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n  isModifyingCurrentTransform() {\n    return true;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    const scale = new Float32Array(2);\n    if (pathType === PathType.SHADING) {\n      Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);\n    } else if (this.matrix) {\n      Util.singularValueDecompose2dScale(this.matrix, scale);\n      const [matrixScaleX, matrixScaleY] = scale;\n      Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n      scale[0] *= matrixScaleX;\n      scale[1] *= matrixScaleY;\n    } else {\n      Util.singularValueDecompose2dScale(owner.baseTransform, scale);\n    }\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\nclass TilingPattern {\n  static MAX_PATTERN_SIZE = 3000;\n  constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {\n    this.color = IR[1];\n    this.operatorList = IR[2];\n    this.matrix = IR[3];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n  createPatternCanvas(owner, opIdx) {\n    const {\n      bbox,\n      operatorList,\n      paintType,\n      tilingType,\n      color,\n      canvasGraphicsFactory\n    } = this;\n    let {\n      xstep,\n      ystep\n    } = this;\n    xstep = Math.abs(xstep);\n    ystep = Math.abs(ystep);\n    info(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n    const width = x1 - x0;\n    const height = y1 - y0;\n    const scale = new Float32Array(2);\n    Util.singularValueDecompose2dScale(this.matrix, scale);\n    const [matrixScaleX, matrixScaleY] = scale;\n    Util.singularValueDecompose2dScale(this.baseTransform, scale);\n    const combinedScaleX = matrixScaleX * scale[0];\n    const combinedScaleY = matrixScaleY * scale[1];\n    let canvasWidth = width,\n      canvasHeight = height,\n      redrawHorizontally = false,\n      redrawVertically = false;\n    const xScaledStep = Math.ceil(xstep * combinedScaleX);\n    const yScaledStep = Math.ceil(ystep * combinedScaleY);\n    const xScaledWidth = Math.ceil(width * combinedScaleX);\n    const yScaledHeight = Math.ceil(height * combinedScaleY);\n    if (xScaledStep >= xScaledWidth) {\n      canvasWidth = xstep;\n    } else {\n      redrawHorizontally = true;\n    }\n    if (yScaledStep >= yScaledHeight) {\n      canvasHeight = ystep;\n    } else {\n      redrawVertically = true;\n    }\n    const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n    const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);\n    graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    graphics.dependencyTracker?.save();\n    this.clipBbox(graphics, x0, y0, x1, y1);\n    graphics.baseTransform = getCurrentTransform(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    graphics.dependencyTracker?.restore();\n    tmpCtx.restore();\n    if (redrawHorizontally || redrawVertically) {\n      const image = tmpCanvas.canvas;\n      if (redrawHorizontally) {\n        canvasWidth = xstep;\n      }\n      if (redrawVertically) {\n        canvasHeight = ystep;\n      }\n      const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);\n      const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);\n      const xSize = dimx2.size;\n      const ySize = dimy2.size;\n      const tmpCanvas2 = owner.cachedCanvases.getCanvas(\"pattern-workaround\", xSize, ySize);\n      const tmpCtx2 = tmpCanvas2.context;\n      const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;\n      const jj = redrawVertically ? Math.floor(height / ystep) : 0;\n      for (let i = 0; i <= ii; i++) {\n        for (let j = 0; j <= jj; j++) {\n          tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);\n        }\n      }\n      return {\n        canvas: tmpCanvas2.canvas,\n        scaleX: dimx2.scale,\n        scaleY: dimy2.scale,\n        offsetX: x0,\n        offsetY: y0\n      };\n    }\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: x0,\n      offsetY: y0\n    };\n  }\n  getSizeAndScale(step, realOutputSize, scale) {\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return {\n      scale,\n      size\n    };\n  }\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);\n    graphics.clip();\n    graphics.endPath();\n  }\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const {\n          fillStyle,\n          strokeStyle\n        } = this.ctx;\n        context.fillStyle = current.fillColor = fillStyle;\n        context.strokeStyle = current.strokeColor = strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        context.fillStyle = context.strokeStyle = color;\n        current.fillColor = current.strokeColor = color;\n        break;\n      default:\n        throw new FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n  isModifyingCurrentTransform() {\n    return false;\n  }\n  getPattern(ctx, owner, inverse, pathType, opIdx) {\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = Util.transform(matrix, this.matrix);\n      }\n    }\n    const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    pattern.setTransform(domMatrix);\n    return pattern;\n  }\n}\n\n;// ./src/shared/image_utils.js\n\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  width,\n  height,\n  nonBlackColor = 0xffffffff,\n  inverseDecode = false\n}) {\n  const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA({\n  src,\n  srcPos = 0,\n  dest,\n  destPos = 0,\n  width,\n  height\n}) {\n  let i = 0;\n  const len = width * height * 3;\n  const len32 = len >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos: srcPos + len,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n;// ./src/display/canvas.js\n\n\n\n\n\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst FULL_CHUNK_HEIGHT = 16;\nconst SCALE_MATRIX = new DOMMatrix();\nconst XY = new Float32Array(2);\nconst MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n  ctx.save = function () {\n    destCtx.save();\n    this.__originalSave();\n  };\n  ctx.restore = function () {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n  ctx.translate = function (x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n  ctx.scale = function (x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n  ctx.transform = function (a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n  ctx.setTransform = function (a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n  ctx.resetTransform = function () {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n  ctx.rotate = function (angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n  ctx.clip = function (rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n  getCanvas(id, width, height) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    return canvasEntry;\n  }\n  delete(id) {\n    delete this.cache[id];\n  }\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\nclass CanvasExtraState {\n  alphaIsShape = false;\n  fontSize = 0;\n  fontSizeScale = 1;\n  textMatrix = null;\n  textMatrixScale = 1;\n  fontMatrix = FONT_IDENTITY_MATRIX;\n  leading = 0;\n  x = 0;\n  y = 0;\n  lineX = 0;\n  lineY = 0;\n  charSpacing = 0;\n  wordSpacing = 0;\n  textHScale = 1;\n  textRenderingMode = TextRenderingMode.FILL;\n  textRise = 0;\n  fillColor = \"#000000\";\n  strokeColor = \"#000000\";\n  patternFill = false;\n  patternStroke = false;\n  fillAlpha = 1;\n  strokeAlpha = 1;\n  lineWidth = 1;\n  activeSMask = null;\n  transferMaps = \"none\";\n  constructor(width, height, preInit) {\n    preInit?.(this);\n    this.clipBox = new Float32Array([0, 0, width, height]);\n    this.minMax = MIN_MAX_INIT.slice();\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    clone.minMax = this.minMax.slice();\n    return clone;\n  }\n  getPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    const box = this.minMax.slice();\n    if (pathType === PathType.STROKE) {\n      if (!transform) {\n        unreachable(\"Stroke bounding box must include transform.\");\n      }\n      Util.singularValueDecompose2dScale(transform, XY);\n      const xStrokePad = XY[0] * this.lineWidth / 2;\n      const yStrokePad = XY[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n  updateClipFromPath() {\n    const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n  isEmptyClip() {\n    return this.minMax[0] === Infinity;\n  }\n  startNewPathAndClipBox(box) {\n    this.clipBox.set(box, 0);\n    this.minMax.set(MIN_MAX_INIT, 0);\n  }\n  getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {\n    return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n}\nfunction putBinaryImageData(ctx, imgData) {\n  if (imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    const white = 0xffffffff;\n    const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n      destPos = 0;\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = convertBlackAndWhiteToRGBA({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight,\n      nonBlackColor: 0\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n  for (const property of properties) {\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n  const {\n    filter\n  } = ctx;\n  if (filter !== \"none\" && filter !== \"\") {\n    ctx.filter = \"none\";\n  }\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  if (interpolate) {\n    return true;\n  }\n  Util.singularValueDecompose2dScale(transform, XY);\n  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);\n  return XY[0] <= actualScale && XY[1] <= actualScale;\n}\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {\n    optionalContentConfig,\n    markedContentStack = null\n  }, annotationCanvasMap, pageColors, dependencyTracker) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this.groupStack = [];\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = markedContentStack || [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.pageColors = pageColors;\n    this._cachedScaleForStroking = [-1, 0];\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n    this.dependencyTracker = dependencyTracker ?? null;\n  }\n  getObject(opIdx, data, fallback = null) {\n    if (typeof data === \"string\") {\n      this.dependencyTracker?.recordNamedDependency(opIdx, data);\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  beginDrawing({\n    transform,\n    viewport,\n    transparency = false,\n    background = null\n  }) {\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const savedFillStyle = this.ctx.fillStyle;\n    this.ctx.fillStyle = background || \"#ffffff\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.fillStyle = savedFillStyle;\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...getCurrentTransform(this.compositeCtx));\n    }\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = getCurrentTransform(this.ctx);\n  }\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n    if (argsArrayLen === i) {\n      return i;\n    }\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId, fnArgs;\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n      if (!operationsFilter || operationsFilter(i)) {\n        fnId = fnArray[i];\n        fnArgs = argsArray[i] ?? null;\n        if (fnId !== OPS.dependency) {\n          if (fnArgs === null) {\n            this[fnId](i);\n          } else {\n            this[fnId](i, ...fnArgs);\n          }\n        } else {\n          for (const depObjId of fnArgs) {\n            this.dependencyTracker?.recordNamedData(depObjId, i);\n            const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n            if (!objsPool.has(depObjId)) {\n              objsPool.get(depObjId, continueCallback);\n              return i;\n            }\n          }\n        }\n      }\n      i++;\n      if (i === argsArrayLen) {\n        return i;\n      }\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n    }\n  }\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n    this.current.activeSMask = null;\n    this.ctx.restore();\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n      cache.clear();\n    }\n    this._cachedBitmapsMap.clear();\n    this.#drawFilter();\n  }\n  #drawFilter() {\n    if (this.pageColors) {\n      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n      if (hcmFilterId !== \"none\") {\n        const savedFilter = this.ctx.filter;\n        this.ctx.filter = hcmFilterId;\n        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n        this.ctx.filter = savedFilter;\n      }\n    }\n  }\n  _scaleImage(img, inverseTransform) {\n    const width = img.width ?? img.displayWidth;\n    const height = img.height ?? img.displayHeight;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n  _createMaskCanvas(opIdx, img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = getCurrentTransform(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n      if (!cache) {\n        cache = new Map();\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n      const cachedImage = cache.get(cacheKey);\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n      scaled = cachedImage;\n    }\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n    let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n    maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const minMax = MIN_MAX_INIT.slice();\n    Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);\n    const [minX, minY, maxX, maxY] = minMax;\n    const drawnWidth = Math.round(maxX - minX) || 1;\n    const drawnHeight = Math.round(maxY - minY) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = minX;\n    const offsetY = minY;\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));\n      scaled = scaled.img;\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n    const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n  setLineWidth(opIdx, width) {\n    this.dependencyTracker?.recordSimpleData(\"lineWidth\", opIdx);\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking[0] = -1;\n    }\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n  setLineCap(opIdx, style) {\n    this.dependencyTracker?.recordSimpleData(\"lineCap\", opIdx);\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(opIdx, style) {\n    this.dependencyTracker?.recordSimpleData(\"lineJoin\", opIdx);\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(opIdx, limit) {\n    this.dependencyTracker?.recordSimpleData(\"miterLimit\", opIdx);\n    this.ctx.miterLimit = limit;\n  }\n  setDash(opIdx, dashArray, dashPhase) {\n    this.dependencyTracker?.recordSimpleData(\"dash\", opIdx);\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n  setRenderingIntent(opIdx, intent) {}\n  setFlatness(opIdx, flatness) {}\n  setGState(opIdx, states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(opIdx, value);\n          break;\n        case \"LC\":\n          this.setLineCap(opIdx, value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(opIdx, value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(opIdx, value);\n          break;\n        case \"D\":\n          this.setDash(opIdx, value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(opIdx, value);\n          break;\n        case \"FL\":\n          this.setFlatness(opIdx, value);\n          break;\n        case \"Font\":\n          this.setFont(opIdx, value[0], value[1]);\n          break;\n        case \"CA\":\n          this.dependencyTracker?.recordSimpleData(\"strokeAlpha\", opIdx);\n          this.current.strokeAlpha = value;\n          break;\n        case \"ca\":\n          this.dependencyTracker?.recordSimpleData(\"fillAlpha\", opIdx);\n          this.ctx.globalAlpha = this.current.fillAlpha = value;\n          break;\n        case \"BM\":\n          this.dependencyTracker?.recordSimpleData(\"globalCompositeOperation\", opIdx);\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.dependencyTracker?.recordSimpleData(\"SMask\", opIdx);\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.dependencyTracker?.recordSimpleData(\"filter\", opIdx);\n          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n          break;\n      }\n    }\n  }\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n  beginSMaskMode(opIdx) {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    const ctx = this.ctx = scratchCanvas.context;\n    ctx.setTransform(this.suspendedCtx.getTransform());\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState(opIdx, [[\"BM\", \"source-over\"]]);\n  }\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n  composeSMask(ctx, smask, layerCtx, layerBox) {\n    const layerOffsetX = layerBox[0];\n    const layerOffsetY = layerBox[1];\n    const layerWidth = layerBox[2] - layerOffsetX;\n    const layerHeight = layerBox[3] - layerOffsetY;\n    if (layerWidth === 0 || layerHeight === 0) {\n      return;\n    }\n    this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n    ctx.save();\n    ctx.globalAlpha = 1;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(layerCtx.canvas, 0, 0);\n    ctx.restore();\n  }\n  genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n    let maskCanvas = maskCtx.canvas;\n    let maskX = layerOffsetX - maskOffsetX;\n    let maskY = layerOffsetY - maskOffsetY;\n    if (backdrop) {\n      if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {\n        const canvas = this.cachedCanvases.getCanvas(\"maskExtension\", width, height);\n        const ctx = canvas.context;\n        ctx.drawImage(maskCanvas, -maskX, -maskY);\n        ctx.globalCompositeOperation = \"destination-atop\";\n        ctx.fillStyle = backdrop;\n        ctx.fillRect(0, 0, width, height);\n        ctx.globalCompositeOperation = \"source-over\";\n        maskCanvas = canvas.canvas;\n        maskX = maskY = 0;\n      } else {\n        maskCtx.save();\n        maskCtx.globalAlpha = 1;\n        maskCtx.setTransform(1, 0, 0, 1, 0, 0);\n        const clip = new Path2D();\n        clip.rect(maskX, maskY, width, height);\n        maskCtx.clip(clip);\n        maskCtx.globalCompositeOperation = \"destination-atop\";\n        maskCtx.fillStyle = backdrop;\n        maskCtx.fillRect(maskX, maskY, width, height);\n        maskCtx.restore();\n      }\n    }\n    layerCtx.save();\n    layerCtx.globalAlpha = 1;\n    layerCtx.setTransform(1, 0, 0, 1, 0, 0);\n    if (subtype === \"Alpha\" && transferMap) {\n      layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);\n    } else if (subtype === \"Luminosity\") {\n      layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);\n    }\n    const clip = new Path2D();\n    clip.rect(layerOffsetX, layerOffsetY, width, height);\n    layerCtx.clip(clip);\n    layerCtx.globalCompositeOperation = \"destination-in\";\n    layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);\n    layerCtx.restore();\n  }\n  save(opIdx) {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n    }\n    this.ctx.save();\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n    this.dependencyTracker?.save(opIdx);\n  }\n  restore(opIdx) {\n    this.dependencyTracker?.restore(opIdx);\n    if (this.stateStack.length === 0) {\n      if (this.inSMaskMode) {\n        this.endSMaskMode();\n      }\n      return;\n    }\n    this.current = this.stateStack.pop();\n    this.ctx.restore();\n    if (this.inSMaskMode) {\n      copyCtxState(this.suspendedCtx, this.ctx);\n    }\n    this.checkSMaskState();\n    this.pendingClip = null;\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  transform(opIdx, a, b, c, d, e, f) {\n    this.dependencyTracker?.recordIncrementalData(\"transform\", opIdx);\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  constructPath(opIdx, op, data, minMax) {\n    let [path] = data;\n    if (!minMax) {\n      path ||= data[0] = new Path2D();\n      this[op](opIdx, path);\n      return;\n    }\n    if (this.dependencyTracker !== null) {\n      const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;\n      this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, [\"transform\"]);\n    }\n    if (!(path instanceof Path2D)) {\n      path = data[0] = makePathFromDrawOPS(path);\n    }\n    Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);\n    this[op](opIdx, path);\n    this._pathStartIdx = opIdx;\n  }\n  closePath(opIdx) {\n    this.ctx.closePath();\n  }\n  stroke(opIdx, path, consumePath = true) {\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n        if (baseTransform) {\n          const newPath = new Path2D();\n          newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n          path = newPath;\n        }\n        this.rescaleAndStroke(path, false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(path, true);\n      }\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);\n    if (consumePath) {\n      this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));\n    }\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n  closeStroke(opIdx, path) {\n    this.stroke(opIdx, path);\n  }\n  fill(opIdx, path, consumePath = true) {\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n    if (isPatternFill) {\n      const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;\n      this.dependencyTracker?.save(opIdx);\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n      if (baseTransform) {\n        const newPath = new Path2D();\n        newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));\n        path = newPath;\n      }\n      needRestore = true;\n    }\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(path, \"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill(path);\n      }\n    }\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);\n    if (needRestore) {\n      ctx.restore();\n      this.dependencyTracker?.restore(opIdx);\n    }\n    if (consumePath) {\n      this.consumePath(opIdx, path, intersect);\n    }\n  }\n  eoFill(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fill(opIdx, path);\n  }\n  fillStroke(opIdx, path) {\n    this.fill(opIdx, path, false);\n    this.stroke(opIdx, path, false);\n    this.consumePath(opIdx, path);\n  }\n  eoFillStroke(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fillStroke(opIdx, path);\n  }\n  closeFillStroke(opIdx, path) {\n    this.fillStroke(opIdx, path);\n  }\n  closeEOFillStroke(opIdx, path) {\n    this.pendingEOFill = true;\n    this.fillStroke(opIdx, path);\n  }\n  endPath(opIdx, path) {\n    this.consumePath(opIdx, path);\n  }\n  rawFillPath(opIdx, path) {\n    this.ctx.fill(path);\n    this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);\n  }\n  clip(opIdx) {\n    this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n    this.pendingClip = NORMAL_CLIP;\n  }\n  eoClip(opIdx) {\n    this.dependencyTracker?.recordFutureForcedDependency(\"clipMode\", opIdx);\n    this.pendingClip = EO_CLIP;\n  }\n  beginText(opIdx) {\n    this.current.textMatrix = null;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n    this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData(\"sameLineText\").resetIncrementalData(\"moveText\", opIdx);\n  }\n  endText(opIdx) {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (this.dependencyTracker) {\n      const {\n        dependencyTracker\n      } = this;\n      if (paths !== undefined) {\n        dependencyTracker.recordFutureForcedDependency(\"textClip\", dependencyTracker.getOpenMarker()).recordFutureForcedDependency(\"textClip\", opIdx);\n      }\n      dependencyTracker.recordCloseMarker(opIdx);\n    }\n    if (paths !== undefined) {\n      const newPath = new Path2D();\n      const invTransf = ctx.getTransform().invertSelf();\n      for (const {\n        transform,\n        x,\n        y,\n        fontSize,\n        path\n      } of paths) {\n        if (!path) {\n          continue;\n        }\n        newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));\n      }\n      ctx.clip(newPath);\n    }\n    delete this.pendingTextPaths;\n  }\n  setCharSpacing(opIdx, spacing) {\n    this.dependencyTracker?.recordSimpleData(\"charSpacing\", opIdx);\n    this.current.charSpacing = spacing;\n  }\n  setWordSpacing(opIdx, spacing) {\n    this.dependencyTracker?.recordSimpleData(\"wordSpacing\", opIdx);\n    this.current.wordSpacing = spacing;\n  }\n  setHScale(opIdx, scale) {\n    this.dependencyTracker?.recordSimpleData(\"hScale\", opIdx);\n    this.current.textHScale = scale / 100;\n  }\n  setLeading(opIdx, leading) {\n    this.dependencyTracker?.recordSimpleData(\"leading\", opIdx);\n    this.current.leading = -leading;\n  }\n  setFont(opIdx, fontRefName, size) {\n    this.dependencyTracker?.recordSimpleData(\"font\", opIdx).recordSimpleDataFromNamed(\"fontObj\", fontRefName, opIdx);\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      warn(\"Invalid font matrix for font \" + fontRefName);\n    }\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n    if (fontObj.isType3Font) {\n      return;\n    }\n    const name = fontObj.loadedName || \"sans-serif\";\n    const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n  setTextRenderingMode(opIdx, mode) {\n    this.dependencyTracker?.recordSimpleData(\"textRenderingMode\", opIdx);\n    this.current.textRenderingMode = mode;\n  }\n  setTextRise(opIdx, rise) {\n    this.dependencyTracker?.recordSimpleData(\"textRise\", opIdx);\n    this.current.textRise = rise;\n  }\n  moveText(opIdx, x, y) {\n    this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordIncrementalData(\"moveText\", opIdx);\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n  setLeadingMoveText(opIdx, x, y) {\n    this.setLeading(opIdx, -y);\n    this.moveText(opIdx, x, y);\n  }\n  setTextMatrix(opIdx, matrix) {\n    this.dependencyTracker?.resetIncrementalData(\"sameLineText\").recordSimpleData(\"textMatrix\", opIdx);\n    const {\n      current\n    } = this;\n    current.textMatrix = matrix;\n    current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n  }\n  nextLine(opIdx) {\n    this.moveText(opIdx, 0, this.current.leading);\n    this.dependencyTracker?.recordIncrementalData(\"moveText\", this.dependencyTracker.getSimpleIndex(\"leading\") ?? opIdx);\n  }\n  #getScaledPath(path, currentTransform, transform) {\n    const newPath = new Path2D();\n    newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));\n    return newPath;\n  }\n  paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    const patternStroke = current.patternStroke && !font.missingFile;\n    let path;\n    if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {\n      path = font.getPathGenerator(this.commonObjs, character);\n    }\n    if (path && (font.disableFontFace || patternFill || patternStroke)) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.scale(fontSize, -fontSize);\n      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);\n      let currentTransform;\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (patternFillTransform) {\n          currentTransform = ctx.getTransform();\n          ctx.setTransform(...patternFillTransform);\n          const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);\n          ctx.fill(scaledPath);\n        } else {\n          ctx.fill(path);\n        }\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (patternStrokeTransform) {\n          currentTransform ||= ctx.getTransform();\n          ctx.setTransform(...patternStrokeTransform);\n          const {\n            a,\n            b,\n            c,\n            d\n          } = currentTransform;\n          const invPatternTransform = Util.inverseTransform(patternStrokeTransform);\n          const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);\n          Util.singularValueDecompose2dScale(transf, XY);\n          ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;\n          ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));\n        } else {\n          ctx.lineWidth /= fontSize;\n          ctx.stroke(path);\n        }\n      }\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n        this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));\n      }\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        if (this.dependencyTracker) {\n          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);\n        }\n        ctx.strokeText(character, x, y);\n      }\n    }\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths ||= [];\n      paths.push({\n        transform: getCurrentTransform(ctx),\n        x,\n        y,\n        fontSize,\n        path\n      });\n      this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);\n    }\n  }\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return shadow(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n  showText(opIdx, glyphs) {\n    if (this.dependencyTracker) {\n      this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);\n      if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {\n        this.dependencyTracker.recordFutureForcedDependency(\"textClip\", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();\n      }\n    }\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      this.showType3Text(opIdx, glyphs);\n      this.dependencyTracker?.recordShowTextOperation(opIdx);\n      return undefined;\n    }\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      this.dependencyTracker?.recordOperation(opIdx);\n      return undefined;\n    }\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    if (current.textMatrix) {\n      ctx.transform(...current.textMatrix);\n    }\n    ctx.translate(current.x, current.y + current.textRise);\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n    let patternFillTransform, patternStrokeTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);\n      patternFillTransform = getCurrentTransform(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n    if (current.patternStroke) {\n      ctx.save();\n      const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);\n      patternStrokeTransform = getCurrentTransform(ctx);\n      ctx.restore();\n      ctx.strokeStyle = pattern;\n    }\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;\n      if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n    ctx.lineWidth = lineWidth;\n    if (font.isInvalidPDFjsFont) {\n      const chars = [];\n      let width = 0;\n      for (const glyph of glyphs) {\n        chars.push(glyph.unicode);\n        width += glyph.width;\n      }\n      const joinedChars = chars.join(\"\");\n      ctx.fillText(joinedChars, 0, 0);\n      if (this.dependencyTracker !== null) {\n        const measure = ctx.measureText(joinedChars);\n        this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);\n      }\n      current.x += width * widthAdvanceScale * textHScale;\n      ctx.restore();\n      this.compose();\n      return undefined;\n    }\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      let measure;\n      if (font.remeasure && width > 0) {\n        measure = ctx.measureText(character);\n        const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {\n            bbox: null\n          } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));\n        } else {\n          this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);\n          }\n        }\n      }\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    this.dependencyTracker?.recordShowTextOperation(opIdx);\n    return undefined;\n  }\n  showType3Text(opIdx, glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    if (current.textMatrix) {\n      ctx.transform(...current.textMatrix);\n    }\n    ctx.translate(current.x, current.y + current.textRise);\n    ctx.scale(textHScale, fontDirection);\n    const dependencyTracker = this.dependencyTracker;\n    this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        warn(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n      } else if (this.contentVisible) {\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n      const p = [glyph.width, 0];\n      Util.applyTransform(p, fontMatrix);\n      width = p[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    if (dependencyTracker) {\n      this.dependencyTracker = dependencyTracker;\n    }\n  }\n  setCharWidth(opIdx, xWidth, yWidth) {}\n  setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {\n    const clip = new Path2D();\n    clip.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip(clip);\n    this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);\n    this.endPath(opIdx);\n  }\n  getColorN_Pattern(opIdx, IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: (ctx, renderingOpIdx) => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n          optionalContentConfig: this.optionalContentConfig,\n          markedContentStack: this.markedContentStack\n        }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)\n      };\n      pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(opIdx, IR[1], IR[2]);\n    }\n    return pattern;\n  }\n  setStrokeColorN(opIdx, ...args) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.current.strokeColor = this.getColorN_Pattern(opIdx, args);\n    this.current.patternStroke = true;\n  }\n  setFillColorN(opIdx, ...args) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.current.fillColor = this.getColorN_Pattern(opIdx, args);\n    this.current.patternFill = true;\n  }\n  setStrokeRGBColor(opIdx, color) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.ctx.strokeStyle = this.current.strokeColor = color;\n    this.current.patternStroke = false;\n  }\n  setStrokeTransparent(opIdx) {\n    this.dependencyTracker?.recordSimpleData(\"strokeColor\", opIdx);\n    this.ctx.strokeStyle = this.current.strokeColor = \"transparent\";\n    this.current.patternStroke = false;\n  }\n  setFillRGBColor(opIdx, color) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.ctx.fillStyle = this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n  setFillTransparent(opIdx) {\n    this.dependencyTracker?.recordSimpleData(\"fillColor\", opIdx);\n    this.ctx.fillStyle = this.current.fillColor = \"transparent\";\n    this.current.patternFill = false;\n  }\n  _getPattern(opIdx, objId, matrix = null) {\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = getShadingPattern(this.getObject(opIdx, objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n  shadingFill(opIdx, objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    this.save(opIdx);\n    const pattern = this._getPattern(opIdx, objId);\n    ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);\n    const inv = getCurrentTransformInverse(ctx);\n    if (inv) {\n      const {\n        width,\n        height\n      } = ctx.canvas;\n      const minMax = MIN_MAX_INIT.slice();\n      Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);\n      const [x0, y0, x1, y1] = minMax;\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n    this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore(opIdx);\n  }\n  beginInlineImage() {\n    unreachable(\"Should not call beginInlineImage\");\n  }\n  beginImageData() {\n    unreachable(\"Should not call beginImageData\");\n  }\n  paintFormXObjectBegin(opIdx, matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save(opIdx);\n    this.baseTransformStack.push(this.baseTransform);\n    if (matrix) {\n      this.transform(opIdx, ...matrix);\n    }\n    this.baseTransform = getCurrentTransform(this.ctx);\n    if (bbox) {\n      Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);\n      const [x0, y0, x1, y1] = bbox;\n      const clip = new Path2D();\n      clip.rect(x0, y0, x1 - x0, y1 - y0);\n      this.ctx.clip(clip);\n      this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);\n      this.endPath(opIdx);\n    }\n  }\n  paintFormXObjectEnd(opIdx) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore(opIdx);\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n  beginGroup(opIdx, group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save(opIdx);\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n    const currentCtx = this.ctx;\n    if (!group.isolated) {\n      info(\"TODO: Support non-isolated groups.\");\n    }\n    if (group.knockout) {\n      warn(\"Knockout groups not supported.\");\n    }\n    const currentTransform = getCurrentTransform(currentCtx);\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n    let bounds = MIN_MAX_INIT.slice();\n    Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n    let clip = new Path2D();\n    const [x0, y0, x1, y1] = group.bbox;\n    clip.rect(x0, y0, x1 - x0, y1 - y0);\n    if (group.matrix) {\n      const path = new Path2D();\n      path.addPath(clip, new DOMMatrix(group.matrix));\n      clip = path;\n    }\n    groupCtx.clip(clip);\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    }\n    if (!group.smask || this.dependencyTracker) {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.save();\n    }\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies([\"fillAlpha\", \"strokeAlpha\", \"globalCompositeOperation\"]).pushBaseTransform(currentCtx);\n    this.setGState(opIdx, [[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n  endGroup(opIdx, group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n    this.dependencyTracker?.popBaseTransform();\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore(opIdx);\n      if (this.dependencyTracker) {\n        this.ctx.restore();\n      }\n    } else {\n      this.ctx.restore();\n      const currentMtx = getCurrentTransform(this.ctx);\n      this.restore(opIdx);\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n      const dirtyBox = MIN_MAX_INIT.slice();\n      Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n  beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx);\n    this.ctx.save();\n    this.save(opIdx);\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n    if (rect) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n        Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.save();\n        this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.endPath(opIdx);\n        const clip = new Path2D();\n        clip.rect(rect[0], rect[1], width, height);\n        this.ctx.clip(clip);\n      }\n    }\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(opIdx, ...transform);\n    this.transform(opIdx, ...matrix);\n  }\n  endAnnotation(opIdx) {\n    if (this.annotationCanvas) {\n      this.ctx.restore();\n      this.#drawFilter();\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n  paintImageMaskXObject(opIdx, img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const count = img.count;\n    img = this.getObject(opIdx, img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const mask = this._createMaskCanvas(opIdx, img);\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    img = this.getObject(opIdx, img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = getCurrentTransform(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(opIdx, img);\n    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n    this.dependencyTracker?.resetBBox(opIdx);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n      ctx.drawImage(mask.canvas, trans[4], trans[5]);\n      this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);\n    }\n    ctx.restore();\n    this.compose();\n    this.dependencyTracker?.recordOperation(opIdx);\n  }\n  paintImageMaskXObjectGroup(opIdx, images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(opIdx, data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);\n      ctx.restore();\n    }\n    this.compose();\n    this.dependencyTracker?.recordOperation(opIdx);\n  }\n  paintImageXObject(opIdx, objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(opIdx, objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    this.paintInlineImageXObject(opIdx, imgData);\n  }\n  paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(opIdx, objId);\n    if (!imgData) {\n      warn(\"Dependent image isn't ready yet\");\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n    this.paintInlineImageXObjectGroup(opIdx, imgData, map);\n  }\n  applyTransferMapsToCanvas(ctx) {\n    if (this.current.transferMaps !== \"none\") {\n      ctx.filter = this.current.transferMaps;\n      ctx.drawImage(ctx.canvas, 0, 0);\n      ctx.filter = \"none\";\n    }\n    return ctx.canvas;\n  }\n  applyTransferMapsToBitmap(imgData) {\n    if (this.current.transferMaps === \"none\") {\n      return imgData.bitmap;\n    }\n    const {\n      bitmap,\n      width,\n      height\n    } = imgData;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n    const tmpCtx = tmpCanvas.context;\n    tmpCtx.filter = this.current.transferMaps;\n    tmpCtx.drawImage(bitmap, 0, 0);\n    tmpCtx.filter = \"none\";\n    return tmpCanvas.canvas;\n  }\n  paintInlineImageXObject(opIdx, imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save(opIdx);\n    const {\n      filter\n    } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n      ctx.filter = \"none\";\n    }\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = this.applyTransferMapsToBitmap(imgData);\n    } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);\n    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n    this.compose();\n    this.restore(opIdx);\n  }\n  paintInlineImageXObjectGroup(opIdx, imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = imgData.bitmap;\n    } else {\n      const w = imgData.width;\n      const h = imgData.height;\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    this.dependencyTracker?.resetBBox(opIdx);\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n      this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);\n      ctx.restore();\n    }\n    this.dependencyTracker?.recordOperation(opIdx);\n    this.compose();\n  }\n  paintSolidColorImageMask(opIdx) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n  markPoint(opIdx, tag) {}\n  markPointProps(opIdx, tag, properties) {}\n  beginMarkedContent(opIdx, tag) {\n    this.dependencyTracker?.beginMarkedContent(opIdx);\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n  beginMarkedContentProps(opIdx, tag, properties) {\n    this.dependencyTracker?.beginMarkedContent(opIdx);\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n  endMarkedContent(opIdx) {\n    this.dependencyTracker?.endMarkedContent(opIdx);\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n  beginCompat(opIdx) {}\n  endCompat(opIdx) {}\n  consumePath(opIdx, path, clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(path, \"evenodd\");\n        } else {\n          ctx.clip(path);\n        }\n      }\n      this.pendingClip = null;\n      this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency(\"clipPath\", opIdx);\n    } else {\n      this.dependencyTracker?.recordOperation(opIdx);\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n  }\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = getCurrentTransform(this.ctx);\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n    return this._cachedGetSinglePixelWidth;\n  }\n  getScaleForStroking() {\n    if (this._cachedScaleForStroking[0] === -1) {\n      const {\n        lineWidth\n      } = this.current;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.ctx.getTransform();\n      let scaleX, scaleY;\n      if (b === 0 && c === 0) {\n        const normX = Math.abs(a);\n        const normY = Math.abs(d);\n        if (normX === normY) {\n          if (lineWidth === 0) {\n            scaleX = scaleY = 1 / normX;\n          } else {\n            const scaledLineWidth = normX * lineWidth;\n            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n          }\n        } else if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(a * d - b * c);\n        const normX = Math.hypot(a, b);\n        const normY = Math.hypot(c, d);\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n      this._cachedScaleForStroking[0] = scaleX;\n      this._cachedScaleForStroking[1] = scaleY;\n    }\n    return this._cachedScaleForStroking;\n  }\n  rescaleAndStroke(path, saveRestore) {\n    const {\n      ctx,\n      current: {\n        lineWidth\n      }\n    } = this;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    if (scaleX === scaleY) {\n      ctx.lineWidth = (lineWidth || 1) * scaleX;\n      ctx.stroke(path);\n      return;\n    }\n    const dashes = ctx.getLineDash();\n    if (saveRestore) {\n      ctx.save();\n    }\n    ctx.scale(scaleX, scaleY);\n    SCALE_MATRIX.a = 1 / scaleX;\n    SCALE_MATRIX.d = 1 / scaleY;\n    const newPath = new Path2D();\n    newPath.addPath(path, SCALE_MATRIX);\n    if (dashes.length > 0) {\n      const scale = Math.max(scaleX, scaleY);\n      ctx.setLineDash(dashes.map(x => x / scale));\n      ctx.lineDashOffset /= scale;\n    }\n    ctx.lineWidth = lineWidth || 1;\n    ctx.stroke(newPath);\n    if (saveRestore) {\n      ctx.restore();\n    }\n  }\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nfor (const op in OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n;// ./src/display/worker_options.js\nclass GlobalWorkerOptions {\n  static #port = null;\n  static #src = \"\";\n  static get workerPort() {\n    return this.#port;\n  }\n  static set workerPort(val) {\n    if (!(typeof Worker !== \"undefined\" && val instanceof Worker) && val !== null) {\n      throw new Error(\"Invalid `workerPort` type.\");\n    }\n    this.#port = val;\n  }\n  static get workerSrc() {\n    return this.#src;\n  }\n  static set workerSrc(val) {\n    if (typeof val !== \"string\") {\n      throw new Error(\"Invalid `workerSrc` type.\");\n    }\n    this.#src = val;\n  }\n}\n\n;// ./src/display/metadata.js\nclass Metadata {\n  #map;\n  #data;\n  constructor({\n    parsedData,\n    rawData\n  }) {\n    this.#map = parsedData;\n    this.#data = rawData;\n  }\n  getRaw() {\n    return this.#data;\n  }\n  get(name) {\n    return this.#map.get(name) ?? null;\n  }\n  [Symbol.iterator]() {\n    return this.#map.entries();\n  }\n}\n\n;// ./src/display/optional_content_config.js\n\n\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n  #isDisplay = false;\n  #isPrint = false;\n  #userSet = false;\n  #visible = true;\n  constructor(renderingIntent, {\n    name,\n    intent,\n    usage,\n    rbGroups\n  }) {\n    this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);\n    this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    this.name = name;\n    this.intent = intent;\n    this.usage = usage;\n    this.rbGroups = rbGroups;\n  }\n  get visible() {\n    if (this.#userSet) {\n      return this.#visible;\n    }\n    if (!this.#visible) {\n      return false;\n    }\n    const {\n      print,\n      view\n    } = this.usage;\n    if (this.#isDisplay) {\n      return view?.viewState !== \"OFF\";\n    } else if (this.#isPrint) {\n      return print?.printState !== \"OFF\";\n    }\n    return true;\n  }\n  _setVisible(internal, visible, userSet = false) {\n    if (internal !== INTERNAL) {\n      unreachable(\"Internal method `_setVisible` called.\");\n    }\n    this.#userSet = userSet;\n    this.#visible = visible;\n  }\n}\nclass OptionalContentConfig {\n  #cachedGetHash = null;\n  #groups = new Map();\n  #initialHash = null;\n  #order = null;\n  constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {\n    this.renderingIntent = renderingIntent;\n    this.name = null;\n    this.creator = null;\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));\n    }\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n    this.#initialHash = this.getHash();\n  }\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        warn(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      info(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        warn(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            warn(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      warn(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    warn(`Unknown group type ${group.type}.`);\n    return true;\n  }\n  setVisibility(id, visible = true, preserveRB = true) {\n    const group = this.#groups.get(id);\n    if (!group) {\n      warn(`Optional content group not found: ${id}`);\n      return;\n    }\n    if (preserveRB && visible && group.rbGroups.length) {\n      for (const rbGroup of group.rbGroups) {\n        for (const otherId of rbGroup) {\n          if (otherId !== id) {\n            this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);\n          }\n        }\n      }\n    }\n    group._setVisible(INTERNAL, !!visible, true);\n    this.#cachedGetHash = null;\n  }\n  setOCGState({\n    state,\n    preserveRB\n  }) {\n    let operator;\n    for (const elem of state) {\n      switch (elem) {\n        case \"ON\":\n        case \"OFF\":\n        case \"Toggle\":\n          operator = elem;\n          continue;\n      }\n      const group = this.#groups.get(elem);\n      if (!group) {\n        continue;\n      }\n      switch (operator) {\n        case \"ON\":\n          this.setVisibility(elem, true, preserveRB);\n          break;\n        case \"OFF\":\n          this.setVisibility(elem, false, preserveRB);\n          break;\n        case \"Toggle\":\n          this.setVisibility(elem, !group.visible, preserveRB);\n          break;\n      }\n    }\n    this.#cachedGetHash = null;\n  }\n  get hasInitialVisibility() {\n    return this.#initialHash === null || this.getHash() === this.#initialHash;\n  }\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n    if (this.#order) {\n      return this.#order.slice();\n    }\n    return [...this.#groups.keys()];\n  }\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n  getHash() {\n    if (this.#cachedGetHash !== null) {\n      return this.#cachedGetHash;\n    }\n    const hash = new MurmurHash3_64();\n    for (const [id, group] of this.#groups) {\n      hash.update(`${id}:${group.visible}`);\n    }\n    return this.#cachedGetHash = hash.hexdigest();\n  }\n  [Symbol.iterator]() {\n    return this.#groups.entries();\n  }\n}\n\n;// ./src/display/transport_stream.js\n\n\nclass PDFDataTransportStream {\n  constructor(pdfDataRangeTransport, {\n    disableRange = false,\n    disableStream = false\n  }) {\n    assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    const {\n      length,\n      initialData,\n      progressiveDone,\n      contentDispositionFilename\n    } = pdfDataRangeTransport;\n    this._queuedChunks = [];\n    this._progressiveDone = progressiveDone;\n    this._contentDispositionFilename = contentDispositionFilename;\n    if (initialData?.length > 0) {\n      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !disableStream;\n    this._isRangeSupported = !disableRange;\n    this._contentLength = length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n    pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n    pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n    pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n    pdfDataRangeTransport.transportReady();\n  }\n  _onReceiveData({\n    begin,\n    chunk\n  }) {\n    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n    if (begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      assert(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      this._rangeReaders[0]?.onProgress?.({\n        loaded: evt.loaded\n      });\n    } else {\n      this._fullRequestReader?.onProgress?.({\n        loaded: evt.loaded,\n        total: evt.total\n      });\n    }\n  }\n  _onProgressiveDone() {\n    this._fullRequestReader?.progressiveDone();\n    this._progressiveDone = true;\n  }\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\n;// ./src/display/content_disposition.js\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch {}\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replaceAll(\"_\", \" \");\n        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n      try {\n        text = atob(text);\n      } catch {}\n      return textdecode(charset, text);\n    });\n  }\n  return \"\";\n}\n\n;// ./src/display/network_utils.js\n\n\n\nfunction createHeaders(isHttp, httpHeaders) {\n  const headers = new Headers();\n  if (!isHttp || !httpHeaders || typeof httpHeaders !== \"object\") {\n    return headers;\n  }\n  for (const key in httpHeaders) {\n    const val = httpHeaders[key];\n    if (val !== undefined) {\n      headers.append(key, val);\n    }\n  }\n  return headers;\n}\nfunction getResponseOrigin(url) {\n  return URL.parse(url)?.origin ?? null;\n}\nfunction validateRangeRequestCapabilities({\n  responseHeaders,\n  isHttp,\n  rangeChunkSize,\n  disableRange\n}) {\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(responseHeaders.get(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n  returnValues.suggestedLength = length;\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (responseHeaders.get(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n  const contentEncoding = responseHeaders.get(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\nfunction extractFilenameFromHeader(responseHeaders) {\n  const contentDisposition = responseHeaders.get(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = getFilenameFromContentDispositionHeader(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch {}\n    }\n    if (isPdfFile(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\nfunction createResponseError(status, url) {\n  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status, status === 404 || status === 0 && url.startsWith(\"file:\"));\n}\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n;// ./src/display/fetch_stream.js\n\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\nfunction getArrayBuffer(val) {\n  if (val instanceof Uint8Array) {\n    return val.buffer;\n  }\n  if (val instanceof ArrayBuffer) {\n    return val;\n  }\n  warn(`getArrayBuffer - unexpected data format: ${val}`);\n  return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n  _responseOrigin = null;\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.headers = createHeaders(this.isHttp, source.httpHeaders);\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    const headers = new Headers(stream.headers);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      stream._responseOrigin = getResponseOrigin(response.url);\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseError(response.status, url);\n      }\n      this._reader = response.body.getReader();\n      this._headersCapability.resolve();\n      const responseHeaders = response.headers;\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = validateRangeRequestCapabilities({\n        responseHeaders,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = extractFilenameFromHeader(responseHeaders);\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = Promise.withResolvers();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    const headers = new Headers(stream.headers);\n    headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n    const url = source.url;\n    fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {\n      const responseOrigin = getResponseOrigin(response.url);\n      if (responseOrigin !== stream._responseOrigin) {\n        throw new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${stream._responseOrigin}\".`);\n      }\n      if (!validateResponseStatus(response.status)) {\n        throw createResponseError(response.status, url);\n      }\n      this._readCapability.resolve();\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\n\n;// ./src/display/network.js\n\n\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction network_getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  return stringToBytes(data).buffer;\n}\nclass NetworkManager {\n  _responseOrigin = null;\n  constructor({\n    url,\n    httpHeaders,\n    withCredentials\n  }) {\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.headers = createHeaders(this.isHttp, httpHeaders);\n    this.withCredentials = withCredentials || false;\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n  request(args) {\n    const xhr = new XMLHttpRequest();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const [key, val] of this.headers) {\n      xhr.setRequestHeader(key, val);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n    assert(args.onError, \"Expected `onError` callback to be provided.\");\n    xhr.onerror = () => {\n      args.onError(xhr.status);\n    };\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n    if (xhr.readyState !== 4) {\n      return;\n    }\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n    delete this.pendingRequests[xhrId];\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError(xhr.status);\n      return;\n    }\n    const chunk = network_getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      if (matches) {\n        pendingRequest.onDone({\n          begin: parseInt(matches[1], 10),\n          chunk\n        });\n      } else {\n        warn(`Missing or invalid \"Content-Range\" header.`);\n        pendingRequest.onError(0);\n      }\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError(xhr.status);\n    }\n  }\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source);\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    this._url = source.url;\n    this._fullRequestId = manager.request({\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    });\n    this._headersCapability = Promise.withResolvers();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n    this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);\n    const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();\n    const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\\S ]+$/, \"\").split(/[\\r\\n]+/).map(x => {\n      const [key, ...val] = x.split(\": \");\n      return [key, val.join(\": \")];\n    }) : []);\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = validateRangeRequestCapabilities({\n      responseHeaders,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = extractFilenameFromHeader(responseHeaders);\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n    this._headersCapability.resolve();\n  }\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  _onError(status) {\n    this._storedError = createResponseError(status, this._url);\n    this._headersCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    this._headersCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    this._url = manager.url;\n    this._requestId = manager.request({\n      begin,\n      end,\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    });\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n  _onHeadersReceived() {\n    const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);\n    if (responseOrigin !== this._manager._responseOrigin) {\n      this._storedError = new Error(`Expected range response-origin \"${responseOrigin}\" to match \"${this._manager._responseOrigin}\".`);\n      this._onError(0);\n    }\n  }\n  _close() {\n    this.onClosed?.(this);\n  }\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n  _onError(status) {\n    this._storedError ??= createResponseError(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = Promise.withResolvers();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\n;// ./src/display/node_stream.js\n\n\nconst urlRegex = /^[a-z][a-z0-9\\-+.]+:/i;\nfunction parseUrlOrPath(sourceUrl) {\n  if (urlRegex.test(sourceUrl)) {\n    return new URL(sourceUrl);\n  }\n  const url = process.getBuiltinModule(\"url\");\n  return new URL(url.pathToFileURL(sourceUrl));\n}\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrlOrPath(source.url);\n    assert(this.url.protocol === \"file:\", \"PDFNodeStream only supports file:// URLs.\");\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    assert(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNodeStreamFsFullReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nclass PDFNodeStreamFsFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    this._headersCapability = Promise.withResolvers();\n    const fs = process.getBuiltinModule(\"fs\");\n    fs.promises.lstat(this._url).then(stat => {\n      this._contentLength = stat.size;\n      this._setReadableStream(fs.createReadStream(this._url));\n      this._headersCapability.resolve();\n    }, error => {\n      if (error.code === \"ENOENT\") {\n        error = createResponseError(0, this._url.href);\n      }\n      this._storedError = error;\n      this._headersCapability.reject(error);\n    });\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new AbortException(\"streaming is disabled\"));\n    }\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass PDFNodeStreamFsRangeReader {\n  constructor(stream, start, end) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = Promise.withResolvers();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n    const fs = process.getBuiltinModule(\"fs\");\n    this._setReadableStream(fs.createReadStream(this._url, {\n      start,\n      end: end - 1\n    }));\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = Promise.withResolvers();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\n\n;// ./src/display/pdf_objects.js\nconst INITIAL_DATA = Symbol(\"INITIAL_DATA\");\nclass PDFObjects {\n  #objs = Object.create(null);\n  #ensureObj(objId) {\n    return this.#objs[objId] ||= {\n      ...Promise.withResolvers(),\n      data: INITIAL_DATA\n    };\n  }\n  get(objId, callback = null) {\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.promise.then(() => callback(obj.data));\n      return null;\n    }\n    const obj = this.#objs[objId];\n    if (!obj || obj.data === INITIAL_DATA) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n  has(objId) {\n    const obj = this.#objs[objId];\n    return !!obj && obj.data !== INITIAL_DATA;\n  }\n  delete(objId) {\n    const obj = this.#objs[objId];\n    if (!obj || obj.data === INITIAL_DATA) {\n      return false;\n    }\n    delete this.#objs[objId];\n    return true;\n  }\n  resolve(objId, data = null) {\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.resolve();\n  }\n  clear() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      data?.bitmap?.close();\n    }\n    this.#objs = Object.create(null);\n  }\n  *[Symbol.iterator]() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      if (data === INITIAL_DATA) {\n        continue;\n      }\n      yield [objId, data];\n    }\n  }\n}\n\n;// ./src/display/text_layer.js\n\n\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nclass TextLayer {\n  #capability = Promise.withResolvers();\n  #container = null;\n  #disableProcessItems = false;\n  #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n  #lang = null;\n  #layoutTextParams = null;\n  #pageHeight = 0;\n  #pageWidth = 0;\n  #reader = null;\n  #rootContainer = null;\n  #rotation = 0;\n  #scale = 0;\n  #styleCache = Object.create(null);\n  #textContentItemsStr = [];\n  #textContentSource = null;\n  #textDivs = [];\n  #textDivProperties = new WeakMap();\n  #transform = null;\n  static #ascentCache = new Map();\n  static #canvasContexts = new Map();\n  static #canvasCtxFonts = new WeakMap();\n  static #minFontSize = null;\n  static #pendingTextLayers = new Set();\n  constructor({\n    textContentSource,\n    container,\n    viewport\n  }) {\n    if (textContentSource instanceof ReadableStream) {\n      this.#textContentSource = textContentSource;\n    } else if (typeof textContentSource === \"object\") {\n      this.#textContentSource = new ReadableStream({\n        start(controller) {\n          controller.enqueue(textContentSource);\n          controller.close();\n        }\n      });\n    } else {\n      throw new Error('No \"textContentSource\" parameter specified.');\n    }\n    this.#container = this.#rootContainer = container;\n    this.#scale = viewport.scale * OutputScale.pixelRatio;\n    this.#rotation = viewport.rotation;\n    this.#layoutTextParams = {\n      div: null,\n      properties: null,\n      ctx: null\n    };\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n    this.#pageWidth = pageWidth;\n    this.#pageHeight = pageHeight;\n    TextLayer.#ensureMinFontSizeComputed();\n    setLayerDimensions(container, viewport);\n    this.#capability.promise.finally(() => {\n      TextLayer.#pendingTextLayers.delete(this);\n      this.#layoutTextParams = null;\n      this.#styleCache = null;\n    }).catch(() => {});\n  }\n  static get fontFamilyMap() {\n    const {\n      isWindows,\n      isFirefox\n    } = util_FeatureTest.platform;\n    return shadow(this, \"fontFamilyMap\", new Map([[\"sans-serif\", `${isWindows && isFirefox ? \"Calibri, \" : \"\"}sans-serif`], [\"monospace\", `${isWindows && isFirefox ? \"Lucida Console, \" : \"\"}monospace`]]));\n  }\n  render() {\n    const pump = () => {\n      this.#reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          this.#capability.resolve();\n          return;\n        }\n        this.#lang ??= value.lang;\n        Object.assign(this.#styleCache, value.styles);\n        this.#processItems(value.items);\n        pump();\n      }, this.#capability.reject);\n    };\n    this.#reader = this.#textContentSource.getReader();\n    TextLayer.#pendingTextLayers.add(this);\n    pump();\n    return this.#capability.promise;\n  }\n  update({\n    viewport,\n    onBefore = null\n  }) {\n    const scale = viewport.scale * OutputScale.pixelRatio;\n    const rotation = viewport.rotation;\n    if (rotation !== this.#rotation) {\n      onBefore?.();\n      this.#rotation = rotation;\n      setLayerDimensions(this.#rootContainer, {\n        rotation\n      });\n    }\n    if (scale !== this.#scale) {\n      onBefore?.();\n      this.#scale = scale;\n      const params = {\n        div: null,\n        properties: null,\n        ctx: TextLayer.#getCtx(this.#lang)\n      };\n      for (const div of this.#textDivs) {\n        params.properties = this.#textDivProperties.get(div);\n        params.div = div;\n        this.#layout(params);\n      }\n    }\n  }\n  cancel() {\n    const abortEx = new AbortException(\"TextLayer task cancelled.\");\n    this.#reader?.cancel(abortEx).catch(() => {});\n    this.#reader = null;\n    this.#capability.reject(abortEx);\n  }\n  get textDivs() {\n    return this.#textDivs;\n  }\n  get textContentItemsStr() {\n    return this.#textContentItemsStr;\n  }\n  #processItems(items) {\n    if (this.#disableProcessItems) {\n      return;\n    }\n    this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);\n    const textDivs = this.#textDivs,\n      textContentItemsStr = this.#textContentItemsStr;\n    for (const item of items) {\n      if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {\n        warn(\"Ignoring additional textDivs for performance reasons.\");\n        this.#disableProcessItems = true;\n        return;\n      }\n      if (item.str === undefined) {\n        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n          const parent = this.#container;\n          this.#container = document.createElement(\"span\");\n          this.#container.classList.add(\"markedContent\");\n          if (item.id) {\n            this.#container.setAttribute(\"id\", `${item.id}`);\n          }\n          parent.append(this.#container);\n        } else if (item.type === \"endMarkedContent\") {\n          this.#container = this.#container.parentNode;\n        }\n        continue;\n      }\n      textContentItemsStr.push(item.str);\n      this.#appendText(item);\n    }\n  }\n  #appendText(geom) {\n    const textDiv = document.createElement(\"span\");\n    const textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      hasText: geom.str !== \"\",\n      hasEOL: geom.hasEOL,\n      fontSize: 0\n    };\n    this.#textDivs.push(textDiv);\n    const tx = Util.transform(this.#transform, geom.transform);\n    let angle = Math.atan2(tx[1], tx[0]);\n    const style = this.#styleCache[geom.fontName];\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n    let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;\n    fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;\n    const fontHeight = Math.hypot(tx[2], tx[3]);\n    const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);\n    let left, top;\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n    const scaleFactorStr = \"calc(var(--total-scale-factor) *\";\n    const divStyle = textDiv.style;\n    if (this.#container === this.#rootContainer) {\n      divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;\n      divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;\n    } else {\n      divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n      divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n    }\n    divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;\n    divStyle.fontFamily = fontFamily;\n    textDivProperties.fontSize = fontHeight;\n    textDiv.setAttribute(\"role\", \"presentation\");\n    textDiv.textContent = geom.str;\n    textDiv.dir = geom.dir;\n    if (this.#fontInspectorEnabled) {\n      textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;\n    }\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n    let shouldScaleText = false;\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n      const absScaleX = Math.abs(geom.transform[0]),\n        absScaleY = Math.abs(geom.transform[3]);\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n    if (shouldScaleText) {\n      textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n    }\n    this.#textDivProperties.set(textDiv, textDivProperties);\n    this.#layoutTextParams.div = textDiv;\n    this.#layoutTextParams.properties = textDivProperties;\n    this.#layout(this.#layoutTextParams);\n    if (textDivProperties.hasText) {\n      this.#container.append(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this.#container.append(br);\n    }\n  }\n  #layout(params) {\n    const {\n      div,\n      properties,\n      ctx\n    } = params;\n    const {\n      style\n    } = div;\n    let transform = \"\";\n    if (TextLayer.#minFontSize > 1) {\n      transform = `scale(${1 / TextLayer.#minFontSize})`;\n    }\n    if (properties.canvasWidth !== 0 && properties.hasText) {\n      const {\n        fontFamily\n      } = style;\n      const {\n        canvasWidth,\n        fontSize\n      } = properties;\n      TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);\n      const {\n        width\n      } = ctx.measureText(div.textContent);\n      if (width > 0) {\n        transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;\n      }\n    }\n    if (properties.angle !== 0) {\n      transform = `rotate(${properties.angle}deg) ${transform}`;\n    }\n    if (transform.length > 0) {\n      style.transform = transform;\n    }\n  }\n  static cleanup() {\n    if (this.#pendingTextLayers.size > 0) {\n      return;\n    }\n    this.#ascentCache.clear();\n    for (const {\n      canvas\n    } of this.#canvasContexts.values()) {\n      canvas.remove();\n    }\n    this.#canvasContexts.clear();\n  }\n  static #getCtx(lang = null) {\n    let ctx = this.#canvasContexts.get(lang ||= \"\");\n    if (!ctx) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.className = \"hiddenCanvasElement\";\n      canvas.lang = lang;\n      document.body.append(canvas);\n      ctx = canvas.getContext(\"2d\", {\n        alpha: false,\n        willReadFrequently: true\n      });\n      this.#canvasContexts.set(lang, ctx);\n      this.#canvasCtxFonts.set(ctx, {\n        size: 0,\n        family: \"\"\n      });\n    }\n    return ctx;\n  }\n  static #ensureCtxFont(ctx, size, family) {\n    const cached = this.#canvasCtxFonts.get(ctx);\n    if (size === cached.size && family === cached.family) {\n      return;\n    }\n    ctx.font = `${size}px ${family}`;\n    cached.size = size;\n    cached.family = family;\n  }\n  static #ensureMinFontSizeComputed() {\n    if (this.#minFontSize !== null) {\n      return;\n    }\n    const div = document.createElement(\"div\");\n    div.style.opacity = 0;\n    div.style.lineHeight = 1;\n    div.style.fontSize = \"1px\";\n    div.style.position = \"absolute\";\n    div.textContent = \"X\";\n    document.body.append(div);\n    this.#minFontSize = div.getBoundingClientRect().height;\n    div.remove();\n  }\n  static #getAscent(fontFamily, style, lang) {\n    const cachedAscent = this.#ascentCache.get(fontFamily);\n    if (cachedAscent) {\n      return cachedAscent;\n    }\n    const ctx = this.#getCtx(lang);\n    ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;\n    this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);\n    const metrics = ctx.measureText(\"\");\n    const ascent = metrics.fontBoundingBoxAscent;\n    const descent = Math.abs(metrics.fontBoundingBoxDescent);\n    ctx.canvas.width = ctx.canvas.height = 0;\n    let ratio = 0.8;\n    if (ascent) {\n      ratio = ascent / (ascent + descent);\n    } else {\n      if (util_FeatureTest.platform.isFirefox) {\n        warn(\"Enable the `dom.textMetrics.fontBoundingBox.enabled` preference \" + \"in `about:config` to improve TextLayer rendering.\");\n      }\n      if (style.ascent) {\n        ratio = style.ascent;\n      } else if (style.descent) {\n        ratio = 1 + style.descent;\n      }\n    }\n    this.#ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n}\n\n;// ./src/display/api.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nfunction getDocument(src = {}) {\n  if (typeof src === \"string\" || src instanceof URL) {\n    src = {\n      url: src\n    };\n  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {\n    src = {\n      data: src\n    };\n  }\n  const task = new PDFDocumentLoadingTask();\n  const {\n    docId\n  } = task;\n  const url = src.url ? getUrlProp(src.url) : null;\n  const data = src.data ? getDataProp(src.data) : null;\n  const httpHeaders = src.httpHeaders || null;\n  const withCredentials = src.withCredentials === true;\n  const password = src.password ?? null;\n  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;\n  let worker = src.worker instanceof PDFWorker ? src.worker : null;\n  const verbosity = src.verbosity;\n  const docBaseUrl = typeof src.docBaseUrl === \"string\" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;\n  const cMapUrl = getFactoryUrlProp(src.cMapUrl);\n  const cMapPacked = src.cMapPacked !== false;\n  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);\n  const iccUrl = getFactoryUrlProp(src.iccUrl);\n  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);\n  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);\n  const wasmUrl = getFactoryUrlProp(src.wasmUrl);\n  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);\n  const ignoreErrors = src.stopAtErrors !== true;\n  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n  const isEvalSupported = src.isEvalSupported !== false;\n  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !isNodeJS;\n  const isImageDecoderSupported = typeof src.isImageDecoderSupported === \"boolean\" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);\n  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n  const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : isNodeJS;\n  const fontExtraProperties = src.fontExtraProperties === true;\n  const enableXfa = src.enableXfa === true;\n  const ownerDocument = src.ownerDocument || globalThis.document;\n  const disableRange = src.disableRange === true;\n  const disableStream = src.disableStream === true;\n  const disableAutoFetch = src.disableAutoFetch === true;\n  const pdfBug = src.pdfBug === true;\n  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);\n  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);\n  const enableHWA = src.enableHWA === true;\n  const useWasm = src.useWasm !== false;\n  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n  const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !isNodeJS && !disableFontFace;\n  const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));\n  const styleElement = null;\n  setVerbosityLevel(verbosity);\n  const transportFactory = {\n    canvasFactory: new CanvasFactory({\n      ownerDocument,\n      enableHWA\n    }),\n    filterFactory: new FilterFactory({\n      docId,\n      ownerDocument\n    }),\n    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({\n      baseUrl: cMapUrl,\n      isCompressed: cMapPacked\n    }),\n    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({\n      baseUrl: standardFontDataUrl\n    }),\n    wasmFactory: useWorkerFetch ? null : new WasmFactory({\n      baseUrl: wasmUrl\n    })\n  };\n  if (!worker) {\n    worker = PDFWorker.create({\n      verbosity,\n      port: GlobalWorkerOptions.workerPort\n    });\n    task._worker = worker;\n  }\n  const docParams = {\n    docId,\n    apiVersion: \"5.4.449\",\n    data,\n    password,\n    disableAutoFetch,\n    rangeChunkSize,\n    length,\n    docBaseUrl,\n    enableXfa,\n    evaluatorOptions: {\n      maxImageSize,\n      disableFontFace,\n      ignoreErrors,\n      isEvalSupported,\n      isOffscreenCanvasSupported,\n      isImageDecoderSupported,\n      canvasMaxAreaInBytes,\n      fontExtraProperties,\n      useSystemFonts,\n      useWasm,\n      useWorkerFetch,\n      cMapUrl,\n      iccUrl,\n      standardFontDataUrl,\n      wasmUrl\n    }\n  };\n  const transportParams = {\n    ownerDocument,\n    pdfBug,\n    styleElement,\n    loadingParams: {\n      disableAutoFetch,\n      enableXfa\n    }\n  };\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n    if (worker.destroyed) {\n      throw new Error(\"Worker was destroyed\");\n    }\n    const workerIdPromise = worker.messageHandler.sendWithPromise(\"GetDocRequest\", docParams, data ? [data.buffer] : null);\n    let networkStream;\n    if (rangeTransport) {\n      networkStream = new PDFDataTransportStream(rangeTransport, {\n        disableRange,\n        disableStream\n      });\n    } else if (!data) {\n      if (!url) {\n        throw new Error(\"getDocument - no `url` parameter provided.\");\n      }\n      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;\n      networkStream = new NetworkStream({\n        url,\n        length,\n        httpHeaders,\n        withCredentials,\n        rangeChunkSize,\n        disableRange,\n        disableStream\n      });\n    }\n    return workerIdPromise.then(workerId => {\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n      if (worker.destroyed) {\n        throw new Error(\"Worker was destroyed\");\n      }\n      const messageHandler = new MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n  _capability = Promise.withResolvers();\n  _transport = null;\n  _worker = null;\n  docId = `d${PDFDocumentLoadingTask.#docId++}`;\n  destroyed = false;\n  onPassword = null;\n  onProgress = null;\n  get promise() {\n    return this._capability.promise;\n  }\n  async destroy() {\n    this.destroyed = true;\n    try {\n      if (this._worker?.port) {\n        this._worker._pendingDestroy = true;\n      }\n      await this._transport?.destroy();\n    } catch (ex) {\n      if (this._worker?.port) {\n        delete this._worker._pendingDestroy;\n      }\n      throw ex;\n    }\n    this._transport = null;\n    this._worker?.destroy();\n    this._worker = null;\n  }\n  async getData() {\n    return this._transport.getData();\n  }\n}\nclass PDFDataRangeTransport {\n  #capability = Promise.withResolvers();\n  #progressiveDoneListeners = [];\n  #progressiveReadListeners = [];\n  #progressListeners = [];\n  #rangeListeners = [];\n  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n  }\n  addRangeListener(listener) {\n    this.#rangeListeners.push(listener);\n  }\n  addProgressListener(listener) {\n    this.#progressListeners.push(listener);\n  }\n  addProgressiveReadListener(listener) {\n    this.#progressiveReadListeners.push(listener);\n  }\n  addProgressiveDoneListener(listener) {\n    this.#progressiveDoneListeners.push(listener);\n  }\n  onDataRange(begin, chunk) {\n    for (const listener of this.#rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n  onDataProgress(loaded, total) {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n  onDataProgressiveRead(chunk) {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n  onDataProgressiveDone() {\n    this.#capability.promise.then(() => {\n      for (const listener of this.#progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n  transportReady() {\n    this.#capability.resolve();\n  }\n  requestDataRange(begin, end) {\n    unreachable(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n  abort() {}\n}\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n  get canvasFactory() {\n    return this._transport.canvasFactory;\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n  getAnnotationsByType(types, pageIndexesToSkip) {\n    return this._transport.getAnnotationsByType(types, pageIndexesToSkip);\n  }\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n  getOutline() {\n    return this._transport.getOutline();\n  }\n  getOptionalContentConfig({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getOptionalContentConfig(renderingIntent);\n  }\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n  getData() {\n    return this._transport.getData();\n  }\n  saveDocument() {\n    return this._transport.saveDocument();\n  }\n  extractPages(pageInfos) {\n    return this._transport.extractPages(pageInfos);\n  }\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n  cleanup(keepLoadedFonts = false) {\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n  cachedPageNumber(ref) {\n    return this._transport.cachedPageNumber(ref);\n  }\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\nclass PDFPageProxy {\n  #pendingCleanup = false;\n  constructor(pageIndex, pageInfo, transport, pdfBug = false) {\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._transport = transport;\n    this._stats = pdfBug ? new StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._intentStates = new Map();\n    this.destroyed = false;\n    this.recordedBBoxes = null;\n  }\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n  get ref() {\n    return this._pageInfo.ref;\n  }\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n  get view() {\n    return this._pageInfo.view;\n  }\n  getViewport({\n    scale,\n    rotation = this.rotate,\n    offsetX = 0,\n    offsetY = 0,\n    dontFlip = false\n  } = {}) {\n    return new PageViewport({\n      viewBox: this.view,\n      userUnit: this.userUnit,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  getAnnotations({\n    intent = \"display\"\n  } = {}) {\n    const {\n      renderingIntent\n    } = this._transport.getRenderingIntent(intent);\n    return this._transport.getAnnotations(this._pageIndex, renderingIntent);\n  }\n  getJSActions() {\n    return this._transport.getPageJSActions(this._pageIndex);\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get isPureXfa() {\n    return shadow(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n  render({\n    canvasContext,\n    canvas = canvasContext.canvas,\n    viewport,\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    transform = null,\n    background = null,\n    optionalContentConfigPromise = null,\n    annotationCanvasMap = null,\n    pageColors = null,\n    printAnnotationStorage = null,\n    isEditing = false,\n    recordOperations = false,\n    operationsFilter = null\n  }) {\n    this._stats?.time(\"Overall\");\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);\n    const {\n      renderingIntent,\n      cacheKey\n    } = intentArgs;\n    this.#pendingCleanup = false;\n    optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);\n    let intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(cacheKey, intentState);\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = Promise.withResolvers();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);\n    const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n      if (shouldRecordOperations) {\n        const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();\n        if (recordedBBoxes) {\n          if (internalRenderTask.stepper) {\n            internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());\n          }\n          if (recordOperations) {\n            this.recordedBBoxes = recordedBBoxes;\n          }\n        }\n      }\n      if (intentPrint) {\n        this.#pendingCleanup = true;\n      }\n      this.#tryCleanup();\n      if (error) {\n        internalRenderTask.capability.reject(error);\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      if (this._stats) {\n        this._stats.timeEnd(\"Rendering\");\n        this._stats.timeEnd(\"Overall\");\n        if (globalThis.Stats?.enabled) {\n          globalThis.Stats.add(this.pageNumber, this._stats);\n        }\n      }\n    };\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvas,\n        canvasContext,\n        dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,\n        viewport,\n        transform,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: this._transport.canvasFactory,\n      filterFactory: this._transport.filterFactory,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors,\n      enableHWA: this._transport.enableHWA,\n      operationsFilter\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {\n      if (this.destroyed) {\n        complete();\n        return;\n      }\n      this._stats?.time(\"Rendering\");\n      if (!(optionalContentConfig.renderingIntent & renderingIntent)) {\n        throw new Error(\"Must use the same `intent`-argument when calling the `PDFPageProxy.render` \" + \"and `PDFDocumentProxy.getOptionalContentConfig` methods.\");\n      }\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n  getOperatorList({\n    intent = \"display\",\n    annotationMode = AnnotationMode.ENABLE,\n    printAnnotationStorage = null,\n    isEditing = false\n  } = {}) {\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = Promise.withResolvers();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n  streamTextContent({\n    includeMarkedContent = false,\n    disableNormalization = false\n  } = {}) {\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      includeMarkedContent: includeMarkedContent === true,\n      disableNormalization: disableNormalization === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n      size(textContent) {\n        return textContent.items.length;\n      }\n    });\n  }\n  getTextContent(params = {}) {\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => XfaText.textContent(xfa));\n    }\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          textContent.lang ??= value.lang;\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null),\n        lang: null\n      };\n      pump();\n    });\n  }\n  getStructTree() {\n    return this._transport.getStructTree(this._pageIndex);\n  }\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return Promise.all(waitOn);\n  }\n  cleanup(resetStats = false) {\n    this.#pendingCleanup = true;\n    const success = this.#tryCleanup();\n    if (resetStats && success) {\n      this._stats &&= new StatTimer();\n    }\n    return success;\n  }\n  #tryCleanup() {\n    if (!this.#pendingCleanup || this.destroyed) {\n      return false;\n    }\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n    this._intentStates.clear();\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return true;\n  }\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return;\n    }\n    this._stats?.timeEnd(\"Page Request\");\n    intentState.displayReadyCapability?.resolve(transparency);\n  }\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n    if (operatorListChunk.lastChunk) {\n      this.#tryCleanup();\n    }\n  }\n  _pumpOperatorList({\n    renderingIntent,\n    cacheKey,\n    annotationStorageSerializable,\n    modifiedIds\n  }) {\n    const {\n      map,\n      transfer\n    } = annotationStorageSerializable;\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: map,\n      modifiedIds\n    }, transfer);\n    const reader = readableStream.getReader();\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n    const pump = () => {\n      reader.read().then(({\n        value,\n        done\n      }) => {\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n        if (this._transport.destroyed) {\n          return;\n        }\n        this._renderPageChunk(value, intentState);\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n          return;\n        }\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          this.#tryCleanup();\n        }\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n    pump();\n  }\n  _abortOperatorList({\n    intentState,\n    reason,\n    force = false\n  }) {\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      if (reason instanceof RenderingCancelledException) {\n        let delay = RENDERING_CANCELLED_TIMEOUT;\n        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n          delay += reason.extraDelay;\n        }\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          intentState.streamReaderCancelTimeout = null;\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n        }, delay);\n        return;\n      }\n    }\n    intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n    if (this._transport.destroyed) {\n      return;\n    }\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    this.cleanup();\n  }\n  get stats() {\n    return this._stats;\n  }\n}\nclass PDFWorker {\n  #capability = Promise.withResolvers();\n  #messageHandler = null;\n  #port = null;\n  #webWorker = null;\n  static #fakeWorkerId = 0;\n  static #isWorkerDisabled = false;\n  static #workerPorts = new WeakMap();\n  static {\n    if (isNodeJS) {\n      this.#isWorkerDisabled = true;\n      GlobalWorkerOptions.workerSrc ||= \"./pdf.worker.mjs\";\n    }\n    this._isSameOrigin = (baseUrl, otherUrl) => {\n      const base = URL.parse(baseUrl);\n      if (!base?.origin || base.origin === \"null\") {\n        return false;\n      }\n      const other = new URL(otherUrl, base);\n      return base.origin === other.origin;\n    };\n    this._createCDNWrapper = url => {\n      const wrapper = `await import(\"${url}\");`;\n      return URL.createObjectURL(new Blob([wrapper], {\n        type: \"text/javascript\"\n      }));\n    };\n    this.fromPort = params => {\n      deprecated(\"`PDFWorker.fromPort` - please use `PDFWorker.create` instead.\");\n      if (!params?.port) {\n        throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n      }\n      return this.create(params);\n    };\n  }\n  constructor({\n    name = null,\n    port = null,\n    verbosity = getVerbosityLevel()\n  } = {}) {\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    if (port) {\n      if (PDFWorker.#workerPorts.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port.\");\n      }\n      PDFWorker.#workerPorts.set(port, this);\n      this.#initializeFromPort(port);\n    } else {\n      this.#initialize();\n    }\n  }\n  get promise() {\n    return this.#capability.promise;\n  }\n  #resolve() {\n    this.#capability.resolve();\n    this.#messageHandler.send(\"configure\", {\n      verbosity: this.verbosity\n    });\n  }\n  get port() {\n    return this.#port;\n  }\n  get messageHandler() {\n    return this.#messageHandler;\n  }\n  #initializeFromPort(port) {\n    this.#port = port;\n    this.#messageHandler = new MessageHandler(\"main\", \"worker\", port);\n    this.#messageHandler.on(\"ready\", () => {});\n    this.#resolve();\n  }\n  #initialize() {\n    if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {\n      this.#setupFakeWorker();\n      return;\n    }\n    let {\n      workerSrc\n    } = PDFWorker;\n    try {\n      if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {\n        workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);\n      }\n      const worker = new Worker(workerSrc, {\n        type: \"module\"\n      });\n      const messageHandler = new MessageHandler(\"main\", \"worker\", worker);\n      const terminateEarly = () => {\n        ac.abort();\n        messageHandler.destroy();\n        worker.terminate();\n        if (this.destroyed) {\n          this.#capability.reject(new Error(\"Worker was destroyed\"));\n        } else {\n          this.#setupFakeWorker();\n        }\n      };\n      const ac = new AbortController();\n      worker.addEventListener(\"error\", () => {\n        if (!this.#webWorker) {\n          terminateEarly();\n        }\n      }, {\n        signal: ac.signal\n      });\n      messageHandler.on(\"test\", data => {\n        ac.abort();\n        if (this.destroyed || !data) {\n          terminateEarly();\n          return;\n        }\n        this.#messageHandler = messageHandler;\n        this.#port = worker;\n        this.#webWorker = worker;\n        this.#resolve();\n      });\n      messageHandler.on(\"ready\", data => {\n        ac.abort();\n        if (this.destroyed) {\n          terminateEarly();\n          return;\n        }\n        try {\n          sendTest();\n        } catch {\n          this.#setupFakeWorker();\n        }\n      });\n      const sendTest = () => {\n        const testObj = new Uint8Array();\n        messageHandler.send(\"test\", testObj, [testObj.buffer]);\n      };\n      sendTest();\n      return;\n    } catch {\n      info(\"The worker has been disabled.\");\n    }\n    this.#setupFakeWorker();\n  }\n  #setupFakeWorker() {\n    if (!PDFWorker.#isWorkerDisabled) {\n      warn(\"Setting up fake worker.\");\n      PDFWorker.#isWorkerDisabled = true;\n    }\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this.#capability.reject(new Error(\"Worker was destroyed\"));\n        return;\n      }\n      const port = new LoopbackPort();\n      this.#port = port;\n      const id = `fake${PDFWorker.#fakeWorkerId++}`;\n      const workerHandler = new MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      this.#messageHandler = new MessageHandler(id, id + \"_worker\", port);\n      this.#resolve();\n    }).catch(reason => {\n      this.#capability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n  destroy() {\n    this.destroyed = true;\n    this.#webWorker?.terminate();\n    this.#webWorker = null;\n    PDFWorker.#workerPorts.delete(this.#port);\n    this.#port = null;\n    this.#messageHandler?.destroy();\n    this.#messageHandler = null;\n  }\n  static create(params) {\n    const cachedPort = this.#workerPorts.get(params?.port);\n    if (cachedPort) {\n      if (cachedPort._pendingDestroy) {\n        throw new Error(\"PDFWorker.create - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n      }\n      return cachedPort;\n    }\n    return new PDFWorker(params);\n  }\n  static get workerSrc() {\n    if (GlobalWorkerOptions.workerSrc) {\n      return GlobalWorkerOptions.workerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n  static get #mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch {\n      return null;\n    }\n  }\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      if (this.#mainThreadWorkerMessageHandler) {\n        return this.#mainThreadWorkerMessageHandler;\n      }\n      const worker = await import(\n      /*webpackIgnore: true*/\n      /*@vite-ignore*/\n      this.workerSrc);\n      return worker.WorkerMessageHandler;\n    };\n    return shadow(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nclass WorkerTransport {\n  #methodPromises = new Map();\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #pageRefCache = new Map();\n  #passwordCapability = null;\n  constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new FontLoader({\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this.loadingParams = params.loadingParams;\n    this._params = params;\n    this.canvasFactory = factory.canvasFactory;\n    this.filterFactory = factory.filterFactory;\n    this.cMapReaderFactory = factory.cMapReaderFactory;\n    this.standardFontDataFactory = factory.standardFontDataFactory;\n    this.wasmFactory = factory.wasmFactory;\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = Promise.withResolvers();\n    this.enableHWA = enableHWA;\n    this.setupMessageHandler();\n  }\n  #cacheSimpleMethod(name, data = null) {\n    const cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, data);\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  get annotationStorage() {\n    return shadow(this, \"annotationStorage\", new AnnotationStorage());\n  }\n  getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {\n    let renderingIntent = RenderingIntentFlag.DISPLAY;\n    let annotationStorageSerializable = SerializableEmpty;\n    switch (intent) {\n      case \"any\":\n        renderingIntent = RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = RenderingIntentFlag.PRINT;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n    const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n    switch (annotationMode) {\n      case AnnotationMode.DISABLE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case AnnotationMode.ENABLE:\n        break;\n      case AnnotationMode.ENABLE_FORMS:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        annotationStorageSerializable = annotationStorage.serializable;\n        break;\n      default:\n        warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n    if (isEditing) {\n      renderingIntent += RenderingIntentFlag.IS_EDITING;\n    }\n    if (isOpList) {\n      renderingIntent += RenderingIntentFlag.OPLIST;\n    }\n    const {\n      ids: modifiedIds,\n      hash: modifiedIdsHash\n    } = annotationStorage.modifiedIds;\n    const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];\n    return {\n      renderingIntent,\n      cacheKey: cacheKeyBuf.join(\"_\"),\n      annotationStorageSerializable,\n      modifiedIds\n    };\n  }\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n    this.destroyed = true;\n    this.destroyCapability = Promise.withResolvers();\n    this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    const waitOn = [];\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    this.#pageRefCache.clear();\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#methodPromises.clear();\n      this.filterFactory.destroy();\n      TextLayer.cleanup();\n      this._networkStream?.cancelAllRequests(new AbortException(\"Worker was terminated.\"));\n      this.messageHandler?.destroy();\n      this.messageHandler = null;\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      assert(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", async data => {\n      await this._fullReader.headersReady;\n      const {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      } = this._fullReader;\n      if (!isStreamingSupported || !isRangeSupported) {\n        if (this._lastProgress) {\n          loadingTask.onProgress?.(this._lastProgress);\n        }\n        this._fullReader.onProgress = evt => {\n          loadingTask.onProgress?.({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        };\n      }\n      return {\n        isStreamingSupported,\n        isRangeSupported,\n        contentLength\n      };\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      assert(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n      sink.onPull = () => {\n        rangeReader.read().then(function ({\n          value,\n          done\n        }) {\n          if (done) {\n            sink.close();\n            return;\n          }\n          assert(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", ({\n      pdfInfo\n    }) => {\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", ex => {\n      loadingTask._capability.reject(wrapReason(ex));\n    });\n    messageHandler.on(\"PasswordRequest\", ex => {\n      this.#passwordCapability = Promise.withResolvers();\n      try {\n        if (!loadingTask.onPassword) {\n          throw wrapReason(ex);\n        }\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this.#passwordCapability.reject(password);\n          } else {\n            this.#passwordCapability.resolve({\n              password\n            });\n          }\n        };\n        loadingTask.onPassword(updatePassword, ex.code);\n      } catch (err) {\n        this.#passwordCapability.reject(err);\n      }\n      return this.#passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", ([id, type, exportedData]) => {\n      if (this.destroyed) {\n        return null;\n      }\n      if (this.commonObjs.has(id)) {\n        return null;\n      }\n      switch (type) {\n        case \"Font\":\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            warn(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n          const fontData = new FontInfo(exportedData);\n          const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;\n          const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);\n          this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise(\"FontFallback\", {\n            id\n          })).finally(() => {\n            if (!font.fontExtraProperties && font.data) {\n              font.clearData();\n            }\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n        case \"CopyLocalImage\":\n          const {\n            imageRef\n          } = exportedData;\n          assert(imageRef, \"The imageRef must be defined.\");\n          for (const pageProxy of this.#pageCache.values()) {\n            for (const [, data] of pageProxy.objs) {\n              if (data?.ref !== imageRef) {\n                continue;\n              }\n              if (!data.dataLen) {\n                return null;\n              }\n              this.commonObjs.resolve(id, structuredClone(data));\n              return data.dataLen;\n            }\n          }\n          break;\n        case \"FontPath\":\n        case \"Image\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        case \"Pattern\":\n          const pattern = new PatternInfo(exportedData);\n          this.commonObjs.resolve(id, pattern.getIR());\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n      return null;\n    });\n    messageHandler.on(\"obj\", ([id, pageIndex, type, imageData]) => {\n      if (this.destroyed) {\n        return;\n      }\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n      if (pageProxy._intentStates.size === 0) {\n        imageData?.bitmap?.close();\n        return;\n      }\n      switch (type) {\n        case \"Image\":\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"FetchBinaryData\", async data => {\n      if (this.destroyed) {\n        throw new Error(\"Worker was destroyed.\");\n      }\n      const factory = this[data.type];\n      if (!factory) {\n        throw new Error(`${data.type} not initialized, see the \\`useWorkerFetch\\` parameter.`);\n      }\n      return factory.fetch(data);\n    });\n  }\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n  saveDocument() {\n    if (this.annotationStorage.size <= 0) {\n      warn(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n    const {\n      map,\n      transfer\n    } = this.annotationStorage.serializable;\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: map,\n      filename: this._fullReader?.filename ?? null\n    }, transfer).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n  extractPages(pageInfos) {\n    return this.messageHandler.sendWithPromise(\"ExtractPages\", {\n      pageInfos\n    });\n  }\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n      if (pageInfo.refStr) {\n        this.#pageRefCache.set(pageInfo.refStr, pageNumber);\n      }\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  getPageIndex(ref) {\n    if (!isRefProxy(ref)) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n  getFieldObjects() {\n    return this.#cacheSimpleMethod(\"GetFieldObjects\");\n  }\n  hasJSActions() {\n    return this.#cacheSimpleMethod(\"HasJSActions\");\n  }\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n  getAnnotationsByType(types, pageIndexesToSkip) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotationsByType\", {\n      types,\n      pageIndexesToSkip\n    });\n  }\n  getDocJSActions() {\n    return this.#cacheSimpleMethod(\"GetDocJSActions\");\n  }\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n  getOptionalContentConfig(renderingIntent) {\n    return this.#cacheSimpleMethod(\"GetOptionalContentConfig\").then(data => new OptionalContentConfig(data, renderingIntent));\n  }\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n  getMetadata() {\n    const name = \"GetMetadata\",\n      cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, null).then(results => ({\n      info: results[0],\n      metadata: results[1] ? new Metadata(results[1]) : null,\n      contentDispositionFilename: this._fullReader?.filename ?? null,\n      contentLength: this._fullReader?.contentLength ?? null,\n      hasStructTree: results[2]\n    }));\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n  async startCleanup(keepLoadedFonts = false) {\n    if (this.destroyed) {\n      return;\n    }\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#methodPromises.clear();\n    this.filterFactory.destroy(true);\n    TextLayer.cleanup();\n  }\n  cachedPageNumber(ref) {\n    if (!isRefProxy(ref)) {\n      return null;\n    }\n    const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;\n    return this.#pageRefCache.get(refStr) ?? null;\n  }\n}\nclass RenderTask {\n  #internalRenderTask = null;\n  onContinue = null;\n  onError = null;\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n  }\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n  cancel(extraDelay = 0) {\n    this.#internalRenderTask.cancel(null, extraDelay);\n  }\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n    if (!separateAnnots) {\n      return false;\n    }\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n}\nclass InternalRenderTask {\n  #rAF = null;\n  static #canvasInUse = new WeakSet();\n  constructor({\n    callback,\n    params,\n    objs,\n    commonObjs,\n    annotationCanvasMap,\n    operatorList,\n    pageIndex,\n    canvasFactory,\n    filterFactory,\n    useRequestAnimationFrame = false,\n    pdfBug = false,\n    pageColors = null,\n    enableHWA = false,\n    operationsFilter = null\n  }) {\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = Promise.withResolvers();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvas;\n    this._canvasContext = params.canvas ? null : params.canvasContext;\n    this._enableHWA = enableHWA;\n    this._dependencyTracker = params.dependencyTracker;\n    this._operationsFilter = operationsFilter;\n  }\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n  initializeGraphics({\n    transparency = false,\n    optionalContentConfig\n  }) {\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const {\n      viewport,\n      transform,\n      background,\n      dependencyTracker\n    } = this.params;\n    const canvasContext = this._canvasContext || this._canvas.getContext(\"2d\", {\n      alpha: false,\n      willReadFrequently: !this._enableHWA\n    });\n    this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n      optionalContentConfig\n    }, this.annotationCanvasMap, this.pageColors, dependencyTracker);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    this.graphicsReadyCallback?.();\n  }\n  cancel(error = null, extraDelay = 0) {\n    this.running = false;\n    this.cancelled = true;\n    this.gfx?.endDrawing();\n    if (this.#rAF) {\n      window.cancelAnimationFrame(this.#rAF);\n      this.#rAF = null;\n    }\n    InternalRenderTask.#canvasInUse.delete(this._canvas);\n    error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);\n    this.callback(error);\n    this.task.onError?.(error);\n  }\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      this.graphicsReadyCallback ||= this._continueBound;\n      return;\n    }\n    this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);\n    this.stepper?.updateOperatorList(this.operatorList);\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      this.#rAF = window.requestAnimationFrame(() => {\n        this.#rAF = null;\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback();\n      }\n    }\n  }\n}\nconst version = \"5.4.449\";\nconst build = \"f44e5f0e6\";\n\n;// ./src/display/editor/color_picker.js\n\n\n\nclass ColorPicker {\n  #button = null;\n  #buttonSwatch = null;\n  #defaultColor;\n  #dropdown = null;\n  #dropdownWasFromKeyboard = false;\n  #isMainColorPicker = false;\n  #editor = null;\n  #eventBus;\n  #openDropdownAC = null;\n  #uiManager = null;\n  static #l10nColor = null;\n  static get _keyboardManager() {\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"Escape\", \"mac+Escape\"], ColorPicker.prototype._hideDropdownFromKeyboard], [[\" \", \"mac+ \"], ColorPicker.prototype._colorSelectFromKeyboard], [[\"ArrowDown\", \"ArrowRight\", \"mac+ArrowDown\", \"mac+ArrowRight\"], ColorPicker.prototype._moveToNext], [[\"ArrowUp\", \"ArrowLeft\", \"mac+ArrowUp\", \"mac+ArrowLeft\"], ColorPicker.prototype._moveToPrevious], [[\"Home\", \"mac+Home\"], ColorPicker.prototype._moveToBeginning], [[\"End\", \"mac+End\"], ColorPicker.prototype._moveToEnd]]));\n  }\n  constructor({\n    editor = null,\n    uiManager = null\n  }) {\n    if (editor) {\n      this.#isMainColorPicker = false;\n      this.#editor = editor;\n    } else {\n      this.#isMainColorPicker = true;\n    }\n    this.#uiManager = editor?._uiManager || uiManager;\n    this.#eventBus = this.#uiManager._eventBus;\n    this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || \"#FFFF98\";\n    ColorPicker.#l10nColor ||= Object.freeze({\n      blue: \"pdfjs-editor-colorpicker-blue\",\n      green: \"pdfjs-editor-colorpicker-green\",\n      pink: \"pdfjs-editor-colorpicker-pink\",\n      red: \"pdfjs-editor-colorpicker-red\",\n      yellow: \"pdfjs-editor-colorpicker-yellow\"\n    });\n  }\n  renderButton() {\n    const button = this.#button = document.createElement(\"button\");\n    button.className = \"colorPicker\";\n    button.tabIndex = \"0\";\n    button.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-button\");\n    button.ariaHasPopup = \"true\";\n    if (this.#editor) {\n      button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;\n    }\n    const signal = this.#uiManager._signal;\n    button.addEventListener(\"click\", this.#openDropdown.bind(this), {\n      signal\n    });\n    button.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    const swatch = this.#buttonSwatch = document.createElement(\"span\");\n    swatch.className = \"swatch\";\n    swatch.ariaHidden = \"true\";\n    swatch.style.backgroundColor = this.#defaultColor;\n    button.append(swatch);\n    return button;\n  }\n  renderMainDropdown() {\n    const dropdown = this.#dropdown = this.#getDropdownRoot();\n    dropdown.ariaOrientation = \"horizontal\";\n    dropdown.ariaLabelledBy = \"highlightColorPickerLabel\";\n    return dropdown;\n  }\n  #getDropdownRoot() {\n    const div = document.createElement(\"div\");\n    const signal = this.#uiManager._signal;\n    div.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    div.className = \"dropdown\";\n    div.role = \"listbox\";\n    div.ariaMultiSelectable = \"false\";\n    div.ariaOrientation = \"vertical\";\n    div.setAttribute(\"data-l10n-id\", \"pdfjs-editor-colorpicker-dropdown\");\n    if (this.#editor) {\n      div.id = `${this.#editor.id}_colorpicker_dropdown`;\n    }\n    for (const [name, color] of this.#uiManager.highlightColors) {\n      const button = document.createElement(\"button\");\n      button.tabIndex = \"0\";\n      button.role = \"option\";\n      button.setAttribute(\"data-color\", color);\n      button.title = name;\n      button.setAttribute(\"data-l10n-id\", ColorPicker.#l10nColor[name]);\n      const swatch = document.createElement(\"span\");\n      button.append(swatch);\n      swatch.className = \"swatch\";\n      swatch.style.backgroundColor = color;\n      button.ariaSelected = color === this.#defaultColor;\n      button.addEventListener(\"click\", this.#colorSelect.bind(this, color), {\n        signal\n      });\n      div.append(button);\n    }\n    div.addEventListener(\"keydown\", this.#keyDown.bind(this), {\n      signal\n    });\n    return div;\n  }\n  #colorSelect(color, event) {\n    event.stopPropagation();\n    this.#eventBus.dispatch(\"switchannotationeditorparams\", {\n      source: this,\n      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n      value: color\n    });\n    this.updateColor(color);\n  }\n  _colorSelectFromKeyboard(event) {\n    if (event.target === this.#button) {\n      this.#openDropdown(event);\n      return;\n    }\n    const color = event.target.getAttribute(\"data-color\");\n    if (!color) {\n      return;\n    }\n    this.#colorSelect(color, event);\n  }\n  _moveToNext(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    if (event.target === this.#button) {\n      this.#dropdown.firstElementChild?.focus();\n      return;\n    }\n    event.target.nextSibling?.focus();\n  }\n  _moveToPrevious(event) {\n    if (event.target === this.#dropdown?.firstElementChild || event.target === this.#button) {\n      if (this.#isDropdownVisible) {\n        this._hideDropdownFromKeyboard();\n      }\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n    }\n    event.target.previousSibling?.focus();\n  }\n  _moveToBeginning(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.firstElementChild?.focus();\n  }\n  _moveToEnd(event) {\n    if (!this.#isDropdownVisible) {\n      this.#openDropdown(event);\n      return;\n    }\n    this.#dropdown.lastElementChild?.focus();\n  }\n  #keyDown(event) {\n    ColorPicker._keyboardManager.exec(this, event);\n  }\n  #openDropdown(event) {\n    if (this.#isDropdownVisible) {\n      this.hideDropdown();\n      return;\n    }\n    this.#dropdownWasFromKeyboard = event.detail === 0;\n    if (!this.#openDropdownAC) {\n      this.#openDropdownAC = new AbortController();\n      window.addEventListener(\"pointerdown\", this.#pointerDown.bind(this), {\n        signal: this.#uiManager.combinedSignal(this.#openDropdownAC)\n      });\n    }\n    this.#button.ariaExpanded = \"true\";\n    if (this.#dropdown) {\n      this.#dropdown.classList.remove(\"hidden\");\n      return;\n    }\n    const root = this.#dropdown = this.#getDropdownRoot();\n    this.#button.append(root);\n  }\n  #pointerDown(event) {\n    if (this.#dropdown?.contains(event.target)) {\n      return;\n    }\n    this.hideDropdown();\n  }\n  hideDropdown() {\n    this.#dropdown?.classList.add(\"hidden\");\n    this.#button.ariaExpanded = \"false\";\n    this.#openDropdownAC?.abort();\n    this.#openDropdownAC = null;\n  }\n  get #isDropdownVisible() {\n    return this.#dropdown && !this.#dropdown.classList.contains(\"hidden\");\n  }\n  _hideDropdownFromKeyboard() {\n    if (this.#isMainColorPicker) {\n      return;\n    }\n    if (!this.#isDropdownVisible) {\n      this.#editor?.unselect();\n      return;\n    }\n    this.hideDropdown();\n    this.#button.focus({\n      preventScroll: true,\n      focusVisible: this.#dropdownWasFromKeyboard\n    });\n  }\n  updateColor(color) {\n    if (this.#buttonSwatch) {\n      this.#buttonSwatch.style.backgroundColor = color;\n    }\n    if (!this.#dropdown) {\n      return;\n    }\n    const i = this.#uiManager.highlightColors.values();\n    for (const child of this.#dropdown.children) {\n      child.ariaSelected = i.next().value === color.toUpperCase();\n    }\n  }\n  destroy() {\n    this.#button?.remove();\n    this.#button = null;\n    this.#buttonSwatch = null;\n    this.#dropdown?.remove();\n    this.#dropdown = null;\n  }\n}\nclass BasicColorPicker {\n  #input = null;\n  #editor = null;\n  #uiManager = null;\n  static #l10nColor = null;\n  constructor(editor) {\n    this.#editor = editor;\n    this.#uiManager = editor._uiManager;\n    BasicColorPicker.#l10nColor ||= Object.freeze({\n      freetext: \"pdfjs-editor-color-picker-free-text-input\",\n      ink: \"pdfjs-editor-color-picker-ink-input\"\n    });\n  }\n  renderButton() {\n    if (this.#input) {\n      return this.#input;\n    }\n    const {\n      editorType,\n      colorType,\n      color\n    } = this.#editor;\n    const input = this.#input = document.createElement(\"input\");\n    input.type = \"color\";\n    input.value = color || \"#000000\";\n    input.className = \"basicColorPicker\";\n    input.tabIndex = 0;\n    input.setAttribute(\"data-l10n-id\", BasicColorPicker.#l10nColor[editorType]);\n    input.addEventListener(\"input\", () => {\n      this.#uiManager.updateParams(colorType, input.value);\n    }, {\n      signal: this.#uiManager._signal\n    });\n    return input;\n  }\n  update(value) {\n    if (!this.#input) {\n      return;\n    }\n    this.#input.value = value;\n  }\n  destroy() {\n    this.#input?.remove();\n    this.#input = null;\n  }\n  hideDropdown() {}\n}\n\n;// ./src/shared/scripting_utils.js\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n  return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n  static CMYK_G([c, y, m, k]) {\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n  static G_CMYK([g]) {\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n  static G_RGB([g]) {\n    return [\"RGB\", g, g, g];\n  }\n  static G_rgb([g]) {\n    g = scaleAndClamp(g);\n    return [g, g, g];\n  }\n  static G_HTML([g]) {\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n  static RGB_G([r, g, b]) {\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n  static RGB_rgb(color) {\n    return color.map(scaleAndClamp);\n  }\n  static RGB_HTML(color) {\n    return `#${color.map(makeColorComp).join(\"\")}`;\n  }\n  static T_HTML() {\n    return \"#00000000\";\n  }\n  static T_rgb() {\n    return [null];\n  }\n  static CMYK_RGB([c, y, m, k]) {\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n  static CMYK_rgb([c, y, m, k]) {\n    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];\n  }\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n  static RGB_CMYK([r, g, b]) {\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\nconst DateFormats = (/* unused pure expression or super */ null && (0));\nconst TimeFormats = (/* unused pure expression or super */ null && (0));\n\n;// ./src/display/svg_factory.js\n\n\nclass BaseSVGFactory {\n  create(width, height, skipDimensions = false) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n  _createSVG(type) {\n    unreachable(\"Abstract method `_createSVG` called.\");\n  }\n}\nclass DOMSVGFactory extends BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\n\n;// ./src/display/annotation_layer.js\n\n\n\n\n\nconst annotation_layer_DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nconst TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n    switch (subtype) {\n      case AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n      case AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n      case AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n      case AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n      case AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n      case AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n      case AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n      case AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n      case AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n      case AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n      case AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n      case AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n      case AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n      case AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n      case AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n      case AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n      case AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n      case AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\nclass AnnotationElement {\n  #updates = null;\n  #hasBorder = false;\n  #popupElement = null;\n  constructor(parameters, {\n    isRenderable = false,\n    ignoreBorder = false,\n    createQuadrilaterals = false\n  } = {}) {\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableComment = parameters.enableComment;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this.parent = parameters.parent;\n    this.hasOwnCommentButton = false;\n    if (isRenderable) {\n      this.contentElement = this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this._createQuadrilaterals();\n    }\n  }\n  static _hasPopupData({\n    contentsObj,\n    richText\n  }) {\n    return !!(contentsObj?.str || richText?.str);\n  }\n  get _isEditable() {\n    return this.data.isEditable;\n  }\n  get hasPopupData() {\n    return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;\n  }\n  get commentData() {\n    const {\n      data\n    } = this;\n    const editor = this.annotationStorage?.getEditor(data.id);\n    if (editor) {\n      return editor.getData();\n    }\n    return data;\n  }\n  get hasCommentButton() {\n    return this.enableComment && this.hasPopupElement;\n  }\n  get commentButtonPosition() {\n    const editor = this.annotationStorage?.getEditor(this.data.id);\n    if (editor) {\n      return editor.commentButtonPositionInPage;\n    }\n    const {\n      quadPoints,\n      inkLists,\n      rect\n    } = this.data;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    if (quadPoints?.length >= 8) {\n      for (let i = 0; i < quadPoints.length; i += 8) {\n        if (quadPoints[i + 1] > maxY) {\n          maxY = quadPoints[i + 1];\n          maxX = quadPoints[i + 2];\n        } else if (quadPoints[i + 1] === maxY) {\n          maxX = Math.max(maxX, quadPoints[i + 2]);\n        }\n      }\n      return [maxX, maxY];\n    }\n    if (inkLists?.length >= 1) {\n      for (const inkList of inkLists) {\n        for (let i = 0, ii = inkList.length; i < ii; i += 2) {\n          if (inkList[i + 1] > maxY) {\n            maxY = inkList[i + 1];\n            maxX = inkList[i];\n          } else if (inkList[i + 1] === maxY) {\n            maxX = Math.max(maxX, inkList[i]);\n          }\n        }\n      }\n      if (maxX !== Infinity) {\n        return [maxX, maxY];\n      }\n    }\n    if (rect) {\n      return [rect[2], rect[3]];\n    }\n    return null;\n  }\n  _normalizePoint(point) {\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.parent;\n    point[1] = view[3] - point[1] + view[1];\n    point[0] = 100 * (point[0] - pageX) / pageWidth;\n    point[1] = 100 * (point[1] - pageY) / pageHeight;\n    return point;\n  }\n  get commentText() {\n    const {\n      data\n    } = this;\n    return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || \"\";\n  }\n  set commentText(text) {\n    const {\n      data\n    } = this;\n    const popup = {\n      deleted: !text,\n      contents: text || \"\"\n    };\n    if (!this.annotationStorage.updateEditor(data.id, {\n      popup\n    })) {\n      this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {\n        id: data.id,\n        annotationType: data.annotationType,\n        pageIndex: this.parent.page._pageIndex,\n        popup,\n        popupRef: data.popupRef,\n        modificationDate: new Date()\n      });\n    }\n    if (!text) {\n      this.removePopup();\n    }\n  }\n  removePopup() {\n    (this.#popupElement?.popup || this.popup)?.remove();\n    this.#popupElement = this.popup = null;\n  }\n  updateEdited(params) {\n    if (!this.container) {\n      return;\n    }\n    if (params.rect) {\n      this.#updates ||= {\n        rect: this.data.rect.slice(0)\n      };\n    }\n    const {\n      rect,\n      popup: newPopup\n    } = params;\n    if (rect) {\n      this.#setRectEdited(rect);\n    }\n    let popup = this.#popupElement?.popup || this.popup;\n    if (!popup && newPopup?.text) {\n      this._createPopup(newPopup);\n      popup = this.#popupElement.popup;\n    }\n    if (!popup) {\n      return;\n    }\n    popup.updateEdited(params);\n    if (newPopup?.deleted) {\n      popup.remove();\n      this.#popupElement = null;\n      this.popup = null;\n    }\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    this.#setRectEdited(this.#updates.rect);\n    this.#popupElement?.popup.resetEdited();\n    this.#updates = null;\n  }\n  #setRectEdited(rect) {\n    const {\n      container: {\n        style\n      },\n      data: {\n        rect: currentRect,\n        rotation\n      },\n      parent: {\n        viewport: {\n          rawDims: {\n            pageWidth,\n            pageHeight,\n            pageX,\n            pageY\n          }\n        }\n      }\n    } = this;\n    currentRect?.splice(0, 4, ...rect);\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;\n    if (rotation === 0) {\n      style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;\n      style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;\n    } else {\n      this.setRotation(rotation);\n    }\n  }\n  _createContainer(ignoreBorder) {\n    const {\n      data,\n      parent: {\n        page,\n        viewport\n      }\n    } = this;\n    const container = document.createElement(\"section\");\n    container.setAttribute(\"data-annotation-id\", data.id);\n    if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {\n      container.tabIndex = 0;\n    }\n    const {\n      style\n    } = container;\n    style.zIndex = this.parent.zIndex;\n    this.parent.zIndex += 2;\n    if (data.alternativeText) {\n      container.title = data.alternativeText;\n    }\n    if (data.noRotate) {\n      container.classList.add(\"norotate\");\n    }\n    if (!data.rect || this instanceof PopupAnnotationElement) {\n      const {\n        rotation\n      } = data;\n      if (!data.hasOwnCanvas && rotation !== 0) {\n        this.setRotation(rotation, container);\n      }\n      return container;\n    }\n    const {\n      width,\n      height\n    } = this;\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;\n        style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;\n        style.borderRadius = radius;\n      }\n      switch (data.borderStyle.style) {\n        case AnnotationBorderStyleType.SOLID:\n          style.borderStyle = \"solid\";\n          break;\n        case AnnotationBorderStyleType.DASHED:\n          style.borderStyle = \"dashed\";\n          break;\n        case AnnotationBorderStyleType.BEVELED:\n          warn(\"Unimplemented border style: beveled\");\n          break;\n        case AnnotationBorderStyleType.INSET:\n          warn(\"Unimplemented border style: inset\");\n          break;\n        case AnnotationBorderStyleType.UNDERLINE:\n          style.borderBottomStyle = \"solid\";\n          break;\n        default:\n          break;\n      }\n      const borderColor = data.borderColor || null;\n      if (borderColor) {\n        this.#hasBorder = true;\n        style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        style.borderWidth = 0;\n      }\n    }\n    const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n    if (data.hasOwnCanvas || rotation === 0) {\n      style.width = `${100 * width / pageWidth}%`;\n      style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n    return container;\n  }\n  setRotation(angle, container = this.container) {\n    if (!this.data.rect) {\n      return;\n    }\n    const {\n      pageWidth,\n      pageHeight\n    } = this.parent.viewport.rawDims;\n    let {\n      width,\n      height\n    } = this;\n    if (angle % 180 !== 0) {\n      [width, height] = [height, width];\n    }\n    container.style.width = `${100 * width / pageWidth}%`;\n    container.style.height = `${100 * height / pageHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      const colorType = color[0];\n      const colorArray = color.slice(1);\n      event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);\n      this.annotationStorage.setValue(this.data.id, {\n        [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)\n      });\n    };\n    return shadow(this, \"_commonActions\", {\n      display: event => {\n        const {\n          display\n        } = event.detail;\n        const hidden = display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noView: hidden,\n          noPrint: display === 1 || display === 2\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: !event.detail.print\n        });\n      },\n      hidden: event => {\n        const {\n          hidden\n        } = event.detail;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: hidden,\n          noView: hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        event.target.disabled = event.detail.readonly;\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      action?.(jsEvent);\n    }\n  }\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n    if (!storedData) {\n      return;\n    }\n    const commonActions = this._commonActions;\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n  _createQuadrilaterals() {\n    if (!this.container) {\n      return;\n    }\n    const {\n      quadPoints\n    } = this.data;\n    if (!quadPoints) {\n      return;\n    }\n    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x => Math.fround(x));\n    if (quadPoints.length === 8) {\n      const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);\n      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n        return;\n      }\n    }\n    const {\n      style\n    } = this.container;\n    let svgBuffer;\n    if (this.#hasBorder) {\n      const {\n        borderColor,\n        borderWidth\n      } = style;\n      style.borderWidth = 0;\n      svgBuffer = [\"url('data:image/svg+xml;utf8,\", `<svg xmlns=\"http://www.w3.org/2000/svg\"`, ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`, `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`];\n      this.container.classList.add(\"hasBorder\");\n    }\n    const width = rectTrX - rectBlX;\n    const height = rectTrY - rectBlY;\n    const {\n      svgFactory\n    } = this;\n    const svg = svgFactory.createElement(\"svg\");\n    svg.classList.add(\"quadrilateralsContainer\");\n    svg.setAttribute(\"width\", 0);\n    svg.setAttribute(\"height\", 0);\n    svg.role = \"none\";\n    const defs = svgFactory.createElement(\"defs\");\n    svg.append(defs);\n    const clipPath = svgFactory.createElement(\"clipPath\");\n    const id = `clippath_${this.data.id}`;\n    clipPath.setAttribute(\"id\", id);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    defs.append(clipPath);\n    for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {\n      const trX = quadPoints[i];\n      const trY = quadPoints[i + 1];\n      const blX = quadPoints[i + 2];\n      const blY = quadPoints[i + 3];\n      const rect = svgFactory.createElement(\"rect\");\n      const x = (blX - rectBlX) / width;\n      const y = (rectTrY - trY) / height;\n      const rectWidth = (trX - blX) / width;\n      const rectHeight = (trY - blY) / height;\n      rect.setAttribute(\"x\", x);\n      rect.setAttribute(\"y\", y);\n      rect.setAttribute(\"width\", rectWidth);\n      rect.setAttribute(\"height\", rectHeight);\n      clipPath.append(rect);\n      svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n    }\n    if (this.#hasBorder) {\n      svgBuffer.push(`</g></svg>')`);\n      style.backgroundImage = svgBuffer.join(\"\");\n    }\n    this.container.append(svg);\n    this.container.style.clipPath = `url(#${id})`;\n  }\n  _createPopup(popupData = null) {\n    const {\n      data\n    } = this;\n    let contentsObj, modificationDate;\n    if (popupData) {\n      contentsObj = {\n        str: popupData.text\n      };\n      modificationDate = popupData.date;\n    } else {\n      contentsObj = data.contentsObj;\n      modificationDate = data.modificationDate;\n    }\n    this.#popupElement = new PopupAnnotationElement({\n      data: {\n        color: data.color,\n        titleObj: data.titleObj,\n        modificationDate,\n        contentsObj,\n        richText: data.richText,\n        parentRect: data.rect,\n        borderStyle: 0,\n        id: `popup_${data.id}`,\n        rotation: data.rotation,\n        noRotate: true\n      },\n      linkService: this.linkService,\n      parent: this.parent,\n      elements: [this]\n    });\n  }\n  get hasPopupElement() {\n    return !!(this.#popupElement || this.popup || this.data.popupRef);\n  }\n  get extraPopupElement() {\n    return this.#popupElement;\n  }\n  render() {\n    unreachable(\"Abstract method `AnnotationElement.render` called\");\n  }\n  _getElementsByName(name, skipId = null) {\n    const fields = [];\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            warn(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n      return fields;\n    }\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        exportValue\n      } = domElement;\n      const id = domElement.getAttribute(\"data-element-id\");\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n    return fields;\n  }\n  show() {\n    if (this.container) {\n      this.container.hidden = false;\n    }\n    this.popup?.maybeShow();\n  }\n  hide() {\n    if (this.container) {\n      this.container.hidden = true;\n    }\n    this.popup?.forceHide();\n  }\n  getElementsToTriggerPopup() {\n    return this.container;\n  }\n  addHighlightArea() {\n    const triggers = this.getElementsToTriggerPopup();\n    if (Array.isArray(triggers)) {\n      for (const element of triggers) {\n        element.classList.add(\"highlightArea\");\n      }\n    } else {\n      triggers.classList.add(\"highlightArea\");\n    }\n  }\n  _editOnDoubleClick() {\n    if (!this._isEditable) {\n      return;\n    }\n    const {\n      annotationEditorType: mode,\n      data: {\n        id: editId\n      }\n    } = this;\n    this.container.addEventListener(\"dblclick\", () => {\n      this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        mode,\n        editId,\n        mustEnterInEditMode: true\n      });\n    });\n  }\n  get width() {\n    return this.data.rect[2] - this.data.rect[0];\n  }\n  get height() {\n    return this.data.rect[3] - this.data.rect[1];\n  }\n}\nclass EditorAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.editor = parameters.editor;\n  }\n  render() {\n    this.container.className = \"editorAnnotation\";\n    return this.container;\n  }\n  createOrUpdatePopup() {\n    const {\n      editor\n    } = this;\n    if (!editor.hasComment) {\n      return;\n    }\n    this._createPopup(editor.comment);\n  }\n  get hasCommentButton() {\n    return this.enableComment && this.editor.hasComment;\n  }\n  get commentButtonPosition() {\n    return this.editor.commentButtonPositionInPage;\n  }\n  get commentText() {\n    return this.editor.comment.text;\n  }\n  set commentText(text) {\n    this.editor.comment = text;\n    if (!text) {\n      this.removePopup();\n    }\n  }\n  get commentData() {\n    return this.editor.getData();\n  }\n  remove() {\n    this.parent.removeAnnotation(this.data.id);\n    this.container.remove();\n    this.container = null;\n    this.removePopup();\n  }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters, options = null) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action, data.overlaidText);\n      isBound = true;\n    } else if (data.attachment) {\n      this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);\n      isBound = true;\n    } else if (data.setOCGState) {\n      this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest, data.overlaidText);\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n        isBound = true;\n      }\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n        isBound = true;\n      }\n    }\n    this.container.classList.add(\"linkAnnotation\");\n    if (isBound) {\n      this.contentElement = link;\n      this.container.append(link);\n    }\n    return this.container;\n  }\n  #setInternalLink() {\n    this.container.setAttribute(\"data-internal-link\", \"\");\n  }\n  _bindLink(link, destination, overlaidText = \"\") {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === \"\") {\n      this.#setInternalLink();\n    }\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n  }\n  _bindNamedAction(link, action, overlaidText = \"\") {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n    this.#setInternalLink();\n  }\n  #bindAttachment(link, attachment, overlaidText = \"\", dest = null) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    if (attachment.description) {\n      link.title = attachment.description;\n    } else if (overlaidText) {\n      link.title = overlaidText;\n    }\n    link.onclick = () => {\n      this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindSetOCGState(link, action, overlaidText = \"\") {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeSetOCGState(action);\n      return false;\n    };\n    if (overlaidText) {\n      link.title = overlaidText;\n    }\n    this.#setInternalLink();\n  }\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n    if (data.overlaidText) {\n      link.title = data.overlaidText;\n    }\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    this.#setInternalLink();\n  }\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    this.#setInternalLink();\n    if (!this._fieldObjects) {\n      warn(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n    link.onclick = () => {\n      otherClickAction?.();\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          default:\n            continue;\n        }\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          warn(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n      return false;\n    };\n  }\n}\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"textAnnotation\");\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.setAttribute(\"data-l10n-id\", \"pdfjs-text-annotation-type\");\n    image.setAttribute(\"data-l10n-args\", JSON.stringify({\n      type: this.data.name\n    }));\n    if (!this.data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.append(image);\n    return this.container;\n  }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    return this.container;\n  }\n  showElementAndHideCanvas(element) {\n    if (this.data.hasOwnCanvas) {\n      if (element.previousSibling?.nodeName === \"CANVAS\") {\n        element.previousSibling.hidden = true;\n      }\n      element.hidden = false;\n    }\n  }\n  _getKeyModifier(event) {\n    return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;\n  }\n  _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        if (baseName === \"blur\") {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n        } else if (baseName === \"focus\") {\n          if (elementData.focused) {\n            return;\n          }\n          elementData.focused = true;\n        }\n        if (!valueGetter) {\n          return;\n        }\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n  _setEventListeners(element, elementData, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        if (eventName === \"Focus\" || eventName === \"Blur\") {\n          elementData ||= {\n            focused: false\n          };\n        }\n        this._setEventListener(element, elementData, baseName, eventName, getter);\n        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n          this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n          this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n        }\n      }\n    }\n  }\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : Util.makeHexColor(color[0], color[1], color[2]);\n  }\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n    const BORDER_SIZE = 2;\n    const roundToOneDecimal = x => Math.round(10 * x) / 10;\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));\n    }\n    style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;\n    style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.classList.add(\"textWidgetAnnotation\");\n    let element = null;\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n      if (fieldFormattedValues && this.data.comb) {\n        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n      }\n      const elementData = {\n        userValue: textContent,\n        formattedValue: fieldFormattedValues,\n        lastCommittedValue: null,\n        commitKey: 1,\n        focused: false\n      };\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = fieldFormattedValues ?? textContent;\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = this.data.password ? \"password\" : \"text\";\n        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n      GetElementsByNameSet.add(element);\n      this.contentElement = element;\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = 0;\n      const {\n        datetimeFormat,\n        datetimeType,\n        timeStep\n      } = this.data;\n      const hasDateOrTime = !!datetimeType && this.enableScripting;\n      if (datetimeFormat) {\n        element.title = datetimeFormat;\n      }\n      this._setRequired(element, this.data.required);\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n        elementData.formattedValue = null;\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n        event.target.scrollLeft = 0;\n      };\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.focused) {\n            return;\n          }\n          const {\n            target\n          } = event;\n          if (hasDateOrTime) {\n            target.type = datetimeType;\n            if (timeStep) {\n              target.step = timeStep;\n            }\n          }\n          if (elementData.userValue) {\n            const value = elementData.userValue;\n            if (hasDateOrTime) {\n              if (datetimeType === \"time\") {\n                const date = new Date(value);\n                const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];\n                target.value = parts.map(v => v.toString().padStart(2, \"0\")).join(\":\");\n              } else {\n                target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === \"date\" ? \"T\" : \".\", 1)[0];\n              }\n            } else {\n              target.value = value;\n            }\n          }\n          elementData.lastCommittedValue = target.value;\n          elementData.commitKey = 1;\n          if (!this.data.actions?.Focus) {\n            elementData.focused = true;\n          }\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          this.showElementAndHideCanvas(jsEvent.target);\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              if (!hasDateOrTime) {\n                storage.setValue(id, {\n                  value: elementData.userValue.toString()\n                });\n              }\n              event.target.value = elementData.userValue;\n            },\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n              const data = {\n                formattedValue\n              };\n              if (hasDateOrTime) {\n                data.value = formattedValue;\n              }\n              storage.setValue(id, data);\n            },\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.commitKey = 1;\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\" && !this.data.multiLine) {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            elementData.commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          const {\n            value\n          } = event.target;\n          if (elementData.lastCommittedValue === value) {\n            return;\n          }\n          elementData.lastCommittedValue = value;\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          if (!this.data.actions?.Blur) {\n            elementData.focused = false;\n          }\n          const {\n            target\n          } = event;\n          let {\n            value\n          } = target;\n          if (hasDateOrTime) {\n            if (value && datetimeType === \"time\") {\n              const parts = value.split(\":\").map(v => parseInt(v, 10));\n              value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();\n              target.step = \"\";\n            } else {\n              if (!value.includes(\"T\")) {\n                value = `${value}T00:00`;\n              }\n              value = new Date(value).valueOf();\n            }\n            target.type = \"text\";\n          }\n          elementData.userValue = value;\n          if (elementData.lastCommittedValue !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: elementData.commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n          _blurListener(event);\n        });\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.lastCommittedValue = null;\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n              selEnd = selectionEnd;\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n                break;\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n                break;\n            }\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n        this._setEventListeners(element, elementData, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n    }\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: !!parameters.data.hasOwnCanvas\n    });\n  }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = 0;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n    if (value) {\n      for (const radio of this._getElementsByName(data.fieldName, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n    }\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.tabIndex = 0;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n  render() {\n    const container = super.render();\n    container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n    const linkElement = container.lastChild;\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n    return container;\n  }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"choiceWidgetAnnotation\");\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n    this._setRequired(selectElement, this.data.required);\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = 0;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n      selectElement.append(optionElement);\n    }\n    let removeEmptyEntry = null;\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n    const getValue = isExport => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const {\n        options,\n        multiple\n      } = selectElement;\n      if (!multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n    let selectedValues = getValue(false);\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => ({\n        displayValue: option.textContent,\n        exportValue: option.value\n      }));\n    };\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n            selectedValues = getValue(false);\n          },\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          items(event) {\n            const {\n              items\n            } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(true);\n        const change = getValue(false);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        event.preventDefault();\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value: selectedValues,\n            change,\n            changeEx: exportValue,\n            willCommit: false,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n      this._setEventListeners(selectElement, null, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], event => event.target.value);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(true)\n        });\n      });\n    }\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n    this._setBackgroundColor(selectElement);\n    this._setDefaultPropertiesFromJS(selectElement);\n    this.container.append(selectElement);\n    return this.container;\n  }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const {\n      data,\n      elements,\n      parent\n    } = parameters;\n    const hasCommentManager = !!parent._commentManager;\n    super(parameters, {\n      isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)\n    });\n    this.elements = elements;\n    if (hasCommentManager && AnnotationElement._hasPopupData(data)) {\n      const popup = this.popup = this.#createPopup();\n      for (const element of elements) {\n        element.popup = popup;\n      }\n    } else {\n      this.popup = null;\n    }\n  }\n  #createPopup() {\n    return new PopupElement({\n      container: this.container,\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate || this.data.creationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n      rect: this.data.rect,\n      parentRect: this.data.parentRect || null,\n      parent: this.parent,\n      elements: this.elements,\n      open: this.data.open,\n      commentManager: this.parent._commentManager\n    });\n  }\n  render() {\n    const {\n      container\n    } = this;\n    container.classList.add(\"popupAnnotation\");\n    container.role = \"comment\";\n    const popup = this.popup = this.#createPopup();\n    const elementIds = [];\n    for (const element of this.elements) {\n      element.popup = popup;\n      element.container.ariaHasPopup = \"dialog\";\n      elementIds.push(element.data.id);\n      element.addHighlightArea();\n    }\n    this.container.setAttribute(\"aria-controls\", elementIds.map(id => `${AnnotationPrefix}${id}`).join(\",\"));\n    return this.container;\n  }\n}\nclass PopupElement {\n  #commentManager = null;\n  #boundKeyDown = this.#keyDown.bind(this);\n  #boundHide = this.#hide.bind(this);\n  #boundShow = this.#show.bind(this);\n  #boundToggle = this.#toggle.bind(this);\n  #color = null;\n  #container = null;\n  #contentsObj = null;\n  #dateObj = null;\n  #elements = null;\n  #parent = null;\n  #parentRect = null;\n  #pinned = false;\n  #popup = null;\n  #popupAbortController = null;\n  #position = null;\n  #commentButton = null;\n  #commentButtonPosition = null;\n  #popupPosition = null;\n  #rect = null;\n  #richText = null;\n  #titleObj = null;\n  #updates = null;\n  #wasVisible = false;\n  #firstElement = null;\n  #commentText = null;\n  constructor({\n    container,\n    color,\n    elements,\n    titleObj,\n    modificationDate,\n    contentsObj,\n    richText,\n    parent,\n    rect,\n    parentRect,\n    open,\n    commentManager = null\n  }) {\n    this.#container = container;\n    this.#titleObj = titleObj;\n    this.#contentsObj = contentsObj;\n    this.#richText = richText;\n    this.#parent = parent;\n    this.#color = color;\n    this.#rect = rect;\n    this.#parentRect = parentRect;\n    this.#elements = elements;\n    this.#commentManager = commentManager;\n    this.#firstElement = elements[0];\n    this.#dateObj = PDFDateString.toDateObject(modificationDate);\n    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());\n    if (!commentManager) {\n      this.#addEventListeners();\n      this.#container.hidden = true;\n      if (open) {\n        this.#toggle();\n      }\n    }\n  }\n  #addEventListeners() {\n    if (this.#popupAbortController) {\n      return;\n    }\n    this.#popupAbortController = new AbortController();\n    const {\n      signal\n    } = this.#popupAbortController;\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this.#boundToggle, {\n        signal\n      });\n      element.addEventListener(\"pointerenter\", this.#boundShow, {\n        signal\n      });\n      element.addEventListener(\"pointerleave\", this.#boundHide, {\n        signal\n      });\n      element.classList.add(\"popupTriggerArea\");\n    }\n    for (const element of this.#elements) {\n      element.container?.addEventListener(\"keydown\", this.#boundKeyDown, {\n        signal\n      });\n    }\n  }\n  #setCommentButtonPosition() {\n    const element = this.#elements.find(e => e.hasCommentButton);\n    if (!element) {\n      return;\n    }\n    this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);\n  }\n  renderCommentButton() {\n    if (this.#commentButton) {\n      if (!this.#commentButton.parentNode) {\n        this.#firstElement.container.after(this.#commentButton);\n      }\n      return;\n    }\n    if (!this.#commentButtonPosition) {\n      this.#setCommentButtonPosition();\n    }\n    if (!this.#commentButtonPosition) {\n      return;\n    }\n    const {\n      signal\n    } = this.#popupAbortController = new AbortController();\n    const hasOwnButton = this.#firstElement.hasOwnCommentButton;\n    const togglePopup = () => {\n      this.#commentManager.toggleCommentPopup(this, true, undefined, !hasOwnButton);\n    };\n    const showPopup = () => {\n      this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);\n    };\n    const hidePopup = () => {\n      this.#commentManager.toggleCommentPopup(this, false, false);\n    };\n    if (!hasOwnButton) {\n      const button = this.#commentButton = document.createElement(\"button\");\n      button.className = \"annotationCommentButton\";\n      const parentContainer = this.#firstElement.container;\n      button.style.zIndex = parentContainer.style.zIndex + 1;\n      button.tabIndex = 0;\n      button.ariaHasPopup = \"dialog\";\n      button.ariaControls = \"commentPopup\";\n      button.setAttribute(\"data-l10n-id\", \"pdfjs-show-comment-button\");\n      this.#updateColor();\n      this.#updateCommentButtonPosition();\n      button.addEventListener(\"keydown\", this.#boundKeyDown, {\n        signal\n      });\n      button.addEventListener(\"click\", togglePopup, {\n        signal\n      });\n      button.addEventListener(\"pointerenter\", showPopup, {\n        signal\n      });\n      button.addEventListener(\"pointerleave\", hidePopup, {\n        signal\n      });\n      parentContainer.after(button);\n    } else {\n      this.#commentButton = this.#firstElement.container;\n      for (const element of this.trigger) {\n        element.ariaHasPopup = \"dialog\";\n        element.ariaControls = \"commentPopup\";\n        element.addEventListener(\"keydown\", this.#boundKeyDown, {\n          signal\n        });\n        element.addEventListener(\"click\", togglePopup, {\n          signal\n        });\n        element.addEventListener(\"pointerenter\", showPopup, {\n          signal\n        });\n        element.addEventListener(\"pointerleave\", hidePopup, {\n          signal\n        });\n        element.classList.add(\"popupTriggerArea\");\n      }\n    }\n  }\n  #updateCommentButtonPosition() {\n    if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {\n      return;\n    }\n    if (!this.#commentButton) {\n      this.renderCommentButton();\n    }\n    const [x, y] = this.#commentButtonPosition;\n    const {\n      style\n    } = this.#commentButton;\n    style.left = `calc(${x}%)`;\n    style.top = `calc(${y}% - var(--comment-button-dim))`;\n  }\n  #updateColor() {\n    if (this.#firstElement.extraPopupElement) {\n      return;\n    }\n    if (!this.#commentButton) {\n      this.renderCommentButton();\n    }\n    this.#commentButton.style.backgroundColor = this.commentButtonColor || \"\";\n  }\n  get commentButtonColor() {\n    const {\n      color,\n      opacity\n    } = this.#firstElement.commentData;\n    if (!color) {\n      return null;\n    }\n    return this.#parent._commentManager.makeCommentColor(color, opacity);\n  }\n  focusCommentButton() {\n    setTimeout(() => {\n      this.#commentButton?.focus();\n    }, 0);\n  }\n  getData() {\n    const {\n      richText,\n      color,\n      opacity,\n      creationDate,\n      modificationDate\n    } = this.#firstElement.commentData;\n    return {\n      contentsObj: {\n        str: this.comment\n      },\n      richText,\n      color,\n      opacity,\n      creationDate,\n      modificationDate\n    };\n  }\n  get elementBeforePopup() {\n    return this.#commentButton;\n  }\n  get comment() {\n    this.#commentText ||= this.#firstElement.commentText;\n    return this.#commentText;\n  }\n  set comment(text) {\n    if (text === this.comment) {\n      return;\n    }\n    this.#firstElement.commentText = this.#commentText = text;\n  }\n  focus() {\n    this.#firstElement.container?.focus();\n  }\n  get parentBoundingClientRect() {\n    return this.#firstElement.layer.getBoundingClientRect();\n  }\n  setCommentButtonStates({\n    selected,\n    hasPopup\n  }) {\n    if (!this.#commentButton) {\n      return;\n    }\n    this.#commentButton.classList.toggle(\"selected\", selected);\n    this.#commentButton.ariaExpanded = hasPopup;\n  }\n  setSelectedCommentButton(selected) {\n    this.#commentButton.classList.toggle(\"selected\", selected);\n  }\n  get commentPopupPosition() {\n    if (this.#popupPosition) {\n      return this.#popupPosition;\n    }\n    const {\n      x,\n      y,\n      height\n    } = this.#commentButton.getBoundingClientRect();\n    const {\n      x: parentX,\n      y: parentY,\n      width: parentWidth,\n      height: parentHeight\n    } = this.#firstElement.layer.getBoundingClientRect();\n    return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];\n  }\n  set commentPopupPosition(pos) {\n    this.#popupPosition = pos;\n  }\n  hasDefaultPopupPosition() {\n    return this.#popupPosition === null;\n  }\n  get commentButtonPosition() {\n    return this.#commentButtonPosition;\n  }\n  get commentButtonWidth() {\n    return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;\n  }\n  editComment(options) {\n    const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map(x => x / 100);\n    const parentDimensions = this.parentBoundingClientRect;\n    const {\n      x: parentX,\n      y: parentY,\n      width: parentWidth,\n      height: parentHeight\n    } = parentDimensions;\n    this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {\n      ...options,\n      parentDimensions\n    });\n  }\n  render() {\n    if (this.#popup) {\n      return;\n    }\n    const popup = this.#popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    if (this.#color) {\n      const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);\n      popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n    }\n    const header = document.createElement(\"span\");\n    header.className = \"header\";\n    if (this.#titleObj?.str) {\n      const title = document.createElement(\"span\");\n      title.className = \"title\";\n      header.append(title);\n      ({\n        dir: title.dir,\n        str: title.textContent\n      } = this.#titleObj);\n    }\n    popup.append(header);\n    if (this.#dateObj) {\n      const modificationDate = document.createElement(\"time\");\n      modificationDate.className = \"popupDate\";\n      modificationDate.setAttribute(\"data-l10n-id\", \"pdfjs-annotation-date-time-string\");\n      modificationDate.setAttribute(\"data-l10n-args\", JSON.stringify({\n        dateObj: this.#dateObj.valueOf()\n      }));\n      modificationDate.dateTime = this.#dateObj.toISOString();\n      header.append(modificationDate);\n    }\n    renderRichText({\n      html: this.#html || this.#contentsObj.str,\n      dir: this.#contentsObj?.dir,\n      className: \"popupContent\"\n    }, popup);\n    this.#container.append(popup);\n  }\n  get #html() {\n    const richText = this.#richText;\n    const contentsObj = this.#contentsObj;\n    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n      return this.#richText.html || null;\n    }\n    return null;\n  }\n  get #fontSize() {\n    return this.#html?.attributes?.style?.fontSize || 0;\n  }\n  get #fontColor() {\n    return this.#html?.attributes?.style?.color || null;\n  }\n  #makePopupContent(text) {\n    const popupLines = [];\n    const popupContent = {\n      str: text,\n      html: {\n        name: \"div\",\n        attributes: {\n          dir: \"auto\"\n        },\n        children: [{\n          name: \"p\",\n          children: popupLines\n        }]\n      }\n    };\n    const lineAttributes = {\n      style: {\n        color: this.#fontColor,\n        fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : \"\"\n      }\n    };\n    for (const line of text.split(\"\\n\")) {\n      popupLines.push({\n        name: \"span\",\n        value: line,\n        attributes: lineAttributes\n      });\n    }\n    return popupContent;\n  }\n  #keyDown(event) {\n    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n    if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n      this.#toggle();\n    }\n  }\n  updateEdited({\n    rect,\n    popup,\n    deleted\n  }) {\n    if (this.#commentManager) {\n      if (deleted) {\n        this.remove();\n        this.#commentText = null;\n      } else if (popup) {\n        if (popup.deleted) {\n          this.remove();\n        } else {\n          this.#updateColor();\n          this.#commentText = popup.text;\n        }\n      }\n      if (rect) {\n        this.#commentButtonPosition = null;\n        this.#setCommentButtonPosition();\n        this.#updateCommentButtonPosition();\n      }\n      return;\n    }\n    if (deleted || popup?.deleted) {\n      this.remove();\n      return;\n    }\n    this.#addEventListeners();\n    this.#updates ||= {\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    };\n    if (rect) {\n      this.#position = null;\n    }\n    if (popup && popup.text) {\n      this.#richText = this.#makePopupContent(popup.text);\n      this.#dateObj = PDFDateString.toDateObject(popup.date);\n      this.#contentsObj = null;\n    }\n    this.#popup?.remove();\n    this.#popup = null;\n  }\n  resetEdited() {\n    if (!this.#updates) {\n      return;\n    }\n    ({\n      contentsObj: this.#contentsObj,\n      richText: this.#richText\n    } = this.#updates);\n    this.#updates = null;\n    this.#popup?.remove();\n    this.#popup = null;\n    this.#position = null;\n  }\n  remove() {\n    this.#popupAbortController?.abort();\n    this.#popupAbortController = null;\n    this.#popup?.remove();\n    this.#popup = null;\n    this.#wasVisible = false;\n    this.#pinned = false;\n    this.#commentButton?.remove();\n    this.#commentButton = null;\n    if (this.trigger) {\n      for (const element of this.trigger) {\n        element.classList.remove(\"popupTriggerArea\");\n      }\n    }\n  }\n  #setPosition() {\n    if (this.#position !== null) {\n      return;\n    }\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.#parent;\n    let useParentRect = !!this.#parentRect;\n    let rect = useParentRect ? this.#parentRect : this.#rect;\n    for (const element of this.#elements) {\n      if (!rect || Util.intersect(element.data.rect, rect) !== null) {\n        rect = element.data.rect;\n        useParentRect = true;\n        break;\n      }\n    }\n    const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);\n    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n    const popupLeft = normalizedRect[0] + parentWidth;\n    const popupTop = normalizedRect[1];\n    this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];\n    const {\n      style\n    } = this.#container;\n    style.left = `${this.#position[0]}%`;\n    style.top = `${this.#position[1]}%`;\n  }\n  #toggle() {\n    if (this.#commentManager) {\n      this.#commentManager.toggleCommentPopup(this, false);\n      return;\n    }\n    this.#pinned = !this.#pinned;\n    if (this.#pinned) {\n      this.#show();\n      this.#container.addEventListener(\"click\", this.#boundToggle);\n      this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n    } else {\n      this.#hide();\n      this.#container.removeEventListener(\"click\", this.#boundToggle);\n      this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n    }\n  }\n  #show() {\n    if (!this.#popup) {\n      this.render();\n    }\n    if (!this.isVisible) {\n      this.#setPosition();\n      this.#container.hidden = false;\n      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n    } else if (this.#pinned) {\n      this.#container.classList.add(\"focused\");\n    }\n  }\n  #hide() {\n    this.#container.classList.remove(\"focused\");\n    if (this.#pinned || !this.isVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n  }\n  forceHide() {\n    this.#wasVisible = this.isVisible;\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n  }\n  maybeShow() {\n    if (this.#commentManager) {\n      return;\n    }\n    this.#addEventListeners();\n    if (!this.#wasVisible) {\n      return;\n    }\n    if (!this.#popup) {\n      this.#show();\n    }\n    this.#wasVisible = false;\n    this.#container.hidden = false;\n  }\n  get isVisible() {\n    if (this.#commentManager) {\n      return false;\n    }\n    return this.#container.hidden === false;\n  }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n    this.textPosition = parameters.data.textPosition;\n    this.annotationEditorType = AnnotationEditorType.FREETEXT;\n  }\n  render() {\n    this.container.classList.add(\"freeTextAnnotation\");\n    if (this.textContent) {\n      const content = this.contentElement = document.createElement(\"div\");\n      content.classList.add(\"annotationTextContent\");\n      content.setAttribute(\"role\", \"comment\");\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n      this.container.append(content);\n    }\n    if (!this.data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass LineAnnotationElement extends AnnotationElement {\n  #line = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"lineAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#line;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n  #square = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"squareAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#square;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n  #circle = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"circleAnnotation\");\n    const {\n      data,\n      width,\n      height\n    } = this;\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#circle;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n  #polyline = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        vertices,\n        borderStyle,\n        popupRef\n      },\n      width,\n      height\n    } = this;\n    if (!vertices) {\n      return this.container;\n    }\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n    for (let i = 0, ii = vertices.length; i < ii; i += 2) {\n      const x = vertices[i] - rect[0];\n      const y = rect[3] - vertices[i + 1];\n      points.push(`${x},${y}`);\n    }\n    points = points.join(\" \");\n    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polyline;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"caretAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nclass InkAnnotationElement extends AnnotationElement {\n  #polylinesGroupElement = null;\n  #polylines = [];\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n    this.annotationEditorType = this.data.it === \"InkHighlight\" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;\n  }\n  #getTransform(rotation, rect) {\n    switch (rotation) {\n      case 90:\n        return {\n          transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,\n          width: rect[3] - rect[1],\n          height: rect[2] - rect[0]\n        };\n      case 180:\n        return {\n          transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,\n          width: rect[2] - rect[0],\n          height: rect[3] - rect[1]\n        };\n      case 270:\n        return {\n          transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,\n          width: rect[3] - rect[1],\n          height: rect[2] - rect[0]\n        };\n      default:\n        return {\n          transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,\n          width: rect[2] - rect[0],\n          height: rect[3] - rect[1]\n        };\n    }\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const {\n      data: {\n        rect,\n        rotation,\n        inkLists,\n        borderStyle,\n        popupRef\n      }\n    } = this;\n    const {\n      transform,\n      width,\n      height\n    } = this.#getTransform(rotation, rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const g = this.#polylinesGroupElement = this.svgFactory.createElement(\"svg:g\");\n    svg.append(g);\n    g.setAttribute(\"stroke-width\", borderStyle.width || 1);\n    g.setAttribute(\"stroke-linecap\", \"round\");\n    g.setAttribute(\"stroke-linejoin\", \"round\");\n    g.setAttribute(\"stroke-miterlimit\", 10);\n    g.setAttribute(\"stroke\", \"transparent\");\n    g.setAttribute(\"fill\", \"transparent\");\n    g.setAttribute(\"transform\", transform);\n    for (let i = 0, ii = inkLists.length; i < ii; i++) {\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      this.#polylines.push(polyline);\n      polyline.setAttribute(\"points\", inkLists[i].join(\",\"));\n      g.append(polyline);\n    }\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.append(svg);\n    this._editOnDoubleClick();\n    return this.container;\n  }\n  updateEdited(params) {\n    super.updateEdited(params);\n    const {\n      thickness,\n      points,\n      rect\n    } = params;\n    const g = this.#polylinesGroupElement;\n    if (thickness >= 0) {\n      g.setAttribute(\"stroke-width\", thickness || 1);\n    }\n    if (points) {\n      for (let i = 0, ii = this.#polylines.length; i < ii; i++) {\n        this.#polylines[i].setAttribute(\"points\", points[i].join(\",\"));\n      }\n    }\n    if (rect) {\n      const {\n        transform,\n        width,\n        height\n      } = this.#getTransform(this.data.rotation, rect);\n      const root = g.parentElement;\n      root.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n      g.setAttribute(\"transform\", transform);\n    }\n  }\n  getElementsToTriggerPopup() {\n    return this.#polylines;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n    this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.classList.add(\"highlightAnnotation\");\n    this._editOnDoubleClick();\n    if (overlaidText) {\n      const mark = document.createElement(\"mark\");\n      mark.classList.add(\"overlaidText\");\n      mark.textContent = overlaidText;\n      this.container.append(mark);\n    }\n    return this.container;\n  }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.classList.add(\"underlineAnnotation\");\n    if (overlaidText) {\n      const underline = document.createElement(\"u\");\n      underline.classList.add(\"overlaidText\");\n      underline.textContent = overlaidText;\n      this.container.append(underline);\n    }\n    return this.container;\n  }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.classList.add(\"squigglyAnnotation\");\n    if (overlaidText) {\n      const underline = document.createElement(\"u\");\n      underline.classList.add(\"overlaidText\");\n      underline.textContent = overlaidText;\n      this.container.append(underline);\n    }\n    return this.container;\n  }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    const {\n      data: {\n        overlaidText,\n        popupRef\n      }\n    } = this;\n    if (!popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this.container.classList.add(\"strikeoutAnnotation\");\n    if (overlaidText) {\n      const strikeout = document.createElement(\"s\");\n      strikeout.classList.add(\"overlaidText\");\n      strikeout.textContent = overlaidText;\n      this.container.append(strikeout);\n    }\n    return this.container;\n  }\n}\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.annotationEditorType = AnnotationEditorType.STAMP;\n  }\n  render() {\n    this.container.classList.add(\"stampAnnotation\");\n    this.container.setAttribute(\"role\", \"img\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  #trigger = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      file\n    } = this.data;\n    this.filename = file.filename;\n    this.content = file.content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      ...file\n    });\n  }\n  render() {\n    this.container.classList.add(\"fileAttachmentAnnotation\");\n    const {\n      container,\n      data\n    } = this;\n    let trigger;\n    if (data.hasAppearance || data.fillAlpha === 0) {\n      trigger = document.createElement(\"div\");\n    } else {\n      trigger = document.createElement(\"img\");\n      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n      if (data.fillAlpha && data.fillAlpha < 1) {\n        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n      }\n    }\n    trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n    this.#trigger = trigger;\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    container.addEventListener(\"keydown\", evt => {\n      if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n        this.#download();\n      }\n    });\n    if (!data.popupRef && this.hasPopupData) {\n      this.hasOwnCommentButton = true;\n      this._createPopup();\n    } else {\n      trigger.classList.add(\"popupTriggerArea\");\n    }\n    container.append(trigger);\n    return container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#trigger;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  #download() {\n    this.downloadManager?.openOrDownloadData(this.content, this.filename);\n  }\n}\nclass AnnotationLayer {\n  #accessibilityManager = null;\n  #annotationCanvasMap = null;\n  #annotationStorage = null;\n  #editableAnnotations = new Map();\n  #structTreeLayer = null;\n  #linkService = null;\n  #elements = [];\n  #hasAriaAttributesFromStructTree = false;\n  constructor({\n    div,\n    accessibilityManager,\n    annotationCanvasMap,\n    annotationEditorUIManager,\n    page,\n    viewport,\n    structTreeLayer,\n    commentManager,\n    linkService,\n    annotationStorage\n  }) {\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationCanvasMap = annotationCanvasMap;\n    this.#structTreeLayer = structTreeLayer || null;\n    this.#linkService = linkService || null;\n    this.#annotationStorage = annotationStorage || new AnnotationStorage();\n    this.page = page;\n    this.viewport = viewport;\n    this.zIndex = 0;\n    this._annotationEditorUIManager = annotationEditorUIManager;\n    this._commentManager = commentManager || null;\n  }\n  hasEditableAnnotations() {\n    return this.#editableAnnotations.size > 0;\n  }\n  async render(params) {\n    const {\n      annotations\n    } = params;\n    const layer = this.div;\n    setLayerDimensions(layer, this.viewport);\n    const popupToElements = new Map();\n    const popupAnnotations = [];\n    const elementParams = {\n      data: null,\n      layer,\n      linkService: this.#linkService,\n      downloadManager: params.downloadManager,\n      imageResourcesPath: params.imageResourcesPath || \"\",\n      renderForms: params.renderForms !== false,\n      svgFactory: new DOMSVGFactory(),\n      annotationStorage: this.#annotationStorage,\n      enableComment: params.enableComment === true,\n      enableScripting: params.enableScripting === true,\n      hasJSActions: params.hasJSActions,\n      fieldObjects: params.fieldObjects,\n      parent: this,\n      elements: null\n    };\n    for (const data of annotations) {\n      if (data.noHTML) {\n        continue;\n      }\n      const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;\n      if (!isPopupAnnotation) {\n        if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {\n          continue;\n        }\n      } else {\n        const elements = popupToElements.get(data.id);\n        if (!elements) {\n          continue;\n        }\n        if (!this._commentManager) {\n          popupAnnotations.push(data);\n          continue;\n        }\n        elementParams.elements = elements;\n      }\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      if (!isPopupAnnotation) {\n        this.#elements.push(element);\n        if (data.popupRef) {\n          const elements = popupToElements.get(data.popupRef);\n          if (!elements) {\n            popupToElements.set(data.popupRef, [element]);\n          } else {\n            elements.push(element);\n          }\n        }\n      }\n      const rendered = element.render();\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      if (element._isEditable) {\n        this.#editableAnnotations.set(element.data.id, element);\n        this._annotationEditorUIManager?.renderAnnotationElement(element);\n      }\n    }\n    await this.#addElementsToDOM();\n    for (const data of popupAnnotations) {\n      const elements = elementParams.elements = popupToElements.get(data.id);\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      const rendered = element.render();\n      element.contentElement.id = `${AnnotationPrefix}${data.id}`;\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      elements.at(-1).container.after(rendered);\n    }\n    this.#setAnnotationCanvasMap();\n  }\n  async #addElementsToDOM() {\n    if (this.#elements.length === 0) {\n      return;\n    }\n    this.div.replaceChildren();\n    const promises = [];\n    if (!this.#hasAriaAttributesFromStructTree) {\n      this.#hasAriaAttributesFromStructTree = true;\n      for (const {\n        contentElement,\n        data: {\n          id\n        }\n      } of this.#elements) {\n        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;\n        promises.push(this.#structTreeLayer?.getAriaAttributes(annotationId).then(ariaAttributes => {\n          if (ariaAttributes) {\n            for (const [key, value] of ariaAttributes) {\n              contentElement.setAttribute(key, value);\n            }\n          }\n        }));\n      }\n    }\n    this.#elements.sort(({\n      data: {\n        rect: [a0, a1, a2, a3]\n      }\n    }, {\n      data: {\n        rect: [b0, b1, b2, b3]\n      }\n    }) => {\n      if (a0 === a2 && a1 === a3) {\n        return +1;\n      }\n      if (b0 === b2 && b1 === b3) {\n        return -1;\n      }\n      const top1 = a3;\n      const bot1 = a1;\n      const mid1 = (a1 + a3) / 2;\n      const top2 = b3;\n      const bot2 = b1;\n      const mid2 = (b1 + b3) / 2;\n      if (mid1 >= top2 && mid2 <= bot1) {\n        return -1;\n      }\n      if (mid2 >= top1 && mid1 <= bot2) {\n        return +1;\n      }\n      const centerX1 = (a0 + a2) / 2;\n      const centerX2 = (b0 + b2) / 2;\n      return centerX1 - centerX2;\n    });\n    const fragment = document.createDocumentFragment();\n    for (const element of this.#elements) {\n      fragment.append(element.container);\n      if (this._commentManager) {\n        (element.extraPopupElement?.popup || element.popup)?.renderCommentButton();\n      } else if (element.extraPopupElement) {\n        fragment.append(element.extraPopupElement.render());\n      }\n    }\n    this.div.append(fragment);\n    await Promise.all(promises);\n    if (this.#accessibilityManager) {\n      for (const element of this.#elements) {\n        this.#accessibilityManager.addPointerInTextLayer(element.contentElement, false);\n      }\n    }\n  }\n  async addLinkAnnotations(annotations) {\n    const elementParams = {\n      data: null,\n      layer: this.div,\n      linkService: this.#linkService,\n      svgFactory: new DOMSVGFactory(),\n      parent: this\n    };\n    for (const data of annotations) {\n      data.borderStyle ||= AnnotationLayer._defaultBorderStyle;\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      element.render();\n      element.contentElement.id = `${AnnotationPrefix}${data.id}`;\n      this.#elements.push(element);\n    }\n    await this.#addElementsToDOM();\n  }\n  update({\n    viewport\n  }) {\n    const layer = this.div;\n    this.viewport = viewport;\n    setLayerDimensions(layer, {\n      rotation: viewport.rotation\n    });\n    this.#setAnnotationCanvasMap();\n    layer.hidden = false;\n  }\n  #setAnnotationCanvasMap() {\n    if (!this.#annotationCanvasMap) {\n      return;\n    }\n    const layer = this.div;\n    for (const [id, canvas] of this.#annotationCanvasMap) {\n      const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n      canvas.className = \"annotationContent\";\n      const {\n        firstChild\n      } = element;\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else if (!firstChild.classList.contains(\"annotationContent\")) {\n        firstChild.before(canvas);\n      } else {\n        firstChild.after(canvas);\n      }\n      const editableAnnotation = this.#editableAnnotations.get(id);\n      if (!editableAnnotation) {\n        continue;\n      }\n      if (editableAnnotation._hasNoCanvas) {\n        this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);\n        editableAnnotation._hasNoCanvas = false;\n      } else {\n        editableAnnotation.canvas = canvas;\n      }\n    }\n    this.#annotationCanvasMap.clear();\n  }\n  getEditableAnnotations() {\n    return Array.from(this.#editableAnnotations.values());\n  }\n  getEditableAnnotation(id) {\n    return this.#editableAnnotations.get(id);\n  }\n  addFakeAnnotation(editor) {\n    const {\n      div\n    } = this;\n    const {\n      id,\n      rotation\n    } = editor;\n    const element = new EditorAnnotationElement({\n      data: {\n        id,\n        rect: editor.getPDFRect(),\n        rotation\n      },\n      editor,\n      layer: div,\n      parent: this,\n      enableComment: !!this._commentManager,\n      linkService: this.#linkService,\n      annotationStorage: this.#annotationStorage\n    });\n    element.render();\n    element.contentElement.id = `${AnnotationPrefix}${id}`;\n    element.createOrUpdatePopup();\n    this.#elements.push(element);\n    return element;\n  }\n  removeAnnotation(id) {\n    const index = this.#elements.findIndex(el => el.data.id === id);\n    if (index < 0) {\n      return;\n    }\n    const [element] = this.#elements.splice(index, 1);\n    this.#accessibilityManager?.removePointerInTextLayer(element.contentElement);\n  }\n  updateFakeAnnotations(editors) {\n    if (editors.length === 0) {\n      return;\n    }\n    for (const editor of editors) {\n      editor.updateFakeAnnotationElement(this);\n    }\n    this.#addElementsToDOM();\n  }\n  togglePointerEvents(enabled = false) {\n    this.div.classList.toggle(\"disabled\", !enabled);\n  }\n  static get _defaultBorderStyle() {\n    return shadow(this, \"_defaultBorderStyle\", Object.freeze({\n      width: 1,\n      rawWidth: 1,\n      style: AnnotationBorderStyleType.SOLID,\n      dashArray: [3],\n      horizontalCornerRadius: 0,\n      verticalCornerRadius: 0\n    }));\n  }\n}\n\n;// ./src/display/editor/freetext.js\n\n\n\n\n\nconst EOL_PATTERN = /\\r\\n?|\\n/g;\nclass FreeTextEditor extends AnnotationEditor {\n  #content = \"\";\n  #editorDivId = `${this.id}-editor`;\n  #editModeAC = null;\n  #fontSize;\n  _colorPicker = null;\n  static _freeTextDefaultContent = \"\";\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static get _keyboardManager() {\n    const proto = FreeTextEditor.prototype;\n    const arrowChecker = self => self.isEmpty();\n    const small = AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = AnnotationEditorUIManager.TRANSLATE_BIG;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+s\", \"mac+meta+s\", \"ctrl+p\", \"mac+meta+p\"], proto.commitOrRemove, {\n      bubbles: true\n    }], [[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], proto.commitOrRemove], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._translateEmpty, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto._translateEmpty, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._translateEmpty, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto._translateEmpty, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._translateEmpty, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto._translateEmpty, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  static _type = \"freetext\";\n  static _editorType = AnnotationEditorType.FREETEXT;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"freeTextEditor\"\n    });\n    this.color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-freetext-added-alert\");\n    }\n    this.canAddComment = false;\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n      case AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.color]];\n  }\n  get toolbarButtons() {\n    this._colorPicker ||= new BasicColorPicker(this);\n    return [[\"colorPicker\", this._colorPicker]];\n  }\n  get colorType() {\n    return AnnotationEditorParamsType.FREETEXT_COLOR;\n  }\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parentScale);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n    const savedFontsize = this.#fontSize;\n    this.addCommands({\n      cmd: setFontsize.bind(this, fontSize),\n      undo: setFontsize.bind(this, savedFontsize),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  onUpdatedColor() {\n    this.editorDiv.style.color = this.color;\n    this._colorPicker?.update(this.color);\n    super.onUpdatedColor();\n  }\n  #updateColor(color) {\n    const setColor = col => {\n      this.color = col;\n      this.onUpdatedColor();\n    };\n    const savedColor = this.color;\n    this.addCommands({\n      cmd: setColor.bind(this, color),\n      undo: setColor.bind(this, savedColor),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _translateEmpty(x, y) {\n    this._uiManager.translateSelectedEditors(x, y, true);\n  }\n  getInitialTranslation() {\n    const scale = this.parentScale;\n    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  enableEditMode() {\n    if (!super.enableEditMode()) {\n      return false;\n    }\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this._isDraggable = false;\n    this.div.removeAttribute(\"aria-activedescendant\");\n    this.#editModeAC = new AbortController();\n    const signal = this._uiManager.combinedSignal(this.#editModeAC);\n    this.editorDiv.addEventListener(\"keydown\", this.editorDivKeydown.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"focus\", this.editorDivFocus.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"blur\", this.editorDivBlur.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"input\", this.editorDivInput.bind(this), {\n      signal\n    });\n    this.editorDiv.addEventListener(\"paste\", this.editorDivPaste.bind(this), {\n      signal\n    });\n    return true;\n  }\n  disableEditMode() {\n    if (!super.disableEditMode()) {\n      return false;\n    }\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n    this._isDraggable = true;\n    this.#editModeAC?.abort();\n    this.#editModeAC = null;\n    this.div.focus({\n      preventScroll: true\n    });\n    this.isEditing = false;\n    this.parent.div.classList.add(\"freetextEditing\");\n    return true;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n  onceAdded(focus) {\n    if (this.width) {\n      return;\n    }\n    this.enableEditMode();\n    if (focus) {\n      this.editorDiv.focus();\n    }\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    }\n    this._initialOptions = null;\n  }\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n  remove() {\n    this.isEditing = false;\n    if (this.parent) {\n      this.parent.setEditingState(true);\n      this.parent.div.classList.add(\"freetextEditing\");\n    }\n    super.remove();\n  }\n  #extractText() {\n    const buffer = [];\n    this.editorDiv.normalize();\n    let prevChild = null;\n    for (const child of this.editorDiv.childNodes) {\n      if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === \"BR\") {\n        continue;\n      }\n      buffer.push(FreeTextEditor.#getNodeContent(child));\n      prevChild = child;\n    }\n    return buffer.join(\"\\n\");\n  }\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    let rect;\n    if (this.isAttachedToDOM) {\n      rect = this.div.getBoundingClientRect();\n    } else {\n      const {\n        currentLayer,\n        div\n      } = this;\n      const savedDisplay = div.style.display;\n      const savedVisibility = div.classList.contains(\"hidden\");\n      div.classList.remove(\"hidden\");\n      div.style.display = \"hidden\";\n      currentLayer.div.append(this.div);\n      rect = div.getBoundingClientRect();\n      div.remove();\n      div.style.display = savedDisplay;\n      div.classList.toggle(\"hidden\", savedVisibility);\n    }\n    if (this.rotation % 180 === this.parentRotation % 180) {\n      this.width = rect.width / parentWidth;\n      this.height = rect.height / parentHeight;\n    } else {\n      this.width = rect.height / parentWidth;\n      this.height = rect.width / parentHeight;\n    }\n    this.fixAndSetPosition();\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    super.commit();\n    this.disableEditMode();\n    const savedText = this.#content;\n    const newText = this.#content = this.#extractText().trimEnd();\n    if (savedText === newText) {\n      return;\n    }\n    const setText = text => {\n      this.#content = text;\n      if (!text) {\n        this.remove();\n        return;\n      }\n      this.#setContent();\n      this._uiManager.rebuild(this);\n      this.#setEditorDimensions();\n    };\n    this.addCommands({\n      cmd: () => {\n        setText(newText);\n      },\n      undo: () => {\n        setText(savedText);\n      },\n      mustExec: false\n    });\n    this.#setEditorDimensions();\n  }\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n  enterInEditMode() {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enterInEditMode();\n      event.preventDefault();\n    }\n  }\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n  editorDivInput(event) {\n    this.parent.div.classList.toggle(\"freetextEditing\", this.isEmpty());\n  }\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n  get canChangeContent() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy || this.annotationElementId) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n    this.editorDiv.setAttribute(\"data-l10n-id\", \"pdfjs-free-text2\");\n    this.editorDiv.setAttribute(\"data-l10n-attrs\", \"default-content\");\n    this.enableEditing();\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n    style.color = this.color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    if (this._isCopy || this.annotationElementId) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      if (this.annotationElementId) {\n        const {\n          position\n        } = this._initialData;\n        let [tx, ty] = this.getInitialTranslation();\n        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        let posX, posY;\n        switch (this.rotation) {\n          case 0:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n            break;\n          case 90:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [ty, -tx];\n            break;\n          case 180:\n            posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [-tx, -ty];\n            break;\n          case 270:\n            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n            [tx, ty] = [-ty, tx];\n            break;\n        }\n        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n      } else {\n        this._moveAfterPaste(baseX, baseY);\n      }\n      this.#setContent();\n      this._isDraggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this._isDraggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n    return this.div;\n  }\n  static #getNodeContent(node) {\n    return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, \"\");\n  }\n  editorDivPaste(event) {\n    const clipboardData = event.clipboardData || window.clipboardData;\n    const {\n      types\n    } = clipboardData;\n    if (types.length === 1 && types[0] === \"text/plain\") {\n      return;\n    }\n    event.preventDefault();\n    const paste = FreeTextEditor.#deserializeContent(clipboardData.getData(\"text\") || \"\").replaceAll(EOL_PATTERN, \"\\n\");\n    if (!paste) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (!selection.rangeCount) {\n      return;\n    }\n    this.editorDiv.normalize();\n    selection.deleteFromDocument();\n    const range = selection.getRangeAt(0);\n    if (!paste.includes(\"\\n\")) {\n      range.insertNode(document.createTextNode(paste));\n      this.editorDiv.normalize();\n      selection.collapseToStart();\n      return;\n    }\n    const {\n      startContainer,\n      startOffset\n    } = range;\n    const bufferBefore = [];\n    const bufferAfter = [];\n    if (startContainer.nodeType === Node.TEXT_NODE) {\n      const parent = startContainer.parentElement;\n      bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, \"\"));\n      if (parent !== this.editorDiv) {\n        let buffer = bufferBefore;\n        for (const child of this.editorDiv.childNodes) {\n          if (child === parent) {\n            buffer = bufferAfter;\n            continue;\n          }\n          buffer.push(FreeTextEditor.#getNodeContent(child));\n        }\n      }\n      bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, \"\"));\n    } else if (startContainer === this.editorDiv) {\n      let buffer = bufferBefore;\n      let i = 0;\n      for (const child of this.editorDiv.childNodes) {\n        if (i++ === startOffset) {\n          buffer = bufferAfter;\n        }\n        buffer.push(FreeTextEditor.#getNodeContent(child));\n      }\n    }\n    this.#content = `${bufferBefore.join(\"\\n\")}${paste}${bufferAfter.join(\"\\n\")}`;\n    this.#setContent();\n    const newRange = new Range();\n    let beforeLength = Math.sumPrecise(bufferBefore.map(line => line.length));\n    for (const {\n      firstChild\n    } of this.editorDiv.childNodes) {\n      if (firstChild.nodeType === Node.TEXT_NODE) {\n        const length = firstChild.nodeValue.length;\n        if (beforeLength <= length) {\n          newRange.setStart(firstChild, beforeLength);\n          newRange.setEnd(firstChild, beforeLength);\n          break;\n        }\n        beforeLength -= length;\n      }\n    }\n    selection.removeAllRanges();\n    selection.addRange(newRange);\n  }\n  #setContent() {\n    this.editorDiv.replaceChildren();\n    if (!this.#content) {\n      return;\n    }\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      this.editorDiv.append(div);\n    }\n  }\n  #serializeContent() {\n    return this.#content.replaceAll(\"\\xa0\", \" \");\n  }\n  static #deserializeContent(content) {\n    return content.replaceAll(\" \", \"\\xa0\");\n  }\n  get contentDiv() {\n    return this.editorDiv;\n  }\n  getPDFRect() {\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    return this.getRect(padding, padding);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof FreeTextAnnotationElement) {\n      const {\n        data: {\n          defaultAppearanceData: {\n            fontSize,\n            fontColor\n          },\n          rect,\n          rotation,\n          id,\n          popupRef,\n          richText,\n          contentsObj,\n          creationDate,\n          modificationDate\n        },\n        textContent,\n        textPosition,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      if (!textContent || textContent.length === 0) {\n        return null;\n      }\n      initialData = data = {\n        annotationType: AnnotationEditorType.FREETEXT,\n        color: Array.from(fontColor),\n        fontSize,\n        value: textContent.join(\"\\n\"),\n        position: textPosition,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        comment: contentsObj?.str || null,\n        richText,\n        creationDate,\n        modificationDate\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.#fontSize = data.fontSize;\n    editor.color = Util.makeHexColor(...data.color);\n    editor.#content = FreeTextEditor.#deserializeContent(data.value);\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data);\n    }\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);\n    const serialized = Object.assign(super.serialize(isForCopying), {\n      color,\n      fontSize: this.#fontSize,\n      value: this.#serializeContent()\n    });\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.isCopy = true;\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      value,\n      fontSize,\n      color,\n      pageIndex\n    } = this._initialData;\n    return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;\n  }\n  renderAnnotationElement(annotation) {\n    const content = super.renderAnnotationElement(annotation);\n    if (!content) {\n      return null;\n    }\n    const {\n      style\n    } = content;\n    style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;\n    style.color = this.color;\n    content.replaceChildren();\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      content.append(div);\n    }\n    annotation.updateEdited({\n      rect: this.getPDFRect(),\n      popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {\n        text: this.#content\n      }\n    });\n    return content;\n  }\n  resetAnnotationElement(annotation) {\n    super.resetAnnotationElement(annotation);\n    annotation.resetEdited();\n  }\n}\n\n;// ./src/display/editor/drawers/outline.js\n\nclass Outline {\n  static PRECISION = 1e-4;\n  toSVGPath() {\n    unreachable(\"Abstract method `toSVGPath` must be implemented.\");\n  }\n  get box() {\n    unreachable(\"Abstract getter `box` must be implemented.\");\n  }\n  serialize(_bbox, _rotation) {\n    unreachable(\"Abstract method `serialize` must be implemented.\");\n  }\n  static _rescale(src, tx, ty, sx, sy, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i] * sx;\n      dest[i + 1] = ty + src[i + 1] * sy;\n    }\n    return dest;\n  }\n  static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i + 1] * sx;\n      dest[i + 1] = ty + src[i] * sy;\n    }\n    return dest;\n  }\n  static _translate(src, tx, ty, dest) {\n    dest ||= new Float32Array(src.length);\n    for (let i = 0, ii = src.length; i < ii; i += 2) {\n      dest[i] = tx + src[i];\n      dest[i + 1] = ty + src[i + 1];\n    }\n    return dest;\n  }\n  static svgRound(x) {\n    return Math.round(x * 10000);\n  }\n  static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {\n    switch (rotation) {\n      case 90:\n        return [1 - y / parentWidth, x / parentHeight];\n      case 180:\n        return [1 - x / parentWidth, 1 - y / parentHeight];\n      case 270:\n        return [y / parentWidth, 1 - x / parentHeight];\n      default:\n        return [x / parentWidth, y / parentHeight];\n    }\n  }\n  static _normalizePagePoint(x, y, rotation) {\n    switch (rotation) {\n      case 90:\n        return [1 - y, x];\n      case 180:\n        return [1 - x, 1 - y];\n      case 270:\n        return [y, 1 - x];\n      default:\n        return [x, y];\n    }\n  }\n  static createBezierPoints(x1, y1, x2, y2, x3, y3) {\n    return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];\n  }\n}\n\n;// ./src/display/editor/drawers/freedraw.js\n\n\nclass FreeDrawOutliner {\n  #box;\n  #bottom = [];\n  #innerMargin;\n  #isLTR;\n  #top = [];\n  #last = new Float32Array(18);\n  #lastX;\n  #lastY;\n  #min;\n  #min_dist;\n  #scaleFactor;\n  #thickness;\n  #points = [];\n  static #MIN_DIST = 8;\n  static #MIN_DIFF = 2;\n  static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;\n  constructor({\n    x,\n    y\n  }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    this.#box = box;\n    this.#thickness = thickness * scaleFactor;\n    this.#isLTR = isLTR;\n    this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);\n    this.#innerMargin = innerMargin;\n    this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;\n    this.#min = FreeDrawOutliner.#MIN * scaleFactor;\n    this.#scaleFactor = scaleFactor;\n    this.#points.push(x, y);\n  }\n  isEmpty() {\n    return isNaN(this.#last[8]);\n  }\n  #getLastCoords() {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [x, y, width, height] = this.#box;\n    return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];\n  }\n  add({\n    x,\n    y\n  }) {\n    this.#lastX = x;\n    this.#lastY = y;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    let [x1, y1, x2, y2] = this.#last.subarray(8, 12);\n    const diffX = x - x2;\n    const diffY = y - y2;\n    const d = Math.hypot(diffX, diffY);\n    if (d < this.#min) {\n      return false;\n    }\n    const diffD = d - this.#min_dist;\n    const K = diffD / d;\n    const shiftX = K * diffX;\n    const shiftY = K * diffY;\n    let x0 = x1;\n    let y0 = y1;\n    x1 = x2;\n    y1 = y2;\n    x2 += shiftX;\n    y2 += shiftY;\n    this.#points?.push(x, y);\n    const nX = -shiftY / diffD;\n    const nY = shiftX / diffD;\n    const thX = nX * this.#thickness;\n    const thY = nY * this.#thickness;\n    this.#last.set(this.#last.subarray(2, 8), 0);\n    this.#last.set([x2 + thX, y2 + thY], 4);\n    this.#last.set(this.#last.subarray(14, 18), 12);\n    this.#last.set([x2 - thX, y2 - thY], 16);\n    if (isNaN(this.#last[6])) {\n      if (this.#top.length === 0) {\n        this.#last.set([x1 + thX, y1 + thY], 2);\n        this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);\n        this.#last.set([x1 - thX, y1 - thY], 14);\n        this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);\n      }\n      this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n      return !this.isEmpty();\n    }\n    this.#last.set([x0, y0, x1, y1, x2, y2], 6);\n    const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));\n    if (angle < Math.PI / 2) {\n      [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n      this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n      [x1, y1, x0, y0] = this.#last.subarray(14, 18);\n      this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);\n      return true;\n    }\n    [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);\n    this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);\n    this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);\n    return true;\n  }\n  toSVGPath() {\n    if (this.isEmpty()) {\n      return \"\";\n    }\n    const top = this.#top;\n    const bottom = this.#bottom;\n    if (isNaN(this.#last[6]) && !this.isEmpty()) {\n      return this.#toSVGPathTwoPoints();\n    }\n    const buffer = [];\n    buffer.push(`M${top[4]} ${top[5]}`);\n    for (let i = 6; i < top.length; i += 6) {\n      if (isNaN(top[i])) {\n        buffer.push(`L${top[i + 4]} ${top[i + 5]}`);\n      } else {\n        buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);\n      }\n    }\n    this.#toSVGPathEnd(buffer);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      if (isNaN(bottom[i])) {\n        buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);\n      } else {\n        buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);\n      }\n    }\n    this.#toSVGPathStart(buffer);\n    return buffer.join(\" \");\n  }\n  #toSVGPathTwoPoints() {\n    const [x, y, width, height] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;\n  }\n  #toSVGPathStart(buffer) {\n    const bottom = this.#bottom;\n    buffer.push(`L${bottom[4]} ${bottom[5]} Z`);\n  }\n  #toSVGPathEnd(buffer) {\n    const [x, y, width, height] = this.#box;\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);\n  }\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n  getOutlines() {\n    const top = this.#top;\n    const bottom = this.#bottom;\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const points = new Float32Array((this.#points?.length ?? 0) + 2);\n    for (let i = 0, ii = points.length - 2; i < ii; i += 2) {\n      points[i] = (this.#points[i] - layerX) / layerWidth;\n      points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;\n    }\n    points[points.length - 2] = (this.#lastX - layerX) / layerWidth;\n    points[points.length - 1] = (this.#lastY - layerY) / layerHeight;\n    if (isNaN(last[6]) && !this.isEmpty()) {\n      return this.#getOutlineTwoPoints(points);\n    }\n    const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);\n    let N = top.length;\n    for (let i = 0; i < N; i += 2) {\n      if (isNaN(top[i])) {\n        outline[i] = outline[i + 1] = NaN;\n        continue;\n      }\n      outline[i] = top[i];\n      outline[i + 1] = top[i + 1];\n    }\n    N = this.#getOutlineEnd(outline, N);\n    for (let i = bottom.length - 6; i >= 6; i -= 6) {\n      for (let j = 0; j < 6; j += 2) {\n        if (isNaN(bottom[i + j])) {\n          outline[N] = outline[N + 1] = NaN;\n          N += 2;\n          continue;\n        }\n        outline[N] = bottom[i + j];\n        outline[N + 1] = bottom[i + j + 1];\n        N += 2;\n      }\n    }\n    this.#getOutlineStart(outline, N);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineTwoPoints(points) {\n    const last = this.#last;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    const outline = new Float32Array(36);\n    outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);\n    return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);\n  }\n  #getOutlineStart(outline, pos) {\n    const bottom = this.#bottom;\n    outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);\n    return pos += 6;\n  }\n  #getOutlineEnd(outline, pos) {\n    const lastTop = this.#last.subarray(4, 6);\n    const lastBottom = this.#last.subarray(16, 18);\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();\n    outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);\n    return pos += 24;\n  }\n}\nclass FreeDrawOutline extends Outline {\n  #box;\n  #bbox = new Float32Array(4);\n  #innerMargin;\n  #isLTR;\n  #points;\n  #scaleFactor;\n  #outline;\n  constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    super();\n    this.#outline = outline;\n    this.#points = points;\n    this.#box = box;\n    this.#scaleFactor = scaleFactor;\n    this.#innerMargin = innerMargin;\n    this.#isLTR = isLTR;\n    this.firstPoint = [NaN, NaN];\n    this.lastPoint = [NaN, NaN];\n    this.#computeMinMax(isLTR);\n    const [x, y, width, height] = this.#bbox;\n    for (let i = 0, ii = outline.length; i < ii; i += 2) {\n      outline[i] = (outline[i] - x) / width;\n      outline[i + 1] = (outline[i + 1] - y) / height;\n    }\n    for (let i = 0, ii = points.length; i < ii; i += 2) {\n      points[i] = (points[i] - x) / width;\n      points[i + 1] = (points[i + 1] - y) / height;\n    }\n  }\n  toSVGPath() {\n    const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];\n    for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {\n      if (isNaN(this.#outline[i])) {\n        buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n        continue;\n      }\n      buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);\n    }\n    buffer.push(\"Z\");\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], rotation) {\n    const width = trX - blX;\n    const height = trY - blY;\n    let outline;\n    let points;\n    switch (rotation) {\n      case 0:\n        outline = Outline._rescale(this.#outline, blX, trY, width, -height);\n        points = Outline._rescale(this.#points, blX, trY, width, -height);\n        break;\n      case 90:\n        outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);\n        points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);\n        break;\n      case 180:\n        outline = Outline._rescale(this.#outline, trX, blY, -width, height);\n        points = Outline._rescale(this.#points, trX, blY, -width, height);\n        break;\n      case 270:\n        outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);\n        points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);\n        break;\n    }\n    return {\n      outline: Array.from(outline),\n      points: [Array.from(points)]\n    };\n  }\n  #computeMinMax(isLTR) {\n    const outline = this.#outline;\n    let lastX = outline[4];\n    let lastY = outline[5];\n    const minMax = [lastX, lastY, lastX, lastY];\n    let firstPointX = lastX;\n    let firstPointY = lastY;\n    let lastPointX = lastX;\n    let lastPointY = lastY;\n    const ltrCallback = isLTR ? Math.max : Math.min;\n    const bezierBbox = new Float32Array(4);\n    for (let i = 6, ii = outline.length; i < ii; i += 6) {\n      const x = outline[i + 4],\n        y = outline[i + 5];\n      if (isNaN(outline[i])) {\n        Util.pointBoundingBox(x, y, minMax);\n        if (firstPointY > y) {\n          firstPointX = x;\n          firstPointY = y;\n        } else if (firstPointY === y) {\n          firstPointX = ltrCallback(firstPointX, x);\n        }\n        if (lastPointY < y) {\n          lastPointX = x;\n          lastPointY = y;\n        } else if (lastPointY === y) {\n          lastPointX = ltrCallback(lastPointX, x);\n        }\n      } else {\n        bezierBbox[0] = bezierBbox[1] = Infinity;\n        bezierBbox[2] = bezierBbox[3] = -Infinity;\n        Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);\n        Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);\n        if (firstPointY > bezierBbox[1]) {\n          firstPointX = bezierBbox[0];\n          firstPointY = bezierBbox[1];\n        } else if (firstPointY === bezierBbox[1]) {\n          firstPointX = ltrCallback(firstPointX, bezierBbox[0]);\n        }\n        if (lastPointY < bezierBbox[3]) {\n          lastPointX = bezierBbox[2];\n          lastPointY = bezierBbox[3];\n        } else if (lastPointY === bezierBbox[3]) {\n          lastPointX = ltrCallback(lastPointX, bezierBbox[2]);\n        }\n      }\n      lastX = x;\n      lastY = y;\n    }\n    const bbox = this.#bbox;\n    bbox[0] = minMax[0] - this.#innerMargin;\n    bbox[1] = minMax[1] - this.#innerMargin;\n    bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;\n    bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;\n    this.firstPoint = [firstPointX, firstPointY];\n    this.lastPoint = [lastPointX, lastPointY];\n  }\n  get box() {\n    return this.#bbox;\n  }\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n  getNewOutline(thickness, innerMargin) {\n    const [x, y, width, height] = this.#bbox;\n    const [layerX, layerY, layerWidth, layerHeight] = this.#box;\n    const sx = width * layerWidth;\n    const sy = height * layerHeight;\n    const tx = x * layerWidth + layerX;\n    const ty = y * layerHeight + layerY;\n    const outliner = this.newOutliner({\n      x: this.#points[0] * sx + tx,\n      y: this.#points[1] * sy + ty\n    }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);\n    for (let i = 2; i < this.#points.length; i += 2) {\n      outliner.add({\n        x: this.#points[i] * sx + tx,\n        y: this.#points[i + 1] * sy + ty\n      });\n    }\n    return outliner.getOutlines();\n  }\n}\n\n;// ./src/display/editor/drawers/highlight.js\n\n\n\nclass HighlightOutliner {\n  #box;\n  #firstPoint;\n  #lastPoint;\n  #verticalEdges = [];\n  #intervals = [];\n  constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {\n    const minMax = [Infinity, Infinity, -Infinity, -Infinity];\n    const NUMBER_OF_DIGITS = 4;\n    const EPSILON = 10 ** -NUMBER_OF_DIGITS;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;\n      const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;\n      const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;\n      const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;\n      const left = [x1, y1, y2, true];\n      const right = [x2, y1, y2, false];\n      this.#verticalEdges.push(left, right);\n      Util.rectBoundingBox(x1, y1, x2, y2, minMax);\n    }\n    const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;\n    const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;\n    const shiftedMinX = minMax[0] - innerMargin;\n    const shiftedMinY = minMax[1] - innerMargin;\n    let firstPointX = isLTR ? -Infinity : Infinity;\n    let firstPointY = Infinity;\n    const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);\n    const lastPoint = [lastEdge[0], lastEdge[2]];\n    for (const edge of this.#verticalEdges) {\n      const [x, y1, y2, left] = edge;\n      if (!left && isLTR) {\n        if (y1 < firstPointY) {\n          firstPointY = y1;\n          firstPointX = x;\n        } else if (y1 === firstPointY) {\n          firstPointX = Math.max(firstPointX, x);\n        }\n      } else if (left && !isLTR) {\n        if (y1 < firstPointY) {\n          firstPointY = y1;\n          firstPointX = x;\n        } else if (y1 === firstPointY) {\n          firstPointX = Math.min(firstPointX, x);\n        }\n      }\n      edge[0] = (x - shiftedMinX) / bboxWidth;\n      edge[1] = (y1 - shiftedMinY) / bboxHeight;\n      edge[2] = (y2 - shiftedMinY) / bboxHeight;\n    }\n    this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);\n    this.#firstPoint = [firstPointX, firstPointY];\n    this.#lastPoint = lastPoint;\n  }\n  getOutlines() {\n    this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n    const outlineVerticalEdges = [];\n    for (const edge of this.#verticalEdges) {\n      if (edge[3]) {\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n        this.#insert(edge);\n      } else {\n        this.#remove(edge);\n        outlineVerticalEdges.push(...this.#breakEdge(edge));\n      }\n    }\n    return this.#getOutlines(outlineVerticalEdges);\n  }\n  #getOutlines(outlineVerticalEdges) {\n    const edges = [];\n    const allEdges = new Set();\n    for (const edge of outlineVerticalEdges) {\n      const [x, y1, y2] = edge;\n      edges.push([x, y1, edge], [x, y2, edge]);\n    }\n    edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);\n    for (let i = 0, ii = edges.length; i < ii; i += 2) {\n      const edge1 = edges[i][2];\n      const edge2 = edges[i + 1][2];\n      edge1.push(edge2);\n      edge2.push(edge1);\n      allEdges.add(edge1);\n      allEdges.add(edge2);\n    }\n    const outlines = [];\n    let outline;\n    while (allEdges.size > 0) {\n      const edge = allEdges.values().next().value;\n      let [x, y1, y2, edge1, edge2] = edge;\n      allEdges.delete(edge);\n      let lastPointX = x;\n      let lastPointY = y1;\n      outline = [x, y2];\n      outlines.push(outline);\n      while (true) {\n        let e;\n        if (allEdges.has(edge1)) {\n          e = edge1;\n        } else if (allEdges.has(edge2)) {\n          e = edge2;\n        } else {\n          break;\n        }\n        allEdges.delete(e);\n        [x, y1, y2, edge1, edge2] = e;\n        if (lastPointX !== x) {\n          outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);\n          lastPointX = x;\n        }\n        lastPointY = lastPointY === y1 ? y2 : y1;\n      }\n      outline.push(lastPointX, lastPointY);\n    }\n    return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);\n  }\n  #binarySearch(y) {\n    const array = this.#intervals;\n    let start = 0;\n    let end = array.length - 1;\n    while (start <= end) {\n      const middle = start + end >> 1;\n      const y1 = array[middle][0];\n      if (y1 === y) {\n        return middle;\n      }\n      if (y1 < y) {\n        start = middle + 1;\n      } else {\n        end = middle - 1;\n      }\n    }\n    return end + 1;\n  }\n  #insert([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    this.#intervals.splice(index, 0, [y1, y2]);\n  }\n  #remove([, y1, y2]) {\n    const index = this.#binarySearch(y1);\n    for (let i = index; i < this.#intervals.length; i++) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n    for (let i = index - 1; i >= 0; i--) {\n      const [start, end] = this.#intervals[i];\n      if (start !== y1) {\n        break;\n      }\n      if (start === y1 && end === y2) {\n        this.#intervals.splice(i, 1);\n        return;\n      }\n    }\n  }\n  #breakEdge(edge) {\n    const [x, y1, y2] = edge;\n    const results = [[x, y1, y2]];\n    const index = this.#binarySearch(y2);\n    for (let i = 0; i < index; i++) {\n      const [start, end] = this.#intervals[i];\n      for (let j = 0, jj = results.length; j < jj; j++) {\n        const [, y3, y4] = results[j];\n        if (end <= y3 || y4 <= start) {\n          continue;\n        }\n        if (y3 >= start) {\n          if (y4 > end) {\n            results[j][1] = end;\n          } else {\n            if (jj === 1) {\n              return [];\n            }\n            results.splice(j, 1);\n            j--;\n            jj--;\n          }\n          continue;\n        }\n        results[j][2] = start;\n        if (y4 > end) {\n          results.push([x, end, y4]);\n        }\n      }\n    }\n    return results;\n  }\n}\nclass HighlightOutline extends Outline {\n  #box;\n  #outlines;\n  constructor(outlines, box, firstPoint, lastPoint) {\n    super();\n    this.#outlines = outlines;\n    this.#box = box;\n    this.firstPoint = firstPoint;\n    this.lastPoint = lastPoint;\n  }\n  toSVGPath() {\n    const buffer = [];\n    for (const polygon of this.#outlines) {\n      let [prevX, prevY] = polygon;\n      buffer.push(`M${prevX} ${prevY}`);\n      for (let i = 2; i < polygon.length; i += 2) {\n        const x = polygon[i];\n        const y = polygon[i + 1];\n        if (x === prevX) {\n          buffer.push(`V${y}`);\n          prevY = y;\n        } else if (y === prevY) {\n          buffer.push(`H${x}`);\n          prevX = x;\n        }\n      }\n      buffer.push(\"Z\");\n    }\n    return buffer.join(\" \");\n  }\n  serialize([blX, blY, trX, trY], _rotation) {\n    const outlines = [];\n    const width = trX - blX;\n    const height = trY - blY;\n    for (const outline of this.#outlines) {\n      const points = new Array(outline.length);\n      for (let i = 0; i < outline.length; i += 2) {\n        points[i] = blX + outline[i] * width;\n        points[i + 1] = trY - outline[i + 1] * height;\n      }\n      outlines.push(points);\n    }\n    return outlines;\n  }\n  get box() {\n    return this.#box;\n  }\n  get classNamesForOutlining() {\n    return [\"highlightOutline\"];\n  }\n}\nclass FreeHighlightOutliner extends FreeDrawOutliner {\n  newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {\n    return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);\n  }\n}\nclass FreeHighlightOutline extends FreeDrawOutline {\n  newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {\n    return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);\n  }\n}\n\n;// ./src/display/editor/highlight.js\n\n\n\n\n\n\n\nclass HighlightEditor extends AnnotationEditor {\n  #anchorNode = null;\n  #anchorOffset = 0;\n  #boxes;\n  #clipPathId = null;\n  #colorPicker = null;\n  #focusOutlines = null;\n  #focusNode = null;\n  #focusOffset = 0;\n  #highlightDiv = null;\n  #highlightOutlines = null;\n  #id = null;\n  #isFreeHighlight = false;\n  #firstPoint = null;\n  #lastPoint = null;\n  #outlineId = null;\n  #text = \"\";\n  #thickness;\n  #methodOfCreation = \"\";\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 12;\n  static _type = \"highlight\";\n  static _editorType = AnnotationEditorType.HIGHLIGHT;\n  static _freeHighlightId = -1;\n  static _freeHighlight = null;\n  static _freeHighlightClipId = \"\";\n  static get _keyboardManager() {\n    const proto = HighlightEditor.prototype;\n    return shadow(this, \"_keyboardManager\", new KeyboardManager([[[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._moveCaret, {\n      args: [0]\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._moveCaret, {\n      args: [1]\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._moveCaret, {\n      args: [2]\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._moveCaret, {\n      args: [3]\n    }]]));\n  }\n  constructor(params) {\n    super({\n      ...params,\n      name: \"highlightEditor\"\n    });\n    this.color = params.color || HighlightEditor._defaultColor;\n    this.#thickness = params.thickness || HighlightEditor._defaultThickness;\n    this.opacity = params.opacity || HighlightEditor._defaultOpacity;\n    this.#boxes = params.boxes || null;\n    this.#methodOfCreation = params.methodOfCreation || \"\";\n    this.#text = params.text || \"\";\n    this._isDraggable = false;\n    this.defaultL10nId = \"pdfjs-editor-highlight-editor\";\n    if (params.highlightId > -1) {\n      this.#isFreeHighlight = true;\n      this.#createFreeOutlines(params);\n      this.#addToDrawLayer();\n    } else if (this.#boxes) {\n      this.#anchorNode = params.anchorNode;\n      this.#anchorOffset = params.anchorOffset;\n      this.#focusNode = params.focusNode;\n      this.#focusOffset = params.focusOffset;\n      this.#createOutlines();\n      this.#addToDrawLayer();\n      this.rotate(this.rotation);\n    }\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-highlight-added-alert\");\n    }\n  }\n  get telemetryInitialData() {\n    return {\n      action: \"added\",\n      type: this.#isFreeHighlight ? \"free_highlight\" : \"highlight\",\n      color: this._uiManager.getNonHCMColorName(this.color),\n      thickness: this.#thickness,\n      methodOfCreation: this.#methodOfCreation\n    };\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"highlight\",\n      color: this._uiManager.getNonHCMColorName(this.color)\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    return {\n      numberOfColors: data.get(\"color\").size\n    };\n  }\n  #createOutlines() {\n    const outliner = new HighlightOutliner(this.#boxes, 0.001);\n    this.#highlightOutlines = outliner.getOutlines();\n    [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;\n    const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === \"ltr\");\n    this.#focusOutlines = outlinerForOutline.getOutlines();\n    const {\n      firstPoint\n    } = this.#highlightOutlines;\n    this.#firstPoint = [(firstPoint[0] - this.x) / this.width, (firstPoint[1] - this.y) / this.height];\n    const {\n      lastPoint\n    } = this.#focusOutlines;\n    this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];\n  }\n  #createFreeOutlines({\n    highlightOutlines,\n    highlightId,\n    clipPathId\n  }) {\n    this.#highlightOutlines = highlightOutlines;\n    const extraThickness = 1.5;\n    this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);\n    if (highlightId >= 0) {\n      this.#id = highlightId;\n      this.#clipPathId = clipPathId;\n      this.parent.drawLayer.finalizeDraw(highlightId, {\n        bbox: highlightOutlines.box,\n        path: {\n          d: highlightOutlines.toSVGPath()\n        }\n      });\n      this.#outlineId = this.parent.drawLayer.drawOutline({\n        rootClass: {\n          highlightOutline: true,\n          free: true\n        },\n        bbox: this.#focusOutlines.box,\n        path: {\n          d: this.#focusOutlines.toSVGPath()\n        }\n      }, true);\n    } else if (this.parent) {\n      const angle = this.parent.viewport.rotation;\n      this.parent.drawLayer.updateProperties(this.#id, {\n        bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),\n        path: {\n          d: highlightOutlines.toSVGPath()\n        }\n      });\n      this.parent.drawLayer.updateProperties(this.#outlineId, {\n        bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n        path: {\n          d: this.#focusOutlines.toSVGPath()\n        }\n      });\n    }\n    const [x, y, width, height] = highlightOutlines.box;\n    switch (this.rotation) {\n      case 0:\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = y;\n          this.y = 1 - x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n      case 180:\n        this.x = 1 - x;\n        this.y = 1 - y;\n        this.width = width;\n        this.height = height;\n        break;\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.parentDimensions;\n          this.x = 1 - y;\n          this.y = x;\n          this.width = width * pageHeight / pageWidth;\n          this.height = height * pageWidth / pageHeight;\n          break;\n        }\n    }\n    const {\n      firstPoint\n    } = highlightOutlines;\n    this.#firstPoint = [(firstPoint[0] - x) / width, (firstPoint[1] - y) / height];\n    const {\n      lastPoint\n    } = this.#focusOutlines;\n    this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || \"#fff066\";\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n        HighlightEditor._defaultColor = value;\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        HighlightEditor._defaultThickness = value;\n        break;\n    }\n  }\n  translateInPage(x, y) {}\n  get toolbarPosition() {\n    return this.#lastPoint;\n  }\n  get commentButtonPosition() {\n    return this.#firstPoint;\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case AnnotationEditorParamsType.HIGHLIGHT_COLOR:\n        this.#updateColor(value);\n        break;\n      case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:\n        this.#updateThickness(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];\n  }\n  get propertiesToUpdate() {\n    return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];\n  }\n  onUpdatedColor() {\n    this.parent?.drawLayer.updateProperties(this.#id, {\n      root: {\n        fill: this.color,\n        \"fill-opacity\": this.opacity\n      }\n    });\n    this.#colorPicker?.updateColor(this.color);\n    super.onUpdatedColor();\n  }\n  #updateColor(color) {\n    const setColorAndOpacity = (col, opa) => {\n      this.color = col;\n      this.opacity = opa;\n      this.onUpdatedColor();\n    };\n    const savedColor = this.color;\n    const savedOpacity = this.opacity;\n    this.addCommands({\n      cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),\n      undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"color_changed\",\n      color: this._uiManager.getNonHCMColorName(color)\n    }, true);\n  }\n  #updateThickness(thickness) {\n    const savedThickness = this.#thickness;\n    const setThickness = th => {\n      this.#thickness = th;\n      this.#changeThickness(th);\n    };\n    this.addCommands({\n      cmd: setThickness.bind(this, thickness),\n      undo: setThickness.bind(this, savedThickness),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type: AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n    this._reportTelemetry({\n      action: \"thickness_changed\",\n      thickness\n    }, true);\n  }\n  get toolbarButtons() {\n    if (this._uiManager.highlightColors) {\n      const colorPicker = this.#colorPicker = new ColorPicker({\n        editor: this\n      });\n      return [[\"colorPicker\", colorPicker]];\n    }\n    return super.toolbarButtons;\n  }\n  disableEditing() {\n    super.disableEditing();\n    this.div.classList.toggle(\"disabled\", true);\n  }\n  enableEditing() {\n    super.enableEditing();\n    this.div.classList.toggle(\"disabled\", false);\n  }\n  fixAndSetPosition() {\n    return super.fixAndSetPosition(this.#getRotation());\n  }\n  getBaseTranslation() {\n    return [0, 0];\n  }\n  getRect(tx, ty) {\n    return super.getRect(tx, ty, this.#getRotation());\n  }\n  onceAdded(focus) {\n    if (!this.annotationElementId) {\n      this.parent.addUndoableEditor(this);\n    }\n    if (focus) {\n      this.div.focus();\n    }\n  }\n  remove() {\n    this.#cleanDrawLayer();\n    this._reportTelemetry({\n      action: \"deleted\"\n    });\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    this.#addToDrawLayer();\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  setParent(parent) {\n    let mustBeSelected = false;\n    if (this.parent && !parent) {\n      this.#cleanDrawLayer();\n    } else if (parent) {\n      this.#addToDrawLayer(parent);\n      mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n    }\n    super.setParent(parent);\n    this.show(this._isVisible);\n    if (mustBeSelected) {\n      this.select();\n    }\n  }\n  #changeThickness(thickness) {\n    if (!this.#isFreeHighlight) {\n      return;\n    }\n    this.#createFreeOutlines({\n      highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)\n    });\n    this.fixAndSetPosition();\n    this.setDims();\n  }\n  #cleanDrawLayer() {\n    if (this.#id === null || !this.parent) {\n      return;\n    }\n    this.parent.drawLayer.remove(this.#id);\n    this.#id = null;\n    this.parent.drawLayer.remove(this.#outlineId);\n    this.#outlineId = null;\n  }\n  #addToDrawLayer(parent = this.parent) {\n    if (this.#id !== null) {\n      return;\n    }\n    ({\n      id: this.#id,\n      clipPathId: this.#clipPathId\n    } = parent.drawLayer.draw({\n      bbox: this.#highlightOutlines.box,\n      root: {\n        viewBox: \"0 0 1 1\",\n        fill: this.color,\n        \"fill-opacity\": this.opacity\n      },\n      rootClass: {\n        highlight: true,\n        free: this.#isFreeHighlight\n      },\n      path: {\n        d: this.#highlightOutlines.toSVGPath()\n      }\n    }, false, true));\n    this.#outlineId = parent.drawLayer.drawOutline({\n      rootClass: {\n        highlightOutline: true,\n        free: this.#isFreeHighlight\n      },\n      bbox: this.#focusOutlines.box,\n      path: {\n        d: this.#focusOutlines.toSVGPath()\n      }\n    }, this.#isFreeHighlight);\n    if (this.#highlightDiv) {\n      this.#highlightDiv.style.clipPath = this.#clipPathId;\n    }\n  }\n  static #rotateBbox([x, y, width, height], angle) {\n    switch (angle) {\n      case 90:\n        return [1 - y - height, x, height, width];\n      case 180:\n        return [1 - x - width, 1 - y - height, width, height];\n      case 270:\n        return [y, 1 - x - width, height, width];\n    }\n    return [x, y, width, height];\n  }\n  rotate(angle) {\n    const {\n      drawLayer\n    } = this.parent;\n    let box;\n    if (this.#isFreeHighlight) {\n      angle = (angle - this.rotation + 360) % 360;\n      box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);\n    } else {\n      box = HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);\n    }\n    drawLayer.updateProperties(this.#id, {\n      bbox: box,\n      root: {\n        \"data-main-rotation\": angle\n      }\n    });\n    drawLayer.updateProperties(this.#outlineId, {\n      bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),\n      root: {\n        \"data-main-rotation\": angle\n      }\n    });\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    const div = super.render();\n    if (this.#text) {\n      div.setAttribute(\"aria-label\", this.#text);\n      div.setAttribute(\"role\", \"mark\");\n    }\n    if (this.#isFreeHighlight) {\n      div.classList.add(\"free\");\n    } else {\n      this.div.addEventListener(\"keydown\", this.#keydown.bind(this), {\n        signal: this._uiManager._signal\n      });\n    }\n    const highlightDiv = this.#highlightDiv = document.createElement(\"div\");\n    div.append(highlightDiv);\n    highlightDiv.setAttribute(\"aria-hidden\", \"true\");\n    highlightDiv.className = \"internal\";\n    highlightDiv.style.clipPath = this.#clipPathId;\n    this.setDims();\n    bindEvents(this, this.#highlightDiv, [\"pointerover\", \"pointerleave\"]);\n    this.enableEditing();\n    return div;\n  }\n  pointerover() {\n    if (!this.isSelected) {\n      this.parent?.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hovered: true\n        }\n      });\n    }\n  }\n  pointerleave() {\n    if (!this.isSelected) {\n      this.parent?.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hovered: false\n        }\n      });\n    }\n  }\n  #keydown(event) {\n    HighlightEditor._keyboardManager.exec(this, event);\n  }\n  _moveCaret(direction) {\n    this.parent.unselect(this);\n    switch (direction) {\n      case 0:\n      case 2:\n        this.#setCaret(true);\n        break;\n      case 1:\n      case 3:\n        this.#setCaret(false);\n        break;\n    }\n  }\n  #setCaret(start) {\n    if (!this.#anchorNode) {\n      return;\n    }\n    const selection = window.getSelection();\n    if (start) {\n      selection.setPosition(this.#anchorNode, this.#anchorOffset);\n    } else {\n      selection.setPosition(this.#focusNode, this.#focusOffset);\n    }\n  }\n  select() {\n    super.select();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.updateProperties(this.#outlineId, {\n      rootClass: {\n        hovered: false,\n        selected: true\n      }\n    });\n  }\n  unselect() {\n    super.unselect();\n    if (!this.#outlineId) {\n      return;\n    }\n    this.parent?.drawLayer.updateProperties(this.#outlineId, {\n      rootClass: {\n        selected: false\n      }\n    });\n    if (!this.#isFreeHighlight) {\n      this.#setCaret(false);\n    }\n  }\n  get _mustFixPosition() {\n    return !this.#isFreeHighlight;\n  }\n  show(visible = this._isVisible) {\n    super.show(visible);\n    if (this.parent) {\n      this.parent.drawLayer.updateProperties(this.#id, {\n        rootClass: {\n          hidden: !visible\n        }\n      });\n      this.parent.drawLayer.updateProperties(this.#outlineId, {\n        rootClass: {\n          hidden: !visible\n        }\n      });\n    }\n  }\n  #getRotation() {\n    return this.#isFreeHighlight ? this.rotation : 0;\n  }\n  #serializeBoxes() {\n    if (this.#isFreeHighlight) {\n      return null;\n    }\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const boxes = this.#boxes;\n    const quadPoints = new Float32Array(boxes.length * 8);\n    let i = 0;\n    for (const {\n      x,\n      y,\n      width,\n      height\n    } of boxes) {\n      const sx = x * pageWidth + pageX;\n      const sy = (1 - y) * pageHeight + pageY;\n      quadPoints[i] = quadPoints[i + 4] = sx;\n      quadPoints[i + 1] = quadPoints[i + 3] = sy;\n      quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;\n      quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;\n      i += 8;\n    }\n    return quadPoints;\n  }\n  #serializeOutlines(rect) {\n    return this.#highlightOutlines.serialize(rect, this.#getRotation());\n  }\n  static startHighlighting(parent, isLTR, {\n    target: textLayer,\n    x,\n    y\n  }) {\n    const {\n      x: layerX,\n      y: layerY,\n      width: parentWidth,\n      height: parentHeight\n    } = textLayer.getBoundingClientRect();\n    const ac = new AbortController();\n    const signal = parent.combinedSignal(ac);\n    const pointerUpCallback = e => {\n      ac.abort();\n      this.#endHighlight(parent, e);\n    };\n    window.addEventListener(\"blur\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerup\", pointerUpCallback, {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", stopEvent, {\n      capture: true,\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    textLayer.addEventListener(\"pointermove\", this.#highlightMove.bind(this, parent), {\n      signal\n    });\n    this._freeHighlight = new FreeHighlightOutliner({\n      x,\n      y\n    }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 0.001);\n    ({\n      id: this._freeHighlightId,\n      clipPathId: this._freeHighlightClipId\n    } = parent.drawLayer.draw({\n      bbox: [0, 0, 1, 1],\n      root: {\n        viewBox: \"0 0 1 1\",\n        fill: this._defaultColor,\n        \"fill-opacity\": this._defaultOpacity\n      },\n      rootClass: {\n        highlight: true,\n        free: true\n      },\n      path: {\n        d: this._freeHighlight.toSVGPath()\n      }\n    }, true, true));\n  }\n  static #highlightMove(parent, event) {\n    if (this._freeHighlight.add(event)) {\n      parent.drawLayer.updateProperties(this._freeHighlightId, {\n        path: {\n          d: this._freeHighlight.toSVGPath()\n        }\n      });\n    }\n  }\n  static #endHighlight(parent, event) {\n    if (!this._freeHighlight.isEmpty()) {\n      parent.createAndAddNewEditor(event, false, {\n        highlightId: this._freeHighlightId,\n        highlightOutlines: this._freeHighlight.getOutlines(),\n        clipPathId: this._freeHighlightClipId,\n        methodOfCreation: \"main_toolbar\"\n      });\n    } else {\n      parent.drawLayer.remove(this._freeHighlightId);\n    }\n    this._freeHighlightId = -1;\n    this._freeHighlight = null;\n    this._freeHighlightClipId = \"\";\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof HighlightAnnotationElement) {\n      const {\n        data: {\n          quadPoints,\n          rect,\n          rotation,\n          id,\n          color,\n          opacity,\n          popupRef,\n          richText,\n          contentsObj,\n          creationDate,\n          modificationDate\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        opacity,\n        quadPoints,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        richText,\n        comment: contentsObj?.str || null,\n        creationDate,\n        modificationDate\n      };\n    } else if (data instanceof InkAnnotationElement) {\n      const {\n        data: {\n          inkLists,\n          rect,\n          rotation,\n          id,\n          color,\n          borderStyle: {\n            rawWidth: thickness\n          },\n          popupRef,\n          richText,\n          contentsObj,\n          creationDate,\n          modificationDate\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.HIGHLIGHT,\n        color: Array.from(color),\n        thickness,\n        inkLists,\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        richText,\n        comment: contentsObj?.str || null,\n        creationDate,\n        modificationDate\n      };\n    }\n    const {\n      color,\n      quadPoints,\n      inkLists,\n      opacity\n    } = data;\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.color = Util.makeHexColor(...color);\n    editor.opacity = opacity || 1;\n    if (inkLists) {\n      editor.#thickness = data.thickness;\n    }\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data);\n    }\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [pageX, pageY] = editor.pageTranslation;\n    if (quadPoints) {\n      const boxes = editor.#boxes = [];\n      for (let i = 0; i < quadPoints.length; i += 8) {\n        boxes.push({\n          x: (quadPoints[i] - pageX) / pageWidth,\n          y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,\n          width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,\n          height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight\n        });\n      }\n      editor.#createOutlines();\n      editor.#addToDrawLayer();\n      editor.rotate(editor.rotation);\n    } else if (inkLists) {\n      editor.#isFreeHighlight = true;\n      const points = inkLists[0];\n      const point = {\n        x: points[0] - pageX,\n        y: pageHeight - (points[1] - pageY)\n      };\n      const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 0.001);\n      for (let i = 0, ii = points.length; i < ii; i += 2) {\n        point.x = points[i] - pageX;\n        point.y = pageHeight - (points[i + 1] - pageY);\n        outliner.add(point);\n      }\n      const {\n        id,\n        clipPathId\n      } = parent.drawLayer.draw({\n        bbox: [0, 0, 1, 1],\n        root: {\n          viewBox: \"0 0 1 1\",\n          fill: editor.color,\n          \"fill-opacity\": editor._defaultOpacity\n        },\n        rootClass: {\n          highlight: true,\n          free: true\n        },\n        path: {\n          d: outliner.toSVGPath()\n        }\n      }, true, true);\n      editor.#createFreeOutlines({\n        highlightOutlines: outliner.getOutlines(),\n        highlightId: id,\n        clipPathId\n      });\n      editor.#addToDrawLayer();\n      editor.rotate(editor.parentRotation);\n    }\n    return editor;\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty() || isForCopying) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));\n    const serialized = super.serialize(isForCopying);\n    Object.assign(serialized, {\n      color,\n      opacity: this.opacity,\n      thickness: this.#thickness,\n      quadPoints: this.#serializeBoxes(),\n      outlines: this.#serializeOutlines(serialized.rect)\n    });\n    this.addComment(serialized);\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      color\n    } = this._initialData;\n    return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    annotation.updateEdited({\n      rect: this.getPDFRect(),\n      popup: this.comment\n    });\n    return null;\n  }\n  static canCreateNewEmptyEditor() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/draw.js\n\n\n\n\nclass DrawingOptions {\n  #svgProperties = Object.create(null);\n  updateProperty(name, value) {\n    this[name] = value;\n    this.updateSVGProperty(name, value);\n  }\n  updateProperties(properties) {\n    if (!properties) {\n      return;\n    }\n    for (const [name, value] of Object.entries(properties)) {\n      if (!name.startsWith(\"_\")) {\n        this.updateProperty(name, value);\n      }\n    }\n  }\n  updateSVGProperty(name, value) {\n    this.#svgProperties[name] = value;\n  }\n  toSVGProperties() {\n    const root = this.#svgProperties;\n    this.#svgProperties = Object.create(null);\n    return {\n      root\n    };\n  }\n  reset() {\n    this.#svgProperties = Object.create(null);\n  }\n  updateAll(options = this) {\n    this.updateProperties(options);\n  }\n  clone() {\n    unreachable(\"Not implemented\");\n  }\n}\nclass DrawingEditor extends AnnotationEditor {\n  #drawOutlines = null;\n  #mustBeCommitted;\n  _colorPicker = null;\n  _drawId = null;\n  static _currentDrawId = -1;\n  static _currentParent = null;\n  static #currentDraw = null;\n  static #currentDrawingAC = null;\n  static #currentDrawingOptions = null;\n  static _INNER_MARGIN = 3;\n  constructor(params) {\n    super(params);\n    this.#mustBeCommitted = params.mustBeCommitted || false;\n    this._addOutlines(params);\n  }\n  onUpdatedColor() {\n    this._colorPicker?.update(this.color);\n    super.onUpdatedColor();\n  }\n  _addOutlines(params) {\n    if (params.drawOutlines) {\n      this.#createDrawOutlines(params);\n      this.#addToDrawLayer();\n    }\n  }\n  #createDrawOutlines({\n    drawOutlines,\n    drawId,\n    drawingOptions\n  }) {\n    this.#drawOutlines = drawOutlines;\n    this._drawingOptions ||= drawingOptions;\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);\n    }\n    if (drawId >= 0) {\n      this._drawId = drawId;\n      this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);\n    } else {\n      this._drawId = this.#createDrawing(drawOutlines, this.parent);\n    }\n    this.#updateBbox(drawOutlines.box);\n  }\n  #createDrawing(drawOutlines, parent) {\n    const {\n      id\n    } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);\n    return id;\n  }\n  static _mergeSVGProperties(p1, p2) {\n    const p1Keys = new Set(Object.keys(p1));\n    for (const [key, value] of Object.entries(p2)) {\n      if (p1Keys.has(key)) {\n        Object.assign(p1[key], value);\n      } else {\n        p1[key] = value;\n      }\n    }\n    return p1;\n  }\n  static getDefaultDrawingOptions(_options) {\n    unreachable(\"Not implemented\");\n  }\n  static get typesMap() {\n    unreachable(\"Not implemented\");\n  }\n  static get isDrawer() {\n    return true;\n  }\n  static get supportMultipleDrawings() {\n    return false;\n  }\n  static updateDefaultParams(type, value) {\n    const propertyName = this.typesMap.get(type);\n    if (propertyName) {\n      this._defaultDrawingOptions.updateProperty(propertyName, value);\n    }\n    if (this._currentParent) {\n      DrawingEditor.#currentDraw.updateProperty(propertyName, value);\n      this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n    }\n  }\n  updateParams(type, value) {\n    const propertyName = this.constructor.typesMap.get(type);\n    if (propertyName) {\n      this._updateProperty(type, propertyName, value);\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    const properties = [];\n    const options = this._defaultDrawingOptions;\n    for (const [type, name] of this.typesMap) {\n      properties.push([type, options[name]]);\n    }\n    return properties;\n  }\n  get propertiesToUpdate() {\n    const properties = [];\n    const {\n      _drawingOptions\n    } = this;\n    for (const [type, name] of this.constructor.typesMap) {\n      properties.push([type, _drawingOptions[name]]);\n    }\n    return properties;\n  }\n  _updateProperty(type, name, value) {\n    const options = this._drawingOptions;\n    const savedValue = options[name];\n    const setter = val => {\n      options.updateProperty(name, val);\n      const bbox = this.#drawOutlines.updateProperty(name, val);\n      if (bbox) {\n        this.#updateBbox(bbox);\n      }\n      this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());\n      if (type === this.colorType) {\n        this.onUpdatedColor();\n      }\n    };\n    this.addCommands({\n      cmd: setter.bind(this, value),\n      undo: setter.bind(this, savedValue),\n      post: this._uiManager.updateUI.bind(this._uiManager, this),\n      mustExec: true,\n      type,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _onResizing() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onResized() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onTranslating(_x, _y) {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      bbox: this.#rotateBox()\n    });\n  }\n  _onTranslated() {\n    this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {\n      bbox: this.#rotateBox()\n    }));\n  }\n  _onStartDragging() {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      rootClass: {\n        moving: true\n      }\n    });\n  }\n  _onStopDragging() {\n    this.parent?.drawLayer.updateProperties(this._drawId, {\n      rootClass: {\n        moving: false\n      }\n    });\n  }\n  commit() {\n    super.commit();\n    this.disableEditMode();\n    this.disableEditing();\n  }\n  disableEditing() {\n    super.disableEditing();\n    this.div.classList.toggle(\"disabled\", true);\n  }\n  enableEditing() {\n    super.enableEditing();\n    this.div.classList.toggle(\"disabled\", false);\n  }\n  getBaseTranslation() {\n    return [0, 0];\n  }\n  get isResizable() {\n    return true;\n  }\n  onceAdded(focus) {\n    if (!this.annotationElementId) {\n      this.parent.addUndoableEditor(this);\n    }\n    this._isDraggable = true;\n    if (this.#mustBeCommitted) {\n      this.#mustBeCommitted = false;\n      this.commit();\n      this.parent.setSelected(this);\n      if (focus && this.isOnScreen) {\n        this.div.focus();\n      }\n    }\n  }\n  remove() {\n    this.#cleanDrawLayer();\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    this.#addToDrawLayer();\n    this.#updateBbox(this.#drawOutlines.box);\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  setParent(parent) {\n    let mustBeSelected = false;\n    if (this.parent && !parent) {\n      this._uiManager.removeShouldRescale(this);\n      this.#cleanDrawLayer();\n    } else if (parent) {\n      this._uiManager.addShouldRescale(this);\n      this.#addToDrawLayer(parent);\n      mustBeSelected = !this.parent && this.div?.classList.contains(\"selectedEditor\");\n    }\n    super.setParent(parent);\n    if (mustBeSelected) {\n      this.select();\n    }\n  }\n  #cleanDrawLayer() {\n    if (this._drawId === null || !this.parent) {\n      return;\n    }\n    this.parent.drawLayer.remove(this._drawId);\n    this._drawId = null;\n    this._drawingOptions.reset();\n  }\n  #addToDrawLayer(parent = this.parent) {\n    if (this._drawId !== null && this.parent === parent) {\n      return;\n    }\n    if (this._drawId !== null) {\n      this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);\n      return;\n    }\n    this._drawingOptions.updateAll();\n    this._drawId = this.#createDrawing(this.#drawOutlines, parent);\n  }\n  #convertToParentSpace([x, y, width, height]) {\n    const {\n      parentDimensions: [pW, pH],\n      rotation\n    } = this;\n    switch (rotation) {\n      case 90:\n        return [y, 1 - x, width * (pH / pW), height * (pW / pH)];\n      case 180:\n        return [1 - x, 1 - y, width, height];\n      case 270:\n        return [1 - y, x, width * (pH / pW), height * (pW / pH)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  #convertToDrawSpace() {\n    const {\n      x,\n      y,\n      width,\n      height,\n      parentDimensions: [pW, pH],\n      rotation\n    } = this;\n    switch (rotation) {\n      case 90:\n        return [1 - y, x, width * (pW / pH), height * (pH / pW)];\n      case 180:\n        return [1 - x, 1 - y, width, height];\n      case 270:\n        return [y, 1 - x, width * (pW / pH), height * (pH / pW)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  #updateBbox(bbox) {\n    [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);\n    if (this.div) {\n      this.fixAndSetPosition();\n      this.setDims();\n    }\n    this._onResized();\n  }\n  #rotateBox() {\n    const {\n      x,\n      y,\n      width,\n      height,\n      rotation,\n      parentRotation,\n      parentDimensions: [pW, pH]\n    } = this;\n    switch ((rotation * 4 + parentRotation) / 90) {\n      case 1:\n        return [1 - y - height, x, height, width];\n      case 2:\n        return [1 - x - width, 1 - y - height, width, height];\n      case 3:\n        return [y, 1 - x - width, height, width];\n      case 4:\n        return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];\n      case 5:\n        return [1 - y, x, width * (pW / pH), height * (pH / pW)];\n      case 6:\n        return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];\n      case 7:\n        return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];\n      case 8:\n        return [x - width, y - height, width, height];\n      case 9:\n        return [1 - y, x - width, height, width];\n      case 10:\n        return [1 - x, 1 - y, width, height];\n      case 11:\n        return [y - height, 1 - x, height, width];\n      case 12:\n        return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];\n      case 13:\n        return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];\n      case 14:\n        return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];\n      case 15:\n        return [y, 1 - x, width * (pW / pH), height * (pH / pW)];\n      default:\n        return [x, y, width, height];\n    }\n  }\n  rotate() {\n    if (!this.parent) {\n      return;\n    }\n    this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({\n      bbox: this.#rotateBox()\n    }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));\n  }\n  static onScaleChangingWhenDrawing() {}\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    const div = super.render();\n    div.classList.add(\"draw\");\n    const drawDiv = document.createElement(\"div\");\n    div.append(drawDiv);\n    drawDiv.setAttribute(\"aria-hidden\", \"true\");\n    drawDiv.className = \"internal\";\n    this.setDims();\n    this._uiManager.addShouldRescale(this);\n    this.disableEditing();\n    if (this._isCopy) {\n      this._moveAfterPaste(baseX, baseY);\n    }\n    return div;\n  }\n  static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {\n    unreachable(\"Not implemented\");\n  }\n  static startDrawing(parent, uiManager, _isLTR, event) {\n    const {\n      target,\n      offsetX: x,\n      offsetY: y,\n      pointerId,\n      pointerType\n    } = event;\n    if (CurrentPointers.isInitializedAndDifferentPointerType(pointerType)) {\n      return;\n    }\n    const {\n      viewport: {\n        rotation\n      }\n    } = parent;\n    const {\n      width: parentWidth,\n      height: parentHeight\n    } = target.getBoundingClientRect();\n    const ac = DrawingEditor.#currentDrawingAC = new AbortController();\n    const signal = parent.combinedSignal(ac);\n    CurrentPointers.setPointer(pointerType, pointerId);\n    window.addEventListener(\"pointerup\", e => {\n      if (CurrentPointers.isSamePointerIdOrRemove(e.pointerId)) {\n        this._endDraw(e);\n      }\n    }, {\n      signal\n    });\n    window.addEventListener(\"pointercancel\", e => {\n      if (CurrentPointers.isSamePointerIdOrRemove(e.pointerId)) {\n        this._currentParent.endDrawingSession();\n      }\n    }, {\n      signal\n    });\n    window.addEventListener(\"pointerdown\", e => {\n      if (!CurrentPointers.isSamePointerType(e.pointerType)) {\n        return;\n      }\n      CurrentPointers.initializeAndAddPointerId(e.pointerId);\n      if (DrawingEditor.#currentDraw.isCancellable()) {\n        DrawingEditor.#currentDraw.removeLastElement();\n        if (DrawingEditor.#currentDraw.isEmpty()) {\n          this._currentParent.endDrawingSession(true);\n        } else {\n          this._endDraw(null);\n        }\n      }\n    }, {\n      capture: true,\n      passive: false,\n      signal\n    });\n    window.addEventListener(\"contextmenu\", noContextMenu, {\n      signal\n    });\n    target.addEventListener(\"pointermove\", this._drawMove.bind(this), {\n      signal\n    });\n    target.addEventListener(\"touchmove\", e => {\n      if (CurrentPointers.isSameTimeStamp(e.timeStamp)) {\n        stopEvent(e);\n      }\n    }, {\n      signal\n    });\n    parent.toggleDrawing();\n    uiManager._editorUndoBar?.hide();\n    if (DrawingEditor.#currentDraw) {\n      parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));\n      return;\n    }\n    uiManager.updateUIForDefaultProperties(this);\n    DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);\n    DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();\n    this._currentParent = parent;\n    ({\n      id: this._currentDrawId\n    } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));\n  }\n  static _drawMove(event) {\n    CurrentPointers.isSameTimeStamp(event.timeStamp);\n    if (!DrawingEditor.#currentDraw) {\n      return;\n    }\n    const {\n      offsetX,\n      offsetY,\n      pointerId\n    } = event;\n    if (!CurrentPointers.isSamePointerId(pointerId)) {\n      return;\n    }\n    if (CurrentPointers.isUsingMultiplePointers()) {\n      this._endDraw(event);\n      return;\n    }\n    this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));\n    CurrentPointers.setTimeStamp(event.timeStamp);\n    stopEvent(event);\n  }\n  static _cleanup(all) {\n    if (all) {\n      this._currentDrawId = -1;\n      this._currentParent = null;\n      DrawingEditor.#currentDraw = null;\n      DrawingEditor.#currentDrawingOptions = null;\n      CurrentPointers.clearPointerType();\n      CurrentPointers.clearTimeStamp();\n    }\n    if (DrawingEditor.#currentDrawingAC) {\n      DrawingEditor.#currentDrawingAC.abort();\n      DrawingEditor.#currentDrawingAC = null;\n      CurrentPointers.clearPointerIds();\n    }\n  }\n  static _endDraw(event) {\n    const parent = this._currentParent;\n    if (!parent) {\n      return;\n    }\n    parent.toggleDrawing(true);\n    this._cleanup(false);\n    if (event?.target === parent.div) {\n      parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));\n    }\n    if (this.supportMultipleDrawings) {\n      const draw = DrawingEditor.#currentDraw;\n      const drawId = this._currentDrawId;\n      const lastElement = draw.getLastElement();\n      parent.addCommands({\n        cmd: () => {\n          parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));\n        },\n        undo: () => {\n          parent.drawLayer.updateProperties(drawId, draw.removeLastElement());\n        },\n        mustExec: false,\n        type: AnnotationEditorParamsType.DRAW_STEP\n      });\n      return;\n    }\n    this.endDrawing(false);\n  }\n  static endDrawing(isAborted) {\n    const parent = this._currentParent;\n    if (!parent) {\n      return null;\n    }\n    parent.toggleDrawing(true);\n    parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);\n    if (!DrawingEditor.#currentDraw.isEmpty()) {\n      const {\n        pageDimensions: [pageWidth, pageHeight],\n        scale\n      } = parent;\n      const editor = parent.createAndAddNewEditor({\n        offsetX: 0,\n        offsetY: 0\n      }, false, {\n        drawId: this._currentDrawId,\n        drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),\n        drawingOptions: DrawingEditor.#currentDrawingOptions,\n        mustBeCommitted: !isAborted\n      });\n      this._cleanup(true);\n      return editor;\n    }\n    parent.drawLayer.remove(this._currentDrawId);\n    this._cleanup(true);\n    return null;\n  }\n  createDrawingOptions(_data) {}\n  static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {\n    unreachable(\"Not implemented\");\n  }\n  static async deserialize(data, parent, uiManager) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = parent.viewport;\n    const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.createDrawingOptions(data);\n    editor.#createDrawOutlines({\n      drawOutlines\n    });\n    editor.#addToDrawLayer();\n    editor.onScaleChanging();\n    editor.rotate();\n    return editor;\n  }\n  serializeDraw(isForCopying) {\n    const [pageX, pageY] = this.pageTranslation;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);\n  }\n  renderAnnotationElement(annotation) {\n    annotation.updateEdited({\n      rect: this.getPDFRect()\n    });\n    return null;\n  }\n  static canCreateNewEmptyEditor() {\n    return false;\n  }\n}\n\n;// ./src/display/editor/drawers/inkdraw.js\n\n\nclass InkDrawOutliner {\n  #last = new Float64Array(6);\n  #line;\n  #lines;\n  #rotation;\n  #thickness;\n  #points;\n  #lastSVGPath = \"\";\n  #lastIndex = 0;\n  #outlines = new InkDrawOutline();\n  #parentWidth;\n  #parentHeight;\n  constructor(x, y, parentWidth, parentHeight, rotation, thickness) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#rotation = rotation;\n    this.#thickness = thickness;\n    [x, y] = this.#normalizePoint(x, y);\n    const line = this.#line = [NaN, NaN, NaN, NaN, x, y];\n    this.#points = [x, y];\n    this.#lines = [{\n      line,\n      points: this.#points\n    }];\n    this.#last.set(line, 0);\n  }\n  updateProperty(name, value) {\n    if (name === \"stroke-width\") {\n      this.#thickness = value;\n    }\n  }\n  #normalizePoint(x, y) {\n    return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);\n  }\n  isEmpty() {\n    return !this.#lines || this.#lines.length === 0;\n  }\n  isCancellable() {\n    return this.#points.length <= 10;\n  }\n  add(x, y) {\n    [x, y] = this.#normalizePoint(x, y);\n    const [x1, y1, x2, y2] = this.#last.subarray(2, 6);\n    const diffX = x - x2;\n    const diffY = y - y2;\n    const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);\n    if (d <= 2) {\n      return null;\n    }\n    this.#points.push(x, y);\n    if (isNaN(x1)) {\n      this.#last.set([x2, y2, x, y], 2);\n      this.#line.push(NaN, NaN, NaN, NaN, x, y);\n      return {\n        path: {\n          d: this.toSVGPath()\n        }\n      };\n    }\n    if (isNaN(this.#last[0])) {\n      this.#line.splice(6, 6);\n    }\n    this.#last.set([x1, y1, x2, y2, x, y], 0);\n    this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  end(x, y) {\n    const change = this.add(x, y);\n    if (change) {\n      return change;\n    }\n    if (this.#points.length === 2) {\n      return {\n        path: {\n          d: this.toSVGPath()\n        }\n      };\n    }\n    return null;\n  }\n  startNew(x, y, parentWidth, parentHeight, rotation) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#rotation = rotation;\n    [x, y] = this.#normalizePoint(x, y);\n    const line = this.#line = [NaN, NaN, NaN, NaN, x, y];\n    this.#points = [x, y];\n    const last = this.#lines.at(-1);\n    if (last) {\n      last.line = new Float32Array(last.line);\n      last.points = new Float32Array(last.points);\n    }\n    this.#lines.push({\n      line,\n      points: this.#points\n    });\n    this.#last.set(line, 0);\n    this.#lastIndex = 0;\n    this.toSVGPath();\n    return null;\n  }\n  getLastElement() {\n    return this.#lines.at(-1);\n  }\n  setLastElement(element) {\n    if (!this.#lines) {\n      return this.#outlines.setLastElement(element);\n    }\n    this.#lines.push(element);\n    this.#line = element.line;\n    this.#points = element.points;\n    this.#lastIndex = 0;\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  removeLastElement() {\n    if (!this.#lines) {\n      return this.#outlines.removeLastElement();\n    }\n    this.#lines.pop();\n    this.#lastSVGPath = \"\";\n    for (let i = 0, ii = this.#lines.length; i < ii; i++) {\n      const {\n        line,\n        points\n      } = this.#lines[i];\n      this.#line = line;\n      this.#points = points;\n      this.#lastIndex = 0;\n      this.toSVGPath();\n    }\n    return {\n      path: {\n        d: this.#lastSVGPath\n      }\n    };\n  }\n  toSVGPath() {\n    const firstX = Outline.svgRound(this.#line[4]);\n    const firstY = Outline.svgRound(this.#line[5]);\n    if (this.#points.length === 2) {\n      this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;\n      return this.#lastSVGPath;\n    }\n    if (this.#points.length <= 6) {\n      const i = this.#lastSVGPath.lastIndexOf(\"M\");\n      this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;\n      this.#lastIndex = 6;\n    }\n    if (this.#points.length === 4) {\n      const secondX = Outline.svgRound(this.#line[10]);\n      const secondY = Outline.svgRound(this.#line[11]);\n      this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;\n      this.#lastIndex = 12;\n      return this.#lastSVGPath;\n    }\n    const buffer = [];\n    if (this.#lastIndex === 0) {\n      buffer.push(`M ${firstX} ${firstY}`);\n      this.#lastIndex = 6;\n    }\n    for (let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6) {\n      const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);\n      buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n    }\n    this.#lastSVGPath += buffer.join(\" \");\n    this.#lastIndex = this.#line.length;\n    return this.#lastSVGPath;\n  }\n  getOutlines(parentWidth, parentHeight, scale, innerMargin) {\n    const last = this.#lines.at(-1);\n    last.line = new Float32Array(last.line);\n    last.points = new Float32Array(last.points);\n    this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);\n    this.#last = null;\n    this.#line = null;\n    this.#lines = null;\n    this.#lastSVGPath = null;\n    return this.#outlines;\n  }\n  get defaultSVGProperties() {\n    return {\n      root: {\n        viewBox: \"0 0 10000 10000\"\n      },\n      rootClass: {\n        draw: true\n      },\n      bbox: [0, 0, 1, 1]\n    };\n  }\n}\nclass InkDrawOutline extends Outline {\n  #bbox;\n  #currentRotation = 0;\n  #innerMargin;\n  #lines;\n  #parentWidth;\n  #parentHeight;\n  #parentScale;\n  #rotation;\n  #thickness;\n  build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {\n    this.#parentWidth = parentWidth;\n    this.#parentHeight = parentHeight;\n    this.#parentScale = parentScale;\n    this.#rotation = rotation;\n    this.#thickness = thickness;\n    this.#innerMargin = innerMargin ?? 0;\n    this.#lines = lines;\n    this.#computeBbox();\n  }\n  get thickness() {\n    return this.#thickness;\n  }\n  setLastElement(element) {\n    this.#lines.push(element);\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  removeLastElement() {\n    this.#lines.pop();\n    return {\n      path: {\n        d: this.toSVGPath()\n      }\n    };\n  }\n  toSVGPath() {\n    const buffer = [];\n    for (const {\n      line\n    } of this.#lines) {\n      buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);\n      if (line.length === 6) {\n        buffer.push(\"Z\");\n        continue;\n      }\n      if (line.length === 12 && isNaN(line[6])) {\n        buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);\n        continue;\n      }\n      for (let i = 6, ii = line.length; i < ii; i += 6) {\n        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);\n        buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);\n      }\n    }\n    return buffer.join(\"\");\n  }\n  serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {\n    const serializedLines = [];\n    const serializedPoints = [];\n    const [x, y, width, height] = this.#getBBoxWithNoMargin();\n    let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;\n    switch (this.#rotation) {\n      case 0:\n        rescaleFn = Outline._rescale;\n        tx = pageX;\n        ty = pageY + pageHeight;\n        sx = pageWidth;\n        sy = -pageHeight;\n        x1 = pageX + x * pageWidth;\n        y1 = pageY + (1 - y - height) * pageHeight;\n        x2 = pageX + (x + width) * pageWidth;\n        y2 = pageY + (1 - y) * pageHeight;\n        break;\n      case 90:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageX;\n        ty = pageY;\n        sx = pageWidth;\n        sy = pageHeight;\n        x1 = pageX + y * pageWidth;\n        y1 = pageY + x * pageHeight;\n        x2 = pageX + (y + height) * pageWidth;\n        y2 = pageY + (x + width) * pageHeight;\n        break;\n      case 180:\n        rescaleFn = Outline._rescale;\n        tx = pageX + pageWidth;\n        ty = pageY;\n        sx = -pageWidth;\n        sy = pageHeight;\n        x1 = pageX + (1 - x - width) * pageWidth;\n        y1 = pageY + y * pageHeight;\n        x2 = pageX + (1 - x) * pageWidth;\n        y2 = pageY + (y + height) * pageHeight;\n        break;\n      case 270:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageX + pageWidth;\n        ty = pageY + pageHeight;\n        sx = -pageWidth;\n        sy = -pageHeight;\n        x1 = pageX + (1 - y - height) * pageWidth;\n        y1 = pageY + (1 - x - width) * pageHeight;\n        x2 = pageX + (1 - y) * pageWidth;\n        y2 = pageY + (1 - x) * pageHeight;\n        break;\n    }\n    for (const {\n      line,\n      points\n    } of this.#lines) {\n      serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));\n      serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));\n    }\n    return {\n      lines: serializedLines,\n      points: serializedPoints,\n      rect: [x1, y1, x2, y2]\n    };\n  }\n  static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {\n    paths: {\n      lines,\n      points\n    },\n    rotation,\n    thickness\n  }) {\n    const newLines = [];\n    let tx, ty, sx, sy, rescaleFn;\n    switch (rotation) {\n      case 0:\n        rescaleFn = Outline._rescale;\n        tx = -pageX / pageWidth;\n        ty = pageY / pageHeight + 1;\n        sx = 1 / pageWidth;\n        sy = -1 / pageHeight;\n        break;\n      case 90:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = -pageY / pageHeight;\n        ty = -pageX / pageWidth;\n        sx = 1 / pageHeight;\n        sy = 1 / pageWidth;\n        break;\n      case 180:\n        rescaleFn = Outline._rescale;\n        tx = pageX / pageWidth + 1;\n        ty = -pageY / pageHeight;\n        sx = -1 / pageWidth;\n        sy = 1 / pageHeight;\n        break;\n      case 270:\n        rescaleFn = Outline._rescaleAndSwap;\n        tx = pageY / pageHeight + 1;\n        ty = pageX / pageWidth + 1;\n        sx = -1 / pageHeight;\n        sy = -1 / pageWidth;\n        break;\n    }\n    if (!lines) {\n      lines = [];\n      for (const point of points) {\n        const len = point.length;\n        if (len === 2) {\n          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));\n          continue;\n        }\n        if (len === 4) {\n          lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));\n          continue;\n        }\n        const line = new Float32Array(3 * (len - 2));\n        lines.push(line);\n        let [x1, y1, x2, y2] = point.subarray(0, 4);\n        line.set([NaN, NaN, NaN, NaN, x1, y1], 0);\n        for (let i = 4; i < len; i += 2) {\n          const x = point[i];\n          const y = point[i + 1];\n          line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n          [x1, y1, x2, y2] = [x2, y2, x, y];\n        }\n      }\n    }\n    for (let i = 0, ii = lines.length; i < ii; i++) {\n      newLines.push({\n        line: rescaleFn(lines[i].map(x => x ?? NaN), tx, ty, sx, sy),\n        points: rescaleFn(points[i].map(x => x ?? NaN), tx, ty, sx, sy)\n      });\n    }\n    const outlines = new this.prototype.constructor();\n    outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);\n    return outlines;\n  }\n  #getMarginComponents(thickness = this.#thickness) {\n    const margin = this.#innerMargin + thickness / 2 * this.#parentScale;\n    return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];\n  }\n  #getBBoxWithNoMargin() {\n    const [x, y, width, height] = this.#bbox;\n    const [marginX, marginY] = this.#getMarginComponents(0);\n    return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];\n  }\n  #computeBbox() {\n    const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);\n    for (const {\n      line\n    } of this.#lines) {\n      if (line.length <= 12) {\n        for (let i = 4, ii = line.length; i < ii; i += 6) {\n          Util.pointBoundingBox(line[i], line[i + 1], bbox);\n        }\n        continue;\n      }\n      let lastX = line[4],\n        lastY = line[5];\n      for (let i = 6, ii = line.length; i < ii; i += 6) {\n        const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);\n        Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);\n        lastX = x;\n        lastY = y;\n      }\n    }\n    const [marginX, marginY] = this.#getMarginComponents();\n    bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);\n    bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);\n    bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);\n    bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);\n    bbox[2] -= bbox[0];\n    bbox[3] -= bbox[1];\n  }\n  get box() {\n    return this.#bbox;\n  }\n  updateProperty(name, value) {\n    if (name === \"stroke-width\") {\n      return this.#updateThickness(value);\n    }\n    return null;\n  }\n  #updateThickness(thickness) {\n    const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n    this.#thickness = thickness;\n    const [newMarginX, newMarginY] = this.#getMarginComponents();\n    const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];\n    const bbox = this.#bbox;\n    bbox[0] -= diffMarginX;\n    bbox[1] -= diffMarginY;\n    bbox[2] += 2 * diffMarginX;\n    bbox[3] += 2 * diffMarginY;\n    return bbox;\n  }\n  updateParentDimensions([width, height], scale) {\n    const [oldMarginX, oldMarginY] = this.#getMarginComponents();\n    this.#parentWidth = width;\n    this.#parentHeight = height;\n    this.#parentScale = scale;\n    const [newMarginX, newMarginY] = this.#getMarginComponents();\n    const diffMarginX = newMarginX - oldMarginX;\n    const diffMarginY = newMarginY - oldMarginY;\n    const bbox = this.#bbox;\n    bbox[0] -= diffMarginX;\n    bbox[1] -= diffMarginY;\n    bbox[2] += 2 * diffMarginX;\n    bbox[3] += 2 * diffMarginY;\n    return bbox;\n  }\n  updateRotation(rotation) {\n    this.#currentRotation = rotation;\n    return {\n      path: {\n        transform: this.rotationTransform\n      }\n    };\n  }\n  get viewBox() {\n    return this.#bbox.map(Outline.svgRound).join(\" \");\n  }\n  get defaultProperties() {\n    const [x, y] = this.#bbox;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`\n      }\n    };\n  }\n  get rotationTransform() {\n    const [,, width, height] = this.#bbox;\n    let a = 0,\n      b = 0,\n      c = 0,\n      d = 0,\n      e = 0,\n      f = 0;\n    switch (this.#currentRotation) {\n      case 90:\n        b = height / width;\n        c = -width / height;\n        e = width;\n        break;\n      case 180:\n        a = -1;\n        d = -1;\n        e = width;\n        f = height;\n        break;\n      case 270:\n        b = -height / width;\n        c = width / height;\n        f = height;\n        break;\n      default:\n        return \"\";\n    }\n    return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;\n  }\n  getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {\n    const [marginX, marginY] = this.#getMarginComponents();\n    const [x, y, width, height] = this.#bbox;\n    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n      const tx = newX + newWidth / 2 - (x + width / 2);\n      const ty = newY + newHeight / 2 - (y + height / 2);\n      return {\n        path: {\n          \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n          transform: `${this.rotationTransform} translate(${tx} ${ty})`\n        }\n      };\n    }\n    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n    const s2x = width / newWidth;\n    const s2y = height / newHeight;\n    return {\n      path: {\n        \"transform-origin\": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,\n        transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`\n      }\n    };\n  }\n  getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {\n    const [marginX, marginY] = this.#getMarginComponents();\n    const bbox = this.#bbox;\n    const [x, y, width, height] = bbox;\n    bbox[0] = newX;\n    bbox[1] = newY;\n    bbox[2] = newWidth;\n    bbox[3] = newHeight;\n    if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {\n      const tx = newX + newWidth / 2 - (x + width / 2);\n      const ty = newY + newHeight / 2 - (y + height / 2);\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._translate(line, tx, ty, line);\n        Outline._translate(points, tx, ty, points);\n      }\n      return {\n        root: {\n          viewBox: this.viewBox\n        },\n        path: {\n          \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n          transform: this.rotationTransform || null,\n          d: this.toSVGPath()\n        }\n      };\n    }\n    const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);\n    const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);\n    const tx = -s1x * (x + marginX) + newX + marginX;\n    const ty = -s1y * (y + marginY) + newY + marginY;\n    if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._rescale(line, tx, ty, s1x, s1y, line);\n        Outline._rescale(points, tx, ty, s1x, s1y, points);\n      }\n    }\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,\n        transform: this.rotationTransform || null,\n        d: this.toSVGPath()\n      }\n    };\n  }\n  getPathTranslatedSVGProperties([newX, newY], parentDimensions) {\n    const [newParentWidth, newParentHeight] = parentDimensions;\n    const bbox = this.#bbox;\n    const tx = newX - bbox[0];\n    const ty = newY - bbox[1];\n    if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._translate(line, tx, ty, line);\n        Outline._translate(points, tx, ty, points);\n      }\n    } else {\n      const sx = this.#parentWidth / newParentWidth;\n      const sy = this.#parentHeight / newParentHeight;\n      this.#parentWidth = newParentWidth;\n      this.#parentHeight = newParentHeight;\n      for (const {\n        line,\n        points\n      } of this.#lines) {\n        Outline._rescale(line, tx, ty, sx, sy, line);\n        Outline._rescale(points, tx, ty, sx, sy, points);\n      }\n      bbox[2] *= sx;\n      bbox[3] *= sy;\n    }\n    bbox[0] = newX;\n    bbox[1] = newY;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      path: {\n        d: this.toSVGPath(),\n        \"transform-origin\": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`\n      }\n    };\n  }\n  get defaultSVGProperties() {\n    const bbox = this.#bbox;\n    return {\n      root: {\n        viewBox: this.viewBox\n      },\n      rootClass: {\n        draw: true\n      },\n      path: {\n        d: this.toSVGPath(),\n        \"transform-origin\": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,\n        transform: this.rotationTransform || null\n      },\n      bbox\n    };\n  }\n}\n\n;// ./src/display/editor/ink.js\n\n\n\n\n\n\nclass InkDrawingOptions extends DrawingOptions {\n  constructor(viewerParameters) {\n    super();\n    this._viewParameters = viewerParameters;\n    super.updateProperties({\n      fill: \"none\",\n      stroke: AnnotationEditor._defaultLineColor,\n      \"stroke-opacity\": 1,\n      \"stroke-width\": 1,\n      \"stroke-linecap\": \"round\",\n      \"stroke-linejoin\": \"round\",\n      \"stroke-miterlimit\": 10\n    });\n  }\n  updateSVGProperty(name, value) {\n    if (name === \"stroke-width\") {\n      value ??= this[\"stroke-width\"];\n      value *= this._viewParameters.realScale;\n    }\n    super.updateSVGProperty(name, value);\n  }\n  clone() {\n    const clone = new InkDrawingOptions(this._viewParameters);\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass InkEditor extends DrawingEditor {\n  static _type = \"ink\";\n  static _editorType = AnnotationEditorType.INK;\n  static _defaultDrawingOptions = null;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"inkEditor\"\n    });\n    this._willKeepAspectRatio = true;\n    this.defaultL10nId = \"pdfjs-editor-ink-editor\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);\n  }\n  static getDefaultDrawingOptions(options) {\n    const clone = this._defaultDrawingOptions.clone();\n    clone.updateProperties(options);\n    return clone;\n  }\n  static get supportMultipleDrawings() {\n    return true;\n  }\n  static get typesMap() {\n    return shadow(this, \"typesMap\", new Map([[AnnotationEditorParamsType.INK_THICKNESS, \"stroke-width\"], [AnnotationEditorParamsType.INK_COLOR, \"stroke\"], [AnnotationEditorParamsType.INK_OPACITY, \"stroke-opacity\"]]));\n  }\n  static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {\n    return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions[\"stroke-width\"]);\n  }\n  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof InkAnnotationElement) {\n      const {\n        data: {\n          inkLists,\n          rect,\n          rotation,\n          id,\n          color,\n          opacity,\n          borderStyle: {\n            rawWidth: thickness\n          },\n          popupRef,\n          richText,\n          contentsObj,\n          creationDate,\n          modificationDate\n        },\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      initialData = data = {\n        annotationType: AnnotationEditorType.INK,\n        color: Array.from(color),\n        thickness,\n        opacity,\n        paths: {\n          points: inkLists\n        },\n        boxes: null,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        popupRef,\n        richText,\n        comment: contentsObj?.str || null,\n        creationDate,\n        modificationDate\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data);\n    }\n    return editor;\n  }\n  get toolbarButtons() {\n    this._colorPicker ||= new BasicColorPicker(this);\n    return [[\"colorPicker\", this._colorPicker]];\n  }\n  get colorType() {\n    return AnnotationEditorParamsType.INK_COLOR;\n  }\n  get color() {\n    return this._drawingOptions.stroke;\n  }\n  get opacity() {\n    return this._drawingOptions[\"stroke-opacity\"];\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    super.onScaleChanging();\n    const {\n      _drawId,\n      _drawingOptions,\n      parent\n    } = this;\n    _drawingOptions.updateSVGProperty(\"stroke-width\");\n    parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());\n  }\n  static onScaleChangingWhenDrawing() {\n    const parent = this._currentParent;\n    if (!parent) {\n      return;\n    }\n    super.onScaleChangingWhenDrawing();\n    this._defaultDrawingOptions.updateSVGProperty(\"stroke-width\");\n    parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());\n  }\n  createDrawingOptions({\n    color,\n    thickness,\n    opacity\n  }) {\n    this._drawingOptions = InkEditor.getDefaultDrawingOptions({\n      stroke: Util.makeHexColor(...color),\n      \"stroke-width\": thickness,\n      \"stroke-opacity\": opacity\n    });\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const {\n      lines,\n      points\n    } = this.serializeDraw(isForCopying);\n    const {\n      _drawingOptions: {\n        stroke,\n        \"stroke-opacity\": opacity,\n        \"stroke-width\": thickness\n      }\n    } = this;\n    const serialized = Object.assign(super.serialize(isForCopying), {\n      color: AnnotationEditor._colorManager.convert(stroke),\n      opacity,\n      thickness,\n      paths: {\n        lines,\n        points\n      }\n    });\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.isCopy = true;\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      color,\n      thickness,\n      opacity,\n      pageIndex\n    } = this._initialData;\n    return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    const {\n      points,\n      rect\n    } = this.serializeDraw(false);\n    annotation.updateEdited({\n      rect,\n      thickness: this._drawingOptions[\"stroke-width\"],\n      points,\n      popup: this.comment\n    });\n    return null;\n  }\n}\n\n;// ./src/display/editor/drawers/contour.js\n\nclass ContourDrawOutline extends InkDrawOutline {\n  toSVGPath() {\n    let path = super.toSVGPath();\n    if (!path.endsWith(\"Z\")) {\n      path += \"Z\";\n    }\n    return path;\n  }\n}\n\n;// ./src/display/editor/drawers/signaturedraw.js\n\n\n\n\nconst BASE_HEADER_LENGTH = 8;\nconst POINTS_PROPERTIES_NUMBER = 3;\nclass SignatureExtractor {\n  static #PARAMETERS = {\n    maxDim: 512,\n    sigmaSFactor: 0.02,\n    sigmaR: 25,\n    kernelSize: 16\n  };\n  static #neighborIndexToId(i0, j0, i, j) {\n    i -= i0;\n    j -= j0;\n    if (i === 0) {\n      return j > 0 ? 0 : 4;\n    }\n    if (i === 1) {\n      return j + 6;\n    }\n    return 2 - j;\n  }\n  static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);\n  static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n    const id = this.#neighborIndexToId(i0, j0, i, j);\n    for (let k = 0; k < 8; k++) {\n      const kk = (-k + id - offset + 16) % 8;\n      const shiftI = this.#neighborIdToIndex[2 * kk];\n      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n        return kk;\n      }\n    }\n    return -1;\n  }\n  static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {\n    const id = this.#neighborIndexToId(i0, j0, i, j);\n    for (let k = 0; k < 8; k++) {\n      const kk = (k + id + offset + 16) % 8;\n      const shiftI = this.#neighborIdToIndex[2 * kk];\n      const shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n      if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {\n        return kk;\n      }\n    }\n    return -1;\n  }\n  static #findContours(buf, width, height, threshold) {\n    const N = buf.length;\n    const types = new Int32Array(N);\n    for (let i = 0; i < N; i++) {\n      types[i] = buf[i] <= threshold ? 1 : 0;\n    }\n    for (let i = 1; i < height - 1; i++) {\n      types[i * width] = types[i * width + width - 1] = 0;\n    }\n    for (let i = 0; i < width; i++) {\n      types[i] = types[width * height - 1 - i] = 0;\n    }\n    let nbd = 1;\n    let lnbd;\n    const contours = [];\n    for (let i = 1; i < height - 1; i++) {\n      lnbd = 1;\n      for (let j = 1; j < width - 1; j++) {\n        const ij = i * width + j;\n        const pix = types[ij];\n        if (pix === 0) {\n          continue;\n        }\n        let i2 = i;\n        let j2 = j;\n        if (pix === 1 && types[ij - 1] === 0) {\n          nbd += 1;\n          j2 -= 1;\n        } else if (pix >= 1 && types[ij + 1] === 0) {\n          nbd += 1;\n          j2 += 1;\n          if (pix > 1) {\n            lnbd = pix;\n          }\n        } else {\n          if (pix !== 1) {\n            lnbd = Math.abs(pix);\n          }\n          continue;\n        }\n        const points = [j, i];\n        const isHole = j2 === j + 1;\n        const contour = {\n          isHole,\n          points,\n          id: nbd,\n          parent: 0\n        };\n        contours.push(contour);\n        let contour0;\n        for (const c of contours) {\n          if (c.id === lnbd) {\n            contour0 = c;\n            break;\n          }\n        }\n        if (!contour0) {\n          contour.parent = isHole ? lnbd : 0;\n        } else if (contour0.isHole) {\n          contour.parent = isHole ? contour0.parent : lnbd;\n        } else {\n          contour.parent = isHole ? lnbd : contour0.parent;\n        }\n        const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);\n        if (k === -1) {\n          types[ij] = -nbd;\n          if (types[ij] !== 1) {\n            lnbd = Math.abs(types[ij]);\n          }\n          continue;\n        }\n        let shiftI = this.#neighborIdToIndex[2 * k];\n        let shiftJ = this.#neighborIdToIndex[2 * k + 1];\n        const i1 = i + shiftI;\n        const j1 = j + shiftJ;\n        i2 = i1;\n        j2 = j1;\n        let i3 = i;\n        let j3 = j;\n        while (true) {\n          const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);\n          shiftI = this.#neighborIdToIndex[2 * kk];\n          shiftJ = this.#neighborIdToIndex[2 * kk + 1];\n          const i4 = i3 + shiftI;\n          const j4 = j3 + shiftJ;\n          points.push(j4, i4);\n          const ij3 = i3 * width + j3;\n          if (types[ij3 + 1] === 0) {\n            types[ij3] = -nbd;\n          } else if (types[ij3] === 1) {\n            types[ij3] = nbd;\n          }\n          if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {\n            if (types[ij] !== 1) {\n              lnbd = Math.abs(types[ij]);\n            }\n            break;\n          } else {\n            i2 = i3;\n            j2 = j3;\n            i3 = i4;\n            j3 = j4;\n          }\n        }\n      }\n    }\n    return contours;\n  }\n  static #douglasPeuckerHelper(points, start, end, output) {\n    if (end - start <= 4) {\n      for (let i = start; i < end - 2; i += 2) {\n        output.push(points[i], points[i + 1]);\n      }\n      return;\n    }\n    const ax = points[start];\n    const ay = points[start + 1];\n    const abx = points[end - 4] - ax;\n    const aby = points[end - 3] - ay;\n    const dist = Math.hypot(abx, aby);\n    const nabx = abx / dist;\n    const naby = aby / dist;\n    const aa = nabx * ay - naby * ax;\n    const m = aby / abx;\n    const invS = 1 / dist;\n    const phi = Math.atan(m);\n    const cosPhi = Math.cos(phi);\n    const sinPhi = Math.sin(phi);\n    const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));\n    const poly = invS * (1 - tmax + tmax ** 2);\n    const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));\n    let dmax = 0;\n    let index = start;\n    for (let i = start + 2; i < end - 2; i += 2) {\n      const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);\n      if (d > dmax) {\n        index = i;\n        dmax = d;\n      }\n    }\n    if (dmax > (dist * partialPhi) ** 2) {\n      this.#douglasPeuckerHelper(points, start, index + 2, output);\n      this.#douglasPeuckerHelper(points, index, end, output);\n    } else {\n      output.push(ax, ay);\n    }\n  }\n  static #douglasPeucker(points) {\n    const output = [];\n    const len = points.length;\n    this.#douglasPeuckerHelper(points, 0, len, output);\n    output.push(points[len - 2], points[len - 1]);\n    return output.length <= 4 ? null : output;\n  }\n  static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {\n    const kernel = new Float32Array(kernelSize ** 2);\n    const sigmaS2 = -2 * sigmaS ** 2;\n    const halfSize = kernelSize >> 1;\n    for (let i = 0; i < kernelSize; i++) {\n      const x = (i - halfSize) ** 2;\n      for (let j = 0; j < kernelSize; j++) {\n        kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);\n      }\n    }\n    const rangeValues = new Float32Array(256);\n    const sigmaR2 = -2 * sigmaR ** 2;\n    for (let i = 0; i < 256; i++) {\n      rangeValues[i] = Math.exp(i ** 2 / sigmaR2);\n    }\n    const N = buf.length;\n    const out = new Uint8Array(N);\n    const histogram = new Uint32Array(256);\n    for (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n        const ij = i * width + j;\n        const center = buf[ij];\n        let sum = 0;\n        let norm = 0;\n        for (let k = 0; k < kernelSize; k++) {\n          const y = i + k - halfSize;\n          if (y < 0 || y >= height) {\n            continue;\n          }\n          for (let l = 0; l < kernelSize; l++) {\n            const x = j + l - halfSize;\n            if (x < 0 || x >= width) {\n              continue;\n            }\n            const neighbour = buf[y * width + x];\n            const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];\n            sum += neighbour * w;\n            norm += w;\n          }\n        }\n        const pix = out[ij] = Math.round(sum / norm);\n        histogram[pix]++;\n      }\n    }\n    return [out, histogram];\n  }\n  static #getHistogram(buf) {\n    const histogram = new Uint32Array(256);\n    for (const g of buf) {\n      histogram[g]++;\n    }\n    return histogram;\n  }\n  static #toUint8(buf) {\n    const N = buf.length;\n    const out = new Uint8ClampedArray(N >> 2);\n    let max = -Infinity;\n    let min = Infinity;\n    for (let i = 0, ii = out.length; i < ii; i++) {\n      const pix = out[i] = buf[i << 2];\n      max = Math.max(max, pix);\n      min = Math.min(min, pix);\n    }\n    const ratio = 255 / (max - min);\n    for (let i = 0, ii = out.length; i < ii; i++) {\n      out[i] = (out[i] - min) * ratio;\n    }\n    return out;\n  }\n  static #guessThreshold(histogram) {\n    let i;\n    let M = -Infinity;\n    let L = -Infinity;\n    const min = histogram.findIndex(v => v !== 0);\n    let pos = min;\n    let spos = min;\n    for (i = min; i < 256; i++) {\n      const v = histogram[i];\n      if (v > M) {\n        if (i - pos > L) {\n          L = i - pos;\n          spos = i - 1;\n        }\n        M = v;\n        pos = i;\n      }\n    }\n    for (i = spos - 1; i >= 0; i--) {\n      if (histogram[i] > histogram[i + 1]) {\n        break;\n      }\n    }\n    return i;\n  }\n  static #getGrayPixels(bitmap) {\n    const originalBitmap = bitmap;\n    const {\n      width,\n      height\n    } = bitmap;\n    const {\n      maxDim\n    } = this.#PARAMETERS;\n    let newWidth = width;\n    let newHeight = height;\n    if (width > maxDim || height > maxDim) {\n      let prevWidth = width;\n      let prevHeight = height;\n      let steps = Math.log2(Math.max(width, height) / maxDim);\n      const isteps = Math.floor(steps);\n      steps = steps === isteps ? isteps - 1 : isteps;\n      for (let i = 0; i < steps; i++) {\n        newWidth = Math.ceil(prevWidth / 2);\n        newHeight = Math.ceil(prevHeight / 2);\n        const offscreen = new OffscreenCanvas(newWidth, newHeight);\n        const ctx = offscreen.getContext(\"2d\");\n        ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n        prevWidth = newWidth;\n        prevHeight = newHeight;\n        if (bitmap !== originalBitmap) {\n          bitmap.close();\n        }\n        bitmap = offscreen.transferToImageBitmap();\n      }\n      const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);\n      newWidth = Math.round(newWidth * ratio);\n      newHeight = Math.round(newHeight * ratio);\n    }\n    const offscreen = new OffscreenCanvas(newWidth, newHeight);\n    const ctx = offscreen.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, newWidth, newHeight);\n    ctx.filter = \"grayscale(1)\";\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);\n    const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;\n    const uint8Buf = this.#toUint8(grayImage);\n    return [uint8Buf, newWidth, newHeight];\n  }\n  static extractContoursFromText(text, {\n    fontFamily,\n    fontStyle,\n    fontWeight\n  }, pageWidth, pageHeight, rotation, innerMargin) {\n    let canvas = new OffscreenCanvas(1, 1);\n    let ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n    const fontSize = 200;\n    const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;\n    const {\n      actualBoundingBoxLeft,\n      actualBoundingBoxRight,\n      actualBoundingBoxAscent,\n      actualBoundingBoxDescent,\n      fontBoundingBoxAscent,\n      fontBoundingBoxDescent,\n      width\n    } = ctx.measureText(text);\n    const SCALE = 1.5;\n    const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);\n    const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);\n    canvas = new OffscreenCanvas(canvasWidth, canvasHeight);\n    ctx = canvas.getContext(\"2d\", {\n      alpha: true,\n      willReadFrequently: true\n    });\n    ctx.font = font;\n    ctx.filter = \"grayscale(1)\";\n    ctx.fillStyle = \"white\";\n    ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n    ctx.fillStyle = \"black\";\n    ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);\n    const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);\n    const histogram = this.#getHistogram(uint8Buf);\n    const threshold = this.#guessThreshold(histogram);\n    const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);\n    return this.processDrawnLines({\n      lines: {\n        curves: contourList,\n        width: canvasWidth,\n        height: canvasHeight\n      },\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin,\n      mustSmooth: true,\n      areContours: true\n    });\n  }\n  static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {\n    const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);\n    const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);\n    const threshold = this.#guessThreshold(histogram);\n    const contourList = this.#findContours(buffer, width, height, threshold);\n    return this.processDrawnLines({\n      lines: {\n        curves: contourList,\n        width,\n        height\n      },\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin,\n      mustSmooth: true,\n      areContours: true\n    });\n  }\n  static processDrawnLines({\n    lines,\n    pageWidth,\n    pageHeight,\n    rotation,\n    innerMargin,\n    mustSmooth,\n    areContours\n  }) {\n    if (rotation % 180 !== 0) {\n      [pageWidth, pageHeight] = [pageHeight, pageWidth];\n    }\n    const {\n      curves,\n      width,\n      height\n    } = lines;\n    const thickness = lines.thickness ?? 0;\n    const linesAndPoints = [];\n    const ratio = Math.min(pageWidth / width, pageHeight / height);\n    const xScale = ratio / pageWidth;\n    const yScale = ratio / pageHeight;\n    const newCurves = [];\n    for (const {\n      points\n    } of curves) {\n      const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;\n      if (!reducedPoints) {\n        continue;\n      }\n      newCurves.push(reducedPoints);\n      const len = reducedPoints.length;\n      const newPoints = new Float32Array(len);\n      const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));\n      linesAndPoints.push({\n        line,\n        points: newPoints\n      });\n      if (len === 2) {\n        newPoints[0] = reducedPoints[0] * xScale;\n        newPoints[1] = reducedPoints[1] * yScale;\n        line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);\n        continue;\n      }\n      let [x1, y1, x2, y2] = reducedPoints;\n      x1 *= xScale;\n      y1 *= yScale;\n      x2 *= xScale;\n      y2 *= yScale;\n      newPoints.set([x1, y1, x2, y2], 0);\n      line.set([NaN, NaN, NaN, NaN, x1, y1], 0);\n      for (let i = 4; i < len; i += 2) {\n        const x = newPoints[i] = reducedPoints[i] * xScale;\n        const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;\n        line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);\n        [x1, y1, x2, y2] = [x2, y2, x, y];\n      }\n    }\n    if (linesAndPoints.length === 0) {\n      return null;\n    }\n    const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();\n    outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);\n    return {\n      outline,\n      newCurves,\n      areContours,\n      thickness,\n      width,\n      height\n    };\n  }\n  static async compressSignature({\n    outlines,\n    areContours,\n    thickness,\n    width,\n    height\n  }) {\n    let minDiff = Infinity;\n    let maxDiff = -Infinity;\n    let outlinesLength = 0;\n    for (const points of outlines) {\n      outlinesLength += points.length;\n      for (let i = 2, ii = points.length; i < ii; i++) {\n        const dx = points[i] - points[i - 2];\n        minDiff = Math.min(minDiff, dx);\n        maxDiff = Math.max(maxDiff, dx);\n      }\n    }\n    let bufferType;\n    if (minDiff >= -128 && maxDiff <= 127) {\n      bufferType = Int8Array;\n    } else if (minDiff >= -32768 && maxDiff <= 32767) {\n      bufferType = Int16Array;\n    } else {\n      bufferType = Int32Array;\n    }\n    const len = outlines.length;\n    const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;\n    const header = new Uint32Array(headerLength);\n    let offset = 0;\n    header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;\n    header[offset++] = 0;\n    header[offset++] = width;\n    header[offset++] = height;\n    header[offset++] = areContours ? 0 : 1;\n    header[offset++] = Math.max(0, Math.floor(thickness ?? 0));\n    header[offset++] = len;\n    header[offset++] = bufferType.BYTES_PER_ELEMENT;\n    for (const points of outlines) {\n      header[offset++] = points.length - 2;\n      header[offset++] = points[0];\n      header[offset++] = points[1];\n    }\n    const cs = new CompressionStream(\"deflate-raw\");\n    const writer = cs.writable.getWriter();\n    await writer.ready;\n    writer.write(header);\n    const BufferCtor = bufferType.prototype.constructor;\n    for (const points of outlines) {\n      const diffs = new BufferCtor(points.length - 2);\n      for (let i = 2, ii = points.length; i < ii; i++) {\n        diffs[i - 2] = points[i] - points[i - 2];\n      }\n      writer.write(diffs);\n    }\n    writer.close();\n    const buf = await new Response(cs.readable).arrayBuffer();\n    const bytes = new Uint8Array(buf);\n    return toBase64Util(bytes);\n  }\n  static async decompressSignature(signatureData) {\n    try {\n      const bytes = fromBase64Util(signatureData);\n      const {\n        readable,\n        writable\n      } = new DecompressionStream(\"deflate-raw\");\n      const writer = writable.getWriter();\n      await writer.ready;\n      writer.write(bytes).then(async () => {\n        await writer.ready;\n        await writer.close();\n      }).catch(() => {});\n      let data = null;\n      let offset = 0;\n      for await (const chunk of readable) {\n        data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);\n        data.set(chunk, offset);\n        offset += chunk.length;\n      }\n      const header = new Uint32Array(data.buffer, 0, data.length >> 2);\n      const version = header[1];\n      if (version !== 0) {\n        throw new Error(`Invalid version: ${version}`);\n      }\n      const width = header[2];\n      const height = header[3];\n      const areContours = header[4] === 0;\n      const thickness = header[5];\n      const numberOfDrawings = header[6];\n      const bufferType = header[7];\n      const outlines = [];\n      const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;\n      let diffs;\n      switch (bufferType) {\n        case Int8Array.BYTES_PER_ELEMENT:\n          diffs = new Int8Array(data.buffer, diffsOffset);\n          break;\n        case Int16Array.BYTES_PER_ELEMENT:\n          diffs = new Int16Array(data.buffer, diffsOffset);\n          break;\n        case Int32Array.BYTES_PER_ELEMENT:\n          diffs = new Int32Array(data.buffer, diffsOffset);\n          break;\n      }\n      offset = 0;\n      for (let i = 0; i < numberOfDrawings; i++) {\n        const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];\n        const points = new Float32Array(len + 2);\n        outlines.push(points);\n        for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {\n          points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];\n        }\n        for (let j = 0; j < len; j++) {\n          points[j + 2] = points[j] + diffs[offset++];\n        }\n      }\n      return {\n        areContours,\n        thickness,\n        outlines,\n        width,\n        height\n      };\n    } catch (e) {\n      warn(`decompressSignature: ${e}`);\n      return null;\n    }\n  }\n}\n\n;// ./src/display/editor/signature.js\n\n\n\n\n\n\n\nclass SignatureOptions extends DrawingOptions {\n  constructor() {\n    super();\n    super.updateProperties({\n      fill: AnnotationEditor._defaultLineColor,\n      \"stroke-width\": 0\n    });\n  }\n  clone() {\n    const clone = new SignatureOptions();\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass DrawnSignatureOptions extends InkDrawingOptions {\n  constructor(viewerParameters) {\n    super(viewerParameters);\n    super.updateProperties({\n      stroke: AnnotationEditor._defaultLineColor,\n      \"stroke-width\": 1\n    });\n  }\n  clone() {\n    const clone = new DrawnSignatureOptions(this._viewParameters);\n    clone.updateAll(this);\n    return clone;\n  }\n}\nclass SignatureEditor extends DrawingEditor {\n  #isExtracted = false;\n  #description = null;\n  #signatureData = null;\n  #signatureUUID = null;\n  static _type = \"signature\";\n  static _editorType = AnnotationEditorType.SIGNATURE;\n  static _defaultDrawingOptions = null;\n  constructor(params) {\n    super({\n      ...params,\n      mustBeCommitted: true,\n      name: \"signatureEditor\"\n    });\n    this._willKeepAspectRatio = true;\n    this.#signatureData = params.signatureData || null;\n    this.#description = null;\n    this.defaultL10nId = \"pdfjs-editor-signature-editor1\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n    this._defaultDrawingOptions = new SignatureOptions();\n    this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);\n  }\n  static getDefaultDrawingOptions(options) {\n    const clone = this._defaultDrawingOptions.clone();\n    clone.updateProperties(options);\n    return clone;\n  }\n  static get supportMultipleDrawings() {\n    return false;\n  }\n  static get typesMap() {\n    return shadow(this, \"typesMap\", new Map());\n  }\n  static get isDrawer() {\n    return false;\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"signature\",\n      hasDescription: !!this.#description\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    const hasDescriptionStats = data.get(\"hasDescription\");\n    return {\n      hasAltText: hasDescriptionStats.get(true) ?? 0,\n      hasNoAltText: hasDescriptionStats.get(false) ?? 0\n    };\n  }\n  get isResizable() {\n    return true;\n  }\n  onScaleChanging() {\n    if (this._drawId === null) {\n      return;\n    }\n    super.onScaleChanging();\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    const {\n      _isCopy\n    } = this;\n    if (_isCopy) {\n      this._isCopy = false;\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    if (this._drawId === null) {\n      if (this.#signatureData) {\n        const {\n          lines,\n          mustSmooth,\n          areContours,\n          description,\n          uuid,\n          heightInPage\n        } = this.#signatureData;\n        const {\n          rawDims: {\n            pageWidth,\n            pageHeight\n          },\n          rotation\n        } = this.parent.viewport;\n        const outline = SignatureExtractor.processDrawnLines({\n          lines,\n          pageWidth,\n          pageHeight,\n          rotation,\n          innerMargin: SignatureEditor._INNER_MARGIN,\n          mustSmooth,\n          areContours\n        });\n        this.addSignature(outline, heightInPage, description, uuid);\n      } else {\n        this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n          description: \"\"\n        }));\n        this.div.hidden = true;\n        this._uiManager.getSignature(this);\n      }\n    } else {\n      this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n        description: this.#description || \"\"\n      }));\n    }\n    if (_isCopy) {\n      this._isCopy = true;\n      this._moveAfterPaste(baseX, baseY);\n    }\n    return this.div;\n  }\n  setUuid(uuid) {\n    this.#signatureUUID = uuid;\n    this.addEditToolbar();\n  }\n  getUuid() {\n    return this.#signatureUUID;\n  }\n  get description() {\n    return this.#description;\n  }\n  set description(description) {\n    this.#description = description;\n    if (!this.div) {\n      return;\n    }\n    this.div.setAttribute(\"data-l10n-args\", JSON.stringify({\n      description\n    }));\n    super.addEditToolbar().then(toolbar => {\n      toolbar?.updateEditSignatureButton(description);\n    });\n  }\n  getSignaturePreview() {\n    const {\n      newCurves,\n      areContours,\n      thickness,\n      width,\n      height\n    } = this.#signatureData;\n    const maxDim = Math.max(width, height);\n    const outlineData = SignatureExtractor.processDrawnLines({\n      lines: {\n        curves: newCurves.map(points => ({\n          points\n        })),\n        thickness,\n        width,\n        height\n      },\n      pageWidth: maxDim,\n      pageHeight: maxDim,\n      rotation: 0,\n      innerMargin: 0,\n      mustSmooth: false,\n      areContours\n    });\n    return {\n      areContours,\n      outline: outlineData.outline\n    };\n  }\n  get toolbarButtons() {\n    if (this._uiManager.signatureManager) {\n      return [[\"editSignature\", this._uiManager.signatureManager]];\n    }\n    return super.toolbarButtons;\n  }\n  addSignature(data, heightInPage, description, uuid) {\n    const {\n      x: savedX,\n      y: savedY\n    } = this;\n    const {\n      outline\n    } = this.#signatureData = data;\n    this.#isExtracted = outline instanceof ContourDrawOutline;\n    this.description = description;\n    let drawingOptions;\n    if (this.#isExtracted) {\n      drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n    } else {\n      drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n      drawingOptions.updateProperties({\n        \"stroke-width\": outline.thickness\n      });\n    }\n    this._addOutlines({\n      drawOutlines: outline,\n      drawingOptions\n    });\n    const [, pageHeight] = this.pageDimensions;\n    let newHeight = heightInPage / pageHeight;\n    newHeight = newHeight >= 1 ? 0.5 : newHeight;\n    this.width *= newHeight / this.height;\n    if (this.width >= 1) {\n      newHeight *= 0.9 / this.width;\n      this.width = 0.9;\n    }\n    this.height = newHeight;\n    this.setDims();\n    this.x = savedX;\n    this.y = savedY;\n    this.center();\n    this._onResized();\n    this.onScaleChanging();\n    this.rotate();\n    this._uiManager.addToAnnotationStorage(this);\n    this.setUuid(uuid);\n    this._reportTelemetry({\n      action: \"pdfjs.signature.inserted\",\n      data: {\n        hasBeenSaved: !!uuid,\n        hasDescription: !!description\n      }\n    });\n    this.div.hidden = false;\n  }\n  getFromImage(bitmap) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n  }\n  getFromText(text, fontInfo) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);\n  }\n  getDrawnSignature(curves) {\n    const {\n      rawDims: {\n        pageWidth,\n        pageHeight\n      },\n      rotation\n    } = this.parent.viewport;\n    return SignatureExtractor.processDrawnLines({\n      lines: curves,\n      pageWidth,\n      pageHeight,\n      rotation,\n      innerMargin: SignatureEditor._INNER_MARGIN,\n      mustSmooth: false,\n      areContours: false\n    });\n  }\n  createDrawingOptions({\n    areContours,\n    thickness\n  }) {\n    if (areContours) {\n      this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();\n    } else {\n      this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();\n      this._drawingOptions.updateProperties({\n        \"stroke-width\": thickness\n      });\n    }\n  }\n  serialize(isForCopying = false) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const {\n      lines,\n      points\n    } = this.serializeDraw(isForCopying);\n    const {\n      _drawingOptions: {\n        \"stroke-width\": thickness\n      }\n    } = this;\n    const serialized = Object.assign(super.serialize(isForCopying), {\n      isSignature: true,\n      areContours: this.#isExtracted,\n      color: [0, 0, 0],\n      thickness: this.#isExtracted ? 0 : thickness\n    });\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.paths = {\n        lines,\n        points\n      };\n      serialized.uuid = this.#signatureUUID;\n      serialized.isCopy = true;\n    } else {\n      serialized.lines = lines;\n    }\n    if (this.#description) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: this.#description\n      };\n    }\n    return serialized;\n  }\n  static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {\n    if (data.areContours) {\n      return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n    }\n    return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);\n  }\n  static async deserialize(data, parent, uiManager) {\n    const editor = await super.deserialize(data, parent, uiManager);\n    editor.#isExtracted = data.areContours;\n    editor.description = data.accessibilityData?.alt || \"\";\n    editor.#signatureUUID = data.uuid;\n    return editor;\n  }\n}\n\n;// ./src/display/editor/stamp.js\n\n\n\n\nclass StampEditor extends AnnotationEditor {\n  #bitmap = null;\n  #bitmapId = null;\n  #bitmapPromise = null;\n  #bitmapUrl = null;\n  #bitmapFile = null;\n  #bitmapFileName = \"\";\n  #canvas = null;\n  #missingCanvas = false;\n  #resizeTimeoutId = null;\n  #isSvg = false;\n  #hasBeenAddedInUndoStack = false;\n  static _type = \"stamp\";\n  static _editorType = AnnotationEditorType.STAMP;\n  constructor(params) {\n    super({\n      ...params,\n      name: \"stampEditor\"\n    });\n    this.#bitmapUrl = params.bitmapUrl;\n    this.#bitmapFile = params.bitmapFile;\n    this.defaultL10nId = \"pdfjs-editor-stamp-editor\";\n  }\n  static initialize(l10n, uiManager) {\n    AnnotationEditor.initialize(l10n, uiManager);\n  }\n  static isHandlingMimeForPasting(mime) {\n    return SupportedImageMimeTypes.includes(mime);\n  }\n  static paste(item, parent) {\n    parent.pasteEditor({\n      mode: AnnotationEditorType.STAMP\n    }, {\n      bitmapFile: item.getAsFile()\n    });\n  }\n  altTextFinish() {\n    if (this._uiManager.useNewAltTextFlow) {\n      this.div.hidden = false;\n    }\n    super.altTextFinish();\n  }\n  get telemetryFinalData() {\n    return {\n      type: \"stamp\",\n      hasAltText: !!this.altTextData?.altText\n    };\n  }\n  static computeTelemetryFinalData(data) {\n    const hasAltTextStats = data.get(\"hasAltText\");\n    return {\n      hasAltText: hasAltTextStats.get(true) ?? 0,\n      hasNoAltText: hasAltTextStats.get(false) ?? 0\n    };\n  }\n  #getBitmapFetched(data, fromId = false) {\n    if (!data) {\n      this.remove();\n      return;\n    }\n    this.#bitmap = data.bitmap;\n    if (!fromId) {\n      this.#bitmapId = data.id;\n      this.#isSvg = data.isSvg;\n    }\n    if (data.file) {\n      this.#bitmapFileName = data.file.name;\n    }\n    this.#createCanvas();\n  }\n  #getBitmapDone() {\n    this.#bitmapPromise = null;\n    this._uiManager.enableWaiting(false);\n    if (!this.#canvas) {\n      return;\n    }\n    if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this.addEditToolbar().then(() => {\n        this._editToolbar.hide();\n        this._uiManager.editAltText(this, true);\n      });\n      return;\n    }\n    if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {\n      this._reportTelemetry({\n        action: \"pdfjs.image.image_added\",\n        data: {\n          alt_text_modal: false,\n          alt_text_type: \"empty\"\n        }\n      });\n      try {\n        this.mlGuessAltText();\n      } catch {}\n    }\n    this.div.focus();\n  }\n  async mlGuessAltText(imageData = null, updateAltTextData = true) {\n    if (this.hasAltTextData()) {\n      return null;\n    }\n    const {\n      mlManager\n    } = this._uiManager;\n    if (!mlManager) {\n      throw new Error(\"No ML.\");\n    }\n    if (!(await mlManager.isEnabledFor(\"altText\"))) {\n      throw new Error(\"ML isn't enabled for alt text.\");\n    }\n    const {\n      data,\n      width,\n      height\n    } = imageData || this.copyCanvas(null, null, true).imageData;\n    const response = await mlManager.guess({\n      name: \"altText\",\n      request: {\n        data,\n        width,\n        height,\n        channels: data.length / (width * height)\n      }\n    });\n    if (!response) {\n      throw new Error(\"No response from the AI service.\");\n    }\n    if (response.error) {\n      throw new Error(\"Error from the AI service.\");\n    }\n    if (response.cancel) {\n      return null;\n    }\n    if (!response.output) {\n      throw new Error(\"No valid response from the AI service.\");\n    }\n    const altText = response.output;\n    await this.setGuessedAltText(altText);\n    if (updateAltTextData && !this.hasAltTextData()) {\n      this.altTextData = {\n        alt: altText,\n        decorative: false\n      };\n    }\n    return altText;\n  }\n  #getBitmap() {\n    if (this.#bitmapId) {\n      this._uiManager.enableWaiting(true);\n      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapUrl) {\n      const url = this.#bitmapUrl;\n      this.#bitmapUrl = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapFile) {\n      const file = this.#bitmapFile;\n      this.#bitmapFile = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = SupportedImageMimeTypes.join(\",\");\n    const signal = this._uiManager._signal;\n    this.#bitmapPromise = new Promise(resolve => {\n      input.addEventListener(\"change\", async () => {\n        if (!input.files || input.files.length === 0) {\n          this.remove();\n        } else {\n          this._uiManager.enableWaiting(true);\n          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n          this._reportTelemetry({\n            action: \"pdfjs.image.image_selected\",\n            data: {\n              alt_text_modal: this._uiManager.useNewAltTextFlow\n            }\n          });\n          this.#getBitmapFetched(data);\n        }\n        resolve();\n      }, {\n        signal\n      });\n      input.addEventListener(\"cancel\", () => {\n        this.remove();\n        resolve();\n      }, {\n        signal\n      });\n    }).finally(() => this.#getBitmapDone());\n    input.click();\n  }\n  remove() {\n    if (this.#bitmapId) {\n      this.#bitmap = null;\n      this._uiManager.imageManager.deleteId(this.#bitmapId);\n      this.#canvas?.remove();\n      this.#canvas = null;\n      if (this.#resizeTimeoutId) {\n        clearTimeout(this.#resizeTimeoutId);\n        this.#resizeTimeoutId = null;\n      }\n    }\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      if (this.#bitmapId) {\n        this.#getBitmap();\n      }\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (this.#bitmapId && this.#canvas === null) {\n      this.#getBitmap();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  onceAdded(focus) {\n    this._isDraggable = true;\n    if (focus) {\n      this.div.focus();\n    }\n  }\n  isEmpty() {\n    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);\n  }\n  get toolbarButtons() {\n    return [[\"altText\", this.createAltText()]];\n  }\n  get isResizable() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this._isCopy) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.hidden = true;\n    this.createAltText();\n    if (!this.#missingCanvas) {\n      if (this.#bitmap) {\n        this.#createCanvas();\n      } else {\n        this.#getBitmap();\n      }\n    }\n    if (this._isCopy) {\n      this._moveAfterPaste(baseX, baseY);\n    }\n    this._uiManager.addShouldRescale(this);\n    return this.div;\n  }\n  setCanvas(annotationElementId, canvas) {\n    const {\n      id: bitmapId,\n      bitmap\n    } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);\n    canvas.remove();\n    if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {\n      this.#bitmapId = bitmapId;\n      if (bitmap) {\n        this.#bitmap = bitmap;\n      }\n      this.#missingCanvas = false;\n      this.#createCanvas();\n    }\n  }\n  _onResized() {\n    this.onScaleChanging();\n  }\n  onScaleChanging() {\n    if (!this.parent) {\n      return;\n    }\n    if (this.#resizeTimeoutId !== null) {\n      clearTimeout(this.#resizeTimeoutId);\n    }\n    const TIME_TO_WAIT = 200;\n    this.#resizeTimeoutId = setTimeout(() => {\n      this.#resizeTimeoutId = null;\n      this.#drawBitmap();\n    }, TIME_TO_WAIT);\n  }\n  #createCanvas() {\n    const {\n      div\n    } = this;\n    let {\n      width,\n      height\n    } = this.#bitmap;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const MAX_RATIO = 0.75;\n    if (this.width) {\n      width = this.width * pageWidth;\n      height = this.height * pageHeight;\n    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n      width *= factor;\n      height *= factor;\n    }\n    this._uiManager.enableWaiting(false);\n    const canvas = this.#canvas = document.createElement(\"canvas\");\n    canvas.setAttribute(\"role\", \"img\");\n    this.addContainer(canvas);\n    this.width = width / pageWidth;\n    this.height = height / pageHeight;\n    this.setDims();\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    } else {\n      this.fixAndSetPosition();\n    }\n    this._initialOptions = null;\n    if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {\n      div.hidden = false;\n    }\n    this.#drawBitmap();\n    if (!this.#hasBeenAddedInUndoStack) {\n      this.parent.addUndoableEditor(this);\n      this.#hasBeenAddedInUndoStack = true;\n    }\n    this._reportTelemetry({\n      action: \"inserted_image\"\n    });\n    if (this.#bitmapFileName) {\n      this.div.setAttribute(\"aria-description\", this.#bitmapFileName);\n    }\n    if (!this.annotationElementId) {\n      this._uiManager.a11yAlert(\"pdfjs-editor-stamp-added-alert\");\n    }\n  }\n  copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {\n    if (!maxDataDimension) {\n      maxDataDimension = 224;\n    }\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    const outputScale = new OutputScale();\n    let bitmap = this.#bitmap;\n    let width = bitmapWidth,\n      height = bitmapHeight;\n    let canvas = null;\n    if (maxPreviewDimension) {\n      if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {\n        const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);\n        width = Math.floor(bitmapWidth * ratio);\n        height = Math.floor(bitmapHeight * ratio);\n      }\n      canvas = document.createElement(\"canvas\");\n      const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);\n      const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);\n      if (!this.#isSvg) {\n        bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);\n      }\n      const ctx = canvas.getContext(\"2d\");\n      ctx.filter = this._uiManager.hcmFilter;\n      let white = \"white\",\n        black = \"#cfcfd8\";\n      if (this._uiManager.hcmFilter !== \"none\") {\n        black = \"black\";\n      } else if (ColorScheme.isDarkMode) {\n        white = \"#8f8f9d\";\n        black = \"#42414d\";\n      }\n      const boxDim = 15;\n      const boxDimWidth = boxDim * outputScale.sx;\n      const boxDimHeight = boxDim * outputScale.sy;\n      const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);\n      const patternCtx = pattern.getContext(\"2d\");\n      patternCtx.fillStyle = white;\n      patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);\n      patternCtx.fillStyle = black;\n      patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);\n      patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);\n      ctx.fillStyle = ctx.createPattern(pattern, \"repeat\");\n      ctx.fillRect(0, 0, scaledWidth, scaledHeight);\n      ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n    }\n    let imageData = null;\n    if (createImageData) {\n      let dataWidth, dataHeight;\n      if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {\n        dataWidth = bitmap.width;\n        dataHeight = bitmap.height;\n      } else {\n        bitmap = this.#bitmap;\n        if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {\n          const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);\n          dataWidth = Math.floor(bitmapWidth * ratio);\n          dataHeight = Math.floor(bitmapHeight * ratio);\n          if (!this.#isSvg) {\n            bitmap = this.#scaleBitmap(dataWidth, dataHeight);\n          }\n        }\n      }\n      const offscreen = new OffscreenCanvas(dataWidth, dataHeight);\n      const offscreenCtx = offscreen.getContext(\"2d\", {\n        willReadFrequently: true\n      });\n      offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);\n      imageData = {\n        width: dataWidth,\n        height: dataHeight,\n        data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data\n      };\n    }\n    return {\n      canvas,\n      width,\n      height,\n      imageData\n    };\n  }\n  #scaleBitmap(width, height) {\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    let newWidth = bitmapWidth;\n    let newHeight = bitmapHeight;\n    let bitmap = this.#bitmap;\n    while (newWidth > 2 * width || newHeight > 2 * height) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      if (newWidth > 2 * width) {\n        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n      }\n      if (newHeight > 2 * height) {\n        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n      }\n      const offscreen = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = offscreen.transferToImageBitmap();\n    }\n    return bitmap;\n  }\n  #drawBitmap() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      width,\n      height\n    } = this;\n    const outputScale = new OutputScale();\n    const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);\n    const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);\n    const canvas = this.#canvas;\n    if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {\n      return;\n    }\n    canvas.width = scaledWidth;\n    canvas.height = scaledHeight;\n    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.filter = this._uiManager.hcmFilter;\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);\n  }\n  #serializeBitmap(toUrl) {\n    if (toUrl) {\n      if (this.#isSvg) {\n        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n        if (url) {\n          return url;\n        }\n      }\n      const canvas = document.createElement(\"canvas\");\n      ({\n        width: canvas.width,\n        height: canvas.height\n      } = this.#bitmap);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0);\n      return canvas.toDataURL();\n    }\n    if (this.#isSvg) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);\n      const offscreen = new OffscreenCanvas(width, height);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n      return offscreen.transferToImageBitmap();\n    }\n    return structuredClone(this.#bitmap);\n  }\n  static async deserialize(data, parent, uiManager) {\n    let initialData = null;\n    let missingCanvas = false;\n    if (data instanceof StampAnnotationElement) {\n      const {\n        data: {\n          rect,\n          rotation,\n          id,\n          structParent,\n          popupRef,\n          richText,\n          contentsObj,\n          creationDate,\n          modificationDate\n        },\n        container,\n        parent: {\n          page: {\n            pageNumber\n          }\n        },\n        canvas\n      } = data;\n      let bitmapId, bitmap;\n      if (canvas) {\n        delete data.canvas;\n        ({\n          id: bitmapId,\n          bitmap\n        } = uiManager.imageManager.getFromCanvas(container.id, canvas));\n        canvas.remove();\n      } else {\n        missingCanvas = true;\n        data._hasNoCanvas = true;\n      }\n      const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get(\"aria-label\") || \"\";\n      initialData = data = {\n        annotationType: AnnotationEditorType.STAMP,\n        bitmapId,\n        bitmap,\n        pageIndex: pageNumber - 1,\n        rect: rect.slice(0),\n        rotation,\n        annotationElementId: id,\n        id,\n        deleted: false,\n        accessibilityData: {\n          decorative: false,\n          altText\n        },\n        isSvg: false,\n        structParent,\n        popupRef,\n        richText,\n        comment: contentsObj?.str || null,\n        creationDate,\n        modificationDate\n      };\n    }\n    const editor = await super.deserialize(data, parent, uiManager);\n    const {\n      rect,\n      bitmap,\n      bitmapUrl,\n      bitmapId,\n      isSvg,\n      accessibilityData\n    } = data;\n    if (missingCanvas) {\n      uiManager.addMissingCanvas(data.id, editor);\n      editor.#missingCanvas = true;\n    } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n      editor.#bitmapId = bitmapId;\n      if (bitmap) {\n        editor.#bitmap = bitmap;\n      }\n    } else {\n      editor.#bitmapUrl = bitmapUrl;\n    }\n    editor.#isSvg = isSvg;\n    const [parentWidth, parentHeight] = editor.pageDimensions;\n    editor.width = (rect[2] - rect[0]) / parentWidth;\n    editor.height = (rect[3] - rect[1]) / parentHeight;\n    if (accessibilityData) {\n      editor.altTextData = accessibilityData;\n    }\n    editor._initialData = initialData;\n    if (data.comment) {\n      editor.setCommentData(data);\n    }\n    editor.#hasBeenAddedInUndoStack = !!initialData;\n    return editor;\n  }\n  serialize(isForCopying = false, context = null) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return this.serializeDeleted();\n    }\n    const serialized = Object.assign(super.serialize(isForCopying), {\n      bitmapId: this.#bitmapId,\n      isSvg: this.#isSvg\n    });\n    this.addComment(serialized);\n    if (isForCopying) {\n      serialized.bitmapUrl = this.#serializeBitmap(true);\n      serialized.accessibilityData = this.serializeAltText(true);\n      serialized.isCopy = true;\n      return serialized;\n    }\n    const {\n      decorative,\n      altText\n    } = this.serializeAltText(false);\n    if (!decorative && altText) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: altText\n      };\n    }\n    if (this.annotationElementId) {\n      const changes = this.#hasElementChanged(serialized);\n      if (changes.isSame) {\n        return null;\n      }\n      if (changes.isSameAltText) {\n        delete serialized.accessibilityData;\n      } else {\n        serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;\n      }\n      serialized.id = this.annotationElementId;\n      delete serialized.bitmapId;\n      return serialized;\n    }\n    if (context === null) {\n      return serialized;\n    }\n    context.stamps ||= new Map();\n    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n    if (!context.stamps.has(this.#bitmapId)) {\n      context.stamps.set(this.#bitmapId, {\n        area,\n        serialized\n      });\n      serialized.bitmap = this.#serializeBitmap(false);\n    } else if (this.#isSvg) {\n      const prevData = context.stamps.get(this.#bitmapId);\n      if (area > prevData.area) {\n        prevData.area = area;\n        prevData.serialized.bitmap.close();\n        prevData.serialized.bitmap = this.#serializeBitmap(false);\n      }\n    }\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      pageIndex,\n      accessibilityData: {\n        altText\n      }\n    } = this._initialData;\n    const isSamePageIndex = serialized.pageIndex === pageIndex;\n    const isSameAltText = (serialized.accessibilityData?.alt || \"\") === altText;\n    return {\n      isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,\n      isSameAltText\n    };\n  }\n  renderAnnotationElement(annotation) {\n    if (this.deleted) {\n      annotation.hide();\n      return null;\n    }\n    annotation.updateEdited({\n      rect: this.getPDFRect(),\n      popup: this.comment\n    });\n    return null;\n  }\n}\n\n;// ./src/display/editor/annotation_editor_layer.js\n\n\n\n\n\n\n\n\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #annotationLayer = null;\n  #clickAC = null;\n  #editorFocusTimeoutId = null;\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isDisabling = false;\n  #isEnabling = false;\n  #drawingAC = null;\n  #focusedElement = null;\n  #textLayer = null;\n  #textSelectionAC = null;\n  #textLayerDblClickAC = null;\n  #lastPointerDownTimestamp = -1;\n  #uiManager;\n  static _initialized = false;\n  static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map(type => [type._editorType, type]));\n  constructor({\n    uiManager,\n    pageIndex,\n    div,\n    structTreeLayer,\n    accessibilityManager,\n    annotationLayer,\n    drawLayer,\n    textLayer,\n    viewport,\n    l10n\n  }) {\n    const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n      for (const editorType of editorTypes) {\n        editorType.initialize(l10n, uiManager);\n      }\n    }\n    uiManager.registerEditorTypes(editorTypes);\n    this.#uiManager = uiManager;\n    this.pageIndex = pageIndex;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationLayer = annotationLayer;\n    this.viewport = viewport;\n    this.#textLayer = textLayer;\n    this.drawLayer = drawLayer;\n    this._structTree = structTreeLayer;\n    this.#uiManager.addLayer(this);\n  }\n  get isEmpty() {\n    return this.#editors.size === 0;\n  }\n  get isInvisible() {\n    return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;\n  }\n  updateToolbar(options) {\n    this.#uiManager.updateToolbar(options);\n  }\n  updateMode(mode = this.#uiManager.getMode()) {\n    this.#cleanup();\n    switch (mode) {\n      case AnnotationEditorType.NONE:\n        this.div.classList.toggle(\"nonEditing\", true);\n        this.disableTextSelection();\n        this.togglePointerEvents(false);\n        this.toggleAnnotationLayerPointerEvents(true);\n        this.disableClick();\n        return;\n      case AnnotationEditorType.INK:\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.enableClick();\n        break;\n      case AnnotationEditorType.HIGHLIGHT:\n        this.enableTextSelection();\n        this.togglePointerEvents(false);\n        this.disableClick();\n        break;\n      default:\n        this.disableTextSelection();\n        this.togglePointerEvents(true);\n        this.enableClick();\n    }\n    this.toggleAnnotationLayerPointerEvents(false);\n    const {\n      classList\n    } = this.div;\n    classList.toggle(\"nonEditing\", false);\n    if (mode === AnnotationEditorType.POPUP) {\n      classList.toggle(\"commentEditing\", true);\n    } else {\n      classList.toggle(\"commentEditing\", false);\n      for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n        classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);\n      }\n    }\n    this.div.hidden = false;\n  }\n  hasTextLayer(textLayer) {\n    return textLayer === this.#textLayer?.div;\n  }\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n  cleanUndoStack(type) {\n    this.#uiManager.cleanUndoStack(type);\n  }\n  toggleDrawing(enabled = false) {\n    this.div.classList.toggle(\"drawing\", !enabled);\n  }\n  togglePointerEvents(enabled = false) {\n    this.div.classList.toggle(\"disabled\", !enabled);\n  }\n  toggleAnnotationLayerPointerEvents(enabled = false) {\n    this.#annotationLayer?.togglePointerEvents(enabled);\n  }\n  get #allEditorsIterator() {\n    return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);\n  }\n  async enable() {\n    this.#isEnabling = true;\n    this.div.tabIndex = 0;\n    this.togglePointerEvents(true);\n    this.div.classList.toggle(\"nonEditing\", false);\n    this.#textLayerDblClickAC?.abort();\n    this.#textLayerDblClickAC = null;\n    const annotationElementIds = new Set();\n    for (const editor of this.#allEditorsIterator) {\n      editor.enableEditing();\n      editor.show(true);\n      if (editor.annotationElementId) {\n        this.#uiManager.removeChangedExistingAnnotation(editor);\n        annotationElementIds.add(editor.annotationElementId);\n      }\n    }\n    const annotationLayer = this.#annotationLayer;\n    if (annotationLayer) {\n      for (const editable of annotationLayer.getEditableAnnotations()) {\n        editable.hide();\n        if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n          continue;\n        }\n        if (annotationElementIds.has(editable.data.id)) {\n          continue;\n        }\n        const editor = await this.deserialize(editable);\n        if (!editor) {\n          continue;\n        }\n        this.addOrRebuild(editor);\n        editor.enableEditing();\n      }\n    }\n    this.#isEnabling = false;\n    this.#uiManager._eventBus.dispatch(\"editorsrendered\", {\n      source: this,\n      pageNumber: this.pageIndex + 1\n    });\n  }\n  disable() {\n    this.#isDisabling = true;\n    this.div.tabIndex = -1;\n    this.togglePointerEvents(false);\n    this.div.classList.toggle(\"nonEditing\", true);\n    if (this.#textLayer && !this.#textLayerDblClickAC) {\n      this.#textLayerDblClickAC = new AbortController();\n      const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);\n      this.#textLayer.div.addEventListener(\"pointerdown\", e => {\n        const DBL_CLICK_THRESHOLD = 500;\n        const {\n          clientX,\n          clientY,\n          timeStamp\n        } = e;\n        const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;\n        if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {\n          this.#lastPointerDownTimestamp = timeStamp;\n          return;\n        }\n        this.#lastPointerDownTimestamp = -1;\n        const {\n          classList\n        } = this.div;\n        classList.toggle(\"getElements\", true);\n        const elements = document.elementsFromPoint(clientX, clientY);\n        classList.toggle(\"getElements\", false);\n        if (!this.div.contains(elements[0])) {\n          return;\n        }\n        let id;\n        const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);\n        for (const element of elements) {\n          if (regex.test(element.id)) {\n            id = element.id;\n            break;\n          }\n        }\n        if (!id) {\n          return;\n        }\n        const editor = this.#editors.get(id);\n        if (editor?.annotationElementId === null) {\n          e.stopPropagation();\n          e.preventDefault();\n          editor.dblclick(e);\n        }\n      }, {\n        signal,\n        capture: true\n      });\n    }\n    const annotationLayer = this.#annotationLayer;\n    const needFakeAnnotation = [];\n    if (annotationLayer) {\n      const changedAnnotations = new Map();\n      const resetAnnotations = new Map();\n      for (const editor of this.#allEditorsIterator) {\n        editor.disableEditing();\n        if (!editor.annotationElementId) {\n          needFakeAnnotation.push(editor);\n          continue;\n        }\n        if (editor.serialize() !== null) {\n          changedAnnotations.set(editor.annotationElementId, editor);\n          continue;\n        } else {\n          resetAnnotations.set(editor.annotationElementId, editor);\n        }\n        this.getEditableAnnotation(editor.annotationElementId)?.show();\n        editor.remove();\n      }\n      const editables = annotationLayer.getEditableAnnotations();\n      for (const editable of editables) {\n        const {\n          id\n        } = editable.data;\n        if (this.#uiManager.isDeletedAnnotationElement(id)) {\n          editable.updateEdited({\n            deleted: true\n          });\n          continue;\n        }\n        let editor = resetAnnotations.get(id);\n        if (editor) {\n          editor.resetAnnotationElement(editable);\n          editor.show(false);\n          editable.show();\n          continue;\n        }\n        editor = changedAnnotations.get(id);\n        if (editor) {\n          this.#uiManager.addChangedExistingAnnotation(editor);\n          if (editor.renderAnnotationElement(editable)) {\n            editor.show(false);\n          }\n        }\n        editable.show();\n      }\n    }\n    this.#cleanup();\n    if (this.isEmpty) {\n      this.div.hidden = true;\n    }\n    const {\n      classList\n    } = this.div;\n    for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {\n      classList.remove(`${editorType._type}Editing`);\n    }\n    this.disableTextSelection();\n    this.toggleAnnotationLayerPointerEvents(true);\n    annotationLayer?.updateFakeAnnotations(needFakeAnnotation);\n    this.#isDisabling = false;\n  }\n  getEditableAnnotation(id) {\n    return this.#annotationLayer?.getEditableAnnotation(id) || null;\n  }\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n    if (currentActive === editor) {\n      return;\n    }\n    this.#uiManager.setActiveEditor(editor);\n  }\n  enableTextSelection() {\n    this.div.tabIndex = -1;\n    if (this.#textLayer?.div && !this.#textSelectionAC) {\n      this.#textSelectionAC = new AbortController();\n      const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);\n      this.#textLayer.div.addEventListener(\"pointerdown\", this.#textLayerPointerDown.bind(this), {\n        signal\n      });\n      this.#textLayer.div.classList.add(\"highlighting\");\n    }\n  }\n  disableTextSelection() {\n    this.div.tabIndex = 0;\n    if (this.#textLayer?.div && this.#textSelectionAC) {\n      this.#textSelectionAC.abort();\n      this.#textSelectionAC = null;\n      this.#textLayer.div.classList.remove(\"highlighting\");\n    }\n  }\n  #textLayerPointerDown(event) {\n    this.#uiManager.unselectAll();\n    const {\n      target\n    } = event;\n    if (target === this.#textLayer.div || (target.getAttribute(\"role\") === \"img\" || target.classList.contains(\"endOfContent\")) && this.#textLayer.div.contains(target)) {\n      const {\n        isMac\n      } = util_FeatureTest.platform;\n      if (event.button !== 0 || event.ctrlKey && isMac) {\n        return;\n      }\n      this.#uiManager.showAllEditors(\"highlight\", true, true);\n      this.#textLayer.div.classList.add(\"free\");\n      this.toggleDrawing();\n      HighlightEditor.startHighlighting(this, this.#uiManager.direction === \"ltr\", {\n        target: this.#textLayer.div,\n        x: event.x,\n        y: event.y\n      });\n      this.#textLayer.div.addEventListener(\"pointerup\", () => {\n        this.#textLayer.div.classList.remove(\"free\");\n        this.toggleDrawing(true);\n      }, {\n        once: true,\n        signal: this.#uiManager._signal\n      });\n      event.preventDefault();\n    }\n  }\n  enableClick() {\n    if (this.#clickAC) {\n      return;\n    }\n    this.#clickAC = new AbortController();\n    const signal = this.#uiManager.combinedSignal(this.#clickAC);\n    this.div.addEventListener(\"pointerdown\", this.pointerdown.bind(this), {\n      signal\n    });\n    const pointerup = this.pointerup.bind(this);\n    this.div.addEventListener(\"pointerup\", pointerup, {\n      signal\n    });\n    this.div.addEventListener(\"pointercancel\", pointerup, {\n      signal\n    });\n  }\n  disableClick() {\n    this.#clickAC?.abort();\n    this.#clickAC = null;\n  }\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n    const {\n      annotationElementId\n    } = editor;\n    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n      this.#uiManager.removeDeletedAnnotationElement(editor);\n    }\n  }\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n    if (!this.#isDisabling && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n    }\n  }\n  remove(editor) {\n    this.detach(editor);\n    this.#uiManager.removeEditor(editor);\n    editor.div.remove();\n    editor.isAttachedToDOM = false;\n  }\n  changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n    if (editor.parent && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n      AnnotationEditor.deleteAnnotationElement(editor);\n      editor.annotationElementId = null;\n    }\n    this.attach(editor);\n    editor.parent?.detach(editor);\n    editor.setParent(this);\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n  add(editor) {\n    if (editor.parent === this && editor.isAttachedToDOM) {\n      return;\n    }\n    this.changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n    editor.fixAndSetPosition();\n    editor.onceAdded(!this.#isEnabling);\n    this.#uiManager.addToAnnotationStorage(editor);\n    editor._reportTelemetry(editor.telemetryInitialData);\n  }\n  moveEditorInDOM(editor) {\n    if (!editor.isAttachedToDOM) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {\n      editor._focusEventsAllowed = false;\n      this.#editorFocusTimeoutId = setTimeout(() => {\n        this.#editorFocusTimeoutId = null;\n        if (!editor.div.contains(document.activeElement)) {\n          editor.div.addEventListener(\"focusin\", () => {\n            editor._focusEventsAllowed = true;\n          }, {\n            once: true,\n            signal: this.#uiManager._signal\n          });\n          activeElement.focus();\n        } else {\n          editor._focusEventsAllowed = true;\n        }\n      }, 0);\n    }\n    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.parent ||= this;\n      editor.rebuild();\n      editor.show();\n    } else {\n      this.add(editor);\n    }\n  }\n  addUndoableEditor(editor) {\n    const cmd = () => editor._uiManager.rebuild(editor);\n    const undo = () => {\n      editor.remove();\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n  getEditorByUID(uid) {\n    for (const editor of this.#editors.values()) {\n      if (editor.uid === uid) {\n        return editor;\n      }\n    }\n    return null;\n  }\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n  get #currentEditorType() {\n    return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());\n  }\n  combinedSignal(ac) {\n    return this.#uiManager.combinedSignal(ac);\n  }\n  #createNewEditor(params) {\n    const editorType = this.#currentEditorType;\n    return editorType ? new editorType.prototype.constructor(params) : null;\n  }\n  canCreateNewEmptyEditor() {\n    return this.#currentEditorType?.canCreateNewEmptyEditor();\n  }\n  async pasteEditor(options, params) {\n    this.updateToolbar(options);\n    await this.#uiManager.updateMode(options.mode);\n    const {\n      offsetX,\n      offsetY\n    } = this.#getCenterPoint();\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: offsetX,\n      y: offsetY,\n      uiManager: this.#uiManager,\n      isCentered: true,\n      ...params\n    });\n    if (editor) {\n      this.add(editor);\n    }\n  }\n  async deserialize(data) {\n    return (await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager)) || null;\n  }\n  createAndAddNewEditor(event, isCentered, data = {}) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY,\n      uiManager: this.#uiManager,\n      isCentered,\n      ...data\n    });\n    if (editor) {\n      this.add(editor);\n    }\n    return editor;\n  }\n  get boundingClientRect() {\n    return this.div.getBoundingClientRect();\n  }\n  #getCenterPoint() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.boundingClientRect;\n    const tlX = Math.max(0, x);\n    const tlY = Math.max(0, y);\n    const brX = Math.min(window.innerWidth, x + width);\n    const brY = Math.min(window.innerHeight, y + height);\n    const centerX = (tlX + brX) / 2 - x;\n    const centerY = (tlY + brY) / 2 - y;\n    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  addNewEditor(data = {}) {\n    this.createAndAddNewEditor(this.#getCenterPoint(), true, data);\n  }\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n  pointerup(event) {\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    if (!this.#hadPointerDown) {\n      return;\n    }\n    this.#hadPointerDown = false;\n    if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {\n      return;\n    }\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n    const currentMode = this.#uiManager.getMode();\n    if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {\n      this.#uiManager.unselectAll();\n      return;\n    }\n    this.createAndAddNewEditor(event, false);\n  }\n  pointerdown(event) {\n    if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {\n      this.enableTextSelection();\n    }\n    if (this.#hadPointerDown) {\n      this.#hadPointerDown = false;\n      return;\n    }\n    const {\n      isMac\n    } = util_FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    this.#hadPointerDown = true;\n    if (this.#currentEditorType?.isDrawer) {\n      this.startDrawingSession(event);\n      return;\n    }\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n  startDrawingSession(event) {\n    this.div.focus({\n      preventScroll: true\n    });\n    if (this.#drawingAC) {\n      this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n      return;\n    }\n    this.#uiManager.setCurrentDrawingSession(this);\n    this.#drawingAC = new AbortController();\n    const signal = this.#uiManager.combinedSignal(this.#drawingAC);\n    this.div.addEventListener(\"blur\", ({\n      relatedTarget\n    }) => {\n      if (relatedTarget && !this.div.contains(relatedTarget)) {\n        this.#focusedElement = null;\n        this.commitOrRemove();\n      }\n    }, {\n      signal\n    });\n    this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);\n  }\n  pause(on) {\n    if (on) {\n      const {\n        activeElement\n      } = document;\n      if (this.div.contains(activeElement)) {\n        this.#focusedElement = activeElement;\n      }\n      return;\n    }\n    if (this.#focusedElement) {\n      setTimeout(() => {\n        this.#focusedElement?.focus();\n        this.#focusedElement = null;\n      }, 0);\n    }\n  }\n  endDrawingSession(isAborted = false) {\n    if (!this.#drawingAC) {\n      return null;\n    }\n    this.#uiManager.setCurrentDrawingSession(null);\n    this.#drawingAC.abort();\n    this.#drawingAC = null;\n    this.#focusedElement = null;\n    return this.#currentEditorType.endDrawing(isAborted);\n  }\n  findNewParent(editor, x, y) {\n    const layer = this.#uiManager.findParent(x, y);\n    if (layer === null || layer === this) {\n      return false;\n    }\n    layer.changeParent(editor);\n    return true;\n  }\n  commitOrRemove() {\n    if (this.#drawingAC) {\n      this.endDrawingSession();\n      return true;\n    }\n    return false;\n  }\n  onScaleChanging() {\n    if (!this.#drawingAC) {\n      return;\n    }\n    this.#currentEditorType.onScaleChangingWhenDrawing(this);\n  }\n  destroy() {\n    this.commitOrRemove();\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.commitOrRemove();\n      this.#uiManager.setActiveEditor(null);\n    }\n    if (this.#editorFocusTimeoutId) {\n      clearTimeout(this.#editorFocusTimeoutId);\n      this.#editorFocusTimeoutId = null;\n    }\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.setParent(null);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n    }\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n  #cleanup() {\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n  }\n  render({\n    viewport\n  }) {\n    this.viewport = viewport;\n    setLayerDimensions(this.div, viewport);\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n      editor.rebuild();\n    }\n    this.updateMode();\n  }\n  update({\n    viewport\n  }) {\n    this.#uiManager.commitOrRemove();\n    this.#cleanup();\n    const oldRotation = this.viewport.rotation;\n    const rotation = viewport.rotation;\n    this.viewport = viewport;\n    setLayerDimensions(this.div, {\n      rotation\n    });\n    if (oldRotation !== rotation) {\n      for (const editor of this.#editors.values()) {\n        editor.rotate(rotation);\n      }\n    }\n  }\n  get pageDimensions() {\n    const {\n      pageWidth,\n      pageHeight\n    } = this.viewport.rawDims;\n    return [pageWidth, pageHeight];\n  }\n  get scale() {\n    return this.#uiManager.viewParameters.realScale;\n  }\n}\n\n;// ./src/display/draw_layer.js\n\n\nclass DrawLayer {\n  #parent = null;\n  #mapping = new Map();\n  #toUpdate = new Map();\n  static #id = 0;\n  constructor({\n    pageIndex\n  }) {\n    this.pageIndex = pageIndex;\n  }\n  setParent(parent) {\n    if (!this.#parent) {\n      this.#parent = parent;\n      return;\n    }\n    if (this.#parent !== parent) {\n      if (this.#mapping.size > 0) {\n        for (const root of this.#mapping.values()) {\n          root.remove();\n          parent.append(root);\n        }\n      }\n      this.#parent = parent;\n    }\n  }\n  static get _svgFactory() {\n    return shadow(this, \"_svgFactory\", new DOMSVGFactory());\n  }\n  static #setBox(element, [x, y, width, height]) {\n    const {\n      style\n    } = element;\n    style.top = `${100 * y}%`;\n    style.left = `${100 * x}%`;\n    style.width = `${100 * width}%`;\n    style.height = `${100 * height}%`;\n  }\n  #createSVG() {\n    const svg = DrawLayer._svgFactory.create(1, 1, true);\n    this.#parent.append(svg);\n    svg.setAttribute(\"aria-hidden\", true);\n    return svg;\n  }\n  #createClipPath(defs, pathId) {\n    const clipPath = DrawLayer._svgFactory.createElement(\"clipPath\");\n    defs.append(clipPath);\n    const clipPathId = `clip_${pathId}`;\n    clipPath.setAttribute(\"id\", clipPathId);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    const clipPathUse = DrawLayer._svgFactory.createElement(\"use\");\n    clipPath.append(clipPathUse);\n    clipPathUse.setAttribute(\"href\", `#${pathId}`);\n    clipPathUse.classList.add(\"clip\");\n    return clipPathId;\n  }\n  #updateProperties(element, properties) {\n    for (const [key, value] of Object.entries(properties)) {\n      if (value === null) {\n        element.removeAttribute(key);\n      } else {\n        element.setAttribute(key, value);\n      }\n    }\n  }\n  draw(properties, isPathUpdatable = false, hasClip = false) {\n    const id = DrawLayer.#id++;\n    const root = this.#createSVG();\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n    if (isPathUpdatable) {\n      this.#toUpdate.set(id, path);\n    }\n    const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;\n    const use = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use);\n    use.setAttribute(\"href\", `#${pathId}`);\n    this.updateProperties(root, properties);\n    this.#mapping.set(id, root);\n    return {\n      id,\n      clipPathId: `url(#${clipPathId})`\n    };\n  }\n  drawOutline(properties, mustRemoveSelfIntersections) {\n    const id = DrawLayer.#id++;\n    const root = this.#createSVG();\n    const defs = DrawLayer._svgFactory.createElement(\"defs\");\n    root.append(defs);\n    const path = DrawLayer._svgFactory.createElement(\"path\");\n    defs.append(path);\n    const pathId = `path_p${this.pageIndex}_${id}`;\n    path.setAttribute(\"id\", pathId);\n    path.setAttribute(\"vector-effect\", \"non-scaling-stroke\");\n    let maskId;\n    if (mustRemoveSelfIntersections) {\n      const mask = DrawLayer._svgFactory.createElement(\"mask\");\n      defs.append(mask);\n      maskId = `mask_p${this.pageIndex}_${id}`;\n      mask.setAttribute(\"id\", maskId);\n      mask.setAttribute(\"maskUnits\", \"objectBoundingBox\");\n      const rect = DrawLayer._svgFactory.createElement(\"rect\");\n      mask.append(rect);\n      rect.setAttribute(\"width\", \"1\");\n      rect.setAttribute(\"height\", \"1\");\n      rect.setAttribute(\"fill\", \"white\");\n      const use = DrawLayer._svgFactory.createElement(\"use\");\n      mask.append(use);\n      use.setAttribute(\"href\", `#${pathId}`);\n      use.setAttribute(\"stroke\", \"none\");\n      use.setAttribute(\"fill\", \"black\");\n      use.setAttribute(\"fill-rule\", \"nonzero\");\n      use.classList.add(\"mask\");\n    }\n    const use1 = DrawLayer._svgFactory.createElement(\"use\");\n    root.append(use1);\n    use1.setAttribute(\"href\", `#${pathId}`);\n    if (maskId) {\n      use1.setAttribute(\"mask\", `url(#${maskId})`);\n    }\n    const use2 = use1.cloneNode();\n    root.append(use2);\n    use1.classList.add(\"mainOutline\");\n    use2.classList.add(\"secondaryOutline\");\n    this.updateProperties(root, properties);\n    this.#mapping.set(id, root);\n    return id;\n  }\n  finalizeDraw(id, properties) {\n    this.#toUpdate.delete(id);\n    this.updateProperties(id, properties);\n  }\n  updateProperties(elementOrId, properties) {\n    if (!properties) {\n      return;\n    }\n    const {\n      root,\n      bbox,\n      rootClass,\n      path\n    } = properties;\n    const element = typeof elementOrId === \"number\" ? this.#mapping.get(elementOrId) : elementOrId;\n    if (!element) {\n      return;\n    }\n    if (root) {\n      this.#updateProperties(element, root);\n    }\n    if (bbox) {\n      DrawLayer.#setBox(element, bbox);\n    }\n    if (rootClass) {\n      const {\n        classList\n      } = element;\n      for (const [className, value] of Object.entries(rootClass)) {\n        classList.toggle(className, value);\n      }\n    }\n    if (path) {\n      const defs = element.firstElementChild;\n      const pathElement = defs.firstElementChild;\n      this.#updateProperties(pathElement, path);\n    }\n  }\n  updateParent(id, layer) {\n    if (layer === this) {\n      return;\n    }\n    const root = this.#mapping.get(id);\n    if (!root) {\n      return;\n    }\n    layer.#parent.append(root);\n    this.#mapping.delete(id);\n    layer.#mapping.set(id, root);\n  }\n  remove(id) {\n    this.#toUpdate.delete(id);\n    if (this.#parent === null) {\n      return;\n    }\n    this.#mapping.get(id).remove();\n    this.#mapping.delete(id);\n  }\n  destroy() {\n    this.#parent = null;\n    for (const root of this.#mapping.values()) {\n      root.remove();\n    }\n    this.#mapping.clear();\n    this.#toUpdate.clear();\n  }\n}\n\n;// ./src/pdf.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{\n  globalThis._pdfjsTestingUtils = {\n    HighlightOutliner: HighlightOutliner\n  };\n}\nglobalThis.pdfjsLib = {\n  AbortException: AbortException,\n  AnnotationEditorLayer: AnnotationEditorLayer,\n  AnnotationEditorParamsType: AnnotationEditorParamsType,\n  AnnotationEditorType: AnnotationEditorType,\n  AnnotationEditorUIManager: AnnotationEditorUIManager,\n  AnnotationLayer: AnnotationLayer,\n  AnnotationMode: AnnotationMode,\n  AnnotationType: AnnotationType,\n  applyOpacity: applyOpacity,\n  build: build,\n  ColorPicker: ColorPicker,\n  createValidAbsoluteUrl: createValidAbsoluteUrl,\n  CSSConstants: CSSConstants,\n  DOMSVGFactory: DOMSVGFactory,\n  DrawLayer: DrawLayer,\n  FeatureTest: util_FeatureTest,\n  fetchData: fetchData,\n  findContrastColor: findContrastColor,\n  getDocument: getDocument,\n  getFilenameFromUrl: getFilenameFromUrl,\n  getPdfFilenameFromUrl: getPdfFilenameFromUrl,\n  getRGB: getRGB,\n  getUuid: getUuid,\n  getXfaPageViewport: getXfaPageViewport,\n  GlobalWorkerOptions: GlobalWorkerOptions,\n  ImageKind: util_ImageKind,\n  InvalidPDFException: InvalidPDFException,\n  isDataScheme: isDataScheme,\n  isPdfFile: isPdfFile,\n  isValidExplicitDest: isValidExplicitDest,\n  MathClamp: MathClamp,\n  noContextMenu: noContextMenu,\n  normalizeUnicode: normalizeUnicode,\n  OPS: OPS,\n  OutputScale: OutputScale,\n  PasswordResponses: PasswordResponses,\n  PDFDataRangeTransport: PDFDataRangeTransport,\n  PDFDateString: PDFDateString,\n  PDFWorker: PDFWorker,\n  PermissionFlag: PermissionFlag,\n  PixelsPerInch: PixelsPerInch,\n  RenderingCancelledException: RenderingCancelledException,\n  renderRichText: renderRichText,\n  ResponseException: ResponseException,\n  setLayerDimensions: setLayerDimensions,\n  shadow: shadow,\n  SignatureExtractor: SignatureExtractor,\n  stopEvent: stopEvent,\n  SupportedImageMimeTypes: SupportedImageMimeTypes,\n  TextLayer: TextLayer,\n  TouchManager: TouchManager,\n  updateUrlHash: updateUrlHash,\n  Util: Util,\n  VerbosityLevel: VerbosityLevel,\n  version: version,\n  XfaLayer: XfaLayer\n};\n\n\n\n//# sourceMappingURL=pdf.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9idWlsZC9wZGYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDhCQUFtQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxlQUFlLDhCQUFtQix3QkFBd0IsOEJBQW1CO0FBQzdFLG1EQUFtRCx3Q0FBd0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixJQUFJO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLElBQUk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsV0FBVyxLQUFLLE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLENBQXdwQjtBQUN4dUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9DQUFvQyxHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixHQUFHLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxLQUFLO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsc0JBQXNCLEVBQUUsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLDJCQUEyQixFQUFFLG1CQUFtQixFQUFFO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZELHlDQUF5QyxXQUFXO0FBQ3BELCtDQUErQyxFQUFFLG1DQUFtQyxFQUFFO0FBQ3RGLDRDQUE0QyxFQUFFLG1DQUFtQyxFQUFFO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEMsMEJBQTBCLGtCQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCLEVBQUUsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3SUFBd0k7QUFDNUs7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWEsR0FBRyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsYUFBYSxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEdBQUcsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCLEVBQUUsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFlBQVk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IscUNBQXFDLG9GQUFvRjtBQUN6SCwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7O0FBUUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixxQkFBcUI7QUFDekMsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQix5QkFBeUI7QUFDOUMsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RSwrQkFBK0IsOENBQThDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxHQUFHLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUNBQXVDLHNCQUFzQixNQUFNLEdBQUc7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsRUFBRSxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVMsV0FBVyxFQUFFO0FBQzlELDhCQUE4QixlQUFlLGVBQWUsRUFBRSxNQUFNLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZSxTQUFTLHdCQUF3QixFQUFFO0FBQzlFO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxnQkFBZ0IsRUFBRSxNQUFNLEtBQUs7QUFDdEUsTUFBTTtBQUNOLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQSxzQ0FBc0MsNkJBQTZCLElBQUk7QUFDdkU7QUFDQSwwQkFBMEIsZUFBZSw0QkFBNEIsRUFBRSxFQUFFLElBQUksTUFBTSxLQUFLO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFrQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDLG1DQUFtQyxXQUFXLElBQUk7QUFDMUYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWMsR0FBRyxHQUFHO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksZ0JBQWdCLFdBQVc7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRLEdBQUcsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZLGFBQWEsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWSxrQkFBa0IsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsR0FBRyxRQUFRLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksT0FBTyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGFBQWEsRUFBRSxTQUFTO0FBQzNDO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhLEVBQUUsU0FBUztBQUMzQztBQUNBLHNEQUFzRCxJQUFJO0FBQzFELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7QUFPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlFQUFlO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0Isd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxVQUFVO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCLDZDQUE2QyxjQUFjO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0EsSUFBSTtBQUNKLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsSUFBSTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLLEtBQUsscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEtBQUssU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3RELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYTtBQUMzRDtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUcsR0FBRyxjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQXFELE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPLDBCQUEwQixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTSxHQUFHLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZSxjQUFjLHVCQUF1QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLEdBQUcsYUFBYTtBQUN4RTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGVBQWUsY0FBYyw4QkFBOEI7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU07QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0JBQWdCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0VBQW9FLDBDQUEwQywrQkFBK0IsaURBQWlEO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRSx3QkFBd0IsMENBQTBDO0FBQ2xFLE1BQU07QUFDTix5QkFBeUIsZUFBZSxFQUFFLGdCQUFnQjtBQUMxRCx3QkFBd0IsZUFBZSxFQUFFLGVBQWU7QUFDeEQ7QUFDQSwyQkFBMkIsZUFBZSxFQUFFLGlEQUFpRDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw4QkFBOEIsa0NBQWtDLElBQUksVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLE9BQU8sVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUssS0FBSyxPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCRDtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFnQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxHQUFHO0FBQzlDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJFQUEyRSxlQUFlO0FBQzFGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZUFBZTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxLQUFLO0FBQ2pFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUSxRQUFRLFFBQVEsR0FBRyxRQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLG9CQUFvQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsQ0FBMEs7QUFDOU8sb0VBQW9FLENBQThDOztBQUVsSCxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBLHVDQUF1QyxPQUFPLEVBQUUsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7OztBQU1EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saURBQWlELHVCQUF1QixFQUFFLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlDQUF5Qyx1QkFBdUIsRUFBRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQsbUJBQW1CLGtEQUFrRDtBQUNyRTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Qsd0JBQXdCLHVDQUF1QztBQUMvRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLHlDQUF5QyxlQUFlO0FBQ3hHO0FBQ0EsUUFBUTtBQUNSLCtCQUErQixNQUFNLHlDQUF5QyxPQUFPO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0Isb0NBQW9DO0FBQ3hELG1CQUFtQixxQ0FBcUM7QUFDeEQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1Qix3QkFBd0I7QUFDL0Msd0JBQXdCLDBCQUEwQjtBQUNsRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QjtBQUN2RCxnQ0FBZ0MsMEJBQTBCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVU7QUFDbkU7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw0Q0FBNEMsc0lBQXNJLFlBQVksa0JBQWtCLFlBQVk7QUFDNU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUUsT0FBTyxFQUFFLFdBQVcsVUFBVSxZQUFZLFdBQVc7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEdBQUc7QUFDNUU7QUFDQSw4REFBOEQsR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLEdBQUc7QUFDMUU7QUFDQTtBQUNBLFVBQVU7QUFDViw4REFBOEQsR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpQkFBaUIsRUFBRSxHQUFHO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsRUFBRTtBQUMzQix3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixrQkFBa0I7QUFDdEMsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBLHFCQUFxQixFQUFFLEdBQUcsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUyxHQUFHLFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTLEdBQUcsUUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFNBQVMsR0FBRyxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUyxHQUFHLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwQ0FBMEMsT0FBTyxFQUFFLE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1Qix3QkFBd0IsYUFBYSx1REFBdUQ7QUFDbkg7QUFDQSwyQ0FBMkMsaUNBQWlDLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUIsRUFBRSxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isb0RBQW9ELGlCQUFpQixFQUFFLEdBQUc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQixFQUFFLFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyxpQkFBaUIsRUFBRSxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3QkFBd0IsRUFBRSxNQUFNLEVBQUUsdUJBQXVCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw2QkFBNkIsZUFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRLEVBQUUsT0FBTztBQUNyQyxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxXQUFXO0FBQ2pELFFBQVE7QUFDUix3QkFBd0IsUUFBUSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxXQUFXO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0Esd0JBQXdCLGVBQWUsRUFBRSxjQUFjO0FBQ3ZELFFBQVE7QUFDUix3QkFBd0IsV0FBVyxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxjQUFjO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDZCQUE2QixFQUFFLDhCQUE4QixHQUFHLDZCQUE2QixFQUFFLDhCQUE4QixHQUFHLFVBQVUsRUFBRSxVQUFVLEdBQUcsYUFBYSxFQUFFLGFBQWEsR0FBRyw4QkFBOEIsRUFBRSwrQkFBK0IsR0FBRyw4QkFBOEIsRUFBRSwrQkFBK0I7QUFDeFU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVcsRUFBRSxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEIsRUFBRSwyQkFBMkIsR0FBRyxVQUFVLEVBQUUsVUFBVSxHQUFHLGFBQWEsRUFBRSxhQUFhLEdBQUcsNkJBQTZCLEVBQUUsNkJBQTZCO0FBQ2xNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUMsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQixFQUFFLGlCQUFpQjtBQUM3RCwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBLHdCQUF3QixzQkFBc0IsRUFBRSxxQkFBcUI7QUFDckU7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0IsRUFBRSxzQkFBc0IsRUFBRSxzQkFBc0IsRUFBRSxzQkFBc0IsRUFBRSxzQkFBc0IsRUFBRSxxQkFBcUI7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPLEVBQUUsTUFBTTtBQUNyQyxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUFRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CLElBQUksUUFBUSxFQUFFLFFBQVE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCLElBQUksUUFBUSxFQUFFLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUIsSUFBSSxTQUFTLEVBQUUsUUFBUTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSwwREFBMEQsUUFBUTtBQUNsRTtBQUNBLHNCQUFzQixLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLDJCQUEyQixFQUFFLDBCQUEwQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QixFQUFFLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQSx3QkFBd0IsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsK0JBQStCLHFCQUFxQixFQUFFLG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUscUJBQXFCLEVBQUUsb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3QkFBd0IsRUFBRSx1QkFBdUI7QUFDbEYsd0JBQXdCLHdCQUF3QixZQUFZLElBQUksRUFBRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUIsRUFBRSxvQkFBb0I7QUFDMUUsc0JBQXNCLHdCQUF3QixRQUFRLEtBQUssRUFBRSxJQUFJLG1CQUFtQiwyQkFBMkIsRUFBRSwwQkFBMEIsVUFBVSxLQUFLLEVBQUUsSUFBSSxtQkFBbUIsNEJBQTRCLEVBQUUsMkJBQTJCO0FBQzVPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLHdCQUF3QixFQUFFLHVCQUF1QjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLCtCQUErQix3QkFBd0IsRUFBRSx1QkFBdUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsK0JBQStCLHdCQUF3QixFQUFFLHVCQUF1QjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQiwyQkFBMkIsRUFBRSwwQkFBMEI7QUFDdEY7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7OztBQU9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsV0FBVyxFQUFFLFlBQVksRUFBRSxTQUFTLEtBQUssV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0I7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7QUFRRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxpQkFBaUIsRUFBRSxHQUFHO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7OztBQVNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixRQUFRO0FBQzNCLG9CQUFvQixRQUFRO0FBQzVCLHFCQUFxQixZQUFZO0FBQ2pDLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsT0FBTztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWUsR0FBRyxHQUFHO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLEdBQUcsR0FBRztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZSxHQUFHLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXc2Qjs7QUFFeDZCIiwic291cmNlcyI6WyIvVXNlcnMvc29oYW0vbW9kdWwvbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDI0IE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4vKipcbiAqIHBkZmpzVmVyc2lvbiA9IDUuNC40NDlcbiAqIHBkZmpzQnVpbGQgPSBmNDRlNWYwZTZcbiAqL1xuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgc2NvcGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfcmVxdWlyZV9fID0ge307XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcblxuOy8vIC4vc3JjL3NoYXJlZC91dGlsLmpzXG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuY29uc3QgRk9OVF9JREVOVElUWV9NQVRSSVggPSBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXTtcbmNvbnN0IExJTkVfRkFDVE9SID0gMS4zNTtcbmNvbnN0IExJTkVfREVTQ0VOVF9GQUNUT1IgPSAwLjM1O1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuY29uc3QgUmVuZGVyaW5nSW50ZW50RmxhZyA9IHtcbiAgQU5ZOiAweDAxLFxuICBESVNQTEFZOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgU0FWRTogMHgwOCxcbiAgQU5OT1RBVElPTlNfRk9STVM6IDB4MTAsXG4gIEFOTk9UQVRJT05TX1NUT1JBR0U6IDB4MjAsXG4gIEFOTk9UQVRJT05TX0RJU0FCTEU6IDB4NDAsXG4gIElTX0VESVRJTkc6IDB4ODAsXG4gIE9QTElTVDogMHgxMDBcbn07XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclR5cGUgPSB7XG4gIERJU0FCTEU6IC0xLFxuICBOT05FOiAwLFxuICBGUkVFVEVYVDogMyxcbiAgSElHSExJR0hUOiA5LFxuICBTVEFNUDogMTMsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgU0lHTkFUVVJFOiAxMDEsXG4gIENPTU1FTlQ6IDEwMlxufTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0ge1xuICBSRVNJWkU6IDEsXG4gIENSRUFURTogMixcbiAgRlJFRVRFWFRfU0laRTogMTEsXG4gIEZSRUVURVhUX0NPTE9SOiAxMixcbiAgRlJFRVRFWFRfT1BBQ0lUWTogMTMsXG4gIElOS19DT0xPUjogMjEsXG4gIElOS19USElDS05FU1M6IDIyLFxuICBJTktfT1BBQ0lUWTogMjMsXG4gIEhJR0hMSUdIVF9DT0xPUjogMzEsXG4gIEhJR0hMSUdIVF9USElDS05FU1M6IDMyLFxuICBISUdITElHSFRfRlJFRTogMzMsXG4gIEhJR0hMSUdIVF9TSE9XX0FMTDogMzQsXG4gIERSQVdfU1RFUDogNDFcbn07XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmNvbnN0IE1lc2hGaWd1cmVUeXBlID0ge1xuICBUUklBTkdMRVM6IDEsXG4gIExBVFRJQ0U6IDIsXG4gIFBBVENIOiAzXG59O1xuY29uc3QgVGV4dFJlbmRlcmluZ01vZGUgPSB7XG4gIEZJTEw6IDAsXG4gIFNUUk9LRTogMSxcbiAgRklMTF9TVFJPS0U6IDIsXG4gIElOVklTSUJMRTogMyxcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxuICBGSUxMX1NUUk9LRV9BRERfVE9fUEFUSDogNixcbiAgQUREX1RPX1BBVEg6IDcsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5jb25zdCB1dGlsX0ltYWdlS2luZCA9IHtcbiAgR1JBWVNDQUxFXzFCUFA6IDEsXG4gIFJHQl8yNEJQUDogMixcbiAgUkdCQV8zMkJQUDogM1xufTtcbmNvbnN0IEFubm90YXRpb25UeXBlID0ge1xuICBURVhUOiAxLFxuICBMSU5LOiAyLFxuICBGUkVFVEVYVDogMyxcbiAgTElORTogNCxcbiAgU1FVQVJFOiA1LFxuICBDSVJDTEU6IDYsXG4gIFBPTFlHT046IDcsXG4gIFBPTFlMSU5FOiA4LFxuICBISUdITElHSFQ6IDksXG4gIFVOREVSTElORTogMTAsXG4gIFNRVUlHR0xZOiAxMSxcbiAgU1RSSUtFT1VUOiAxMixcbiAgU1RBTVA6IDEzLFxuICBDQVJFVDogMTQsXG4gIElOSzogMTUsXG4gIFBPUFVQOiAxNixcbiAgRklMRUFUVEFDSE1FTlQ6IDE3LFxuICBTT1VORDogMTgsXG4gIE1PVklFOiAxOSxcbiAgV0lER0VUOiAyMCxcbiAgU0NSRUVOOiAyMSxcbiAgUFJJTlRFUk1BUks6IDIyLFxuICBUUkFQTkVUOiAyMyxcbiAgV0FURVJNQVJLOiAyNCxcbiAgVEhSRUVEOiAyNSxcbiAgUkVEQUNUOiAyNlxufTtcbmNvbnN0IEFubm90YXRpb25SZXBseVR5cGUgPSB7XG4gIEdST1VQOiBcIkdyb3VwXCIsXG4gIFJFUExZOiBcIlJcIlxufTtcbmNvbnN0IEFubm90YXRpb25GbGFnID0ge1xuICBJTlZJU0lCTEU6IDB4MDEsXG4gIEhJRERFTjogMHgwMixcbiAgUFJJTlQ6IDB4MDQsXG4gIE5PWk9PTTogMHgwOCxcbiAgTk9ST1RBVEU6IDB4MTAsXG4gIE5PVklFVzogMHgyMCxcbiAgUkVBRE9OTFk6IDB4NDAsXG4gIExPQ0tFRDogMHg4MCxcbiAgVE9HR0xFTk9WSUVXOiAweDEwMCxcbiAgTE9DS0VEQ09OVEVOVFM6IDB4MjAwXG59O1xuY29uc3QgQW5ub3RhdGlvbkZpZWxkRmxhZyA9IHtcbiAgUkVBRE9OTFk6IDB4MDAwMDAwMSxcbiAgUkVRVUlSRUQ6IDB4MDAwMDAwMixcbiAgTk9FWFBPUlQ6IDB4MDAwMDAwNCxcbiAgTVVMVElMSU5FOiAweDAwMDEwMDAsXG4gIFBBU1NXT1JEOiAweDAwMDIwMDAsXG4gIE5PVE9HR0xFVE9PRkY6IDB4MDAwNDAwMCxcbiAgUkFESU86IDB4MDAwODAwMCxcbiAgUFVTSEJVVFRPTjogMHgwMDEwMDAwLFxuICBDT01CTzogMHgwMDIwMDAwLFxuICBFRElUOiAweDAwNDAwMDAsXG4gIFNPUlQ6IDB4MDA4MDAwMCxcbiAgRklMRVNFTEVDVDogMHgwMTAwMDAwLFxuICBNVUxUSVNFTEVDVDogMHgwMjAwMDAwLFxuICBET05PVFNQRUxMQ0hFQ0s6IDB4MDQwMDAwMCxcbiAgRE9OT1RTQ1JPTEw6IDB4MDgwMDAwMCxcbiAgQ09NQjogMHgxMDAwMDAwLFxuICBSSUNIVEVYVDogMHgyMDAwMDAwLFxuICBSQURJT1NJTlVOSVNPTjogMHgyMDAwMDAwLFxuICBDT01NSVRPTlNFTENIQU5HRTogMHg0MDAwMDAwXG59O1xuY29uc3QgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHtcbiAgU09MSUQ6IDEsXG4gIERBU0hFRDogMixcbiAgQkVWRUxFRDogMyxcbiAgSU5TRVQ6IDQsXG4gIFVOREVSTElORTogNVxufTtcbmNvbnN0IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSB7XG4gIEU6IFwiTW91c2UgRW50ZXJcIixcbiAgWDogXCJNb3VzZSBFeGl0XCIsXG4gIEQ6IFwiTW91c2UgRG93blwiLFxuICBVOiBcIk1vdXNlIFVwXCIsXG4gIEZvOiBcIkZvY3VzXCIsXG4gIEJsOiBcIkJsdXJcIixcbiAgUE86IFwiUGFnZU9wZW5cIixcbiAgUEM6IFwiUGFnZUNsb3NlXCIsXG4gIFBWOiBcIlBhZ2VWaXNpYmxlXCIsXG4gIFBJOiBcIlBhZ2VJbnZpc2libGVcIixcbiAgSzogXCJLZXlzdHJva2VcIixcbiAgRjogXCJGb3JtYXRcIixcbiAgVjogXCJWYWxpZGF0ZVwiLFxuICBDOiBcIkNhbGN1bGF0ZVwiXG59O1xuY29uc3QgRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSB7XG4gIFdDOiBcIldpbGxDbG9zZVwiLFxuICBXUzogXCJXaWxsU2F2ZVwiLFxuICBEUzogXCJEaWRTYXZlXCIsXG4gIFdQOiBcIldpbGxQcmludFwiLFxuICBEUDogXCJEaWRQcmludFwiXG59O1xuY29uc3QgUGFnZUFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgTzogXCJQYWdlT3BlblwiLFxuICBDOiBcIlBhZ2VDbG9zZVwiXG59O1xuY29uc3QgVmVyYm9zaXR5TGV2ZWwgPSB7XG4gIEVSUk9SUzogMCxcbiAgV0FSTklOR1M6IDEsXG4gIElORk9TOiA1XG59O1xuY29uc3QgT1BTID0ge1xuICBkZXBlbmRlbmN5OiAxLFxuICBzZXRMaW5lV2lkdGg6IDIsXG4gIHNldExpbmVDYXA6IDMsXG4gIHNldExpbmVKb2luOiA0LFxuICBzZXRNaXRlckxpbWl0OiA1LFxuICBzZXREYXNoOiA2LFxuICBzZXRSZW5kZXJpbmdJbnRlbnQ6IDcsXG4gIHNldEZsYXRuZXNzOiA4LFxuICBzZXRHU3RhdGU6IDksXG4gIHNhdmU6IDEwLFxuICByZXN0b3JlOiAxMSxcbiAgdHJhbnNmb3JtOiAxMixcbiAgbW92ZVRvOiAxMyxcbiAgbGluZVRvOiAxNCxcbiAgY3VydmVUbzogMTUsXG4gIGN1cnZlVG8yOiAxNixcbiAgY3VydmVUbzM6IDE3LFxuICBjbG9zZVBhdGg6IDE4LFxuICByZWN0YW5nbGU6IDE5LFxuICBzdHJva2U6IDIwLFxuICBjbG9zZVN0cm9rZTogMjEsXG4gIGZpbGw6IDIyLFxuICBlb0ZpbGw6IDIzLFxuICBmaWxsU3Ryb2tlOiAyNCxcbiAgZW9GaWxsU3Ryb2tlOiAyNSxcbiAgY2xvc2VGaWxsU3Ryb2tlOiAyNixcbiAgY2xvc2VFT0ZpbGxTdHJva2U6IDI3LFxuICBlbmRQYXRoOiAyOCxcbiAgY2xpcDogMjksXG4gIGVvQ2xpcDogMzAsXG4gIGJlZ2luVGV4dDogMzEsXG4gIGVuZFRleHQ6IDMyLFxuICBzZXRDaGFyU3BhY2luZzogMzMsXG4gIHNldFdvcmRTcGFjaW5nOiAzNCxcbiAgc2V0SFNjYWxlOiAzNSxcbiAgc2V0TGVhZGluZzogMzYsXG4gIHNldEZvbnQ6IDM3LFxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZTogMzgsXG4gIHNldFRleHRSaXNlOiAzOSxcbiAgbW92ZVRleHQ6IDQwLFxuICBzZXRMZWFkaW5nTW92ZVRleHQ6IDQxLFxuICBzZXRUZXh0TWF0cml4OiA0MixcbiAgbmV4dExpbmU6IDQzLFxuICBzaG93VGV4dDogNDQsXG4gIHNob3dTcGFjZWRUZXh0OiA0NSxcbiAgbmV4dExpbmVTaG93VGV4dDogNDYsXG4gIG5leHRMaW5lU2V0U3BhY2luZ1Nob3dUZXh0OiA0NyxcbiAgc2V0Q2hhcldpZHRoOiA0OCxcbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzOiA0OSxcbiAgc2V0U3Ryb2tlQ29sb3JTcGFjZTogNTAsXG4gIHNldEZpbGxDb2xvclNwYWNlOiA1MSxcbiAgc2V0U3Ryb2tlQ29sb3I6IDUyLFxuICBzZXRTdHJva2VDb2xvck46IDUzLFxuICBzZXRGaWxsQ29sb3I6IDU0LFxuICBzZXRGaWxsQ29sb3JOOiA1NSxcbiAgc2V0U3Ryb2tlR3JheTogNTYsXG4gIHNldEZpbGxHcmF5OiA1NyxcbiAgc2V0U3Ryb2tlUkdCQ29sb3I6IDU4LFxuICBzZXRGaWxsUkdCQ29sb3I6IDU5LFxuICBzZXRTdHJva2VDTVlLQ29sb3I6IDYwLFxuICBzZXRGaWxsQ01ZS0NvbG9yOiA2MSxcbiAgc2hhZGluZ0ZpbGw6IDYyLFxuICBiZWdpbklubGluZUltYWdlOiA2MyxcbiAgYmVnaW5JbWFnZURhdGE6IDY0LFxuICBlbmRJbmxpbmVJbWFnZTogNjUsXG4gIHBhaW50WE9iamVjdDogNjYsXG4gIG1hcmtQb2ludDogNjcsXG4gIG1hcmtQb2ludFByb3BzOiA2OCxcbiAgYmVnaW5NYXJrZWRDb250ZW50OiA2OSxcbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHM6IDcwLFxuICBlbmRNYXJrZWRDb250ZW50OiA3MSxcbiAgYmVnaW5Db21wYXQ6IDcyLFxuICBlbmRDb21wYXQ6IDczLFxuICBwYWludEZvcm1YT2JqZWN0QmVnaW46IDc0LFxuICBwYWludEZvcm1YT2JqZWN0RW5kOiA3NSxcbiAgYmVnaW5Hcm91cDogNzYsXG4gIGVuZEdyb3VwOiA3NyxcbiAgYmVnaW5Bbm5vdGF0aW9uOiA4MCxcbiAgZW5kQW5ub3RhdGlvbjogODEsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxLFxuICBzZXRTdHJva2VUcmFuc3BhcmVudDogOTIsXG4gIHNldEZpbGxUcmFuc3BhcmVudDogOTMsXG4gIHJhd0ZpbGxQYXRoOiA5NFxufTtcbmNvbnN0IERyYXdPUFMgPSB7XG4gIG1vdmVUbzogMCxcbiAgbGluZVRvOiAxLFxuICBjdXJ2ZVRvOiAyLFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiAzLFxuICBjbG9zZVBhdGg6IDRcbn07XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xubGV0IHZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTO1xuZnVuY3Rpb24gc2V0VmVyYm9zaXR5TGV2ZWwobGV2ZWwpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIobGV2ZWwpKSB7XG4gICAgdmVyYm9zaXR5ID0gbGV2ZWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5JTkZPUykge1xuICAgIGNvbnNvbGUuaW5mbyhgSW5mbzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5mdW5jdGlvbiB1bnJlYWNoYWJsZShtc2cpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG59XG5mdW5jdGlvbiBhc3NlcnQoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkge1xuICAgIHVucmVhY2hhYmxlKG1zZyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIHN3aXRjaCAodXJsPy5wcm90b2NvbCkge1xuICAgIGNhc2UgXCJodHRwOlwiOlxuICAgIGNhc2UgXCJodHRwczpcIjpcbiAgICBjYXNlIFwiZnRwOlwiOlxuICAgIGNhc2UgXCJtYWlsdG86XCI6XG4gICAgY2FzZSBcInRlbDpcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwodXJsLCBiYXNlVXJsID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgY29uc3QgZG90cyA9IHVybC5tYXRjaCgvXFwuL2cpO1xuICAgICAgaWYgKGRvdHM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICB1cmwgPSBzdHJpbmdUb1VURjhTdHJpbmcodXJsKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gIH1cbiAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gVVJMLnBhcnNlKHVybCwgYmFzZVVybCkgOiBVUkwucGFyc2UodXJsKTtcbiAgcmV0dXJuIF9pc1ZhbGlkUHJvdG9jb2woYWJzb2x1dGVVcmwpID8gYWJzb2x1dGVVcmwgOiBudWxsO1xufVxuZnVuY3Rpb24gdXBkYXRlVXJsSGFzaCh1cmwsIGhhc2gsIGFsbG93UmVsID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzID0gVVJMLnBhcnNlKHVybCk7XG4gIGlmIChyZXMpIHtcbiAgICByZXMuaGFzaCA9IGhhc2g7XG4gICAgcmV0dXJuIHJlcy5ocmVmO1xuICB9XG4gIGlmIChhbGxvd1JlbCAmJiBjcmVhdGVWYWxpZEFic29sdXRlVXJsKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIikpIHtcbiAgICByZXR1cm4gdXJsLnNwbGl0KFwiI1wiLCAxKVswXSArIGAke2hhc2ggPyBgIyR7aGFzaH1gIDogXCJcIn1gO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuZnVuY3Rpb24gc2hhZG93KG9iaiwgcHJvcCwgdmFsdWUsIG5vblNlcmlhbGl6YWJsZSA9IGZhbHNlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZSxcbiAgICBlbnVtZXJhYmxlOiAhbm9uU2VyaWFsaXphYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG4gIEJhc2VFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG4gIEJhc2VFeGNlcHRpb24uY29uc3RydWN0b3IgPSBCYXNlRXhjZXB0aW9uO1xuICByZXR1cm4gQmFzZUV4Y2VwdGlvbjtcbn0oKTtcbmNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgIHN1cGVyKG1zZywgXCJQYXNzd29yZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5jbGFzcyBSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cywgbWlzc2luZykge1xuICAgIHN1cGVyKG1zZywgXCJSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLm1pc3NpbmcgPSBtaXNzaW5nO1xuICB9XG59XG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiRm9ybWF0RXJyb3JcIik7XG4gIH1cbn1cbmNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJBYm9ydEV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzICE9PSBcIm9iamVjdFwiIHx8IGJ5dGVzPy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIHV0aWxfRmVhdHVyZVRlc3Qge1xuICBzdGF0aWMgZ2V0IGlzTGl0dGxlRW5kaWFuKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0xpdHRsZUVuZGlhblwiLCBpc0xpdHRsZUVuZGlhbigpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRXZhbFN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNFdmFsU3VwcG9ydGVkXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ltYWdlRGVjb2RlclN1cHBvcnRlZFwiLCB0eXBlb2YgSW1hZ2VEZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzRmxvYXQxNkFycmF5U3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0Zsb2F0MTZBcnJheVN1cHBvcnRlZFwiLCB0eXBlb2YgRmxvYXQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzU2FuaXRpemVyU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc1Nhbml0aXplclN1cHBvcnRlZFwiLCB0eXBlb2YgU2FuaXRpemVyICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXRmb3JtLFxuICAgICAgdXNlckFnZW50XG4gICAgfSA9IG5hdmlnYXRvcjtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNBbmRyb2lkOiB1c2VyQWdlbnQuaW5jbHVkZXMoXCJBbmRyb2lkXCIpLFxuICAgICAgaXNMaW51eDogcGxhdGZvcm0uaW5jbHVkZXMoXCJMaW51eFwiKSxcbiAgICAgIGlzTWFjOiBwbGF0Zm9ybS5pbmNsdWRlcyhcIk1hY1wiKSxcbiAgICAgIGlzV2luZG93czogcGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc0ZpcmVmb3g6IHVzZXJBZ2VudC5pbmNsdWRlcyhcIkZpcmVmb3hcIilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzQ1NTUm91bmRTdXBwb3J0ZWRcIiwgZ2xvYmFsVGhpcy5DU1M/LnN1cHBvcnRzPy4oXCJ3aWR0aDogcm91bmQoMS41cHgsIDFweClcIikpO1xuICB9XG59XG5jb25zdCBoZXhOdW1iZXJzID0gQXJyYXkuZnJvbShBcnJheSgyNTYpLmtleXMoKSwgbiA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuY2xhc3MgVXRpbCB7XG4gIHN0YXRpYyBtYWtlSGV4Q29sb3IociwgZywgYikge1xuICAgIHJldHVybiBgIyR7aGV4TnVtYmVyc1tyXX0ke2hleE51bWJlcnNbZ119JHtoZXhOdW1iZXJzW2JdfWA7XG4gIH1cbiAgc3RhdGljIGRvbU1hdHJpeFRvVHJhbnNmb3JtKGRtKSB7XG4gICAgcmV0dXJuIFtkbS5hLCBkbS5iLCBkbS5jLCBkbS5kLCBkbS5lLCBkbS5mXTtcbiAgfVxuICBzdGF0aWMgc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpIHtcbiAgICBsZXQgdGVtcDtcbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzBdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIGlmICh0cmFuc2Zvcm1bM10gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgaWYgKHRyYW5zZm9ybVsxXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFsxXTtcbiAgICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzFdICo9IHRyYW5zZm9ybVsxXTtcbiAgICAgIG1pbk1heFszXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMF0gKj0gdHJhbnNmb3JtWzJdO1xuICAgICAgbWluTWF4WzJdICo9IHRyYW5zZm9ybVsyXTtcbiAgICB9XG4gICAgbWluTWF4WzBdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMV0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFsyXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzNdICs9IHRyYW5zZm9ybVs1XTtcbiAgfVxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG4gIHN0YXRpYyBtdWx0aXBseUJ5RE9NTWF0cml4KG0sIG1kKSB7XG4gICAgcmV0dXJuIFttWzBdICogbWQuYSArIG1bMl0gKiBtZC5iLCBtWzFdICogbWQuYSArIG1bM10gKiBtZC5iLCBtWzBdICogbWQuYyArIG1bMl0gKiBtZC5kLCBtWzFdICogbWQuYyArIG1bM10gKiBtZC5kLCBtWzBdICogbWQuZSArIG1bMl0gKiBtZC5mICsgbVs0XSwgbVsxXSAqIG1kLmUgKyBtWzNdICogbWQuZiArIG1bNV1dO1xuICB9XG4gIHN0YXRpYyBhcHBseVRyYW5zZm9ybShwLCBtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgcDAgPSBwW3Bvc107XG4gICAgY29uc3QgcDEgPSBwW3BvcyArIDFdO1xuICAgIHBbcG9zXSA9IHAwICogbVswXSArIHAxICogbVsyXSArIG1bNF07XG4gICAgcFtwb3MgKyAxXSA9IHAwICogbVsxXSArIHAxICogbVszXSArIG1bNV07XG4gIH1cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtVG9CZXppZXIocCwgdHJhbnNmb3JtLCBwb3MgPSAwKSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHBJID0gcFtwb3MgKyBpXTtcbiAgICAgIGNvbnN0IHBJMSA9IHBbcG9zICsgaSArIDFdO1xuICAgICAgcFtwb3MgKyBpXSA9IHBJICogbTAgKyBwSTEgKiBtMiArIG00O1xuICAgICAgcFtwb3MgKyBpICsgMV0gPSBwSSAqIG0xICsgcEkxICogbTMgKyBtNTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgcDAgPSBwWzBdO1xuICAgIGNvbnN0IHAxID0gcFsxXTtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICBwWzBdID0gKHAwICogbVszXSAtIHAxICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBwWzFdID0gKC1wMCAqIG1bMV0gKyBwMSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gIH1cbiAgc3RhdGljIGF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHJlY3QsIHRyYW5zZm9ybSwgb3V0cHV0KSB7XG4gICAgY29uc3QgbTAgPSB0cmFuc2Zvcm1bMF07XG4gICAgY29uc3QgbTEgPSB0cmFuc2Zvcm1bMV07XG4gICAgY29uc3QgbTIgPSB0cmFuc2Zvcm1bMl07XG4gICAgY29uc3QgbTMgPSB0cmFuc2Zvcm1bM107XG4gICAgY29uc3QgbTQgPSB0cmFuc2Zvcm1bNF07XG4gICAgY29uc3QgbTUgPSB0cmFuc2Zvcm1bNV07XG4gICAgY29uc3QgcjAgPSByZWN0WzBdO1xuICAgIGNvbnN0IHIxID0gcmVjdFsxXTtcbiAgICBjb25zdCByMiA9IHJlY3RbMl07XG4gICAgY29uc3QgcjMgPSByZWN0WzNdO1xuICAgIGxldCBhMCA9IG0wICogcjAgKyBtNDtcbiAgICBsZXQgYTIgPSBhMDtcbiAgICBsZXQgYTEgPSBtMCAqIHIyICsgbTQ7XG4gICAgbGV0IGEzID0gYTE7XG4gICAgbGV0IGIwID0gbTMgKiByMSArIG01O1xuICAgIGxldCBiMiA9IGIwO1xuICAgIGxldCBiMSA9IG0zICogcjMgKyBtNTtcbiAgICBsZXQgYjMgPSBiMTtcbiAgICBpZiAobTEgIT09IDAgfHwgbTIgIT09IDApIHtcbiAgICAgIGNvbnN0IG0xcjAgPSBtMSAqIHIwO1xuICAgICAgY29uc3QgbTFyMiA9IG0xICogcjI7XG4gICAgICBjb25zdCBtMnIxID0gbTIgKiByMTtcbiAgICAgIGNvbnN0IG0ycjMgPSBtMiAqIHIzO1xuICAgICAgYTAgKz0gbTJyMTtcbiAgICAgIGEzICs9IG0ycjE7XG4gICAgICBhMSArPSBtMnIzO1xuICAgICAgYTIgKz0gbTJyMztcbiAgICAgIGIwICs9IG0xcjA7XG4gICAgICBiMyArPSBtMXIwO1xuICAgICAgYjEgKz0gbTFyMjtcbiAgICAgIGIyICs9IG0xcjI7XG4gICAgfVxuICAgIG91dHB1dFswXSA9IE1hdGgubWluKG91dHB1dFswXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFsxXSA9IE1hdGgubWluKG91dHB1dFsxXSwgYjAsIGIxLCBiMiwgYjMpO1xuICAgIG91dHB1dFsyXSA9IE1hdGgubWF4KG91dHB1dFsyXSwgYTAsIGExLCBhMiwgYTMpO1xuICAgIG91dHB1dFszXSA9IE1hdGgubWF4KG91dHB1dFszXSwgYjAsIGIxLCBiMiwgYjMpO1xuICB9XG4gIHN0YXRpYyBpbnZlcnNlVHJhbnNmb3JtKG0pIHtcbiAgICBjb25zdCBkID0gbVswXSAqIG1bM10gLSBtWzFdICogbVsyXTtcbiAgICByZXR1cm4gW21bM10gLyBkLCAtbVsxXSAvIGQsIC1tWzJdIC8gZCwgbVswXSAvIGQsIChtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQsIChtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGRdO1xuICB9XG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtYXRyaXgsIG91dHB1dCkge1xuICAgIGNvbnN0IG0wID0gbWF0cml4WzBdO1xuICAgIGNvbnN0IG0xID0gbWF0cml4WzFdO1xuICAgIGNvbnN0IG0yID0gbWF0cml4WzJdO1xuICAgIGNvbnN0IG0zID0gbWF0cml4WzNdO1xuICAgIGNvbnN0IGEgPSBtMCAqKiAyICsgbTEgKiogMjtcbiAgICBjb25zdCBiID0gbTAgKiBtMiArIG0xICogbTM7XG4gICAgY29uc3QgYyA9IG0yICoqIDIgKyBtMyAqKiAyO1xuICAgIGNvbnN0IGZpcnN0ID0gKGEgKyBjKSAvIDI7XG4gICAgY29uc3Qgc2Vjb25kID0gTWF0aC5zcXJ0KGZpcnN0ICoqIDIgLSAoYSAqIGMgLSBiICoqIDIpKTtcbiAgICBvdXRwdXRbMF0gPSBNYXRoLnNxcnQoZmlyc3QgKyBzZWNvbmQgfHwgMSk7XG4gICAgb3V0cHV0WzFdID0gTWF0aC5zcXJ0KGZpcnN0IC0gc2Vjb25kIHx8IDEpO1xuICB9XG4gIHN0YXRpYyBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICBjb25zdCByID0gcmVjdC5zbGljZSgwKTtcbiAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgIHJbMF0gPSByZWN0WzJdO1xuICAgICAgclsyXSA9IHJlY3RbMF07XG4gICAgfVxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgc3RhdGljIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICBjb25zdCB4TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5taW4ocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgY29uc3QgeEhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVswXSwgcmVjdDFbMl0pLCBNYXRoLm1heChyZWN0MlswXSwgcmVjdDJbMl0pKTtcbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeUxvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWluKHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGNvbnN0IHlIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5tYXgocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgaWYgKHlMb3cgPiB5SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuICBzdGF0aWMgcG9pbnRCb3VuZGluZ0JveCh4LCB5LCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyByZWN0Qm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIG1pbk1heCkge1xuICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgeDAsIHgxKTtcbiAgICBtaW5NYXhbMV0gPSBNYXRoLm1pbihtaW5NYXhbMV0sIHkwLCB5MSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4MCwgeDEpO1xuICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgeTAsIHkxKTtcbiAgfVxuICBzdGF0aWMgI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIHQsIG1pbk1heCkge1xuICAgIGlmICh0IDw9IDAgfHwgdCA+PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgY29uc3QgdHQgPSB0ICogdDtcbiAgICBjb25zdCB0dHQgPSB0dCAqIHQ7XG4gICAgY29uc3QgeCA9IG10ICogKG10ICogKG10ICogeDAgKyAzICogdCAqIHgxKSArIDMgKiB0dCAqIHgyKSArIHR0dCAqIHgzO1xuICAgIGNvbnN0IHkgPSBtdCAqIChtdCAqIChtdCAqIHkwICsgMyAqIHQgKiB5MSkgKyAzICogdHQgKiB5MikgKyB0dHQgKiB5MztcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgpO1xuICAgIG1pbk1heFsxXSA9IE1hdGgubWluKG1pbk1heFsxXSwgeSk7XG4gICAgbWluTWF4WzJdID0gTWF0aC5tYXgobWluTWF4WzJdLCB4KTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkpO1xuICB9XG4gIHN0YXRpYyAjZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCBhLCBiLCBjLCBtaW5NYXgpIHtcbiAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgaWYgKE1hdGguYWJzKGIpID49IDFlLTEyKSB7XG4gICAgICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsIC1jIC8gYiwgbWluTWF4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVsdGEgPSBiICoqIDIgLSA0ICogYyAqIGE7XG4gICAgaWYgKGRlbHRhIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzcXJ0RGVsdGEgPSBNYXRoLnNxcnQoZGVsdGEpO1xuICAgIGNvbnN0IGEyID0gMiAqIGE7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW1PbkN1cnZlKHgwLCB4MSwgeDIsIHgzLCB5MCwgeTEsIHkyLCB5MywgKC1iICsgc3FydERlbHRhKSAvIGEyLCBtaW5NYXgpO1xuICAgIHRoaXMuI2dldEV4dHJlbXVtT25DdXJ2ZSh4MCwgeDEsIHgyLCB4MywgeTAsIHkxLCB5MiwgeTMsICgtYiAtIHNxcnREZWx0YSkgLyBhMiwgbWluTWF4KTtcbiAgfVxuICBzdGF0aWMgYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCBtaW5NYXgpIHtcbiAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIHgwLCB4Myk7XG4gICAgbWluTWF4WzFdID0gTWF0aC5taW4obWluTWF4WzFdLCB5MCwgeTMpO1xuICAgIG1pbk1heFsyXSA9IE1hdGgubWF4KG1pbk1heFsyXSwgeDAsIHgzKTtcbiAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIHkwLCB5Myk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC14MCArIDMgKiAoeDEgLSB4MikgKyB4MyksIDYgKiAoeDAgLSAyICogeDEgKyB4MiksIDMgKiAoeDEgLSB4MCksIG1pbk1heCk7XG4gICAgdGhpcy4jZ2V0RXh0cmVtdW0oeDAsIHgxLCB4MiwgeDMsIHkwLCB5MSwgeTIsIHkzLCAzICogKC15MCArIDMgKiAoeTEgLSB5MikgKyB5MyksIDYgKiAoeTAgLSAyICogeTEgKyB5MiksIDMgKiAoeTEgLSB5MCksIG1pbk1heCk7XG4gIH1cbn1cbmNvbnN0IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlID0gKC8qIHVudXNlZCBwdXJlIGV4cHJlc3Npb24gb3Igc3VwZXIgKi8gbnVsbCAmJiAoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MmQ4LCAweDJjNywgMHgyYzYsIDB4MmQ5LCAweDJkZCwgMHgyZGIsIDB4MmRhLCAweDJkYywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMHgyMDIyLCAweDIwMjAsIDB4MjAyMSwgMHgyMDI2LCAweDIwMTQsIDB4MjAxMywgMHgxOTIsIDB4MjA0NCwgMHgyMDM5LCAweDIwM2EsIDB4MjIxMiwgMHgyMDMwLCAweDIwMWUsIDB4MjAxYywgMHgyMDFkLCAweDIwMTgsIDB4MjAxOSwgMHgyMDFhLCAweDIxMjIsIDB4ZmIwMSwgMHhmYjAyLCAweDE0MSwgMHgxNTIsIDB4MTYwLCAweDE3OCwgMHgxN2QsIDB4MTMxLCAweDE0MiwgMHgxNTMsIDB4MTYxLCAweDE3ZSwgMCwgMHgyMGFjXSkpO1xuZnVuY3Rpb24gc3RyaW5nVG9QREZTdHJpbmcoc3RyLCBrZWVwRXNjYXBlU2VxdWVuY2UgPSBmYWxzZSkge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcbiAgICBpZiAoc3RyWzBdID09PSBcIlxceEZFXCIgJiYgc3RyWzFdID09PSBcIlxceEZGXCIpIHtcbiAgICAgIGVuY29kaW5nID0gXCJ1dGYtMTZiZVwiO1xuICAgICAgaWYgKHN0ci5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgICBpZiAoc3RyLmxlbmd0aCAlIDIgPT09IDEpIHtcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIGlmIChrZWVwRXNjYXBlU2VxdWVuY2UgfHwgIWRlY29kZWQuaW5jbHVkZXMoXCJcXHgxYlwiKSkge1xuICAgICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWNvZGVkLnJlcGxhY2VBbGwoL1xceDFiW15cXHgxYl0qKD86XFx4MWJ8JCkvZywgXCJcIik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICgha2VlcEVzY2FwZVNlcXVlbmNlICYmIGNoYXJDb2RlID09PSAweDFiKSB7XG4gICAgICB3aGlsZSAoKytpIDwgaWkgJiYgc3RyLmNoYXJDb2RlQXQoaSkgIT09IDB4MWIpIHt9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW2NoYXJDb2RlXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5mdW5jdGlvbiB1dGY4U3RyaW5nVG9TdHJpbmcoc3RyKSB7XG4gIHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG59XG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IGFycjEubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoKSkge1xuICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cbmxldCBOb3JtYWxpemVSZWdleCA9IG51bGw7XG5sZXQgTm9ybWFsaXphdGlvbk1hcCA9IG51bGw7XG5mdW5jdGlvbiBub3JtYWxpemVVbmljb2RlKHN0cikge1xuICBpZiAoIU5vcm1hbGl6ZVJlZ2V4KSB7XG4gICAgTm9ybWFsaXplUmVnZXggPSAvKFtcXHUwMGEwXFx1MDBiNVxcdTAzN2VcXHUwZWIzXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIxMjZcXHVmYjAwLVxcdWZiMDRcXHVmYjA2XFx1ZmIyMC1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmJhMVxcdWZiYTQtXFx1ZmJhOVxcdWZiYWUtXFx1ZmJiMVxcdWZiZDMtXFx1ZmJkY1xcdWZiZGUtXFx1ZmJlN1xcdWZiZWEtXFx1ZmJmOFxcdWZiZmMtXFx1ZmJmZFxcdWZjMDAtXFx1ZmM1ZFxcdWZjNjQtXFx1ZmNmMVxcdWZjZjUtXFx1ZmQzZFxcdWZkODhcXHVmZGY0XFx1ZmRmYS1cXHVmZGZiXFx1ZmU3MVxcdWZlNzdcXHVmZTc5XFx1ZmU3YlxcdWZlN2RdKyl8KFxcdWZiMDUrKS9ndTtcbiAgICBOb3JtYWxpemF0aW9uTWFwID0gbmV3IE1hcChbW1wi76yFXCIsIFwixb90XCJdXSk7XG4gIH1cbiAgcmV0dXJuIHN0ci5yZXBsYWNlQWxsKE5vcm1hbGl6ZVJlZ2V4LCAoXywgcDEsIHAyKSA9PiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMikpO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1Zik7XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmZ1bmN0aW9uIF9pc1ZhbGlkRXhwbGljaXREZXN0KHZhbGlkUmVmLCB2YWxpZE5hbWUsIGRlc3QpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRlc3QpIHx8IGRlc3QubGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbcGFnZSwgem9vbSwgLi4uYXJnc10gPSBkZXN0O1xuICBpZiAoIXZhbGlkUmVmKHBhZ2UpICYmICFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2UpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghdmFsaWROYW1lKHpvb20pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFyZ3NMZW4gPSBhcmdzLmxlbmd0aDtcbiAgbGV0IGFsbG93TnVsbCA9IHRydWU7XG4gIHN3aXRjaCAoem9vbS5uYW1lKSB7XG4gICAgY2FzZSBcIlhZWlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gPCAyIHx8IGFyZ3NMZW4gPiAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGaXRcIjpcbiAgICBjYXNlIFwiRml0QlwiOlxuICAgICAgcmV0dXJuIGFyZ3NMZW4gPT09IDA7XG4gICAgY2FzZSBcIkZpdEhcIjpcbiAgICBjYXNlIFwiRml0QkhcIjpcbiAgICBjYXNlIFwiRml0VlwiOlxuICAgIGNhc2UgXCJGaXRCVlwiOlxuICAgICAgaWYgKGFyZ3NMZW4gPiAxKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGaXRSXCI6XG4gICAgICBpZiAoYXJnc0xlbiAhPT0gNCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBhbGxvd051bGwgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiIHx8IGFsbG93TnVsbCAmJiBhcmcgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBNYXRoQ2xhbXAodiwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG59XG5mdW5jdGlvbiB0b0hleFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0hleCkge1xuICAgIHJldHVybiBhcnIudG9IZXgoKTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShhcnIsIG51bSA9PiBoZXhOdW1iZXJzW251bV0pLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiB0b0Jhc2U2NFV0aWwoYXJyKSB7XG4gIGlmIChVaW50OEFycmF5LnByb3RvdHlwZS50b0Jhc2U2NCkge1xuICAgIHJldHVybiBhcnIudG9CYXNlNjQoKTtcbiAgfVxuICByZXR1cm4gYnRvYShieXRlc1RvU3RyaW5nKGFycikpO1xufVxuZnVuY3Rpb24gZnJvbUJhc2U2NFV0aWwoc3RyKSB7XG4gIGlmIChVaW50OEFycmF5LmZyb21CYXNlNjQpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tQmFzZTY0KHN0cik7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoYXRvYihzdHIpKTtcbn1cbmlmICh0eXBlb2YgUHJvbWlzZS50cnkgIT09IFwiZnVuY3Rpb25cIikge1xuICBQcm9taXNlLnRyeSA9IGZ1bmN0aW9uIChmbiwgLi4uYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHJlc29sdmUoZm4oLi4uYXJncykpO1xuICAgIH0pO1xuICB9O1xufVxuaWYgKHR5cGVvZiBNYXRoLnN1bVByZWNpc2UgIT09IFwiZnVuY3Rpb25cIikge1xuICBNYXRoLnN1bVByZWNpc2UgPSBmdW5jdGlvbiAobnVtYmVycykge1xuICAgIHJldHVybiBudW1iZXJzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICB9O1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS94ZmFfdGV4dC5qc1xuY2xhc3MgWGZhVGV4dCB7XG4gIHN0YXRpYyB0ZXh0Q29udGVudCh4ZmEpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGl0ZW1zLFxuICAgICAgc3R5bGVzOiBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKCFYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5vZGU/LmF0dHJpYnV0ZXM/LnRleHRDb250ZW50KSB7XG4gICAgICAgIHN0ciA9IG5vZGUuYXR0cmlidXRlcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICBzdHIgPSBub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICBzdHJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHdhbGsoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICB3YWxrKHhmYSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkveGZhX2xheWVyLmpzXG5cbmNsYXNzIFhmYUxheWVyIHtcbiAgc3RhdGljIHNldHVwU3RvcmFnZShodG1sLCBpZCwgZWxlbWVudCwgc3RvcmFnZSwgaW50ZW50KSB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG4gICAgc3dpdGNoIChlbGVtZW50Lm5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwudGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICBpZiAoZWxlbWVudC5hdHRyaWJ1dGVzLnR5cGUgPT09IFwicmFkaW9cIiB8fCBlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgPT09IGVsZW1lbnQuYXR0cmlidXRlcy54ZmFPbikge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9mZikge1xuICAgICAgICAgICAgaHRtbC5yZW1vdmVBdHRyaWJ1dGUoXCJjaGVja2VkXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT25cIikgOiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT2ZmXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgaWYgKHN0b3JlZERhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uYXR0cmlidXRlcy52YWx1ZSA9PT0gc3RvcmVkRGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KFwic2VsZWN0ZWRcIikpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3B0aW9ucy5zZWxlY3RlZEluZGV4ID09PSAtMSA/IFwiXCIgOiBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgc2V0QXR0cmlidXRlcyh7XG4gICAgaHRtbCxcbiAgICBlbGVtZW50LFxuICAgIHN0b3JhZ2UgPSBudWxsLFxuICAgIGludGVudCxcbiAgICBsaW5rU2VydmljZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGlzSFRNTEFuY2hvckVsZW1lbnQgPSBodG1sIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5hbWUgPSBgJHthdHRyaWJ1dGVzLm5hbWV9LSR7aW50ZW50fWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUuam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFJZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaHRtbC5zdHlsZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0hUTUxBbmNob3JFbGVtZW50IHx8IGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcIm5ld1dpbmRvd1wiKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhodG1sLCBhdHRyaWJ1dGVzLmhyZWYsIGF0dHJpYnV0ZXMubmV3V2luZG93KTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2UgJiYgYXR0cmlidXRlcy5kYXRhSWQpIHtcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlKGh0bWwsIGF0dHJpYnV0ZXMuZGF0YUlkLCBlbGVtZW50LCBzdG9yYWdlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgbGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIGNvbnN0IHJvb3QgPSBwYXJhbWV0ZXJzLnhmYUh0bWw7XG4gICAgY29uc3QgaW50ZW50ID0gcGFyYW1ldGVycy5pbnRlbnQgfHwgXCJkaXNwbGF5XCI7XG4gICAgY29uc3Qgcm9vdEh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJvb3QubmFtZSk7XG4gICAgaWYgKHJvb3QuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgaHRtbDogcm9vdEh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHJvb3QsXG4gICAgICAgIGludGVudCxcbiAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBpc05vdEZvclJpY2hUZXh0ID0gaW50ZW50ICE9PSBcInJpY2hUZXh0XCI7XG4gICAgY29uc3Qgcm9vdERpdiA9IHBhcmFtZXRlcnMuZGl2O1xuICAgIHJvb3REaXYuYXBwZW5kKHJvb3RIdG1sKTtcbiAgICBpZiAocGFyYW1ldGVycy52aWV3cG9ydCkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgcm9vdERpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmIChpc05vdEZvclJpY2hUZXh0KSB7XG4gICAgICByb290RGl2LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwieGZhTGF5ZXIgeGZhRm9udFwiKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dERpdnMgPSBbXTtcbiAgICBpZiAocm9vdC5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChyb290LnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyb290LnZhbHVlKTtcbiAgICAgICAgcm9vdEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgICBpZiAoaXNOb3RGb3JSaWNoVGV4dCAmJiBYZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChyb290Lm5hbWUpKSB7XG4gICAgICAgICAgdGV4dERpdnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dERpdnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gW1tyb290LCAtMSwgcm9vdEh0bWxdXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW3BhcmVudCwgaSwgaHRtbF0gPSBzdGFjay5hdCgtMSk7XG4gICAgICBpZiAoaSArIDEgPT09IHBhcmVudC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5bKytzdGFjay5hdCgtMSlbMV1dO1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lXG4gICAgICB9ID0gY2hpbGQ7XG4gICAgICBpZiAobmFtZSA9PT0gXCIjdGV4dFwiKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG4gICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIGh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkSHRtbCA9IGNoaWxkPy5hdHRyaWJ1dGVzPy54bWxucyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhjaGlsZC5hdHRyaWJ1dGVzLnhtbG5zLCBuYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmFtZSk7XG4gICAgICBodG1sLmFwcGVuZChjaGlsZEh0bWwpO1xuICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICBodG1sOiBjaGlsZEh0bWwsXG4gICAgICAgICAgZWxlbWVudDogY2hpbGQsXG4gICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICBpbnRlbnQsXG4gICAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuY2hpbGRyZW4/Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChbY2hpbGQsIC0xLCBjaGlsZEh0bWxdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgaWYgKGlzTm90Rm9yUmljaFRleHQgJiYgWGZhVGV4dC5zaG91bGRCdWlsZFRleHQobmFtZSkpIHtcbiAgICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkSHRtbC5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWwgb2Ygcm9vdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLnhmYU5vbkludGVyYWN0aXZlIGlucHV0LCAueGZhTm9uSW50ZXJhY3RpdmUgdGV4dGFyZWFcIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRPbmx5XCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGV4dERpdnNcbiAgICB9O1xuICB9XG4gIHN0YXRpYyB1cGRhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IGBtYXRyaXgoJHtwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKX0pYDtcbiAgICBwYXJhbWV0ZXJzLmRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgcGFyYW1ldGVycy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZGlzcGxheV91dGlscy5qc1xuXG5cbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIHR5cGUgPSBcInRleHRcIikge1xuICBpZiAoaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdHlwZTtcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgcmVzb2x2ZShyZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuICAgIHJlcXVlc3Quc2VuZChudWxsKTtcbiAgfSk7XG59XG5jbGFzcyBQYWdlVmlld3BvcnQge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbixcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0pIHtcbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMudXNlclVuaXQgPSB1c2VyVW5pdDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBzY2FsZSAqPSB1c2VyVW5pdDtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiArPSAzNjA7XG4gICAgfVxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gLTE7XG4gICAgICAgIHJvdGF0ZUMgPSAtMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuICAgIGlmIChkb250RmxpcCkge1xuICAgICAgcm90YXRlQyA9IC1yb3RhdGVDO1xuICAgICAgcm90YXRlRCA9IC1yb3RhdGVEO1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9ICh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9ICh2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgKiBzY2FsZTtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGdldCByYXdEaW1zKCkge1xuICAgIGNvbnN0IGRpbXMgPSB0aGlzLnZpZXdCb3g7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInJhd0RpbXNcIiwge1xuICAgICAgcGFnZVdpZHRoOiBkaW1zWzJdIC0gZGltc1swXSxcbiAgICAgIHBhZ2VIZWlnaHQ6IGRpbXNbM10gLSBkaW1zWzFdLFxuICAgICAgcGFnZVg6IGRpbXNbMF0sXG4gICAgICBwYWdlWTogZGltc1sxXVxuICAgIH0pO1xuICB9XG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIGNvbnN0IHAgPSBbeCwgeV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBbcmVjdFswXSwgcmVjdFsxXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybSh0b3BMZWZ0LCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgVXRpbC5hcHBseVRyYW5zZm9ybShib3R0b21SaWdodCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgY29uc3QgcCA9IFt4LCB5XTtcbiAgICBVdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmV4dHJhRGVsYXkgPSBleHRyYURlbGF5O1xuICB9XG59XG5mdW5jdGlvbiBpc0RhdGFTY2hlbWUodXJsKSB7XG4gIGNvbnN0IGlpID0gdXJsLmxlbmd0aDtcbiAgbGV0IGkgPSAwO1xuICB3aGlsZSAoaSA8IGlpICYmIHVybFtpXS50cmltKCkgPT09IFwiXCIpIHtcbiAgICBpKys7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cbmZ1bmN0aW9uIGlzUGRmRmlsZShmaWxlbmFtZSkge1xuICByZXR1cm4gdHlwZW9mIGZpbGVuYW1lID09PSBcInN0cmluZ1wiICYmIC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSk7XG59XG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21VcmwodXJsKSB7XG4gIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbn1cbmZ1bmN0aW9uIGdldFBkZkZpbGVuYW1lRnJvbVVybCh1cmwsIGRlZmF1bHRGaWxlbmFtZSA9IFwiZG9jdW1lbnQucGRmXCIpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG4gIGlmIChpc0RhdGFTY2hlbWUodXJsKSkge1xuICAgIHdhcm4oJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBnZXRVUkwgPSB1cmxTdHJpbmcgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IFVSTCh1cmxTdHJpbmcpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwoZGVjb2RlVVJJQ29tcG9uZW50KHVybFN0cmluZykpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsU3RyaW5nLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVJMKGRlY29kZVVSSUNvbXBvbmVudCh1cmxTdHJpbmcpLCBcImh0dHBzOi8vZm9vLmJhclwiKTtcbiAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgbmV3VVJMID0gZ2V0VVJMKHVybCk7XG4gIGlmICghbmV3VVJMKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuICBjb25zdCBkZWNvZGUgPSBuYW1lID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGRlY29kZWQgPSBkZWNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICBpZiAoZGVjb2RlZC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbiAgICAgICAgaWYgKGRlY29kZWQudGVzdCgvXlxcLnBkZiQvaSkpIHtcbiAgICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICB9O1xuICBjb25zdCBwZGZSZWdleCA9IC9cXC5wZGYkL2k7XG4gIGNvbnN0IGZpbGVuYW1lID0gbmV3VVJMLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5hdCgtMSk7XG4gIGlmIChwZGZSZWdleC50ZXN0KGZpbGVuYW1lKSkge1xuICAgIHJldHVybiBkZWNvZGUoZmlsZW5hbWUpO1xuICB9XG4gIGlmIChuZXdVUkwuc2VhcmNoUGFyYW1zLnNpemUgPiAwKSB7XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuZnJvbShuZXdVUkwuc2VhcmNoUGFyYW1zLnZhbHVlcygpKS5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmIChwZGZSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IEFycmF5LmZyb20obmV3VVJMLnNlYXJjaFBhcmFtcy5rZXlzKCkpLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAocGRmUmVnZXgudGVzdChrZXkpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5ld1VSTC5oYXNoKSB7XG4gICAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICAgIGNvbnN0IGhhc2hGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhuZXdVUkwuaGFzaCk7XG4gICAgaWYgKGhhc2hGaWxlbmFtZSkge1xuICAgICAgcmV0dXJuIGRlY29kZShoYXNoRmlsZW5hbWVbMF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xufVxuY2xhc3MgU3RhdFRpbWVyIHtcbiAgc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHRpbWVzID0gW107XG4gIHRpbWUobmFtZSkge1xuICAgIGlmIChuYW1lIGluIHRoaXMuc3RhcnRlZCkge1xuICAgICAgd2FybihgVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciAke25hbWV9YCk7XG4gICAgfVxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cbiAgdGltZUVuZChuYW1lKSB7XG4gICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICB3YXJuKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRGZXRjaFVybCh1cmwsIGJhc2VVcmwpIHtcbiAgY29uc3QgcmVzID0gYmFzZVVybCA/IFVSTC5wYXJzZSh1cmwsIGJhc2VVcmwpIDogVVJMLnBhcnNlKHVybCk7XG4gIHJldHVybiByZXM/LnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcmVzPy5wcm90b2NvbCA9PT0gXCJodHRwczpcIjtcbn1cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnUoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZSkge1xuICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgI3JlZ2V4O1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gdGhpcy4jcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKTtcbiAgICBsZXQgbW9udGggPSBwYXJzZUludChtYXRjaGVzWzJdLCAxMCk7XG4gICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICBsZXQgZGF5ID0gcGFyc2VJbnQobWF0Y2hlc1szXSwgMTApO1xuICAgIGRheSA9IGRheSA+PSAxICYmIGRheSA8PSAzMSA/IGRheSA6IDE7XG4gICAgbGV0IGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgaG91ciA9IGhvdXIgPj0gMCAmJiBob3VyIDw9IDIzID8gaG91ciA6IDA7XG4gICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKTtcbiAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgIGxldCBzZWNvbmQgPSBwYXJzZUludChtYXRjaGVzWzZdLCAxMCk7XG4gICAgc2Vjb25kID0gc2Vjb25kID49IDAgJiYgc2Vjb25kIDw9IDU5ID8gc2Vjb25kIDogMDtcbiAgICBjb25zdCB1bml2ZXJzYWxUaW1lUmVsYXRpb24gPSBtYXRjaGVzWzddIHx8IFwiWlwiO1xuICAgIGxldCBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgIG9mZnNldEhvdXIgPSBvZmZzZXRIb3VyID49IDAgJiYgb2Zmc2V0SG91ciA8PSAyMyA/IG9mZnNldEhvdXIgOiAwO1xuICAgIGxldCBvZmZzZXRNaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzldLCAxMCkgfHwgMDtcbiAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuICAgIGlmICh1bml2ZXJzYWxUaW1lUmVsYXRpb24gPT09IFwiLVwiKSB7XG4gICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICBtaW51dGUgKz0gb2Zmc2V0TWludXRlO1xuICAgIH0gZWxzZSBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIitcIikge1xuICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlIC09IG9mZnNldE1pbnV0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFhmYVBhZ2VWaWV3cG9ydCh4ZmFQYWdlLCB7XG4gIHNjYWxlID0gMSxcbiAgcm90YXRpb24gPSAwXG59KSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICB1c2VyVW5pdDogMSxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICB3YXJuKGBOb3QgYSB2YWxpZCBjb2xvciBmb3JtYXQ6IFwiJHtjb2xvcn1cImApO1xuICByZXR1cm4gWzAsIDAsIDBdO1xufVxuZnVuY3Rpb24gZ2V0Q29sb3JWYWx1ZXMoY29sb3JzKSB7XG4gIGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgc3Bhbi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgc3Bhbi5zdHlsZS5jb2xvclNjaGVtZSA9IFwib25seSBsaWdodFwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCwgbXVzdEZsaXAgPSBmYWxzZSwgbXVzdFJvdGF0ZSA9IHRydWUpIHtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IHV0aWxfRmVhdHVyZVRlc3QuaXNDU1NSb3VuZFN1cHBvcnRlZDtcbiAgICBjb25zdCB3ID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VXaWR0aH1weGAsXG4gICAgICBoID0gYHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKiAke3BhZ2VIZWlnaHR9cHhgO1xuICAgIGNvbnN0IHdpZHRoU3RyID0gdXNlUm91bmQgPyBgcm91bmQoZG93biwgJHt3fSwgdmFyKC0tc2NhbGUtcm91bmQteCkpYCA6IGBjYWxjKCR7d30pYCxcbiAgICAgIGhlaWdodFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKGRvd24sICR7aH0sIHZhcigtLXNjYWxlLXJvdW5kLXkpKWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuY2xhc3MgT3V0cHV0U2NhbGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvXG4gICAgfSA9IE91dHB1dFNjYWxlO1xuICAgIHRoaXMuc3ggPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuc3kgPSBwaXhlbFJhdGlvO1xuICB9XG4gIGdldCBzY2FsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ggIT09IDEgfHwgdGhpcy5zeSAhPT0gMTtcbiAgfVxuICBnZXQgc3ltbWV0cmljKCkge1xuICAgIHJldHVybiB0aGlzLnN4ID09PSB0aGlzLnN5O1xuICB9XG4gIGxpbWl0Q2FudmFzKHdpZHRoLCBoZWlnaHQsIG1heFBpeGVscywgbWF4RGltLCBjYXBBcmVhRmFjdG9yID0gLTEpIHtcbiAgICBsZXQgbWF4QXJlYVNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhXaWR0aFNjYWxlID0gSW5maW5pdHksXG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IEluZmluaXR5O1xuICAgIG1heFBpeGVscyA9IE91dHB1dFNjYWxlLmNhcFBpeGVscyhtYXhQaXhlbHMsIGNhcEFyZWFGYWN0b3IpO1xuICAgIGlmIChtYXhQaXhlbHMgPiAwKSB7XG4gICAgICBtYXhBcmVhU2NhbGUgPSBNYXRoLnNxcnQobWF4UGl4ZWxzIC8gKHdpZHRoICogaGVpZ2h0KSk7XG4gICAgfVxuICAgIGlmIChtYXhEaW0gIT09IC0xKSB7XG4gICAgICBtYXhXaWR0aFNjYWxlID0gbWF4RGltIC8gd2lkdGg7XG4gICAgICBtYXhIZWlnaHRTY2FsZSA9IG1heERpbSAvIGhlaWdodDtcbiAgICB9XG4gICAgY29uc3QgbWF4U2NhbGUgPSBNYXRoLm1pbihtYXhBcmVhU2NhbGUsIG1heFdpZHRoU2NhbGUsIG1heEhlaWdodFNjYWxlKTtcbiAgICBpZiAodGhpcy5zeCA+IG1heFNjYWxlIHx8IHRoaXMuc3kgPiBtYXhTY2FsZSkge1xuICAgICAgdGhpcy5zeCA9IG1heFNjYWxlO1xuICAgICAgdGhpcy5zeSA9IG1heFNjYWxlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHBpeGVsUmF0aW8oKSB7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICB9XG4gIHN0YXRpYyBjYXBQaXhlbHMobWF4UGl4ZWxzLCBjYXBBcmVhRmFjdG9yKSB7XG4gICAgaWYgKGNhcEFyZWFGYWN0b3IgPj0gMCkge1xuICAgICAgY29uc3Qgd2luUGl4ZWxzID0gTWF0aC5jZWlsKHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aCAqIHdpbmRvdy5zY3JlZW4uYXZhaWxIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKiogMiAqICgxICsgY2FwQXJlYUZhY3RvciAvIDEwMCkpO1xuICAgICAgcmV0dXJuIG1heFBpeGVscyA+IDAgPyBNYXRoLm1pbihtYXhQaXhlbHMsIHdpblBpeGVscykgOiB3aW5QaXhlbHM7XG4gICAgfVxuICAgIHJldHVybiBtYXhQaXhlbHM7XG4gIH1cbn1cbmNvbnN0IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzID0gW1wiaW1hZ2UvYXBuZ1wiLCBcImltYWdlL2F2aWZcIiwgXCJpbWFnZS9ibXBcIiwgXCJpbWFnZS9naWZcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2Uvc3ZnK3htbFwiLCBcImltYWdlL3dlYnBcIiwgXCJpbWFnZS94LWljb25cIl07XG5jbGFzcyBDb2xvclNjaGVtZSB7XG4gIHN0YXRpYyBnZXQgaXNEYXJrTW9kZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNEYXJrTW9kZVwiLCAhIXdpbmRvdz8ubWF0Y2hNZWRpYT8uKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKTtcbiAgfVxufVxuY2xhc3MgQ1NTQ29uc3RhbnRzIHtcbiAgc3RhdGljIGdldCBjb21tZW50Rm9yZWdyb3VuZENvbG9yKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21tZW50XCIsIFwic2lkZWJhclwiKTtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBlbGVtZW50O1xuICAgIHN0eWxlLndpZHRoID0gc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHN0eWxlLmNvbG9yID0gXCJ2YXIoLS1jb21tZW50LWZnLWNvbG9yKVwiO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGVsZW1lbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yXG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImNvbW1lbnRGb3JlZ3JvdW5kQ29sb3JcIiwgZ2V0UkdCKGNvbG9yKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5T3BhY2l0eShyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgPSBNYXRoLm1pbihNYXRoLm1heChvcGFjaXR5ID8/IDEsIDApLCAxKTtcbiAgY29uc3Qgd2hpdGUgPSAyNTUgKiAoMSAtIG9wYWNpdHkpO1xuICByID0gTWF0aC5yb3VuZChyICogb3BhY2l0eSArIHdoaXRlKTtcbiAgZyA9IE1hdGgucm91bmQoZyAqIG9wYWNpdHkgKyB3aGl0ZSk7XG4gIGIgPSBNYXRoLnJvdW5kKGIgKiBvcGFjaXR5ICsgd2hpdGUpO1xuICByZXR1cm4gW3IsIGcsIGJdO1xufVxuZnVuY3Rpb24gUkdCVG9IU0wocmdiLCBvdXRwdXQpIHtcbiAgY29uc3QgciA9IHJnYlswXSAvIDI1NTtcbiAgY29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcbiAgY29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICBvdXRwdXRbMF0gPSBvdXRwdXRbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XG4gICAgb3V0cHV0WzFdID0gbCA8IDAuNSA/IGQgLyAobWF4ICsgbWluKSA6IGQgLyAoMiAtIG1heCAtIG1pbik7XG4gICAgc3dpdGNoIChtYXgpIHtcbiAgICAgIGNhc2UgcjpcbiAgICAgICAgb3V0cHV0WzBdID0gKChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApKSAqIDYwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgb3V0cHV0WzBdID0gKChiIC0gcikgLyBkICsgMikgKiA2MDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGI6XG4gICAgICAgIG91dHB1dFswXSA9ICgociAtIGcpIC8gZCArIDQpICogNjA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvdXRwdXRbMl0gPSBsO1xufVxuZnVuY3Rpb24gSFNMVG9SR0IoaHNsLCBvdXRwdXQpIHtcbiAgY29uc3QgaCA9IGhzbFswXTtcbiAgY29uc3QgcyA9IGhzbFsxXTtcbiAgY29uc3QgbCA9IGhzbFsyXTtcbiAgY29uc3QgYyA9ICgxIC0gTWF0aC5hYnMoMiAqIGwgLSAxKSkgKiBzO1xuICBjb25zdCB4ID0gYyAqICgxIC0gTWF0aC5hYnMoaCAvIDYwICUgMiAtIDEpKTtcbiAgY29uc3QgbSA9IGwgLSBjIC8gMjtcbiAgc3dpdGNoIChNYXRoLmZsb29yKGggLyA2MCkpIHtcbiAgICBjYXNlIDA6XG4gICAgICBvdXRwdXRbMF0gPSBjICsgbTtcbiAgICAgIG91dHB1dFsxXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzJdID0gbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIG91dHB1dFswXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzFdID0gYyArIG07XG4gICAgICBvdXRwdXRbMl0gPSBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgb3V0cHV0WzBdID0gbTtcbiAgICAgIG91dHB1dFsxXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzJdID0geCArIG07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBvdXRwdXRbMF0gPSBtO1xuICAgICAgb3V0cHV0WzFdID0geCArIG07XG4gICAgICBvdXRwdXRbMl0gPSBjICsgbTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIG91dHB1dFswXSA9IHggKyBtO1xuICAgICAgb3V0cHV0WzFdID0gbTtcbiAgICAgIG91dHB1dFsyXSA9IGMgKyBtO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgIGNhc2UgNjpcbiAgICAgIG91dHB1dFswXSA9IGMgKyBtO1xuICAgICAgb3V0cHV0WzFdID0gbTtcbiAgICAgIG91dHB1dFsyXSA9IHggKyBtO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVMdW1pbmFuY2UoeCkge1xuICByZXR1cm4geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbn1cbmZ1bmN0aW9uIGNvbnRyYXN0UmF0aW8oaHNsMSwgaHNsMiwgb3V0cHV0KSB7XG4gIEhTTFRvUkdCKGhzbDEsIG91dHB1dCk7XG4gIG91dHB1dC5tYXAoY29tcHV0ZUx1bWluYW5jZSk7XG4gIGNvbnN0IGx1bTEgPSAwLjIxMjYgKiBvdXRwdXRbMF0gKyAwLjcxNTIgKiBvdXRwdXRbMV0gKyAwLjA3MjIgKiBvdXRwdXRbMl07XG4gIEhTTFRvUkdCKGhzbDIsIG91dHB1dCk7XG4gIG91dHB1dC5tYXAoY29tcHV0ZUx1bWluYW5jZSk7XG4gIGNvbnN0IGx1bTIgPSAwLjIxMjYgKiBvdXRwdXRbMF0gKyAwLjcxNTIgKiBvdXRwdXRbMV0gKyAwLjA3MjIgKiBvdXRwdXRbMl07XG4gIHJldHVybiBsdW0xID4gbHVtMiA/IChsdW0xICsgMC4wNSkgLyAobHVtMiArIDAuMDUpIDogKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG59XG5jb25zdCBjb250cmFzdENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZmluZENvbnRyYXN0Q29sb3IoYmFzZUNvbG9yLCBmaXhlZENvbG9yKSB7XG4gIGNvbnN0IGtleSA9IGJhc2VDb2xvclswXSArIGJhc2VDb2xvclsxXSAqIDB4MTAwICsgYmFzZUNvbG9yWzJdICogMHgxMDAwMCArIGZpeGVkQ29sb3JbMF0gKiAweDEwMDAwMDAgKyBmaXhlZENvbG9yWzFdICogMHgxMDAwMDAwMDAgKyBmaXhlZENvbG9yWzJdICogMHgxMDAwMDAwMDAwMDtcbiAgbGV0IGNhY2hlZFZhbHVlID0gY29udHJhc3RDYWNoZS5nZXQoa2V5KTtcbiAgaWYgKGNhY2hlZFZhbHVlKSB7XG4gICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICB9XG4gIGNvbnN0IGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgY29uc3Qgb3V0cHV0ID0gYXJyYXkuc3ViYXJyYXkoMCwgMyk7XG4gIGNvbnN0IGJhc2VIU0wgPSBhcnJheS5zdWJhcnJheSgzLCA2KTtcbiAgUkdCVG9IU0woYmFzZUNvbG9yLCBiYXNlSFNMKTtcbiAgY29uc3QgZml4ZWRIU0wgPSBhcnJheS5zdWJhcnJheSg2LCA5KTtcbiAgUkdCVG9IU0woZml4ZWRDb2xvciwgZml4ZWRIU0wpO1xuICBjb25zdCBpc0ZpeGVkQ29sb3JEYXJrID0gZml4ZWRIU0xbMl0gPCAwLjU7XG4gIGNvbnN0IG1pbkNvbnRyYXN0ID0gaXNGaXhlZENvbG9yRGFyayA/IDEyIDogNC41O1xuICBiYXNlSFNMWzJdID0gaXNGaXhlZENvbG9yRGFyayA/IE1hdGguc3FydChiYXNlSFNMWzJdKSA6IDEgLSBNYXRoLnNxcnQoMSAtIGJhc2VIU0xbMl0pO1xuICBpZiAoY29udHJhc3RSYXRpbyhiYXNlSFNMLCBmaXhlZEhTTCwgb3V0cHV0KSA8IG1pbkNvbnRyYXN0KSB7XG4gICAgbGV0IHN0YXJ0LCBlbmQ7XG4gICAgaWYgKGlzRml4ZWRDb2xvckRhcmspIHtcbiAgICAgIHN0YXJ0ID0gYmFzZUhTTFsyXTtcbiAgICAgIGVuZCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IGJhc2VIU0xbMl07XG4gICAgfVxuICAgIGNvbnN0IFBSRUNJU0lPTiA9IDAuMDA1O1xuICAgIHdoaWxlIChlbmQgLSBzdGFydCA+IFBSRUNJU0lPTikge1xuICAgICAgY29uc3QgbWlkID0gYmFzZUhTTFsyXSA9IChzdGFydCArIGVuZCkgLyAyO1xuICAgICAgaWYgKGlzRml4ZWRDb2xvckRhcmsgPT09IGNvbnRyYXN0UmF0aW8oYmFzZUhTTCwgZml4ZWRIU0wsIG91dHB1dCkgPCBtaW5Db250cmFzdCkge1xuICAgICAgICBzdGFydCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgYmFzZUhTTFsyXSA9IGlzRml4ZWRDb2xvckRhcmsgPyBlbmQgOiBzdGFydDtcbiAgfVxuICBIU0xUb1JHQihiYXNlSFNMLCBvdXRwdXQpO1xuICBjYWNoZWRWYWx1ZSA9IFV0aWwubWFrZUhleENvbG9yKE1hdGgucm91bmQob3V0cHV0WzBdICogMjU1KSwgTWF0aC5yb3VuZChvdXRwdXRbMV0gKiAyNTUpLCBNYXRoLnJvdW5kKG91dHB1dFsyXSAqIDI1NSkpO1xuICBjb250cmFzdENhY2hlLnNldChrZXksIGNhY2hlZFZhbHVlKTtcbiAgcmV0dXJuIGNhY2hlZFZhbHVlO1xufVxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoe1xuICBodG1sLFxuICBkaXIsXG4gIGNsYXNzTmFtZVxufSwgY29udGFpbmVyKSB7XG4gIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICBpZiAodHlwZW9mIGh0bWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5kaXIgPSBkaXIgfHwgXCJhdXRvXCI7XG4gICAgY29uc3QgbGluZXMgPSBodG1sLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBmcmFnbWVudC5hcHBlbmQocCk7XG4gIH0gZWxzZSB7XG4gICAgWGZhTGF5ZXIucmVuZGVyKHtcbiAgICAgIHhmYUh0bWw6IGh0bWwsXG4gICAgICBkaXY6IGZyYWdtZW50LFxuICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCJcbiAgICB9KTtcbiAgfVxuICBmcmFnbWVudC5maXJzdEVsZW1lbnRDaGlsZC5jbGFzc0xpc3QuYWRkKFwicmljaFRleHRcIiwgY2xhc3NOYW1lKTtcbiAgY29udGFpbmVyLmFwcGVuZChmcmFnbWVudCk7XG59XG5mdW5jdGlvbiBtYWtlUGF0aEZyb21EcmF3T1BTKGRhdGEpIHtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTspIHtcbiAgICBzd2l0Y2ggKGRhdGFbaSsrXSkge1xuICAgICAgY2FzZSBEcmF3T1BTLm1vdmVUbzpcbiAgICAgICAgcGF0aC5tb3ZlVG8oZGF0YVtpKytdLCBkYXRhW2krK10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhd09QUy5saW5lVG86XG4gICAgICAgIHBhdGgubGluZVRvKGRhdGFbaSsrXSwgZGF0YVtpKytdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYXdPUFMuY3VydmVUbzpcbiAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRHJhd09QUy5xdWFkcmF0aWNDdXJ2ZVRvOlxuICAgICAgICBwYXRoLnF1YWRyYXRpY0N1cnZlVG8oZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERyYXdPUFMuY2xvc2VQYXRoOlxuICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYFVucmVjb2duaXplZCBkcmF3aW5nIHBhdGggb3BlcmF0b3I6ICR7ZGF0YVtpIC0gMV19YCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL3Rvb2xiYXIuanNcblxuY2xhc3MgRWRpdG9yVG9vbGJhciB7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI2NvbG9yUGlja2VyID0gbnVsbDtcbiAgI2VkaXRvcjtcbiAgI2J1dHRvbnMgPSBudWxsO1xuICAjYWx0VGV4dCA9IG51bGw7XG4gICNjb21tZW50ID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b25EaXZpZGVyID0gbnVsbDtcbiAgI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uID0gbnVsbDtcbiAgc3RhdGljICNsMTBuUmVtb3ZlID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yID0gZWRpdG9yO1xuICAgIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmUgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1mcmVldGV4dC1idXR0b25cIixcbiAgICAgIGhpZ2hsaWdodDogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWhpZ2hsaWdodC1idXR0b25cIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItcmVtb3ZlLWluay1idXR0b25cIixcbiAgICAgIHN0YW1wOiBcInBkZmpzLWVkaXRvci1yZW1vdmUtc3RhbXAtYnV0dG9uXCIsXG4gICAgICBzaWduYXR1cmU6IFwicGRmanMtZWRpdG9yLXJlbW92ZS1zaWduYXR1cmUtYnV0dG9uXCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiZWRpdFRvb2xiYXJcIiwgXCJoaWRkZW5cIik7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBpZiAoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwgJiYgIXNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBlZGl0VG9vbGJhci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIEVkaXRvclRvb2xiYXIuI3BvaW50ZXJEb3duLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzLiNidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBidXR0b25zLmNsYXNzTmFtZSA9IFwiYnV0dG9uc1wiO1xuICAgIGVkaXRUb29sYmFyLmFwcGVuZChidXR0b25zKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI2VkaXRvci50b29sYmFyUG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gZWRpdFRvb2xiYXI7XG4gICAgICBjb25zdCB4ID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiID8gMSAtIHBvc2l0aW9uWzBdIDogcG9zaXRpb25bMF07XG4gICAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgICBzdHlsZS50b3AgPSBgY2FsYygkezEwMCAqIHBvc2l0aW9uWzFdfSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gIGdldCBkaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Rvb2xiYXI7XG4gIH1cbiAgc3RhdGljICNwb2ludGVyRG93bihlKSB7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjZm9jdXNJbihlKSB7XG4gICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICBzdG9wRXZlbnQoZSk7XG4gIH1cbiAgI2ZvY3VzT3V0KGUpIHtcbiAgICB0aGlzLiNlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgc3RvcEV2ZW50KGUpO1xuICB9XG4gICNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHx8IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgdGhpcy4jZm9jdXNJbi5iaW5kKHRoaXMpLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy4jZm9jdXNPdXQuYmluZCh0aGlzKSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy4jdG9vbGJhci5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5oaWRlRHJvcGRvd24oKTtcbiAgfVxuICBzaG93KCkge1xuICAgIHRoaXMuI3Rvb2xiYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbiAgICB0aGlzLiNhbHRUZXh0Py5zaG93bigpO1xuICAgIHRoaXMuI2NvbW1lbnQ/LnNob3duKCk7XG4gIH1cbiAgYWRkRGVsZXRlQnV0dG9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclR5cGUsXG4gICAgICBfdWlNYW5hZ2VyXG4gICAgfSA9IHRoaXMuI2VkaXRvcjtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiYmFzaWNcIiwgXCJkZWxldGVCdXR0b25cIik7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEVkaXRvclRvb2xiYXIuI2wxMG5SZW1vdmVbZWRpdG9yVHlwZV0pO1xuICAgIGlmICh0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKSkge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBlID0+IHtcbiAgICAgICAgX3VpTWFuYWdlci5kZWxldGUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsOiBfdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24pO1xuICB9XG4gIGdldCAjZGl2aWRlcigpIHtcbiAgICBjb25zdCBkaXZpZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXZpZGVyLmNsYXNzTmFtZSA9IFwiZGl2aWRlclwiO1xuICAgIHJldHVybiBkaXZpZGVyO1xuICB9XG4gIGFzeW5jIGFkZEFsdFRleHQoYWx0VGV4dCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGF3YWl0IGFsdFRleHQucmVuZGVyKCk7XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uLCB0aGlzLiNkaXZpZGVyKTtcbiAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgfVxuICBhZGRDb21tZW50KGNvbW1lbnQsIGJlZm9yZUVsZW1lbnQgPSBudWxsKSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uID0gY29tbWVudC5yZW5kZXJGb3JUb29sYmFyKCk7XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkTGlzdGVuZXJzVG9FbGVtZW50KGJ1dHRvbik7XG4gICAgY29uc3QgZGl2aWRlciA9IHRoaXMuI2NvbW1lbnRCdXR0b25EaXZpZGVyID0gdGhpcy4jZGl2aWRlcjtcbiAgICBpZiAoIWJlZm9yZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgZGl2aWRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2J1dHRvbnMuaW5zZXJ0QmVmb3JlKGJ1dHRvbiwgYmVmb3JlRWxlbWVudCk7XG4gICAgICB0aGlzLiNidXR0b25zLmluc2VydEJlZm9yZShkaXZpZGVyLCBiZWZvcmVFbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgY29tbWVudC50b29sYmFyID0gdGhpcztcbiAgfVxuICBhZGRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIGlmICh0aGlzLiNjb2xvclBpY2tlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICAgIGNvbnN0IGJ1dHRvbiA9IGNvbG9yUGlja2VyLnJlbmRlckJ1dHRvbigpO1xuICAgIHRoaXMuI2FkZExpc3RlbmVyc1RvRWxlbWVudChidXR0b24pO1xuICAgIHRoaXMuI2J1dHRvbnMuYXBwZW5kKGJ1dHRvbiwgdGhpcy4jZGl2aWRlcik7XG4gIH1cbiAgYXN5bmMgYWRkRWRpdFNpZ25hdHVyZUJ1dHRvbihzaWduYXR1cmVNYW5hZ2VyKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24gPSBhd2FpdCBzaWduYXR1cmVNYW5hZ2VyLnJlbmRlckVkaXRCdXR0b24odGhpcy4jZWRpdG9yKTtcbiAgICB0aGlzLiNhZGRMaXN0ZW5lcnNUb0VsZW1lbnQoYnV0dG9uKTtcbiAgICB0aGlzLiNidXR0b25zLmFwcGVuZChidXR0b24sIHRoaXMuI2RpdmlkZXIpO1xuICB9XG4gIHJlbW92ZUJ1dHRvbihuYW1lKSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICB0aGlzLiNjb21tZW50Py5yZW1vdmVUb29sYmFyQ29tbWVudEJ1dHRvbigpO1xuICAgICAgICB0aGlzLiNjb21tZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbkRpdmlkZXI/LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLiNjb21tZW50QnV0dG9uRGl2aWRlciA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBhc3luYyBhZGRCdXR0b24obmFtZSwgdG9vbCkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcImNvbG9yUGlja2VyXCI6XG4gICAgICAgIGlmICh0b29sKSB7XG4gICAgICAgICAgdGhpcy5hZGRDb2xvclBpY2tlcih0b29sKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJhbHRUZXh0XCI6XG4gICAgICAgIGlmICh0b29sKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5hZGRBbHRUZXh0KHRvb2wpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVkaXRTaWduYXR1cmVcIjpcbiAgICAgICAgaWYgKHRvb2wpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFkZEVkaXRTaWduYXR1cmVCdXR0b24odG9vbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIHRoaXMuYWRkRGVsZXRlQnV0dG9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgaWYgKHRvb2wpIHtcbiAgICAgICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZEJ1dHRvbkJlZm9yZShuYW1lLCB0b29sLCBiZWZvcmVTZWxlY3Rvcikge1xuICAgIGlmICghdG9vbCAmJiBuYW1lID09PSBcImNvbW1lbnRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmVFbGVtZW50ID0gdGhpcy4jYnV0dG9ucy5xdWVyeVNlbGVjdG9yKGJlZm9yZVNlbGVjdG9yKTtcbiAgICBpZiAoIWJlZm9yZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICB0aGlzLmFkZENvbW1lbnQodG9vbCwgYmVmb3JlRWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVkaXRTaWduYXR1cmVCdXR0b24oZGVzY3JpcHRpb24pIHtcbiAgICBpZiAodGhpcy4jc2lnbmF0dXJlRGVzY3JpcHRpb25CdXR0b24pIHtcbiAgICAgIHRoaXMuI3NpZ25hdHVyZURlc2NyaXB0aW9uQnV0dG9uLnRpdGxlID0gZGVzY3JpcHRpb247XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiN0b29sYmFyLnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBGbG9hdGluZ1Rvb2xiYXIge1xuICAjYnV0dG9ucyA9IG51bGw7XG4gICN0b29sYmFyID0gbnVsbDtcbiAgI3VpTWFuYWdlcjtcbiAgY29uc3RydWN0b3IodWlNYW5hZ2VyKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICB9XG4gICNyZW5kZXIoKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXIgPSB0aGlzLiN0b29sYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlZGl0VG9vbGJhci5jbGFzc05hbWUgPSBcImVkaXRUb29sYmFyXCI7XG4gICAgZWRpdFRvb2xiYXIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2xiYXJcIik7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKHNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsICYmICFzaWduYWwuYWJvcnRlZCkge1xuICAgICAgZWRpdFRvb2xiYXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9ucyA9IHRoaXMuI2J1dHRvbnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGJ1dHRvbnMuY2xhc3NOYW1lID0gXCJidXR0b25zXCI7XG4gICAgZWRpdFRvb2xiYXIuYXBwZW5kKGJ1dHRvbnMpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgdGhpcy4jbWFrZUJ1dHRvbihcImNvbW1lbnRCdXR0b25cIiwgYHBkZmpzLWNvbW1lbnQtZmxvYXRpbmctYnV0dG9uYCwgXCJwZGZqcy1jb21tZW50LWZsb2F0aW5nLWJ1dHRvbi1sYWJlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI3VpTWFuYWdlci5jb21tZW50U2VsZWN0aW9uKFwiZmxvYXRpbmdfYnV0dG9uXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuI21ha2VCdXR0b24oXCJoaWdobGlnaHRCdXR0b25cIiwgYHBkZmpzLWhpZ2hsaWdodC1mbG9hdGluZy1idXR0b24xYCwgXCJwZGZqcy1oaWdobGlnaHQtZmxvYXRpbmctYnV0dG9uLWxhYmVsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5oaWdobGlnaHRTZWxlY3Rpb24oXCJmbG9hdGluZ19idXR0b25cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVkaXRUb29sYmFyO1xuICB9XG4gICNnZXRMYXN0UG9pbnQoYm94ZXMsIGlzTFRSKSB7XG4gICAgbGV0IGxhc3RZID0gMDtcbiAgICBsZXQgbGFzdFggPSAwO1xuICAgIGZvciAoY29uc3QgYm94IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgaWYgKHkgPCBsYXN0WSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHggPSBib3gueCArIChpc0xUUiA/IGJveC53aWR0aCA6IDApO1xuICAgICAgaWYgKHkgPiBsYXN0WSkge1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgaWYgKHggPiBsYXN0WCkge1xuICAgICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh4IDwgbGFzdFgpIHtcbiAgICAgICAgbGFzdFggPSB4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2lzTFRSID8gMSAtIGxhc3RYIDogbGFzdFgsIGxhc3RZXTtcbiAgfVxuICBzaG93KHBhcmVudCwgYm94ZXMsIGlzTFRSKSB7XG4gICAgY29uc3QgW3gsIHldID0gdGhpcy4jZ2V0TGFzdFBvaW50KGJveGVzLCBpc0xUUik7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jdG9vbGJhciB8fD0gdGhpcy4jcmVuZGVyKCk7XG4gICAgcGFyZW50LmFwcGVuZCh0aGlzLiN0b29sYmFyKTtcbiAgICBzdHlsZS5pbnNldElubGluZUVuZCA9IGAkezEwMCAqIHh9JWA7XG4gICAgc3R5bGUudG9wID0gYGNhbGMoJHsxMDAgKiB5fSUgKyB2YXIoLS1lZGl0b3ItdG9vbGJhci12ZXJ0LW9mZnNldCkpYDtcbiAgfVxuICBoaWRlKCkge1xuICAgIHRoaXMuI3Rvb2xiYXIucmVtb3ZlKCk7XG4gIH1cbiAgI21ha2VCdXR0b24oYnV0dG9uQ2xhc3MsIGwxMG5JZCwgbGFiZWxMMTBuSWQsIGNsaWNrSGFuZGxlcikge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJiYXNpY1wiLCBidXR0b25DbGFzcyk7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIGwxMG5JZCk7XG4gICAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGJ1dHRvbi5hcHBlbmQoc3Bhbik7XG4gICAgc3Bhbi5jbGFzc05hbWUgPSBcInZpc3VhbGx5SGlkZGVuXCI7XG4gICAgc3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbGFiZWxMMTBuSWQpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGlmIChzaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCAmJiAhc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbGlja0hhbmRsZXIsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy4jYnV0dG9ucy5hcHBlbmQoYnV0dG9uKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvdG9vbHMuanNcblxuXG5cbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmNsYXNzIEN1cnJlbnRQb2ludGVycyB7XG4gIHN0YXRpYyAjcG9pbnRlcklkID0gTmFOO1xuICBzdGF0aWMgI3BvaW50ZXJJZHMgPSBudWxsO1xuICBzdGF0aWMgI21vdmVUaW1lc3RhbXAgPSBOYU47XG4gIHN0YXRpYyAjcG9pbnRlclR5cGUgPSBudWxsO1xuICBzdGF0aWMgaW5pdGlhbGl6ZUFuZEFkZFBvaW50ZXJJZChwb2ludGVySWQpIHtcbiAgICAoQ3VycmVudFBvaW50ZXJzLiNwb2ludGVySWRzIHx8PSBuZXcgU2V0KCkpLmFkZChwb2ludGVySWQpO1xuICB9XG4gIHN0YXRpYyBzZXRQb2ludGVyKHBvaW50ZXJUeXBlLCBwb2ludGVySWQpIHtcbiAgICBDdXJyZW50UG9pbnRlcnMuI3BvaW50ZXJJZCB8fD0gcG9pbnRlcklkO1xuICAgIEN1cnJlbnRQb2ludGVycy4jcG9pbnRlclR5cGUgPz89IHBvaW50ZXJUeXBlO1xuICB9XG4gIHN0YXRpYyBzZXRUaW1lU3RhbXAodGltZVN0YW1wKSB7XG4gICAgQ3VycmVudFBvaW50ZXJzLiNtb3ZlVGltZXN0YW1wID0gdGltZVN0YW1wO1xuICB9XG4gIHN0YXRpYyBpc1NhbWVQb2ludGVySWQocG9pbnRlcklkKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRQb2ludGVycy4jcG9pbnRlcklkID09PSBwb2ludGVySWQ7XG4gIH1cbiAgc3RhdGljIGlzU2FtZVBvaW50ZXJJZE9yUmVtb3ZlKHBvaW50ZXJJZCkge1xuICAgIGlmIChDdXJyZW50UG9pbnRlcnMuI3BvaW50ZXJJZCA9PT0gcG9pbnRlcklkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgQ3VycmVudFBvaW50ZXJzLiNwb2ludGVySWRzPy5kZWxldGUocG9pbnRlcklkKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGlzU2FtZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRQb2ludGVycy4jcG9pbnRlclR5cGUgPT09IHBvaW50ZXJUeXBlO1xuICB9XG4gIHN0YXRpYyBpc0luaXRpYWxpemVkQW5kRGlmZmVyZW50UG9pbnRlclR5cGUocG9pbnRlclR5cGUpIHtcbiAgICByZXR1cm4gQ3VycmVudFBvaW50ZXJzLiNwb2ludGVyVHlwZSAhPT0gbnVsbCAmJiAhQ3VycmVudFBvaW50ZXJzLmlzU2FtZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKTtcbiAgfVxuICBzdGF0aWMgaXNTYW1lVGltZVN0YW1wKHRpbWVTdGFtcCkge1xuICAgIHJldHVybiBDdXJyZW50UG9pbnRlcnMuI21vdmVUaW1lc3RhbXAgPT09IHRpbWVTdGFtcDtcbiAgfVxuICBzdGF0aWMgaXNVc2luZ011bHRpcGxlUG9pbnRlcnMoKSB7XG4gICAgcmV0dXJuIEN1cnJlbnRQb2ludGVycy4jcG9pbnRlcklkcz8uc2l6ZSA+PSAxO1xuICB9XG4gIHN0YXRpYyBjbGVhclBvaW50ZXJUeXBlKCkge1xuICAgIEN1cnJlbnRQb2ludGVycy4jcG9pbnRlclR5cGUgPSBudWxsO1xuICB9XG4gIHN0YXRpYyBjbGVhclBvaW50ZXJJZHMoKSB7XG4gICAgQ3VycmVudFBvaW50ZXJzLiNwb2ludGVySWQgPSBOYU47XG4gICAgQ3VycmVudFBvaW50ZXJzLiNwb2ludGVySWRzID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2xlYXJUaW1lU3RhbXAoKSB7XG4gICAgQ3VycmVudFBvaW50ZXJzLiNtb3ZlVGltZXN0YW1wID0gTmFOO1xuICB9XG59XG5jbGFzcyBJZE1hbmFnZXIge1xuICAjaWQgPSAwO1xuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSBnZXRVdWlkKCk7XG4gICNpZCA9IDA7XG4gICNjYWNoZSA9IG51bGw7XG4gIHN0YXRpYyBnZXQgX2lzU1ZHRml0dGluZ0NhbnZhcygpIHtcbiAgICBjb25zdCBzdmcgPSBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsPHN2ZyB2aWV3Qm94PVwiMCAwIDEgMVwiIHdpZHRoPVwiMVwiIGhlaWdodD1cIjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHN0eWxlPVwiZmlsbDpyZWQ7XCIvPjwvc3ZnPmA7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAzKTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2Uuc3JjID0gc3ZnO1xuICAgIGNvbnN0IHByb21pc2UgPSBpbWFnZS5kZWNvZGUoKS50aGVuKCgpID0+IHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIDEsIDEsIDAsIDAsIDEsIDMpO1xuICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEuYnVmZmVyKVswXSA9PT0gMDtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2lzU1ZHRml0dGluZ0NhbnZhc1wiLCBwcm9taXNlKTtcbiAgfVxuICBhc3luYyAjZ2V0KGtleSwgcmF3RGF0YSkge1xuICAgIHRoaXMuI2NhY2hlIHx8PSBuZXcgTWFwKCk7XG4gICAgbGV0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhPy5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhIHx8PSB7XG4gICAgICAgIGJpdG1hcDogbnVsbCxcbiAgICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICAgIHJlZkNvdW50ZXI6IDAsXG4gICAgICAgIGlzU3ZnOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGxldCBpbWFnZTtcbiAgICAgIGlmICh0eXBlb2YgcmF3RGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLnVybCA9IHJhd0RhdGE7XG4gICAgICAgIGltYWdlID0gYXdhaXQgZmV0Y2hEYXRhKHJhd0RhdGEsIFwiYmxvYlwiKTtcbiAgICAgIH0gZWxzZSBpZiAocmF3RGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfSBlbHNlIGlmIChyYXdEYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBpbWFnZSA9IHJhd0RhdGE7XG4gICAgICB9XG4gICAgICBpZiAoaW1hZ2UudHlwZSA9PT0gXCJpbWFnZS9zdmcreG1sXCIpIHtcbiAgICAgICAgY29uc3QgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSA9IEltYWdlTWFuYWdlci5faXNTVkdGaXR0aW5nQ2FudmFzO1xuICAgICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGNvbnN0IGltYWdlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgZGF0YS5iaXRtYXAgPSBpbWFnZUVsZW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmlzU3ZnID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZGF0YS5zdmdVcmwgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSAoYXdhaXQgbXVzdFJlbW92ZUFzcGVjdFJhdGlvUHJvbWlzZSkgPyBgJHt1cmx9I3N2Z1ZpZXcocHJlc2VydmVBc3BlY3RSYXRpbyhub25lKSlgIDogdXJsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSBmaWxlUmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2UpO1xuICAgICAgICBhd2FpdCBpbWFnZVByb21pc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhLmJpdG1hcCA9IGF3YWl0IGNyZWF0ZUltYWdlQml0bWFwKGltYWdlKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucmVmQ291bnRlciA9IDE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihlKTtcbiAgICAgIGRhdGEgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCBkYXRhKTtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KGRhdGEuaWQsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBhc3luYyBnZXRGcm9tRmlsZShmaWxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGFzdE1vZGlmaWVkLFxuICAgICAgbmFtZSxcbiAgICAgIHNpemUsXG4gICAgICB0eXBlXG4gICAgfSA9IGZpbGU7XG4gICAgcmV0dXJuIHRoaXMuI2dldChgJHtsYXN0TW9kaWZpZWR9XyR7bmFtZX1fJHtzaXplfV8ke3R5cGV9YCwgZmlsZSk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbVVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy4jZ2V0KHVybCwgdXJsKTtcbiAgfVxuICBhc3luYyBnZXRGcm9tQmxvYihpZCwgYmxvYlByb21pc2UpIHtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgYmxvYlByb21pc2U7XG4gICAgcmV0dXJuIHRoaXMuI2dldChpZCwgYmxvYik7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJsb2JQcm9taXNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGJsb2JQcm9taXNlXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGRlbGV0ZSBkYXRhLmJsb2JQcm9taXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RnJvbUJsb2IoZGF0YS5pZCwgYmxvYlByb21pc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGcm9tVXJsKGRhdGEudXJsKTtcbiAgfVxuICBnZXRGcm9tQ2FudmFzKGlkLCBjYW52YXMpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgZGF0YSA9IHtcbiAgICAgIGJpdG1hcDogb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpLFxuICAgICAgaWQ6IGBpbWFnZV8ke3RoaXMuI2Jhc2VJZH1fJHt0aGlzLiNpZCsrfWAsXG4gICAgICByZWZDb3VudGVyOiAxLFxuICAgICAgaXNTdmc6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoaWQsIGRhdGEpO1xuICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICBnZXRTdmdVcmwoaWQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGE/LmlzU3ZnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGEuc3ZnVXJsO1xuICB9XG4gIGRlbGV0ZUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS5yZWZDb3VudGVyIC09IDE7XG4gICAgaWYgKGRhdGEucmVmQ291bnRlciAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBiaXRtYXBcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoIWRhdGEudXJsICYmICFkYXRhLmZpbGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiYml0bWFwcmVuZGVyZXJcIik7XG4gICAgICBjdHgudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAoYml0bWFwKTtcbiAgICAgIGRhdGEuYmxvYlByb21pc2UgPSBjYW52YXMuY29udmVydFRvQmxvYigpO1xuICAgIH1cbiAgICBiaXRtYXAuY2xvc2U/LigpO1xuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDEyOCkge1xuICAgIHRoaXMuI21heFNpemUgPSBtYXhTaXplO1xuICB9XG4gIGFkZCh7XG4gICAgY21kLFxuICAgIHVuZG8sXG4gICAgcG9zdCxcbiAgICBtdXN0RXhlYyxcbiAgICB0eXBlID0gTmFOLFxuICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGUgPSBmYWxzZSxcbiAgICBrZWVwVW5kbyA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAobXVzdEV4ZWMpIHtcbiAgICAgIGNtZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbG9ja2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgcG9zdCxcbiAgICAgIHR5cGVcbiAgICB9O1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAob3ZlcndyaXRlSWZTYW1lVHlwZSAmJiB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgaWYgKGtlZXBVbmRvKSB7XG4gICAgICAgIHNhdmUudW5kbyA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvO1xuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dID0gc2F2ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcbiAgICBpZiAobmV4dCA9PT0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKDAsIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG5leHQ7XG4gICAgICBpZiAobmV4dCA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UobmV4dCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cbiAgdW5kbygpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdW5kbyxcbiAgICAgIHBvc3RcbiAgICB9ID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dO1xuICAgIHVuZG8oKTtcbiAgICBwb3N0Py4oKTtcbiAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNwb3NpdGlvbiAtPSAxO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNtZCxcbiAgICAgICAgcG9zdFxuICAgICAgfSA9IHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXTtcbiAgICAgIGNtZCgpO1xuICAgICAgcG9zdD8uKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9VbmRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiAhPT0gLTE7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9SZWRvKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cbiAgY2xlYW5UeXBlKHR5cGUpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNwb3NpdGlvbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLiNjb21tYW5kc1tpXS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZShpICsgMSwgdGhpcy4jcG9zaXRpb24gLSBpKTtcbiAgICAgICAgdGhpcy4jcG9zaXRpb24gPSBpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2NvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy4jcG9zaXRpb24gPSAtMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1hbmRzID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgS2V5Ym9hcmRNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFsbEtleXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncywgZXZlbnQpKCk7XG4gICAgaWYgKCFidWJibGVzKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICBnZXRDb2xvclZhbHVlcyhjb2xvcnMpO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfY29sb3JzXCIsIGNvbG9ycyk7XG4gIH1cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9IGdldFJHQihjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciB7XG4gICNhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAjYWxsRWRpdGFibGVBbm5vdGF0aW9ucyA9IG51bGw7XG4gICNhbGxFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjYWxsTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnMgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2NvbW1lbnRNYW5hZ2VyID0gbnVsbDtcbiAgI2NvcHlQYXN0ZUFDID0gbnVsbDtcbiAgI2N1cnJlbnREcmF3aW5nU2Vzc2lvbiA9IG51bGw7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICNkcmFnZ2luZ0VkaXRvcnMgPSBudWxsO1xuICAjZWRpdG9yVHlwZXMgPSBudWxsO1xuICAjZWRpdG9yc1RvUmVzY2FsZSA9IG5ldyBTZXQoKTtcbiAgX2VkaXRvclVuZG9CYXIgPSBudWxsO1xuICAjZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24gPSBmYWxzZTtcbiAgI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGZhbHNlO1xuICAjZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZSA9IGZhbHNlO1xuICAjZmlsdGVyRmFjdG9yeSA9IG51bGw7XG4gICNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAjZm9jdXNNYW5hZ2VyQUMgPSBudWxsO1xuICAjaGlnaGxpZ2h0Q29sb3JzID0gbnVsbDtcbiAgI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICNmbG9hdGluZ1Rvb2xiYXIgPSBudWxsO1xuICAjaWRNYW5hZ2VyID0gbmV3IElkTWFuYWdlcigpO1xuICAjaXNFbmFibGVkID0gZmFsc2U7XG4gICNpc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc1dhaXRpbmcgPSBmYWxzZTtcbiAgI2tleWJvYXJkTWFuYWdlckFDID0gbnVsbDtcbiAgI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IG51bGw7XG4gICNtaXNzaW5nQ2FudmFzZXMgPSBudWxsO1xuICAjbWxNYW5hZ2VyID0gbnVsbDtcbiAgI21vZGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FO1xuICAjc2VsZWN0ZWRFZGl0b3JzID0gbmV3IFNldCgpO1xuICAjc2VsZWN0ZWRUZXh0Tm9kZSA9IG51bGw7XG4gICNzaWduYXR1cmVNYW5hZ2VyID0gbnVsbDtcbiAgI3BhZ2VDb2xvcnMgPSBudWxsO1xuICAjc2hvd0FsbFN0YXRlcyA9IG51bGw7XG4gICNwZGZEb2N1bWVudCA9IG51bGw7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZFRleHQ6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICAjdmlld2VyQWxlcnQgPSBudWxsO1xuICAjdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLiNjb250YWluZXIuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lICE9PSBcIkJVVFRPTlwiICYmIHNlbGYuaGFzU29tZXRoaW5nVG9Db250cm9sKCk7XG4gICAgY29uc3QgdGV4dElucHV0Q2hlY2tlciA9IChfc2VsZiwge1xuICAgICAgdGFyZ2V0OiBlbFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGVcbiAgICAgICAgfSA9IGVsO1xuICAgICAgICByZXR1cm4gdHlwZSAhPT0gXCJ0ZXh0XCIgJiYgdHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9rZXlib2FyZE1hbmFnZXJcIiwgbmV3IEtleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrYVwiLCBcIm1hYyttZXRhK2FcIl0sIHByb3RvLnNlbGVjdEFsbCwge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt6XCIsIFwibWFjK21ldGErelwiXSwgcHJvdG8udW5kbywge1xuICAgICAgY2hlY2tlcjogdGV4dElucHV0Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG8sIHtcbiAgICAgIGNoZWNrZXI6IHRleHRJbnB1dENoZWNrZXJcbiAgICB9XSwgW1tcIkJhY2tzcGFjZVwiLCBcImFsdCtCYWNrc3BhY2VcIiwgXCJjdHJsK0JhY2tzcGFjZVwiLCBcInNoaWZ0K0JhY2tzcGFjZVwiLCBcIm1hYytCYWNrc3BhY2VcIiwgXCJtYWMrYWx0K0JhY2tzcGFjZVwiLCBcIm1hYytjdHJsK0JhY2tzcGFjZVwiLCBcIkRlbGV0ZVwiLCBcImN0cmwrRGVsZXRlXCIsIFwic2hpZnQrRGVsZXRlXCIsIFwibWFjK0RlbGV0ZVwiXSwgcHJvdG8uZGVsZXRlLCB7XG4gICAgICBjaGVja2VyOiB0ZXh0SW5wdXRDaGVja2VyXG4gICAgfV0sIFtbXCJFbnRlclwiLCBcIm1hYytFbnRlclwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhlbCkgJiYgIXNlbGYuaXNFbnRlckhhbmRsZWRcbiAgICB9XSwgW1tcIiBcIiwgXCJtYWMrIFwiXSwgcHJvdG8uYWRkTmV3RWRpdG9yRnJvbUtleWJvYXJkLCB7XG4gICAgICBjaGVja2VyOiAoc2VsZiwge1xuICAgICAgICB0YXJnZXQ6IGVsXG4gICAgICB9KSA9PiAhKGVsIGluc3RhbmNlb2YgSFRNTEJ1dHRvbkVsZW1lbnQpICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgdmlld2VyQWxlcnQsIGFsdFRleHRNYW5hZ2VyLCBjb21tZW50TWFuYWdlciwgc2lnbmF0dXJlTWFuYWdlciwgZXZlbnRCdXMsIHBkZkRvY3VtZW50LCBwYWdlQ29sb3JzLCBoaWdobGlnaHRDb2xvcnMsIGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uLCBlbmFibGVVcGRhdGVkQWRkSW1hZ2UsIGVuYWJsZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UsIG1sTWFuYWdlciwgZWRpdG9yVW5kb0Jhciwgc3VwcG9ydHNQaW5jaFRvWm9vbSkge1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3NpZ25hbCA9IHRoaXMuI2Fib3J0Q29udHJvbGxlci5zaWduYWw7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3ZpZXdlciA9IHZpZXdlcjtcbiAgICB0aGlzLiN2aWV3ZXJBbGVydCA9IHZpZXdlckFsZXJ0O1xuICAgIHRoaXMuI2FsdFRleHRNYW5hZ2VyID0gYWx0VGV4dE1hbmFnZXI7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXIgPSBjb21tZW50TWFuYWdlcjtcbiAgICB0aGlzLiNzaWduYXR1cmVNYW5hZ2VyID0gc2lnbmF0dXJlTWFuYWdlcjtcbiAgICB0aGlzLiNwZGZEb2N1bWVudCA9IHBkZkRvY3VtZW50O1xuICAgIHRoaXMuX2V2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgZXZlbnRCdXMuX29uKFwiZWRpdGluZ2FjdGlvblwiLCB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy5vblBhZ2VDaGFuZ2luZy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMub25TY2FsZUNoYW5naW5nLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGV2ZW50QnVzLl9vbihcInJvdGF0aW9uY2hhbmdpbmdcIiwgdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZXZlbnRCdXMuX29uKFwic2V0cHJlZmVyZW5jZVwiLCB0aGlzLm9uU2V0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBldmVudEJ1cy5fb24oXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIGV2dCA9PiB0aGlzLnVwZGF0ZVBhcmFtcyhldnQudHlwZSwgZXZ0LnZhbHVlKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNpc1BvaW50ZXJEb3duID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jaXNQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIH0sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNhZGRTZWxlY3Rpb25MaXN0ZW5lcigpO1xuICAgIHRoaXMuI2FkZERyYWdBbmREcm9wTGlzdGVuZXJzKCk7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLiNmaWx0ZXJGYWN0b3J5ID0gcGRmRG9jdW1lbnQuZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLiNwYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPSBoaWdobGlnaHRDb2xvcnMgfHwgbnVsbDtcbiAgICB0aGlzLiNlbmFibGVIaWdobGlnaHRGbG9hdGluZ0J1dHRvbiA9IGVuYWJsZUhpZ2hsaWdodEZsb2F0aW5nQnV0dG9uO1xuICAgIHRoaXMuI2VuYWJsZVVwZGF0ZWRBZGRJbWFnZSA9IGVuYWJsZVVwZGF0ZWRBZGRJbWFnZTtcbiAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZTtcbiAgICB0aGlzLiNtbE1hbmFnZXIgPSBtbE1hbmFnZXIgfHwgbnVsbDtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzID0ge1xuICAgICAgcmVhbFNjYWxlOiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMsXG4gICAgICByb3RhdGlvbjogMFxuICAgIH07XG4gICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgIHRoaXMuX2VkaXRvclVuZG9CYXIgPSBlZGl0b3JVbmRvQmFyIHx8IG51bGw7XG4gICAgdGhpcy5fc3VwcG9ydHNQaW5jaFRvWm9vbSA9IHN1cHBvcnRzUGluY2hUb1pvb20gIT09IGZhbHNlO1xuICAgIGNvbW1lbnRNYW5hZ2VyPy5zZXRTaWRlYmFyVWlNYW5hZ2VyKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHk/LnJlc29sdmUoKTtcbiAgICB0aGlzLiN1cGRhdGVNb2RlQ2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy4jYWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI2Fib3J0Q29udHJvbGxlciA9IG51bGw7XG4gICAgdGhpcy5fc2lnbmFsID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLiNhbGxMYXllcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5jbGVhcigpO1xuICAgIHRoaXMuI21pc3NpbmdDYW52YXNlcz8uY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jc2lnbmF0dXJlTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhciA9IG51bGw7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy4jbWFpbkhpZ2hsaWdodENvbG9yUGlja2VyID0gbnVsbDtcbiAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zID0gbnVsbDtcbiAgICBpZiAodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3BkZkRvY3VtZW50ID0gbnVsbDtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoW3RoaXMuX3NpZ25hbCwgYWMuc2lnbmFsXSk7XG4gIH1cbiAgZ2V0IG1sTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWxNYW5hZ2VyO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0RmxvdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZW5hYmxlVXBkYXRlZEFkZEltYWdlO1xuICB9XG4gIGdldCB1c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlO1xuICB9XG4gIGdldCBoY21GaWx0ZXIoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhjbUZpbHRlclwiLCB0aGlzLiNwYWdlQ29sb3JzID8gdGhpcy4jZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy4jcGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLiNwYWdlQ29sb3JzLmJhY2tncm91bmQpIDogXCJub25lXCIpO1xuICB9XG4gIGdldCBkaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXQgX2hpZ2hsaWdodENvbG9ycygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2hpZ2hsaWdodENvbG9yc1wiLCB0aGlzLiNoaWdobGlnaHRDb2xvcnMgPyBuZXcgTWFwKHRoaXMuI2hpZ2hsaWdodENvbG9ycy5zcGxpdChcIixcIikubWFwKHBhaXIgPT4ge1xuICAgICAgcGFpciA9IHBhaXIuc3BsaXQoXCI9XCIpLm1hcCh4ID0+IHgudHJpbSgpKTtcbiAgICAgIHBhaXJbMV0gPSBwYWlyWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9KSkgOiBudWxsKTtcbiAgfVxuICBnZXQgaGlnaGxpZ2h0Q29sb3JzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIF9oaWdobGlnaHRDb2xvcnNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIV9oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvcnNcIiwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBoYXNIQ00gPSAhIXRoaXMuI3BhZ2VDb2xvcnM7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgY29sb3JdIG9mIF9oaWdobGlnaHRDb2xvcnMpIHtcbiAgICAgIGNvbnN0IGlzTmFtZUZvckhDTSA9IG5hbWUuZW5kc1dpdGgoXCJfSENNXCIpO1xuICAgICAgaWYgKGhhc0hDTSAmJiBpc05hbWVGb3JIQ00pIHtcbiAgICAgICAgbWFwLnNldChuYW1lLnJlcGxhY2UoXCJfSENNXCIsIFwiXCIpLCBjb2xvcik7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNIQ00gJiYgIWlzTmFtZUZvckhDTSkge1xuICAgICAgICBtYXAuc2V0KG5hbWUsIGNvbG9yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImhpZ2hsaWdodENvbG9yc1wiLCBtYXApO1xuICB9XG4gIGdldCBoaWdobGlnaHRDb2xvck5hbWVzKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJoaWdobGlnaHRDb2xvck5hbWVzXCIsIHRoaXMuaGlnaGxpZ2h0Q29sb3JzID8gbmV3IE1hcChBcnJheS5mcm9tKHRoaXMuaGlnaGxpZ2h0Q29sb3JzLCBlID0+IGUucmV2ZXJzZSgpKSkgOiBudWxsKTtcbiAgfVxuICBnZXROb25IQ01Db2xvcihjb2xvcikge1xuICAgIGlmICghdGhpcy5faGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpO1xuICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRDb2xvcnMuZ2V0KGNvbG9yTmFtZSkgfHwgY29sb3I7XG4gIH1cbiAgZ2V0Tm9uSENNQ29sb3JOYW1lKGNvbG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0Q29sb3JOYW1lcy5nZXQoY29sb3IpIHx8IGNvbG9yO1xuICB9XG4gIHNldEN1cnJlbnREcmF3aW5nU2Vzc2lvbihsYXllcikge1xuICAgIGlmIChsYXllcikge1xuICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbiA9IGxheWVyO1xuICB9XG4gIHNldE1haW5IaWdobGlnaHRDb2xvclBpY2tlcihjb2xvclBpY2tlcikge1xuICAgIHRoaXMuI21haW5IaWdobGlnaHRDb2xvclBpY2tlciA9IGNvbG9yUGlja2VyO1xuICB9XG4gIGVkaXRBbHRUZXh0KGVkaXRvciwgZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZWRpdEFsdFRleHQodGhpcywgZWRpdG9yLCBmaXJzdFRpbWUpO1xuICB9XG4gIGhhc0NvbW1lbnRNYW5hZ2VyKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2NvbW1lbnRNYW5hZ2VyO1xuICB9XG4gIGVkaXRDb21tZW50KGVkaXRvciwgcG9zWCwgcG9zWSwgb3B0aW9ucykge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5zaG93RGlhbG9nKHRoaXMsIGVkaXRvciwgcG9zWCwgcG9zWSwgb3B0aW9ucyk7XG4gIH1cbiAgc2VsZWN0Q29tbWVudChwYWdlSW5kZXgsIHVpZCkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jYWxsTGF5ZXJzLmdldChwYWdlSW5kZXgpO1xuICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5nZXRFZGl0b3JCeVVJRCh1aWQpO1xuICAgIGVkaXRvcj8udG9nZ2xlQ29tbWVudCh0cnVlLCB0cnVlKTtcbiAgfVxuICB1cGRhdGVDb21tZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy51cGRhdGVDb21tZW50KGVkaXRvci5nZXREYXRhKCkpO1xuICB9XG4gIHVwZGF0ZVBvcHVwQ29sb3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnVwZGF0ZVBvcHVwQ29sb3IoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVDb21tZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5yZW1vdmVDb21tZW50cyhbZWRpdG9yLnVpZF0pO1xuICB9XG4gIHRvZ2dsZUNvbW1lbnQoZWRpdG9yLCBpc1NlbGVjdGVkLCB2aXNpYmlsaXR5ID0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnRvZ2dsZUNvbW1lbnRQb3B1cChlZGl0b3IsIGlzU2VsZWN0ZWQsIHZpc2liaWxpdHkpO1xuICB9XG4gIG1ha2VDb21tZW50Q29sb3IoY29sb3IsIG9wYWNpdHkpIHtcbiAgICByZXR1cm4gY29sb3IgJiYgdGhpcy4jY29tbWVudE1hbmFnZXI/Lm1ha2VDb21tZW50Q29sb3IoY29sb3IsIG9wYWNpdHkpIHx8IG51bGw7XG4gIH1cbiAgZ2V0Q29tbWVudERpYWxvZ0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRNYW5hZ2VyPy5kaWFsb2dFbGVtZW50IHx8IG51bGw7XG4gIH1cbiAgYXN5bmMgd2FpdEZvckVkaXRvcnNSZW5kZXJlZChwYWdlTnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuI2FsbExheWVycy5oYXMocGFnZU51bWJlciAtIDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmUsXG4gICAgICBwcm9taXNlXG4gICAgfSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IG9uRWRpdG9yc1JlbmRlcmVkID0gZXZ0ID0+IHtcbiAgICAgIGlmIChldnQucGFnZU51bWJlciA9PT0gcGFnZU51bWJlcikge1xuICAgICAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwiZWRpdG9yc3JlbmRlcmVkXCIsIG9uRWRpdG9yc1JlbmRlcmVkKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRCdXMub24oXCJlZGl0b3JzcmVuZGVyZWRcIiwgb25FZGl0b3JzUmVuZGVyZWQpO1xuICAgIGF3YWl0IHByb21pc2U7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlKGVkaXRvcikge1xuICAgIHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmdldFNpZ25hdHVyZSh7XG4gICAgICB1aU1hbmFnZXI6IHRoaXMsXG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfVxuICBnZXQgc2lnbmF0dXJlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2lnbmF0dXJlTWFuYWdlcjtcbiAgfVxuICBzd2l0Y2hUb01vZGUobW9kZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5vbihcImFubm90YXRpb25lZGl0b3Jtb2RlY2hhbmdlZFwiLCBjYWxsYmFjaywge1xuICAgICAgb25jZTogdHJ1ZSxcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzaG93YW5ub3RhdGlvbmVkaXRvcnVpXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG1vZGVcbiAgICB9KTtcbiAgfVxuICBzZXRQcmVmZXJlbmNlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJzZXRwcmVmZXJlbmNlXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIG5hbWUsXG4gICAgICB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIG9uU2V0UHJlZmVyZW5jZSh7XG4gICAgbmFtZSxcbiAgICB2YWx1ZVxuICB9KSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwiZW5hYmxlTmV3QWx0VGV4dFdoZW5BZGRpbmdJbWFnZVwiOlxuICAgICAgICB0aGlzLiNlbmFibGVOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBvblBhZ2VDaGFuZ2luZyh7XG4gICAgcGFnZU51bWJlclxuICB9KSB7XG4gICAgdGhpcy4jY3VycmVudFBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuICB9XG4gIGZvY3VzTWFpbkNvbnRhaW5lcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIuZm9jdXMoKTtcbiAgfVxuICBmaW5kUGFyZW50KHgsIHkpIHtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiBsYXllclgsXG4gICAgICAgIHk6IGxheWVyWSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IGxheWVyLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh4ID49IGxheWVyWCAmJiB4IDw9IGxheWVyWCArIHdpZHRoICYmIHkgPj0gbGF5ZXJZICYmIHkgPD0gbGF5ZXJZICsgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZGlzYWJsZVVzZXJTZWxlY3QodmFsdWUgPSBmYWxzZSkge1xuICAgIHRoaXMuI3ZpZXdlci5jbGFzc0xpc3QudG9nZ2xlKFwibm9Vc2VyU2VsZWN0XCIsIHZhbHVlKTtcbiAgfVxuICBhZGRTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuYWRkKGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlU2hvdWxkUmVzY2FsZShlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3JzVG9SZXNjYWxlLmRlbGV0ZShlZGl0b3IpO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZyh7XG4gICAgc2NhbGVcbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gICAgdGhpcy4jY3VycmVudERyYXdpbmdTZXNzaW9uPy5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgfVxuICBvblJvdGF0aW9uQ2hhbmdpbmcoe1xuICAgIHBhZ2VzUm90YXRpb25cbiAgfSkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uID0gcGFnZXNSb3RhdGlvbjtcbiAgfVxuICAjZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbih7XG4gICAgYW5jaG9yTm9kZVxuICB9KSB7XG4gICAgcmV0dXJuIGFuY2hvck5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFID8gYW5jaG9yTm9kZS5wYXJlbnRFbGVtZW50IDogYW5jaG9yTm9kZTtcbiAgfVxuICAjZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudExheWVyXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGN1cnJlbnRMYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRMYXllcjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChsYXllci5oYXNUZXh0TGF5ZXIodGV4dExheWVyKSkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhpZ2hsaWdodFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIiwgY29tbWVudCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldFxuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBjb25zdCBib3hlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uQm94ZXModGV4dExheWVyKTtcbiAgICBpZiAoIWJveGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGlvbi5lbXB0eSgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKTtcbiAgICBjb25zdCBpc05vbmVNb2RlID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVkaXRvciA9IGxheWVyPy5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBtZXRob2RPZkNyZWF0aW9uLFxuICAgICAgICBib3hlcyxcbiAgICAgICAgYW5jaG9yTm9kZSxcbiAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICBmb2N1c05vZGUsXG4gICAgICAgIGZvY3VzT2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICAgIGlmIChpc05vbmVNb2RlKSB7XG4gICAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBlZGl0b3I/LmVkaXRDb21tZW50KCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNOb25lTW9kZSkge1xuICAgICAgdGhpcy5zd2l0Y2hUb01vZGUoQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hULCBjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbiAgY29tbWVudFNlbGVjdGlvbihtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24sIHRydWUpO1xuICB9XG4gICNkaXNwbGF5RmxvYXRpbmdUb29sYmFyKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JFbGVtZW50ID0gdGhpcy4jZ2V0QW5jaG9yRWxlbWVudEZvclNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IHRleHRMYXllciA9IGFuY2hvckVsZW1lbnQuY2xvc2VzdChcIi50ZXh0TGF5ZXJcIik7XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLmdldFNlbGVjdGlvbkJveGVzKHRleHRMYXllcik7XG4gICAgaWYgKCFib3hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNmbG9hdGluZ1Rvb2xiYXIgfHw9IG5ldyBGbG9hdGluZ1Rvb2xiYXIodGhpcyk7XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyLnNob3codGV4dExheWVyLCBib3hlcywgdGhpcy5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICB9XG4gIGdldEFuZFJlbW92ZURhdGFGcm9tQW5ub3RhdGlvblN0b3JhZ2UoYW5ub3RhdGlvbklkKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHthbm5vdGF0aW9uSWR9YDtcbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKGtleSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlKSB7XG4gICAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5yZW1vdmUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0b3JlZFZhbHVlO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhMTF5QWxlcnQobWVzc2FnZUlkLCBhcmdzID0gbnVsbCkge1xuICAgIGNvbnN0IHZpZXdlckFsZXJ0ID0gdGhpcy4jdmlld2VyQWxlcnQ7XG4gICAgaWYgKCF2aWV3ZXJBbGVydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aWV3ZXJBbGVydC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgbWVzc2FnZUlkKTtcbiAgICBpZiAoYXJncykge1xuICAgICAgdmlld2VyQWxlcnQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3ZXJBbGVydC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWwxMG4tYXJnc1wiKTtcbiAgICB9XG4gIH1cbiAgI3NlbGVjdGlvbkNoYW5nZSgpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgIGlmICh0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICAgIHRoaXMuI2Zsb2F0aW5nVG9vbGJhcj8uaGlkZSgpO1xuICAgICAgICB0aGlzLiNzZWxlY3RlZFRleHROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICAgIGhhc1NlbGVjdGVkVGV4dDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvck5vZGVcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChhbmNob3JOb2RlID09PSB0aGlzLiNzZWxlY3RlZFRleHROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckVsZW1lbnQgPSB0aGlzLiNnZXRBbmNob3JFbGVtZW50Rm9yU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgdGV4dExheWVyID0gYW5jaG9yRWxlbWVudC5jbG9zZXN0KFwiLnRleHRMYXllclwiKTtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgaWYgKHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUpIHtcbiAgICAgICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgICAgIHRoaXMuI3NlbGVjdGVkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgICAgaGFzU2VsZWN0ZWRUZXh0OiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmxvYXRpbmdUb29sYmFyPy5oaWRlKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRUZXh0Tm9kZSA9IGFuY2hvck5vZGU7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRUZXh0OiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCAmJiB0aGlzLiNtb2RlICE9PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuc2hvd0FsbEVkaXRvcnMoXCJoaWdobGlnaHRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gdGhpcy5pc1NoaWZ0S2V5RG93bjtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24pIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUxheWVyID0gdGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUID8gdGhpcy4jZ2V0TGF5ZXJGb3JUZXh0TGF5ZXIodGV4dExheWVyKSA6IG51bGw7XG4gICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZygpO1xuICAgICAgaWYgKHRoaXMuI2lzUG9pbnRlckRvd24pIHtcbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwoYWMpO1xuICAgICAgICBjb25zdCBwb2ludGVydXAgPSBlID0+IHtcbiAgICAgICAgICBpZiAoZS50eXBlID09PSBcInBvaW50ZXJ1cFwiICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgICAgYWN0aXZlTGF5ZXI/LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJwb2ludGVydXBcIikge1xuICAgICAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVydXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVMYXllcj8udG9nZ2xlRHJhd2luZyh0cnVlKTtcbiAgICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNvblNlbGVjdEVuZChtZXRob2RPZkNyZWF0aW9uID0gXCJcIikge1xuICAgIGlmICh0aGlzLiNtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQpIHtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKG1ldGhvZE9mQ3JlYXRpb24pO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jZW5hYmxlSGlnaGxpZ2h0RmxvYXRpbmdCdXR0b24pIHtcbiAgICAgIHRoaXMuI2Rpc3BsYXlGbG9hdGluZ1Rvb2xiYXIoKTtcbiAgICB9XG4gIH1cbiAgI2FkZFNlbGVjdGlvbkxpc3RlbmVyKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy4jc2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy5fc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI2FkZEZvY3VzTWFuYWdlcigpIHtcbiAgICBpZiAodGhpcy4jZm9jdXNNYW5hZ2VyQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZm9jdXNNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5jb21iaW5lZFNpZ25hbCh0aGlzLiNmb2N1c01hbmFnZXJBQyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0aGlzLmZvY3VzLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNmb2N1c01hbmFnZXJBQyA9IG51bGw7XG4gIH1cbiAgYmx1cigpIHtcbiAgICB0aGlzLmlzU2hpZnRLZXlEb3duID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICB0aGlzLiNoaWdobGlnaHRXaGVuU2hpZnRVcCA9IGZhbHNlO1xuICAgICAgdGhpcy4jb25TZWxlY3RFbmQoXCJtYWluX3Rvb2xiYXJcIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWN0aXZlRWxlbWVudFxuICAgIH0gPSBkb2N1bWVudDtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gW2VkaXRvciwgYWN0aXZlRWxlbWVudF07XG4gICAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAoIXRoaXMuI2xhc3RBY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtsYXN0RWRpdG9yLCBsYXN0QWN0aXZlRWxlbWVudF0gPSB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudDtcbiAgICB0aGlzLiNsYXN0QWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgbGFzdEFjdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgKCkgPT4ge1xuICAgICAgbGFzdEVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICB9LCB7XG4gICAgICBvbmNlOiB0cnVlLFxuICAgICAgc2lnbmFsOiB0aGlzLl9zaWduYWxcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgaWYgKHRoaXMuI2tleWJvYXJkTWFuYWdlckFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2tleWJvYXJkTWFuYWdlckFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCB0aGlzLmtleXVwLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4ja2V5Ym9hcmRNYW5hZ2VyQUMgPSBudWxsO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2NvcHlQYXN0ZUFDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvcHlQYXN0ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuY29tYmluZWRTaWduYWwodGhpcy4jY29weVBhc3RlQUMpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsIHRoaXMuY29weS5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuY3V0LmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLnBhc3RlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jY29weVBhc3RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jY29weVBhc3RlQUMgPSBudWxsO1xuICB9XG4gICNhZGREcmFnQW5kRHJvcExpc3RlbmVycygpIHtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLl9zaWduYWw7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyYWdvdmVyXCIsIHRoaXMuZHJhZ092ZXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImRyb3BcIiwgdGhpcy5kcm9wLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gIGFkZEVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jYWRkS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gIH1cbiAgcmVtb3ZlRWRpdExpc3RlbmVycygpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gIH1cbiAgZHJhZ092ZXIoZXZlbnQpIHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9IG9mIGV2ZW50LmRhdGFUcmFuc2Zlci5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyh0eXBlKSkge1xuICAgICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJjb3B5XCI7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJvcChldmVudCkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBldmVudC5kYXRhVHJhbnNmZXIuaXRlbXMpIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgICBpZiAoZWRpdG9yVHlwZS5pc0hhbmRsaW5nTWltZUZvclBhc3RpbmcoaXRlbS50eXBlKSkge1xuICAgICAgICAgIGVkaXRvclR5cGUucGFzdGUoaXRlbSwgdGhpcy5jdXJyZW50TGF5ZXIpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHkoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2FjdGl2ZUVkaXRvcj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBlZGl0b3Iuc2VyaWFsaXplKHRydWUpO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgZWRpdG9ycy5wdXNoKHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIiwgSlNPTi5zdHJpbmdpZnkoZWRpdG9ycykpO1xuICB9XG4gIGN1dChldmVudCkge1xuICAgIHRoaXMuY29weShldmVudCk7XG4gICAgdGhpcy5kZWxldGUoKTtcbiAgfVxuICBhc3luYyBwYXN0ZShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3Qge1xuICAgICAgY2xpcGJvYXJkRGF0YVxuICAgIH0gPSBldmVudDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2xpcGJvYXJkRGF0YS5pdGVtcykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGlmIChlZGl0b3JUeXBlLmlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhpdGVtLnR5cGUpKSB7XG4gICAgICAgICAgZWRpdG9yVHlwZS5wYXN0ZShpdGVtLCB0aGlzLmN1cnJlbnRMYXllcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBkYXRhID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiYXBwbGljYXRpb24vcGRmanNcIik7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgcGFzdGU6IFwiJHtleC5tZXNzYWdlfVwiLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5jdXJyZW50TGF5ZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5ld0VkaXRvcnMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGRhdGEpIHtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRWRpdG9yID0gYXdhaXQgbGF5ZXIuZGVzZXJpYWxpemUoZWRpdG9yKTtcbiAgICAgICAgaWYgKCFkZXNlcmlhbGl6ZWRFZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV3RWRpdG9ycy5wdXNoKGRlc2VyaWFsaXplZEVkaXRvcik7XG4gICAgICB9XG4gICAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIG5ld0VkaXRvcnMpIHtcbiAgICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jc2VsZWN0RWRpdG9ycyhuZXdFZGl0b3JzKTtcbiAgICAgIH07XG4gICAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZCxcbiAgICAgICAgdW5kbyxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICB3YXJuKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNTaGlmdEtleURvd24gJiYgZXZlbnQua2V5ID09PSBcIlNoaWZ0XCIpIHtcbiAgICAgIHRoaXMuaXNTaGlmdEtleURvd24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSAmJiAhdGhpcy5pc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAga2V5dXAoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5pc1NoaWZ0S2V5RG93biAmJiBldmVudC5rZXkgPT09IFwiU2hpZnRcIikge1xuICAgICAgdGhpcy5pc1NoaWZ0S2V5RG93biA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwKSB7XG4gICAgICAgIHRoaXMuI2hpZ2hsaWdodFdoZW5TaGlmdFVwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuI29uU2VsZWN0RW5kKFwibWFpbl90b29sYmFyXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBvbkVkaXRpbmdBY3Rpb24oe1xuICAgIG5hbWVcbiAgfSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSBcInVuZG9cIjpcbiAgICAgIGNhc2UgXCJyZWRvXCI6XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICBjYXNlIFwic2VsZWN0QWxsXCI6XG4gICAgICAgIHRoaXNbbmFtZV0oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uKFwiY29udGV4dF9tZW51XCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJjb21tZW50U2VsZWN0aW9uXCI6XG4gICAgICAgIHRoaXMuY29tbWVudFNlbGVjdGlvbihcImNvbnRleHRfbWVudVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoKFtrZXksIHZhbHVlXSkgPT4gdGhpcy4jcHJldmlvdXNTdGF0ZXNba2V5XSAhPT0gdmFsdWUpO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy4jbW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUICYmIGRldGFpbHMuaGFzU2VsZWN0ZWRFZGl0b3IgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoW1tBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfRlJFRSwgdHJ1ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNhZGRGb2N1c01hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVDb3B5UGFzdGVMaXN0ZW5lcnMoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIGlmICh0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3JUeXBlcyA9IHR5cGVzO1xuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3JUeXBlLmRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmlkO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQodGhpcy4jY3VycmVudFBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0TGF5ZXIocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgfVxuICBnZXQgY3VycmVudFBhZ2VJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY3VycmVudFBhZ2VJbmRleDtcbiAgfVxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG4gICAgaWYgKHRoaXMuI2lzRW5hYmxlZCkge1xuICAgICAgbGF5ZXIuZW5hYmxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheWVyLmRpc2FibGUoKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuZGVsZXRlKGxheWVyLnBhZ2VJbmRleCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTW9kZShtb2RlLCBlZGl0SWQgPSBudWxsLCBpc0Zyb21LZXlib2FyZCA9IGZhbHNlLCBtdXN0RW50ZXJJbkVkaXRNb2RlID0gZmFsc2UsIGVkaXRDb21tZW50ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jbW9kZSA9PT0gbW9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICBpZiAoIXRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlcj8uaGlkZVNpZGViYXIoKTtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LmRlc3Ryb3lQb3B1cCgpO1xuICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FKSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZShmYWxzZSk7XG4gICAgICB0aGlzLiNkaXNhYmxlQWxsKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5oaWRlU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VkaXRvclVuZG9CYXI/LmhpZGUoKTtcbiAgICAgIHRoaXMudG9nZ2xlQ29tbWVudChudWxsKTtcbiAgICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmFkZFN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgfVxuICAgIGlmIChtb2RlID09PSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5TSUdOQVRVUkUpIHtcbiAgICAgIGF3YWl0IHRoaXMuI3NpZ25hdHVyZU1hbmFnZXI/LmxvYWRTaWduYXR1cmVzKCk7XG4gICAgfVxuICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIGF3YWl0IHRoaXMuI2VuYWJsZUFsbCgpO1xuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIudXBkYXRlTW9kZShtb2RlKTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zIHx8PSBhd2FpdCB0aGlzLiNwZGZEb2N1bWVudC5nZXRBbm5vdGF0aW9uc0J5VHlwZShuZXcgU2V0KHRoaXMuI2VkaXRvclR5cGVzLm1hcChlZGl0b3JDbGFzcyA9PiBlZGl0b3JDbGFzcy5fZWRpdG9yVHlwZSkpKTtcbiAgICAgIGNvbnN0IGVsZW1lbnRJZHMgPSBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBhbGxDb21tZW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgICAgICBoYXNDb21tZW50LFxuICAgICAgICAgIGRlbGV0ZWRcbiAgICAgICAgfSA9IGVkaXRvcjtcbiAgICAgICAgaWYgKGFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgICBlbGVtZW50SWRzLmFkZChhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ29tbWVudCAmJiAhZGVsZXRlZCkge1xuICAgICAgICAgIGFsbENvbW1lbnRzLnB1c2goZWRpdG9yLmdldERhdGEoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiB0aGlzLiNhbGxFZGl0YWJsZUFubm90YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICBjb250ZW50c09ialxuICAgICAgICB9ID0gYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHBvcHVwUmVmICYmIGNvbnRlbnRzT2JqPy5zdHIgJiYgIWVsZW1lbnRJZHMuaGFzKGlkKSAmJiAhdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgYWxsQ29tbWVudHMucHVzaChhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy4jY29tbWVudE1hbmFnZXI/LnNob3dTaWRlYmFyKGFsbENvbW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCFlZGl0SWQpIHtcbiAgICAgIGlmIChpc0Zyb21LZXlib2FyZCkge1xuICAgICAgICB0aGlzLmFkZE5ld0VkaXRvckZyb21LZXlib2FyZCgpO1xuICAgICAgfVxuICAgICAgdGhpcy4jdXBkYXRlTW9kZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnVpZCA9PT0gZWRpdElkKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgICAgICAgaWYgKGVkaXRDb21tZW50KSB7XG4gICAgICAgICAgZWRpdG9yLmVkaXRDb21tZW50KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobXVzdEVudGVySW5FZGl0TW9kZSkge1xuICAgICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZU1vZGVDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBhZGROZXdFZGl0b3JGcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudExheWVyLmNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkpIHtcbiAgICAgIHRoaXMuY3VycmVudExheWVyLmFkZE5ld0VkaXRvcigpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sYmFyKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5tb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURTpcbiAgICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEw6XG4gICAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICAgICAgICAgIGFjdGlvbjogXCJ0b2dnbGVfdmlzaWJpbGl0eVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgKHRoaXMuI3Nob3dBbGxTdGF0ZXMgfHw9IG5ldyBNYXAoKSkuc2V0KHR5cGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgICBlZGl0b3IudXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNob3dBbGxFZGl0b3JzKHR5cGUsIHZpc2libGUsIHVwZGF0ZUJ1dHRvbiA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5lZGl0b3JUeXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVkaXRvci5zaG93KHZpc2libGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuI3Nob3dBbGxTdGF0ZXM/LmdldChBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfU0hPV19BTEwpID8/IHRydWU7XG4gICAgaWYgKHN0YXRlICE9PSB2aXNpYmxlKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX1NIT1dfQUxMLCB2aXNpYmxlXV0pO1xuICAgIH1cbiAgfVxuICBlbmFibGVXYWl0aW5nKG11c3RXYWl0ID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gIGFzeW5jICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChsYXllci5lbmFibGUoKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGVkaXRvci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqZ2V0RWRpdG9ycyhwYWdlSW5kZXgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIHlpZWxkIGVkaXRvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0RWRpdG9yKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsbEVkaXRvcnMuZ2V0KGlkKTtcbiAgfVxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG4gIHJlbW92ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLmRpdi5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgaWYgKHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jZm9jdXNNYWluQ29udGFpbmVyVGltZW91dElkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2ZvY3VzTWFpbkNvbnRhaW5lclRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmZvY3VzTWFpbkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLiNmb2N1c01haW5Db250YWluZXJUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiNtaXNzaW5nQ2FudmFzZXM/LmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3QoZWRpdG9yKTtcbiAgICBpZiAoIWVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkIHx8ICF0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlPy5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICB9XG4gIH1cbiAgYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICB0aGlzLmFkZENoYW5nZWRFeGlzdGluZ0Fubm90YXRpb24oZWRpdG9yKTtcbiAgICBlZGl0b3IuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmhhcyhhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5kZWxldGUoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIHRoaXMucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgIGVkaXRvci5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuICAgIGlmIChsYXllcikge1xuICAgICAgbGF5ZXIuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRWRpdG9yKGVkaXRvcik7XG4gICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgZ2V0ICNsYXN0U2VsZWN0ZWRFZGl0b3IoKSB7XG4gICAgbGV0IGVkID0gbnVsbDtcbiAgICBmb3IgKGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge31cbiAgICByZXR1cm4gZWQ7XG4gIH1cbiAgdXBkYXRlVUkoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2xhc3RTZWxlY3RlZEVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzKGVkaXRvclR5cGUpIHtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKSkge1xuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIHRoaXMudXBkYXRlVG9vbGJhcih7XG4gICAgICBtb2RlOiBlZGl0b3IubW9kZSxcbiAgICAgIGVkaXRJZDogZWRpdG9yLnVpZFxuICAgIH0pO1xuICAgIHRoaXMuI2N1cnJlbnREcmF3aW5nU2Vzc2lvbj8uY29tbWl0T3JSZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IGVkIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkICE9PSBlZGl0b3IpIHtcbiAgICAgICAgZWQudW5zZWxlY3QoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvci5wcm9wZXJ0aWVzVG9VcGRhdGUpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG4gIGdldCBmaXJzdFNlbGVjdGVkRWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBnZXQgaGFzU2VsZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuc2l6ZSAhPT0gMDtcbiAgfVxuICBnZXQgaXNFbnRlckhhbmRsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplID09PSAxICYmIHRoaXMuZmlyc3RTZWxlY3RlZEVkaXRvci5pc0VudGVySGFuZGxlZDtcbiAgfVxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICB9XG4gIHJlZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIucmVkbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdHJ1ZSxcbiAgICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9SZWRvKCksXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5hZGQocGFyYW1zKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgY2xlYW5VbmRvU3RhY2sodHlwZSkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmNsZWFuVHlwZSh0eXBlKTtcbiAgfVxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuc2l6ZSA9PT0gMSkge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmlzRW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlbGV0ZSgpIHtcbiAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgY29uc3QgZHJhd2luZ0VkaXRvciA9IHRoaXMuY3VycmVudExheWVyPy5lbmREcmF3aW5nU2Vzc2lvbih0cnVlKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uICYmICFkcmF3aW5nRWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBkcmF3aW5nRWRpdG9yID8gW2RyYXdpbmdFZGl0b3JdIDogWy4uLnRoaXMuI3NlbGVjdGVkRWRpdG9yc107XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWRpdG9yVW5kb0Jhcj8uc2hvdyh1bmRvLCBlZGl0b3JzLmxlbmd0aCA9PT0gMSA/IGVkaXRvcnNbMF0uZWRpdG9yVHlwZSA6IGVkaXRvcnMubGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3I/LmNvbW1pdE9yUmVtb3ZlKCk7XG4gIH1cbiAgaGFzU29tZXRoaW5nVG9Db250cm9sKCkge1xuICAgIHJldHVybiB0aGlzLiNhY3RpdmVFZGl0b3IgfHwgdGhpcy5oYXNTZWxlY3Rpb247XG4gIH1cbiAgI3NlbGVjdEVkaXRvcnMoZWRpdG9ycykge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmFkZChlZGl0b3IpO1xuICAgICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdGhpcy5oYXNTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBzZWxlY3RBbGwoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdEVkaXRvcnModGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSk7XG4gIH1cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICBpZiAodGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLiNjdXJyZW50RHJhd2luZ1Nlc3Npb24/LmNvbW1pdE9yUmVtb3ZlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51bnNlbGVjdCgpO1xuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogZmFsc2VcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMoeCwgeSwgbm9Db21taXQgPSBmYWxzZSkge1xuICAgIGlmICghbm9Db21taXQpIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblswXSArPSB4O1xuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzFdICs9IHk7XG4gICAgY29uc3QgW3RvdGFsWCwgdG90YWxZXSA9IHRoaXMuI3RyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAxMDAwO1xuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdID0gdGhpcy4jdHJhbnNsYXRpb25bMV0gPSAwO1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UodG90YWxYLCB0b3RhbFkpO1xuICAgICAgICAgICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuI2FsbEVkaXRvcnMuaGFzKGVkaXRvci5pZCkpIHtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSgtdG90YWxYLCAtdG90YWxZKTtcbiAgICAgICAgICAgICAgZWRpdG9yLnRyYW5zbGF0aW9uRG9uZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9LCBUSU1FX1RPX1dBSVQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoeCwgeSk7XG4gICAgICBlZGl0b3IudHJhbnNsYXRpb25Eb25lKCk7XG4gICAgfVxuICB9XG4gIHNldFVwRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KHRydWUpO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5zZXQoZWRpdG9yLCB7XG4gICAgICAgIHNhdmVkWDogZWRpdG9yLngsXG4gICAgICAgIHNhdmVkWTogZWRpdG9yLnksXG4gICAgICAgIHNhdmVkUGFnZUluZGV4OiBlZGl0b3IucGFnZUluZGV4LFxuICAgICAgICBuZXdYOiAwLFxuICAgICAgICBuZXdZOiAwLFxuICAgICAgICBuZXdQYWdlSW5kZXg6IC0xXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhZ1Nlc3Npb24oKSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVXNlclNlbGVjdChmYWxzZSk7XG4gICAgY29uc3QgbWFwID0gdGhpcy4jZHJhZ2dpbmdFZGl0b3JzO1xuICAgIHRoaXMuI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICAgbGV0IG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFt7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0sIHZhbHVlXSBvZiBtYXApIHtcbiAgICAgIHZhbHVlLm5ld1ggPSB4O1xuICAgICAgdmFsdWUubmV3WSA9IHk7XG4gICAgICB2YWx1ZS5uZXdQYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICBtdXN0QmVBZGRlZEluVW5kb1N0YWNrIHx8PSB4ICE9PSB2YWx1ZS5zYXZlZFggfHwgeSAhPT0gdmFsdWUuc2F2ZWRZIHx8IHBhZ2VJbmRleCAhPT0gdmFsdWUuc2F2ZWRQYWdlSW5kZXg7XG4gICAgfVxuICAgIGlmICghbXVzdEJlQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtb3ZlID0gKGVkaXRvciwgeCwgeSwgcGFnZUluZGV4KSA9PiB7XG4gICAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBlZGl0b3IuX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgICAgICBlZGl0b3IueCA9IHg7XG4gICAgICAgICAgZWRpdG9yLnkgPSB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBuZXdYLFxuICAgICAgICAgIG5ld1ksXG4gICAgICAgICAgbmV3UGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBuZXdYLCBuZXdZLCBuZXdQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtlZGl0b3IsIHtcbiAgICAgICAgICBzYXZlZFgsXG4gICAgICAgICAgc2F2ZWRZLFxuICAgICAgICAgIHNhdmVkUGFnZUluZGV4XG4gICAgICAgIH1dIG9mIG1hcCkge1xuICAgICAgICAgIG1vdmUoZWRpdG9yLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRQYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSkge1xuICAgIGlmICghdGhpcy4jZHJhZ2dpbmdFZGl0b3JzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2RyYWdnaW5nRWRpdG9ycy5rZXlzKCkpIHtcbiAgICAgIGVkaXRvci5kcmFnKHR4LCB0eSk7XG4gICAgfVxuICB9XG4gIHJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0TGF5ZXIoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICAgICAgcGFyZW50LmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICAgICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci5wYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGdldCBpc0VkaXRvckhhbmRsaW5nS2V5Ym9hcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkgfHwgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgPT09IDEgJiYgdGhpcy5maXJzdFNlbGVjdGVkRWRpdG9yLnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCk7XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgaXNFZGl0aW5nTW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbW9kZSAhPT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgfVxuICBnZXQgaW1hZ2VNYW5hZ2VyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpbWFnZU1hbmFnZXJcIiwgbmV3IEltYWdlTWFuYWdlcigpKTtcbiAgfVxuICBnZXRTZWxlY3Rpb25Cb3hlcyh0ZXh0TGF5ZXIpIHtcbiAgICBpZiAoIXRleHRMYXllcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRvY3VtZW50LmdldFNlbGVjdGlvbigpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNlbGVjdGlvbi5yYW5nZUNvdW50OyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKCF0ZXh0TGF5ZXIuY29udGFpbnMoc2VsZWN0aW9uLmdldFJhbmdlQXQoaSkuY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB4OiBsYXllclgsXG4gICAgICB5OiBsYXllclksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgbGV0IHJvdGF0b3I7XG4gICAgc3dpdGNoICh0ZXh0TGF5ZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIpKSB7XG4gICAgICBjYXNlIFwiOTBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6ICh5IC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB5OiAxIC0gKHggKyB3IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHdpZHRoOiBoIC8gcGFyZW50SGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogdyAvIHBhcmVudFdpZHRoXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCIxODBcIjpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6IDEgLSAoeCArIHcgLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgeTogMSAtICh5ICsgaCAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgd2lkdGg6IHcgLyBwYXJlbnRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGggLyBwYXJlbnRIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjI3MFwiOlxuICAgICAgICByb3RhdG9yID0gKHgsIHksIHcsIGgpID0+ICh7XG4gICAgICAgICAgeDogMSAtICh5ICsgaCAtIGxheWVyWSkgLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgeTogKHggLSBsYXllclgpIC8gcGFyZW50V2lkdGgsXG4gICAgICAgICAgd2lkdGg6IGggLyBwYXJlbnRIZWlnaHQsXG4gICAgICAgICAgaGVpZ2h0OiB3IC8gcGFyZW50V2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcm90YXRvciA9ICh4LCB5LCB3LCBoKSA9PiAoe1xuICAgICAgICAgIHg6ICh4IC0gbGF5ZXJYKSAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIHk6ICh5IC0gbGF5ZXJZKSAvIHBhcmVudEhlaWdodCxcbiAgICAgICAgICB3aWR0aDogdyAvIHBhcmVudFdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaCAvIHBhcmVudEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGJveGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc2VsZWN0aW9uLnJhbmdlQ291bnQ7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KGkpO1xuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICB9IG9mIHJhbmdlLmdldENsaWVudFJlY3RzKCkpIHtcbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJveGVzLnB1c2gocm90YXRvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3hlcy5sZW5ndGggPT09IDAgPyBudWxsIDogYm94ZXM7XG4gIH1cbiAgYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbih7XG4gICAgYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICBpZFxuICB9KSB7XG4gICAgKHRoaXMuI2NoYW5nZWRFeGlzdGluZ0Fubm90YXRpb25zIHx8PSBuZXcgTWFwKCkpLnNldChhbm5vdGF0aW9uRWxlbWVudElkLCBpZCk7XG4gIH1cbiAgcmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbih7XG4gICAgYW5ub3RhdGlvbkVsZW1lbnRJZFxuICB9KSB7XG4gICAgdGhpcy4jY2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbnM/LmRlbGV0ZShhbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgZWRpdG9ySWQgPSB0aGlzLiNjaGFuZ2VkRXhpc3RpbmdBbm5vdGF0aW9ucz8uZ2V0KGFubm90YXRpb24uZGF0YS5pZCk7XG4gICAgaWYgKCFlZGl0b3JJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5nZXRSYXdWYWx1ZShlZGl0b3JJZCk7XG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUgJiYgIWVkaXRvci5oYXNCZWVuTW9kaWZpZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICB9XG4gIHNldE1pc3NpbmdDYW52YXMoYW5ub3RhdGlvbklkLCBhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNtaXNzaW5nQ2FudmFzZXM/LmdldChhbm5vdGF0aW9uSWQpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci5zZXRDYW52YXMoYW5ub3RhdGlvbkVsZW1lbnRJZCwgY2FudmFzKTtcbiAgICB0aGlzLiNtaXNzaW5nQ2FudmFzZXMuZGVsZXRlKGFubm90YXRpb25JZCk7XG4gIH1cbiAgYWRkTWlzc2luZ0NhbnZhcyhhbm5vdGF0aW9uSWQsIGVkaXRvcikge1xuICAgICh0aGlzLiNtaXNzaW5nQ2FudmFzZXMgfHw9IG5ldyBNYXAoKSkuc2V0KGFubm90YXRpb25JZCwgZWRpdG9yKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvYWx0X3RleHQuanNcblxuY2xhc3MgQWx0VGV4dCB7XG4gICNhbHRUZXh0ID0gbnVsbDtcbiAgI2FsdFRleHREZWNvcmF0aXZlID0gZmFsc2U7XG4gICNhbHRUZXh0QnV0dG9uID0gbnVsbDtcbiAgI2FsdFRleHRCdXR0b25MYWJlbCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICNhbHRUZXh0VG9vbHRpcFRpbWVvdXQgPSBudWxsO1xuICAjYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICAjYmFkZ2UgPSBudWxsO1xuICAjZWRpdG9yID0gbnVsbDtcbiAgI2d1ZXNzZWRUZXh0ID0gbnVsbDtcbiAgI3RleHRXaXRoRGlzY2xhaW1lciA9IG51bGw7XG4gICN1c2VOZXdBbHRUZXh0RmxvdyA9IGZhbHNlO1xuICBzdGF0aWMgI2wxMG5OZXdCdXR0b24gPSBudWxsO1xuICBzdGF0aWMgX2wxMG4gPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cgPSBlZGl0b3IuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdztcbiAgICBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGFkZGVkOiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtYWRkZWQtYnV0dG9uXCIsXG4gICAgICBcImFkZGVkLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1hZGRlZC1idXR0b24tbGFiZWxcIixcbiAgICAgIG1pc3Npbmc6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvblwiLFxuICAgICAgXCJtaXNzaW5nLWxhYmVsXCI6IFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1taXNzaW5nLWJ1dHRvbi1sYWJlbFwiLFxuICAgICAgcmV2aWV3OiBcInBkZmpzLWVkaXRvci1uZXctYWx0LXRleHQtdG8tcmV2aWV3LWJ1dHRvblwiLFxuICAgICAgXCJyZXZpZXctbGFiZWxcIjogXCJwZGZqcy1lZGl0b3ItbmV3LWFsdC10ZXh0LXRvLXJldmlldy1idXR0b24tbGFiZWxcIlxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBBbHRUZXh0Ll9sMTBuID8/PSBsMTBuO1xuICB9XG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBjb25zdCBhbHRUZXh0ID0gdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYWx0VGV4dC5jbGFzc05hbWUgPSBcImFsdFRleHRcIjtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBhbHRUZXh0LmFwcGVuZChsYWJlbCk7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICBhbHRUZXh0LmNsYXNzTGlzdC5hZGQoXCJuZXdcIik7XG4gICAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uLm1pc3NpbmcpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFsdFRleHQuI2wxMG5OZXdCdXR0b25bXCJtaXNzaW5nLWxhYmVsXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWx0VGV4dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtYnV0dG9uXCIpO1xuICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtZWRpdG9yLWFsdC10ZXh0LWJ1dHRvbi1sYWJlbFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBhbHRUZXh0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLiNlZGl0b3IpO1xuICAgICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuYWx0X3RleHQuaW1hZ2Vfc3RhdHVzX2xhYmVsX2NsaWNrZWRcIixcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBsYWJlbDogdGhpcy4jbGFiZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkID0gdHJ1ZTtcbiAgICAgICAgb25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy4jc2V0U3RhdGUoKTtcbiAgICByZXR1cm4gYWx0VGV4dDtcbiAgfVxuICBnZXQgI2xhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0ICYmIFwiYWRkZWRcIiB8fCB0aGlzLiNhbHRUZXh0ID09PSBudWxsICYmIHRoaXMuZ3Vlc3NlZFRleHQgJiYgXCJyZXZpZXdcIiB8fCBcIm1pc3NpbmdcIjtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24uZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0aGlzLiNhbHRUZXh0V2FzRnJvbUtleUJvYXJkXG4gICAgfSk7XG4gICAgdGhpcy4jYWx0VGV4dFdhc0Zyb21LZXlCb2FyZCA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgaWYgKHRoaXMuI3VzZU5ld0FsdFRleHRGbG93KSB7XG4gICAgICByZXR1cm4gdGhpcy4jYWx0VGV4dCA9PT0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZTtcbiAgfVxuICBoYXNEYXRhKCkge1xuICAgIGlmICh0aGlzLiN1c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgcmV0dXJuIHRoaXMuI2FsdFRleHQgIT09IG51bGwgfHwgISF0aGlzLiNndWVzc2VkVGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGdldCBndWVzc2VkVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZFRleHQoZ3Vlc3NlZFRleHQpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNndWVzc2VkVGV4dCA9IGd1ZXNzZWRUZXh0O1xuICAgIHRoaXMuI3RleHRXaXRoRGlzY2xhaW1lciA9IGF3YWl0IEFsdFRleHQuX2wxMG4uZ2V0KFwicGRmanMtZWRpdG9yLW5ldy1hbHQtdGV4dC1nZW5lcmF0ZWQtYWx0LXRleHQtd2l0aC1kaXNjbGFpbWVyXCIsIHtcbiAgICAgIGdlbmVyYXRlZEFsdFRleHQ6IGd1ZXNzZWRUZXh0XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGVBbHRUZXh0QmFkZ2UodmlzaWJpbGl0eSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiN1c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLiNhbHRUZXh0KSB7XG4gICAgICB0aGlzLiNiYWRnZT8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLiNiYWRnZSA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jYmFkZ2UpIHtcbiAgICAgIGNvbnN0IGJhZGdlID0gdGhpcy4jYmFkZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgYmFkZ2UuY2xhc3NOYW1lID0gXCJub0FsdFRleHRCYWRnZVwiO1xuICAgICAgdGhpcy4jZWRpdG9yLmRpdi5hcHBlbmQoYmFkZ2UpO1xuICAgIH1cbiAgICB0aGlzLiNiYWRnZS5jbGFzc0xpc3QudG9nZ2xlKFwiaGlkZGVuXCIsICF2aXNpYmlsaXR5KTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nKSB7XG4gICAgbGV0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIGlmICghaXNGb3JDb3B5aW5nICYmIHRoaXMuI2d1ZXNzZWRUZXh0ID09PSBhbHRUZXh0KSB7XG4gICAgICBhbHRUZXh0ID0gdGhpcy4jdGV4dFdpdGhEaXNjbGFpbWVyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlLFxuICAgICAgZ3Vlc3NlZFRleHQ6IHRoaXMuI2d1ZXNzZWRUZXh0LFxuICAgICAgdGV4dFdpdGhEaXNjbGFpbWVyOiB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXJcbiAgICB9O1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhbHRUZXh0OiB0aGlzLiNhbHRUZXh0LFxuICAgICAgZGVjb3JhdGl2ZTogdGhpcy4jYWx0VGV4dERlY29yYXRpdmVcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHtcbiAgICBhbHRUZXh0LFxuICAgIGRlY29yYXRpdmUsXG4gICAgZ3Vlc3NlZFRleHQsXG4gICAgdGV4dFdpdGhEaXNjbGFpbWVyLFxuICAgIGNhbmNlbCA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoZ3Vlc3NlZFRleHQpIHtcbiAgICAgIHRoaXMuI2d1ZXNzZWRUZXh0ID0gZ3Vlc3NlZFRleHQ7XG4gICAgICB0aGlzLiN0ZXh0V2l0aERpc2NsYWltZXIgPSB0ZXh0V2l0aERpc2NsYWltZXI7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0ID09PSBhbHRUZXh0ICYmIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID09PSBkZWNvcmF0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuY2VsKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0ID0gYWx0VGV4dDtcbiAgICAgIHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID0gZGVjb3JhdGl2ZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3RhdGUoKTtcbiAgfVxuICB0b2dnbGUoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCAmJiB0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNhbHRUZXh0VG9vbHRpcFRpbWVvdXQpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICB9XG4gIHNob3duKCkge1xuICAgIHRoaXMuI2VkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5hbHRfdGV4dC5pbWFnZV9zdGF0dXNfbGFiZWxfZGlzcGxheWVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGxhYmVsOiB0aGlzLiNsYWJlbFxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbkxhYmVsID0gbnVsbDtcbiAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy4jYmFkZ2U/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2JhZGdlID0gbnVsbDtcbiAgfVxuICBhc3luYyAjc2V0U3RhdGUoKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYWx0VGV4dEJ1dHRvbjtcbiAgICBpZiAoIWJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jdXNlTmV3QWx0VGV4dEZsb3cpIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwiZG9uZVwiLCAhIXRoaXMuI2FsdFRleHQpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW3RoaXMuI2xhYmVsXSk7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uTGFiZWw/LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBBbHRUZXh0LiNsMTBuTmV3QnV0dG9uW2Ake3RoaXMuI2xhYmVsfS1sYWJlbGBdKTtcbiAgICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8ucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImRvbmVcIik7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwPy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJkb25lXCIpO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hbHQtdGV4dC1lZGl0LWJ1dHRvblwiKTtcbiAgICB9XG4gICAgbGV0IHRvb2x0aXAgPSB0aGlzLiNhbHRUZXh0VG9vbHRpcDtcbiAgICBpZiAoIXRvb2x0aXApIHtcbiAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwID0gdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgdG9vbHRpcC5jbGFzc05hbWUgPSBcInRvb2x0aXBcIjtcbiAgICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRvb2x0aXBcIik7XG4gICAgICB0b29sdGlwLmlkID0gYGFsdC10ZXh0LXRvb2x0aXAtJHt0aGlzLiNlZGl0b3IuaWR9YDtcbiAgICAgIGNvbnN0IERFTEFZX1RPX1NIT1dfVE9PTFRJUCA9IDEwMDtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgIHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCA9IG51bGw7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLiNlZGl0b3IuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwiYWx0X3RleHRfdG9vbHRpcFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIERFTEFZX1RPX1NIT1dfVE9PTFRJUCk7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2FsdFRleHRUb29sdGlwVGltZW91dCk7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcD8uY2xhc3NMaXN0LnJlbW92ZShcInNob3dcIik7XG4gICAgICB9LCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItYWx0LXRleHQtZGVjb3JhdGl2ZS10b29sdGlwXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sdGlwLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiKTtcbiAgICAgIHRvb2x0aXAudGV4dENvbnRlbnQgPSB0aGlzLiNhbHRUZXh0O1xuICAgIH1cbiAgICBpZiAoIXRvb2x0aXAucGFyZW50Tm9kZSkge1xuICAgICAgYnV0dG9uLmFwcGVuZCh0b29sdGlwKTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VkaXRvci5nZXRFbGVtZW50Rm9yQWx0VGV4dCgpO1xuICAgIGVsZW1lbnQ/LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgdG9vbHRpcC5pZCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbW1lbnQuanNcblxuY2xhc3MgQ29tbWVudCB7XG4gICNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IG51bGw7XG4gICNjb21tZW50VG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gICNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICNlZGl0b3IgPSBudWxsO1xuICAjaW5pdGlhbFRleHQgPSBudWxsO1xuICAjcmljaFRleHQgPSBudWxsO1xuICAjdGV4dCA9IG51bGw7XG4gICNkYXRlID0gbnVsbDtcbiAgI2RlbGV0ZWQgPSBmYWxzZTtcbiAgI3BvcHVwUG9zaXRpb24gPSBudWxsO1xuICBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNlZGl0b3IgPSBlZGl0b3I7XG4gIH1cbiAgcmVuZGVyRm9yVG9vbGJhcigpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiY29tbWVudFwiO1xuICAgIHJldHVybiB0aGlzLiNyZW5kZXIoYnV0dG9uLCBmYWxzZSk7XG4gIH1cbiAgcmVuZGVyRm9yU3RhbmRhbG9uZSgpIHtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbW1lbnRCdXR0b25cIjtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI2VkaXRvci5jb21tZW50QnV0dG9uUG9zaXRpb247XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0eWxlXG4gICAgICB9ID0gYnV0dG9uO1xuICAgICAgc3R5bGUuaW5zZXRJbmxpbmVFbmQgPSBgY2FsYygkezEwMCAqICh0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyAxIC0gcG9zaXRpb25bMF0gOiBwb3NpdGlvblswXSl9JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgICAgIHN0eWxlLnRvcCA9IGBjYWxjKCR7MTAwICogcG9zaXRpb25bMV19JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy4jZWRpdG9yLmNvbW1lbnRCdXR0b25Db2xvcjtcbiAgICAgIGlmIChjb2xvcikge1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3JlbmRlcihidXR0b24sIHRydWUpO1xuICB9XG4gIGZvY3VzQnV0dG9uKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgKHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID8/IHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uKT8uZm9jdXMoKTtcbiAgICB9LCAwKTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbG9yID0gdGhpcy4jZWRpdG9yLmNvbW1lbnRCdXR0b25Db2xvcjtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICB0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci51cGRhdGVQb3B1cENvbG9yKHRoaXMuI2VkaXRvcik7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25XaWR0aCgpIHtcbiAgICByZXR1cm4gKHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA/PyAwKSAvIHRoaXMuI2VkaXRvci5wYXJlbnQuYm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICB9XG4gIGdldCBjb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwUG9zaXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLiNwb3B1cFBvc2l0aW9uO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgeDogcGFyZW50WCxcbiAgICAgIHk6IHBhcmVudFksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICByZXR1cm4gWyh4IC0gcGFyZW50WCkgLyBwYXJlbnRXaWR0aCwgKHkgKyBoZWlnaHQgLSBwYXJlbnRZKSAvIHBhcmVudEhlaWdodF07XG4gIH1cbiAgc2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcihwb3MpIHtcbiAgICB0aGlzLiNwb3B1cFBvc2l0aW9uID0gcG9zO1xuICB9XG4gIGhhc0RlZmF1bHRQb3B1cFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3B1cFBvc2l0aW9uID09PSBudWxsO1xuICB9XG4gIHJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCkge1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlVG9vbGJhckNvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uID0gbnVsbDtcbiAgfVxuICBzZXRDb21tZW50QnV0dG9uU3RhdGVzKHtcbiAgICBzZWxlY3RlZCxcbiAgICBoYXNQb3B1cFxuICB9KSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwic2VsZWN0ZWRcIiwgc2VsZWN0ZWQpO1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmFyaWFFeHBhbmRlZCA9IGhhc1BvcHVwO1xuICB9XG4gICNyZW5kZXIoY29tbWVudCwgaXNTdGFuZGFsb25lKSB7XG4gICAgaWYgKCF0aGlzLiNlZGl0b3IuX3VpTWFuYWdlci5oYXNDb21tZW50TWFuYWdlcigpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29tbWVudC50YWJJbmRleCA9IFwiMFwiO1xuICAgIGNvbW1lbnQuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICBpZiAoaXNTdGFuZGFsb25lKSB7XG4gICAgICBjb21tZW50LmFyaWFDb250cm9scyA9IFwiY29tbWVudFBvcHVwXCI7XG4gICAgICBjb21tZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXNob3ctY29tbWVudC1idXR0b25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1lbnQuYXJpYUNvbnRyb2xzRWxlbWVudHMgPSBbdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZ2V0Q29tbWVudERpYWxvZ0VsZW1lbnQoKV07XG4gICAgICBjb21tZW50LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWVkaXRvci1hZGQtY29tbWVudC1idXR0b25cIik7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI2VkaXRvci5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgaWYgKCEoc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHx8IHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm4gY29tbWVudDtcbiAgICB9XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKGlzU3RhbmRhbG9uZSkge1xuICAgICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBlID0+IHtcbiAgICAgICAgdGhpcy4jZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBldmVudCA9PiBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3Qgb25DbGljayA9IGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoY29tbWVudCA9PT0gdGhpcy4jY29tbWVudFRvb2xiYXJCdXR0b24pIHtcbiAgICAgICAgdGhpcy5lZGl0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNlZGl0b3IudG9nZ2xlQ29tbWVudCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBjb21tZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGNvbW1lbnQgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudFdhc0Zyb21LZXlCb2FyZCA9IHRydWU7XG4gICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLiNlZGl0b3IudG9nZ2xlQ29tbWVudChmYWxzZSwgdHJ1ZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29tbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuI2VkaXRvci50b2dnbGVDb21tZW50KGZhbHNlLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cbiAgZWRpdChvcHRpb25zKSB7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcjtcbiAgICBsZXQgcG9zWCwgcG9zWTtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgIFtwb3NYLCBwb3NZXSA9IHBvc2l0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBbcG9zWCwgcG9zWV0gPSB0aGlzLiNlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgICAgcG9zWCA9IHggKyBwb3NYICogd2lkdGg7XG4gICAgICBwb3NZID0geSArIHBvc1kgKiBoZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudERpbWVuc2lvbnMgPSB0aGlzLiNlZGl0b3IucGFyZW50LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICBjb25zdCB7XG4gICAgICB4OiBwYXJlbnRYLFxuICAgICAgeTogcGFyZW50WSxcbiAgICAgIHdpZHRoOiBwYXJlbnRXaWR0aCxcbiAgICAgIGhlaWdodDogcGFyZW50SGVpZ2h0XG4gICAgfSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy4jZWRpdG9yLl91aU1hbmFnZXIuZWRpdENvbW1lbnQodGhpcy4jZWRpdG9yLCBwYXJlbnRYICsgcG9zWCAqIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcG9zWSAqIHBhcmVudEhlaWdodCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHBhcmVudERpbWVuc2lvbnNcbiAgICB9KTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgaWYgKCF0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbi5mb2N1cyh7XG4gICAgICBmb2N1c1Zpc2libGU6IHRoaXMuI2NvbW1lbnRXYXNGcm9tS2V5Qm9hcmRcbiAgICB9KTtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gIH1cbiAgaXNEZWxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWxldGVkIHx8IHRoaXMuI3RleHQgPT09IFwiXCI7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dCA9PT0gbnVsbDtcbiAgfVxuICBoYXNCZWVuRWRpdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmlzRGVsZXRlZCgpIHx8IHRoaXMuI3RleHQgIT09IHRoaXMuI2luaXRpYWxUZXh0O1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLiN0ZXh0LFxuICAgICAgcmljaFRleHQ6IHRoaXMuI3JpY2hUZXh0LFxuICAgICAgZGF0ZTogdGhpcy4jZGF0ZSxcbiAgICAgIGRlbGV0ZWQ6IHRoaXMuaXNEZWxldGVkKClcbiAgICB9O1xuICB9XG4gIHNldCBkYXRhKHRleHQpIHtcbiAgICBpZiAodGV4dCAhPT0gdGhpcy4jdGV4dCkge1xuICAgICAgdGhpcy4jcmljaFRleHQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGV4dCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy4jdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLiNkZWxldGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdGV4dCA9IHRleHQ7XG4gICAgdGhpcy4jZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIHNldEluaXRpYWxUZXh0KHRleHQsIHJpY2hUZXh0ID0gbnVsbCkge1xuICAgIHRoaXMuI2luaXRpYWxUZXh0ID0gdGV4dDtcbiAgICB0aGlzLmRhdGEgPSB0ZXh0O1xuICAgIHRoaXMuI2RhdGUgPSBudWxsO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gIH1cbiAgc2hvd24oKSB7fVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2NvbW1lbnRUb29sYmFyQnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50VG9vbGJhckJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gbnVsbDtcbiAgICB0aGlzLiN0ZXh0ID0gXCJcIjtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IG51bGw7XG4gICAgdGhpcy4jZGF0ZSA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9yID0gbnVsbDtcbiAgICB0aGlzLiNjb21tZW50V2FzRnJvbUtleUJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jZGVsZXRlZCA9IGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L3RvdWNoX21hbmFnZXIuanNcblxuY2xhc3MgVG91Y2hNYW5hZ2VyIHtcbiAgI2NvbnRhaW5lcjtcbiAgI2lzUGluY2hpbmcgPSBmYWxzZTtcbiAgI2lzUGluY2hpbmdTdG9wcGVkID0gbnVsbDtcbiAgI2lzUGluY2hpbmdEaXNhYmxlZDtcbiAgI29uUGluY2hTdGFydDtcbiAgI29uUGluY2hpbmc7XG4gICNvblBpbmNoRW5kO1xuICAjcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICNzaWduYWw7XG4gICN0b3VjaEluZm8gPSBudWxsO1xuICAjdG91Y2hNYW5hZ2VyQUM7XG4gICN0b3VjaE1vdmVBQyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgaXNQaW5jaGluZ0Rpc2FibGVkID0gbnVsbCxcbiAgICBpc1BpbmNoaW5nU3RvcHBlZCA9IG51bGwsXG4gICAgb25QaW5jaFN0YXJ0ID0gbnVsbCxcbiAgICBvblBpbmNoaW5nID0gbnVsbCxcbiAgICBvblBpbmNoRW5kID0gbnVsbCxcbiAgICBzaWduYWxcbiAgfSkge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiNpc1BpbmNoaW5nU3RvcHBlZCA9IGlzUGluY2hpbmdTdG9wcGVkO1xuICAgIHRoaXMuI2lzUGluY2hpbmdEaXNhYmxlZCA9IGlzUGluY2hpbmdEaXNhYmxlZDtcbiAgICB0aGlzLiNvblBpbmNoU3RhcnQgPSBvblBpbmNoU3RhcnQ7XG4gICAgdGhpcy4jb25QaW5jaGluZyA9IG9uUGluY2hpbmc7XG4gICAgdGhpcy4jb25QaW5jaEVuZCA9IG9uUGluY2hFbmQ7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy4jc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFtzaWduYWwsIHRoaXMuI3RvdWNoTWFuYWdlckFDLnNpZ25hbF0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLiNvblRvdWNoU3RhcnQuYmluZCh0aGlzKSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBzaWduYWw6IHRoaXMuI3NpZ25hbFxuICAgIH0pO1xuICB9XG4gIGdldCBNSU5fVE9VQ0hfRElTVEFOQ0VfVE9fUElOQ0goKSB7XG4gICAgcmV0dXJuIDM1IC8gT3V0cHV0U2NhbGUucGl4ZWxSYXRpbztcbiAgfVxuICAjb25Ub3VjaFN0YXJ0KGV2dCkge1xuICAgIGlmICh0aGlzLiNpc1BpbmNoaW5nRGlzYWJsZWQ/LigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLiNwb2ludGVyRG93bkFDKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvaW50ZXJEb3duQUMgPSB0aGlzLiNwb2ludGVyRG93bkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHBvaW50ZXJEb3duQUMuc2lnbmFsXSk7XG4gICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLiNjb250YWluZXI7XG4gICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICBzaWduYWwsXG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9O1xuICAgICAgY29uc3QgY2FuY2VsUG9pbnRlckRvd24gPSBlID0+IHtcbiAgICAgICAgaWYgKGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgICAgICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIGNhbmNlbFBvaW50ZXJEb3duKGUpO1xuICAgICAgICB9XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGNhbmNlbFBvaW50ZXJEb3duLCBvcHRzKTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBjYW5jZWxQb2ludGVyRG93biwgb3B0cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hNb3ZlQUMpIHtcbiAgICAgIHRoaXMuI3RvdWNoTW92ZUFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gQWJvcnRTaWduYWwuYW55KFt0aGlzLiNzaWduYWwsIHRoaXMuI3RvdWNoTW92ZUFDLnNpZ25hbF0pO1xuICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy4jY29udGFpbmVyO1xuICAgICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuI29uVG91Y2hNb3ZlLmJpbmQodGhpcyksIG9wdCk7XG4gICAgICBjb25zdCBvblRvdWNoRW5kID0gdGhpcy4jb25Ub3VjaEVuZC5iaW5kKHRoaXMpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBvblRvdWNoRW5kLCBvcHQpO1xuICAgICAgb3B0LmNhcHR1cmUgPSB0cnVlO1xuICAgICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHN0b3BFdmVudCwgb3B0KTtcbiAgICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBzdG9wRXZlbnQsIG9wdCk7XG4gICAgICB0aGlzLiNvblBpbmNoU3RhcnQ/LigpO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZ0KTtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IHRoaXMuI2lzUGluY2hpbmdTdG9wcGVkPy4oKSkge1xuICAgICAgdGhpcy4jdG91Y2hJbmZvID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFt0b3VjaDAsIHRvdWNoMV0gPSBldnQudG91Y2hlcztcbiAgICBpZiAodG91Y2gwLmlkZW50aWZpZXIgPiB0b3VjaDEuaWRlbnRpZmllcikge1xuICAgICAgW3RvdWNoMCwgdG91Y2gxXSA9IFt0b3VjaDEsIHRvdWNoMF07XG4gICAgfVxuICAgIHRoaXMuI3RvdWNoSW5mbyA9IHtcbiAgICAgIHRvdWNoMFg6IHRvdWNoMC5zY3JlZW5YLFxuICAgICAgdG91Y2gwWTogdG91Y2gwLnNjcmVlblksXG4gICAgICB0b3VjaDFYOiB0b3VjaDEuc2NyZWVuWCxcbiAgICAgIHRvdWNoMVk6IHRvdWNoMS5zY3JlZW5ZXG4gICAgfTtcbiAgfVxuICAjb25Ub3VjaE1vdmUoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLiN0b3VjaEluZm8gfHwgZXZ0LnRvdWNoZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIGxldCBbdG91Y2gwLCB0b3VjaDFdID0gZXZ0LnRvdWNoZXM7XG4gICAgaWYgKHRvdWNoMC5pZGVudGlmaWVyID4gdG91Y2gxLmlkZW50aWZpZXIpIHtcbiAgICAgIFt0b3VjaDAsIHRvdWNoMV0gPSBbdG91Y2gxLCB0b3VjaDBdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4wWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjBZXG4gICAgfSA9IHRvdWNoMDtcbiAgICBjb25zdCB7XG4gICAgICBzY3JlZW5YOiBzY3JlZW4xWCxcbiAgICAgIHNjcmVlblk6IHNjcmVlbjFZXG4gICAgfSA9IHRvdWNoMTtcbiAgICBjb25zdCB0b3VjaEluZm8gPSB0aGlzLiN0b3VjaEluZm87XG4gICAgY29uc3Qge1xuICAgICAgdG91Y2gwWDogcFRvdWNoMFgsXG4gICAgICB0b3VjaDBZOiBwVG91Y2gwWSxcbiAgICAgIHRvdWNoMVg6IHBUb3VjaDFYLFxuICAgICAgdG91Y2gxWTogcFRvdWNoMVlcbiAgICB9ID0gdG91Y2hJbmZvO1xuICAgIGNvbnN0IHByZXZHYXBYID0gcFRvdWNoMVggLSBwVG91Y2gwWDtcbiAgICBjb25zdCBwcmV2R2FwWSA9IHBUb3VjaDFZIC0gcFRvdWNoMFk7XG4gICAgY29uc3QgY3VyckdhcFggPSBzY3JlZW4xWCAtIHNjcmVlbjBYO1xuICAgIGNvbnN0IGN1cnJHYXBZID0gc2NyZWVuMVkgLSBzY3JlZW4wWTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoY3VyckdhcFgsIGN1cnJHYXBZKSB8fCAxO1xuICAgIGNvbnN0IHBEaXN0YW5jZSA9IE1hdGguaHlwb3QocHJldkdhcFgsIHByZXZHYXBZKSB8fCAxO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZyAmJiBNYXRoLmFicyhwRGlzdGFuY2UgLSBkaXN0YW5jZSkgPD0gVG91Y2hNYW5hZ2VyLk1JTl9UT1VDSF9ESVNUQU5DRV9UT19QSU5DSCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0b3VjaEluZm8udG91Y2gwWCA9IHNjcmVlbjBYO1xuICAgIHRvdWNoSW5mby50b3VjaDBZID0gc2NyZWVuMFk7XG4gICAgdG91Y2hJbmZvLnRvdWNoMVggPSBzY3JlZW4xWDtcbiAgICB0b3VjaEluZm8udG91Y2gxWSA9IHNjcmVlbjFZO1xuICAgIGlmICghdGhpcy4jaXNQaW5jaGluZykge1xuICAgICAgdGhpcy4jaXNQaW5jaGluZyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbiA9IFsoc2NyZWVuMFggKyBzY3JlZW4xWCkgLyAyLCAoc2NyZWVuMFkgKyBzY3JlZW4xWSkgLyAyXTtcbiAgICB0aGlzLiNvblBpbmNoaW5nPy4ob3JpZ2luLCBwRGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgfVxuICAjb25Ub3VjaEVuZChldnQpIHtcbiAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3RvdWNoTW92ZUFDKSB7XG4gICAgICB0aGlzLiN0b3VjaE1vdmVBQy5hYm9ydCgpO1xuICAgICAgdGhpcy4jdG91Y2hNb3ZlQUMgPSBudWxsO1xuICAgICAgdGhpcy4jb25QaW5jaEVuZD8uKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy4jdG91Y2hJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0b3BFdmVudChldnQpO1xuICAgIHRoaXMuI3RvdWNoSW5mbyA9IG51bGw7XG4gICAgdGhpcy4jaXNQaW5jaGluZyA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jdG91Y2hNYW5hZ2VyQUMgPSBudWxsO1xuICAgIHRoaXMuI3BvaW50ZXJEb3duQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jcG9pbnRlckRvd25BQyA9IG51bGw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2VkaXRvci5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FjY2Vzc2liaWxpdHlEYXRhID0gbnVsbDtcbiAgI2FsbFJlc2l6ZXJEaXZzID0gbnVsbDtcbiAgI2FsdFRleHQgPSBudWxsO1xuICAjY29tbWVudCA9IG51bGw7XG4gICNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbiA9IG51bGw7XG4gICNkaXNhYmxlZCA9IGZhbHNlO1xuICAjZHJhZ1BvaW50ZXJJZCA9IG51bGw7XG4gICNkcmFnUG9pbnRlclR5cGUgPSBcIlwiO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjbGFzdFBvaW50ZXJDb29yZHMgPSBudWxsO1xuICAjc2F2ZWREaW1lbnNpb25zID0gbnVsbDtcbiAgI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgI2ZvY3VzQUMgPSBudWxsO1xuICAjZm9jdXNlZFJlc2l6ZXJOYW1lID0gXCJcIjtcbiAgI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICNpbml0aWFsUmVjdCA9IG51bGw7XG4gICNpc0VkaXRpbmcgPSBmYWxzZTtcbiAgI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAjaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgI3ByZXZEcmFnWCA9IDA7XG4gICNwcmV2RHJhZ1kgPSAwO1xuICAjdGVsZW1ldHJ5VGltZW91dHMgPSBudWxsO1xuICAjdG91Y2hNYW5hZ2VyID0gbnVsbDtcbiAgaXNTZWxlY3RlZCA9IGZhbHNlO1xuICBfaXNDb3B5ID0gZmFsc2U7XG4gIF9lZGl0VG9vbGJhciA9IG51bGw7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF9pbml0aWFsRGF0YSA9IG51bGw7XG4gIF9pc1Zpc2libGUgPSB0cnVlO1xuICBfdWlNYW5hZ2VyID0gbnVsbDtcbiAgX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gIHN0YXRpYyBfbDEwbiA9IG51bGw7XG4gIHN0YXRpYyBfbDEwblJlc2l6ZXIgPSBudWxsO1xuICAjaXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2JvcmRlckxpbmVXaWR0aCA9IC0xO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBDb2xvck1hbmFnZXIoKTtcbiAgc3RhdGljIF96SW5kZXggPSAxO1xuICBzdGF0aWMgX3RlbGVtZXRyeVRpbWVvdXQgPSAxMDAwO1xuICBzdGF0aWMgZ2V0IF9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHJlc2l6ZSA9IEFubm90YXRpb25FZGl0b3IucHJvdG90eXBlLl9yZXNpemVXaXRoS2V5Ym9hcmQ7XG4gICAgY29uc3Qgc21hbGwgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogW2JpZywgMF1cbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXVxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHJlc2l6ZSwge1xuICAgICAgYXJnczogWzAsIC1iaWddXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCByZXNpemUsIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF1cbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcmVzaXplLCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXVxuICAgIH1dLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgQW5ub3RhdGlvbkVkaXRvci5wcm90b3R5cGUuX3N0b3BSZXNpemluZ1dpdGhLZXlib2FyZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMucGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQ7XG4gICAgdGhpcy5pZCA9IHBhcmFtZXRlcnMuaWQ7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gbnVsbDtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhcmFtZXRlcnMucGFyZW50LnBhZ2VJbmRleDtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbWV0ZXJzLm5hbWU7XG4gICAgdGhpcy5kaXYgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlciA9IHBhcmFtZXRlcnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IG51bGw7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zLmlzQ2VudGVyZWQgPSBwYXJhbWV0ZXJzLmlzQ2VudGVyZWQ7XG4gICAgdGhpcy5fc3RydWN0VHJlZVBhcmVudElkID0gbnVsbDtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25FbGVtZW50SWQgfHwgbnVsbDtcbiAgICB0aGlzLmNyZWF0aW9uRGF0ZSA9IHBhcmFtZXRlcnMuY3JlYXRpb25EYXRlIHx8IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5tb2RpZmljYXRpb25EYXRlID0gcGFyYW1ldGVycy5tb2RpZmljYXRpb25EYXRlIHx8IG51bGw7XG4gICAgdGhpcy5jYW5BZGRDb21tZW50ID0gdHJ1ZTtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbixcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMucGFnZVJvdGF0aW9uID0gKDM2MCArIHJvdGF0aW9uIC0gdGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uKSAlIDM2MDtcbiAgICB0aGlzLnBhZ2VEaW1lbnNpb25zID0gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gICAgdGhpcy5wYWdlVHJhbnNsYXRpb24gPSBbcGFnZVgsIHBhZ2VZXTtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ID0gcGFyYW1ldGVycy54IC8gd2lkdGg7XG4gICAgdGhpcy55ID0gcGFyYW1ldGVycy55IC8gaGVpZ2h0O1xuICAgIHRoaXMuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgdGhpcy5kZWxldGVkID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGVkaXRvclR5cGUoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvci5fdHlwZTtcbiAgfVxuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9kZWZhdWx0TGluZUNvbG9yXCIsIHRoaXMuX2NvbG9yTWFuYWdlci5nZXRIZXhDb2RlKFwiQ2FudmFzVGV4dFwiKSk7XG4gIH1cbiAgc3RhdGljIGRlbGV0ZUFubm90YXRpb25FbGVtZW50KGVkaXRvcikge1xuICAgIGNvbnN0IGZha2VFZGl0b3IgPSBuZXcgRmFrZUVkaXRvcih7XG4gICAgICBpZDogZWRpdG9yLnBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHBhcmVudDogZWRpdG9yLnBhcmVudCxcbiAgICAgIHVpTWFuYWdlcjogZWRpdG9yLl91aU1hbmFnZXJcbiAgICB9KTtcbiAgICBmYWtlRWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICBmYWtlRWRpdG9yLmRlbGV0ZWQgPSB0cnVlO1xuICAgIGZha2VFZGl0b3IuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGZha2VFZGl0b3IpO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIF91aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuID8/PSBsMTBuO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIHRvcExlZnQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItdG9wLWxlZnRcIixcbiAgICAgIHRvcE1pZGRsZTogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtbWlkZGxlXCIsXG4gICAgICB0b3BSaWdodDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci10b3AtcmlnaHRcIixcbiAgICAgIG1pZGRsZVJpZ2h0OiBcInBkZmpzLWVkaXRvci1yZXNpemVyLW1pZGRsZS1yaWdodFwiLFxuICAgICAgYm90dG9tUmlnaHQ6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLXJpZ2h0XCIsXG4gICAgICBib3R0b21NaWRkbGU6IFwicGRmanMtZWRpdG9yLXJlc2l6ZXItYm90dG9tLW1pZGRsZVwiLFxuICAgICAgYm90dG9tTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1ib3R0b20tbGVmdFwiLFxuICAgICAgbWlkZGxlTGVmdDogXCJwZGZqcy1lZGl0b3ItcmVzaXplci1taWRkbGUtbGVmdFwiXG4gICAgfSk7XG4gICAgaWYgKEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fYm9yZGVyTGluZVdpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1vdXRsaW5lLXdpZHRoXCIpKSB8fCAwO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKF90eXBlLCBfdmFsdWUpIHt9XG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBwYXN0ZShpdGVtLCBwYXJlbnQpIHtcbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgZ2V0IHVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkIHx8IHRoaXMuaWQ7XG4gIH1cbiAgZ2V0IGlzRW50ZXJIYW5kbGVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNlbnRlcigpIHtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgc3dpdGNoICh0aGlzLnBhcmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB0aGlzLnggLT0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHRoaXMueCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55ICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAvIChwYWdlV2lkdGggKiAyKTtcbiAgICAgICAgdGhpcy55IC09IHRoaXMud2lkdGggKiBwYWdlV2lkdGggLyAocGFnZUhlaWdodCAqIDIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy55IC09IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyO1xuICB9XG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG4gIHNldEluRm9yZWdyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSB0aGlzLiN6SW5kZXg7XG4gIH1cbiAgc2V0UGFyZW50KHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMucGFnZUluZGV4ID0gcGFyZW50LnBhZ2VJbmRleDtcbiAgICAgIHRoaXMucGFnZURpbWVuc2lvbnMgPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgfVxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQ2xpY2tlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5DbGlja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mb2N1c0V2ZW50c0FsbG93ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICh0YXJnZXQ/LmNsb3Nlc3QoYCMke3RoaXMuaWR9YCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Py5pc011bHRpcGxlU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBfbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgIHRoaXMuX29uVHJhbnNsYXRlZCgpO1xuICB9XG4gICN0cmFuc2xhdGUoW3dpZHRoLCBoZWlnaHRdLCB4LCB5KSB7XG4gICAgW3gsIHldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KTtcbiAgICB0aGlzLnggKz0geCAvIHdpZHRoO1xuICAgIHRoaXMueSArPSB5IC8gaGVpZ2h0O1xuICAgIHRoaXMuX29uVHJhbnNsYXRpbmcodGhpcy54LCB0aGlzLnkpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICB0cmFuc2xhdGUoeCwgeSkge1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHgsIHkpO1xuICB9XG4gIHRyYW5zbGF0ZUluUGFnZSh4LCB5KSB7XG4gICAgdGhpcy4jaW5pdGlhbFJlY3QgfHw9IFt0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdO1xuICAgIHRoaXMuI3RyYW5zbGF0ZSh0aGlzLnBhZ2VEaW1lbnNpb25zLCB4LCB5KTtcbiAgICB0aGlzLmRpdi5zY3JvbGxJbnRvVmlldyh7XG4gICAgICBibG9jazogXCJuZWFyZXN0XCJcbiAgICB9KTtcbiAgfVxuICB0cmFuc2xhdGlvbkRvbmUoKSB7XG4gICAgdGhpcy5fb25UcmFuc2xhdGVkKHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBkcmFnKHR4LCB0eSkge1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLnggKz0gdHggLyBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLnkgKz0gdHkgLyBwYXJlbnRIZWlnaHQ7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICh0aGlzLnggPCAwIHx8IHRoaXMueCA+IDEgfHwgdGhpcy55IDwgMCB8fCB0aGlzLnkgPiAxKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuZmluZE5ld1BhcmVudCh0aGlzLCB4LCB5KSkge1xuICAgICAgICB0aGlzLnggLT0gTWF0aC5mbG9vcih0aGlzLngpO1xuICAgICAgICB0aGlzLnkgLT0gTWF0aC5mbG9vcih0aGlzLnkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIHgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7KDEwMCAqIHkpLnRvRml4ZWQoMil9JWA7XG4gICAgdGhpcy5fb25UcmFuc2xhdGluZyh4LCB5KTtcbiAgICBkaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRpbmcoeCwgeSkge31cbiAgX29uVHJhbnNsYXRlZCh4LCB5KSB7fVxuICBnZXQgX2hhc0JlZW5Nb3ZlZCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNpbml0aWFsUmVjdCAmJiAodGhpcy4jaW5pdGlhbFJlY3RbMF0gIT09IHRoaXMueCB8fCB0aGlzLiNpbml0aWFsUmVjdFsxXSAhPT0gdGhpcy55KTtcbiAgfVxuICBnZXQgX2hhc0JlZW5SZXNpemVkKCkge1xuICAgIHJldHVybiAhIXRoaXMuI2luaXRpYWxSZWN0ICYmICh0aGlzLiNpbml0aWFsUmVjdFsyXSAhPT0gdGhpcy53aWR0aCB8fCB0aGlzLiNpbml0aWFsUmVjdFszXSAhPT0gdGhpcy5oZWlnaHQpO1xuICB9XG4gIGdldEJhc2VUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3Qge1xuICAgICAgX2JvcmRlckxpbmVXaWR0aFxuICAgIH0gPSBBbm5vdGF0aW9uRWRpdG9yO1xuICAgIGNvbnN0IHggPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgeSA9IF9ib3JkZXJMaW5lV2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWy14LCB5XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCwgLXldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFsteCwgLXldO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmaXhBbmRTZXRQb3NpdGlvbihyb3RhdGlvbiA9IHRoaXMucm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXY6IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0sXG4gICAgICBwYWdlRGltZW5zaW9uczogW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIHdpZHRoICo9IHBhZ2VXaWR0aDtcbiAgICBoZWlnaHQgKj0gcGFnZUhlaWdodDtcbiAgICB4ICo9IHBhZ2VXaWR0aDtcbiAgICB5ICo9IHBhZ2VIZWlnaHQ7XG4gICAgaWYgKHRoaXMuX211c3RGaXhQb3NpdGlvbikge1xuICAgICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgeCA9IE1hdGhDbGFtcCh4LCAwLCBwYWdlV2lkdGggLSB3aWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCAwLCBwYWdlSGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIDAsIHBhZ2VXaWR0aCAtIGhlaWdodCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCB3aWR0aCwgcGFnZUhlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgIHggPSBNYXRoQ2xhbXAoeCwgd2lkdGgsIHBhZ2VXaWR0aCk7XG4gICAgICAgICAgeSA9IE1hdGhDbGFtcCh5LCBoZWlnaHQsIHBhZ2VIZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI3MDpcbiAgICAgICAgICB4ID0gTWF0aENsYW1wKHgsIGhlaWdodCwgcGFnZVdpZHRoKTtcbiAgICAgICAgICB5ID0gTWF0aENsYW1wKHksIDAsIHBhZ2VIZWlnaHQgLSB3aWR0aCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMueCA9IHggLz0gcGFnZVdpZHRoO1xuICAgIHRoaXMueSA9IHkgLz0gcGFnZUhlaWdodDtcbiAgICBjb25zdCBbYngsIGJ5XSA9IHRoaXMuZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtwYWdlV2lkdGggKiBwYXJlbnRTY2FsZSwgcGFnZUhlaWdodCAqIHBhcmVudFNjYWxlXTtcbiAgfVxuICBzZXREaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgc3R5bGUud2lkdGggPSBgJHsoMTAwICogd2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIGhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICAjY3JlYXRlUmVzaXplcnMoKSB7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZXJzRGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplcnNcIik7XG4gICAgY29uc3QgY2xhc3NlcyA9IHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPyBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl0gOiBbXCJ0b3BMZWZ0XCIsIFwidG9wTWlkZGxlXCIsIFwidG9wUmlnaHRcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbVJpZ2h0XCIsIFwiYm90dG9tTWlkZGxlXCIsIFwiYm90dG9tTGVmdFwiLCBcIm1pZGRsZUxlZnRcIl07XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWw7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwicmVzaXplclwiLCBuYW1lKTtcbiAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiLCBuYW1lKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcmVzaXplclBvaW50ZXJkb3duLmJpbmQodGhpcywgbmFtZSksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZGl2LnRhYkluZGV4ID0gLTE7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZShmYWxzZSk7XG4gICAgY29uc3Qgc2F2ZWREcmFnZ2FibGUgPSB0aGlzLl9pc0RyYWdnYWJsZTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuI2xhc3RQb2ludGVyQ29vcmRzID0gW2V2ZW50LnNjcmVlblgsIGV2ZW50LnNjcmVlblldO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgdGhpcy5wYXJlbnQudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNyZXNpemVyUG9pbnRlcm1vdmUuYmluZCh0aGlzLCBuYW1lKSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSB7XG4gICAgICBzYXZlZFg6IHRoaXMueCxcbiAgICAgIHNhdmVkWTogdGhpcy55LFxuICAgICAgc2F2ZWRXaWR0aDogdGhpcy53aWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIGFjLmFib3J0KCk7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlKHRydWUpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSBzYXZlZERyYWdnYWJsZTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgdGhpcy4jYWRkUmVzaXplVG9VbmRvU3RhY2soKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNyZXNpemUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gIF9vblJlc2l6ZWQoKSB7fVxuICAjYWRkUmVzaXplVG9VbmRvU3RhY2soKSB7XG4gICAgaWYgKCF0aGlzLiNzYXZlZERpbWVuc2lvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2F2ZWRYLFxuICAgICAgc2F2ZWRZLFxuICAgICAgc2F2ZWRXaWR0aCxcbiAgICAgIHNhdmVkSGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NhdmVkRGltZW5zaW9ucztcbiAgICB0aGlzLiNzYXZlZERpbWVuc2lvbnMgPSBudWxsO1xuICAgIGNvbnN0IG5ld1ggPSB0aGlzLng7XG4gICAgY29uc3QgbmV3WSA9IHRoaXMueTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgaWYgKG5ld1ggPT09IHNhdmVkWCAmJiBuZXdZID09PSBzYXZlZFkgJiYgbmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogdGhpcy4jcmVzaXplLmJpbmQodGhpcywgbmV3WCwgbmV3WSwgbmV3V2lkdGgsIG5ld0hlaWdodCksXG4gICAgICB1bmRvOiB0aGlzLiNyZXNpemUuYmluZCh0aGlzLCBzYXZlZFgsIHNhdmVkWSwgc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgX3JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IGludlJvdGF0aW9uTWF0cml4ID0gdGhpcy4jZ2V0Um90YXRpb25NYXRyaXgoMzYwIC0gdGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgaW52VHJhbnNmID0gKHgsIHkpID0+IFtpbnZSb3RhdGlvbk1hdHJpeFswXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFsyXSAqIHksIGludlJvdGF0aW9uTWF0cml4WzFdICogeCArIGludlJvdGF0aW9uTWF0cml4WzNdICogeV07XG4gICAgbGV0IGdldFBvaW50O1xuICAgIGxldCBnZXRPcHBvc2l0ZTtcbiAgICBsZXQgaXNEaWFnb25hbCA9IGZhbHNlO1xuICAgIGxldCBpc0hvcml6b250YWwgPSBmYWxzZTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgIGNhc2UgXCJ0b3BMZWZ0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbMCwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcFJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWlkZGxlUmlnaHRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tUmlnaHRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJib3R0b21NaWRkbGVcIjpcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3cgLyAyLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3cgLyAyLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGhdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZUxlZnRcIjpcbiAgICAgICAgaXNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIGggLyAyXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIGggLyAyXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ID0gZ2V0UG9pbnQoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGNvbnN0IG9wcG9zaXRlUG9pbnQgPSBnZXRPcHBvc2l0ZShzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgbGV0IHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4ub3Bwb3NpdGVQb2ludCk7XG4gICAgY29uc3Qgb3Bwb3NpdGVYID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRYICsgdHJhbnNmT3Bwb3NpdGVQb2ludFswXSk7XG4gICAgY29uc3Qgb3Bwb3NpdGVZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmT3Bwb3NpdGVQb2ludFsxXSk7XG4gICAgbGV0IHJhdGlvWCA9IDE7XG4gICAgbGV0IHJhdGlvWSA9IDE7XG4gICAgbGV0IGRlbHRhWCwgZGVsdGFZO1xuICAgIGlmICghZXZlbnQuZnJvbUtleWJvYXJkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjcmVlblgsXG4gICAgICAgIHNjcmVlbllcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IFtsYXN0U2NyZWVuWCwgbGFzdFNjcmVlblldID0gdGhpcy4jbGFzdFBvaW50ZXJDb29yZHM7XG4gICAgICBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihzY3JlZW5YIC0gbGFzdFNjcmVlblgsIHNjcmVlblkgLSBsYXN0U2NyZWVuWSk7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1swXSA9IHNjcmVlblg7XG4gICAgICB0aGlzLiNsYXN0UG9pbnRlckNvb3Jkc1sxXSA9IHNjcmVlblk7XG4gICAgfSBlbHNlIHtcbiAgICAgICh7XG4gICAgICAgIGRlbHRhWCxcbiAgICAgICAgZGVsdGFZXG4gICAgICB9ID0gZXZlbnQpO1xuICAgIH1cbiAgICBbZGVsdGFYLCBkZWx0YVldID0gaW52VHJhbnNmKGRlbHRhWCAvIHBhcmVudFdpZHRoLCBkZWx0YVkgLyBwYXJlbnRIZWlnaHQpO1xuICAgIGlmIChpc0RpYWdvbmFsKSB7XG4gICAgICBjb25zdCBvbGREaWFnID0gTWF0aC5oeXBvdChzYXZlZFdpZHRoLCBzYXZlZEhlaWdodCk7XG4gICAgICByYXRpb1ggPSByYXRpb1kgPSBNYXRoLm1heChNYXRoLm1pbihNYXRoLmh5cG90KG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCwgb3Bwb3NpdGVQb2ludFsxXSAtIHBvaW50WzFdIC0gZGVsdGFZKSAvIG9sZERpYWcsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgcmF0aW9YID0gTWF0aENsYW1wKE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMF0gLSBwb2ludFswXSAtIGRlbHRhWCksIG1pbldpZHRoLCAxKSAvIHNhdmVkV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhdGlvWSA9IE1hdGhDbGFtcChNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzFdIC0gcG9pbnRbMV0gLSBkZWx0YVkpLCBtaW5IZWlnaHQsIDEpIC8gc2F2ZWRIZWlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IG5ld1dpZHRoID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRXaWR0aCAqIHJhdGlvWCk7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRIZWlnaHQgKiByYXRpb1kpO1xuICAgIHRyYW5zZk9wcG9zaXRlUG9pbnQgPSB0cmFuc2YoLi4uZ2V0T3Bwb3NpdGUobmV3V2lkdGgsIG5ld0hlaWdodCkpO1xuICAgIGNvbnN0IG5ld1ggPSBvcHBvc2l0ZVggLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzBdO1xuICAgIGNvbnN0IG5ld1kgPSBvcHBvc2l0ZVkgLSB0cmFuc2ZPcHBvc2l0ZVBvaW50WzFdO1xuICAgIHRoaXMuI2luaXRpYWxSZWN0IHx8PSBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblJlc2l6aW5nKCk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7fVxuICBhbHRUZXh0RmluaXNoKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LmZpbmlzaCgpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBhc3luYyBhZGRFZGl0VG9vbGJhcigpIHtcbiAgICBpZiAodGhpcy5fZWRpdFRvb2xiYXIgfHwgdGhpcy4jaXNJbkVkaXRNb2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyID0gbmV3IEVkaXRvclRvb2xiYXIodGhpcyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuX2VkaXRUb29sYmFyLnJlbmRlcigpKTtcbiAgICBjb25zdCB7XG4gICAgICB0b29sYmFyQnV0dG9uc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0b29sYmFyQnV0dG9ucykge1xuICAgICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgdG9vbGJhckJ1dHRvbnMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKG5hbWUsIHRvb2wpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzQ29tbWVudCkge1xuICAgICAgdGhpcy5fZWRpdFRvb2xiYXIuYWRkQnV0dG9uKFwiY29tbWVudFwiLCB0aGlzLmFkZENvbW1lbnRCdXR0b24oKSk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyLmFkZEJ1dHRvbihcImRlbGV0ZVwiKTtcbiAgICByZXR1cm4gdGhpcy5fZWRpdFRvb2xiYXI7XG4gIH1cbiAgYWRkQ29tbWVudEJ1dHRvbkluVG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uYWRkQnV0dG9uQmVmb3JlKFwiY29tbWVudFwiLCB0aGlzLmFkZENvbW1lbnRCdXR0b24oKSwgXCIuZGVsZXRlQnV0dG9uXCIpO1xuICB9XG4gIHJlbW92ZUNvbW1lbnRCdXR0b25Gcm9tVG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8ucmVtb3ZlQnV0dG9uKFwiY29tbWVudFwiKTtcbiAgfVxuICByZW1vdmVFZGl0VG9vbGJhcigpIHtcbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8ucmVtb3ZlKCk7XG4gICAgdGhpcy5fZWRpdFRvb2xiYXIgPSBudWxsO1xuICAgIHRoaXMuI2FsdFRleHQ/LmRlc3Ryb3koKTtcbiAgfVxuICBhZGRDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgY29uc3QgZWRpdFRvb2xiYXJEaXYgPSB0aGlzLl9lZGl0VG9vbGJhcj8uZGl2O1xuICAgIGlmIChlZGl0VG9vbGJhckRpdikge1xuICAgICAgZWRpdFRvb2xiYXJEaXYuYmVmb3JlKGNvbnRhaW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChjb250YWluZXIpO1xuICAgIH1cbiAgfVxuICBnZXRDbGllbnREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBjcmVhdGVBbHRUZXh0KCkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgQWx0VGV4dC5pbml0aWFsaXplKEFubm90YXRpb25FZGl0b3IuX2wxMG4pO1xuICAgICAgdGhpcy4jYWx0VGV4dCA9IG5ldyBBbHRUZXh0KHRoaXMpO1xuICAgICAgaWYgKHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhKSB7XG4gICAgICAgIHRoaXMuI2FsdFRleHQuZGF0YSA9IHRoaXMuI2FjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5RGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNhbHRUZXh0O1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZGF0YTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoZGF0YSkge1xuICAgIGlmICghdGhpcy4jYWx0VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhbHRUZXh0LmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBndWVzc2VkQWx0VGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWx0VGV4dD8uZ3Vlc3NlZFRleHQ7XG4gIH1cbiAgYXN5bmMgc2V0R3Vlc3NlZEFsdFRleHQodGV4dCkge1xuICAgIGF3YWl0IHRoaXMuI2FsdFRleHQ/LnNldEd1ZXNzZWRUZXh0KHRleHQpO1xuICB9XG4gIHNlcmlhbGl6ZUFsdFRleHQoaXNGb3JDb3B5aW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/LnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICB9XG4gIGhhc0FsdFRleHQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy4jYWx0VGV4dCAmJiAhdGhpcy4jYWx0VGV4dC5pc0VtcHR5KCk7XG4gIH1cbiAgaGFzQWx0VGV4dERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FsdFRleHQ/Lmhhc0RhdGEoKSA/PyBmYWxzZTtcbiAgfVxuICBmb2N1c0NvbW1lbnRCdXR0b24oKSB7XG4gICAgdGhpcy4jY29tbWVudD8uZm9jdXNCdXR0b24oKTtcbiAgfVxuICBhZGRDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLmNhbkFkZENvbW1lbnQgPyB0aGlzLiNjb21tZW50IHx8PSBuZXcgQ29tbWVudCh0aGlzKSA6IG51bGw7XG4gIH1cbiAgYWRkU3RhbmRhbG9uZUNvbW1lbnRCdXR0b24oKSB7XG4gICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuaGFzQ29tbWVudE1hbmFnZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24pIHtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaXNFZGl0aW5nTW9kZSgpKSB7XG4gICAgICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNDb21tZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uID0gdGhpcy4jY29tbWVudC5yZW5kZXJGb3JTdGFuZGFsb25lKCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuI2NvbW1lbnRTdGFuZGFsb25lQnV0dG9uKTtcbiAgfVxuICByZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50LnJlbW92ZVN0YW5kYWxvbmVDb21tZW50QnV0dG9uKCk7XG4gICAgdGhpcy4jY29tbWVudFN0YW5kYWxvbmVCdXR0b24gPSBudWxsO1xuICB9XG4gIGhpZGVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpIHtcbiAgICB0aGlzLiNjb21tZW50U3RhbmRhbG9uZUJ1dHRvbj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgfVxuICBnZXQgY29tbWVudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICB0ZXh0LFxuICAgICAgICBkYXRlLFxuICAgICAgICBkZWxldGVkXG4gICAgICB9XG4gICAgfSA9IHRoaXMuI2NvbW1lbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQsXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGRhdGUsXG4gICAgICBkZWxldGVkLFxuICAgICAgY29sb3I6IHRoaXMuZ2V0Tm9uSENNQ29sb3IoKSxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSA/PyAxXG4gICAgfTtcbiAgfVxuICBzZXQgY29tbWVudCh0ZXh0KSB7XG4gICAgdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgdGhpcy4jY29tbWVudC5kYXRhID0gdGV4dDtcbiAgICBpZiAodGhpcy5oYXNDb21tZW50KSB7XG4gICAgICB0aGlzLnJlbW92ZUNvbW1lbnRCdXR0b25Gcm9tVG9vbGJhcigpO1xuICAgICAgdGhpcy5hZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZUNvbW1lbnQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkQ29tbWVudEJ1dHRvbkluVG9vbGJhcigpO1xuICAgICAgdGhpcy5yZW1vdmVTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUNvbW1lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldENvbW1lbnREYXRhKHtcbiAgICBjb21tZW50LFxuICAgIHBvcHVwUmVmLFxuICAgIHJpY2hUZXh0XG4gIH0pIHtcbiAgICBpZiAoIXBvcHVwUmVmKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbW1lbnQgfHw9IG5ldyBDb21tZW50KHRoaXMpO1xuICAgIHRoaXMuI2NvbW1lbnQuc2V0SW5pdGlhbFRleHQoY29tbWVudCwgcmljaFRleHQpO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLl91aU1hbmFnZXIuZ2V0QW5kUmVtb3ZlRGF0YUZyb21Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGlmIChzdG9yZWREYXRhKSB7XG4gICAgICB0aGlzLnVwZGF0ZUZyb21Bbm5vdGF0aW9uTGF5ZXIoc3RvcmVkRGF0YSk7XG4gICAgfVxuICB9XG4gIGdldCBoYXNFZGl0ZWRDb21tZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50Py5oYXNCZWVuRWRpdGVkKCk7XG4gIH1cbiAgZ2V0IGhhc0RlbGV0ZWRDb21tZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50Py5pc0RlbGV0ZWQoKTtcbiAgfVxuICBnZXQgaGFzQ29tbWVudCgpIHtcbiAgICByZXR1cm4gISF0aGlzLiNjb21tZW50ICYmICF0aGlzLiNjb21tZW50LmlzRW1wdHkoKSAmJiAhdGhpcy4jY29tbWVudC5pc0RlbGV0ZWQoKTtcbiAgfVxuICBhc3luYyBlZGl0Q29tbWVudChvcHRpb25zKSB7XG4gICAgdGhpcy4jY29tbWVudCB8fD0gbmV3IENvbW1lbnQodGhpcyk7XG4gICAgdGhpcy4jY29tbWVudC5lZGl0KG9wdGlvbnMpO1xuICB9XG4gIHRvZ2dsZUNvbW1lbnQoaXNTZWxlY3RlZCwgdmlzaWJpbGl0eSA9IHVuZGVmaW5lZCkge1xuICAgIGlmICh0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci50b2dnbGVDb21tZW50KHRoaXMsIGlzU2VsZWN0ZWQsIHZpc2liaWxpdHkpO1xuICAgIH1cbiAgfVxuICBzZXRTZWxlY3RlZENvbW1lbnRCdXR0b24oc2VsZWN0ZWQpIHtcbiAgICB0aGlzLiNjb21tZW50LnNldFNlbGVjdGVkQnV0dG9uKHNlbGVjdGVkKTtcbiAgfVxuICBhZGRDb21tZW50KHNlcmlhbGl6ZWQpIHtcbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50KSB7XG4gICAgICBjb25zdCBERUZBVUxUX1BPUFVQX1dJRFRIID0gMTgwO1xuICAgICAgY29uc3QgREVGQVVMVF9QT1BVUF9IRUlHSFQgPSAxMDA7XG4gICAgICBjb25zdCBbLCwsIHRyWV0gPSBzZXJpYWxpemVkLnJlY3Q7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoXSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCBbcGFnZVhdID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgICBjb25zdCBibFggPSBwYWdlWCArIHBhZ2VXaWR0aCArIDE7XG4gICAgICBjb25zdCBibFkgPSB0clkgLSBERUZBVUxUX1BPUFVQX0hFSUdIVDtcbiAgICAgIGNvbnN0IHRyWCA9IGJsWCArIERFRkFVTFRfUE9QVVBfV0lEVEg7XG4gICAgICBzZXJpYWxpemVkLnBvcHVwID0ge1xuICAgICAgICBjb250ZW50czogdGhpcy5jb21tZW50LnRleHQsXG4gICAgICAgIGRlbGV0ZWQ6IHRoaXMuY29tbWVudC5kZWxldGVkLFxuICAgICAgICByZWN0OiBbYmxYLCBibFksIHRyWCwgdHJZXVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRnJvbUFubm90YXRpb25MYXllcih7XG4gICAgcG9wdXA6IHtcbiAgICAgIGNvbnRlbnRzLFxuICAgICAgZGVsZXRlZFxuICAgIH1cbiAgfSkge1xuICAgIHRoaXMuI2NvbW1lbnQuZGF0YSA9IGRlbGV0ZWQgPyBudWxsIDogY29udGVudHM7XG4gIH1cbiAgZ2V0IHBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuYm91bmRpbmdDbGllbnRSZWN0O1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBkaXYgPSB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtZWRpdG9yLXJvdGF0aW9uXCIsICgzNjAgLSB0aGlzLnJvdGF0aW9uKSAlIDM2MCk7XG4gICAgZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgZGl2LnRhYkluZGV4ID0gdGhpcy4jZGlzYWJsZWQgPyAtMSA6IDA7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJhcHBsaWNhdGlvblwiKTtcbiAgICBpZiAodGhpcy5kZWZhdWx0TDEwbklkKSB7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIHRoaXMuZGVmYXVsdEwxMG5JZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKSB7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLiNhZGRGb2N1c0xpc3RlbmVycygpO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBpZiAodGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCAhPT0gMCkge1xuICAgICAgZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgZGl2LnN0eWxlLm1heEhlaWdodCA9IGAkeygxMDAgKiBwYXJlbnRXaWR0aCAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLmdldEluaXRpYWxUcmFuc2xhdGlvbigpO1xuICAgIHRoaXMudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgYmluZEV2ZW50cyh0aGlzLCBkaXYsIFtcImtleWRvd25cIiwgXCJwb2ludGVyZG93blwiLCBcImRibGNsaWNrXCJdKTtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSAmJiB0aGlzLl91aU1hbmFnZXIuX3N1cHBvcnRzUGluY2hUb1pvb20pIHtcbiAgICAgIHRoaXMuI3RvdWNoTWFuYWdlciB8fD0gbmV3IFRvdWNoTWFuYWdlcih7XG4gICAgICAgIGNvbnRhaW5lcjogZGl2LFxuICAgICAgICBpc1BpbmNoaW5nRGlzYWJsZWQ6ICgpID0+ICF0aGlzLmlzU2VsZWN0ZWQsXG4gICAgICAgIG9uUGluY2hTdGFydDogdGhpcy4jdG91Y2hQaW5jaFN0YXJ0Q2FsbGJhY2suYmluZCh0aGlzKSxcbiAgICAgICAgb25QaW5jaGluZzogdGhpcy4jdG91Y2hQaW5jaENhbGxiYWNrLmJpbmQodGhpcyksXG4gICAgICAgIG9uUGluY2hFbmQ6IHRoaXMuI3RvdWNoUGluY2hFbmRDYWxsYmFjay5iaW5kKHRoaXMpLFxuICAgICAgICBzaWduYWw6IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5hZGRTdGFuZGFsb25lQ29tbWVudEJ1dHRvbigpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgI3RvdWNoUGluY2hTdGFydENhbGxiYWNrKCkge1xuICAgIHRoaXMuI3NhdmVkRGltZW5zaW9ucyA9IHtcbiAgICAgIHNhdmVkWDogdGhpcy54LFxuICAgICAgc2F2ZWRZOiB0aGlzLnksXG4gICAgICBzYXZlZFdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgc2F2ZWRIZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLiNhbHRUZXh0Py50b2dnbGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICB9XG4gICN0b3VjaFBpbmNoQ2FsbGJhY2soX29yaWdpbiwgcHJldkRpc3RhbmNlLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IHNsb3dEb3duRmFjdG9yID0gMC43O1xuICAgIGxldCBmYWN0b3IgPSBzbG93RG93bkZhY3RvciAqIChkaXN0YW5jZSAvIHByZXZEaXN0YW5jZSkgKyAxIC0gc2xvd0Rvd25GYWN0b3I7XG4gICAgaWYgKGZhY3RvciA9PT0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRyYW5zZiA9ICh4LCB5KSA9PiBbcm90YXRpb25NYXRyaXhbMF0gKiB4ICsgcm90YXRpb25NYXRyaXhbMl0gKiB5LCByb3RhdGlvbk1hdHJpeFsxXSAqIHggKyByb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBmYWN0b3IgPSBNYXRoLm1heChNYXRoLm1pbihmYWN0b3IsIDEgLyBzYXZlZFdpZHRoLCAxIC8gc2F2ZWRIZWlnaHQpLCBtaW5XaWR0aCAvIHNhdmVkV2lkdGgsIG1pbkhlaWdodCAvIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkV2lkdGggKiBmYWN0b3IpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkSGVpZ2h0ICogZmFjdG9yKTtcbiAgICBpZiAobmV3V2lkdGggPT09IHNhdmVkV2lkdGggJiYgbmV3SGVpZ2h0ID09PSBzYXZlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpbml0aWFsUmVjdCB8fD0gW3NhdmVkWCwgc2F2ZWRZLCBzYXZlZFdpZHRoLCBzYXZlZEhlaWdodF07XG4gICAgY29uc3QgdHJhbnNmQ2VudGVyUG9pbnQgPSB0cmFuc2Yoc2F2ZWRXaWR0aCAvIDIsIHNhdmVkSGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY2VudGVyWCA9IEFubm90YXRpb25FZGl0b3IuX3JvdW5kKHNhdmVkWCArIHRyYW5zZkNlbnRlclBvaW50WzBdKTtcbiAgICBjb25zdCBjZW50ZXJZID0gQW5ub3RhdGlvbkVkaXRvci5fcm91bmQoc2F2ZWRZICsgdHJhbnNmQ2VudGVyUG9pbnRbMV0pO1xuICAgIGNvbnN0IG5ld1RyYW5zZkNlbnRlclBvaW50ID0gdHJhbnNmKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XG4gICAgdGhpcy54ID0gY2VudGVyWCAtIG5ld1RyYW5zZkNlbnRlclBvaW50WzBdO1xuICAgIHRoaXMueSA9IGNlbnRlclkgLSBuZXdUcmFuc2ZDZW50ZXJQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKCk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIHRoaXMuX29uUmVzaXppbmcoKTtcbiAgfVxuICAjdG91Y2hQaW5jaEVuZENhbGxiYWNrKCkge1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZSh0cnVlKTtcbiAgICB0aGlzLnBhcmVudC50b2dnbGVQb2ludGVyRXZlbnRzKHRydWUpO1xuICAgIHRoaXMuI2FkZFJlc2l6ZVRvVW5kb1N0YWNrKCk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9pc0RyYWdnYWJsZSkge1xuICAgICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdE9uUG9pbnRlckV2ZW50KGV2ZW50KTtcbiAgfVxuICAjc2VsZWN0T25Qb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5jdHJsS2V5ICYmICFpc01hYyB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5tZXRhS2V5ICYmIGlzTWFjKSB7XG4gICAgICB0aGlzLnBhcmVudC50b2dnbGVTZWxlY3RlZCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfVxuICB9XG4gICNzZXRVcERyYWdTZXNzaW9uKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNTZWxlY3RlZFxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuX3VpTWFuYWdlci5zZXRVcERyYWdTZXNzaW9uKCk7XG4gICAgbGV0IGhhc0RyYWdnaW5nU3RhcnRlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH07XG4gICAgY29uc3QgY2FuY2VsRHJhZyA9IGUgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2RyYWdQb2ludGVySWQgPSBudWxsO1xuICAgICAgdGhpcy4jaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLmVuZERyYWdTZXNzaW9uKCkpIHtcbiAgICAgICAgdGhpcy4jc2VsZWN0T25Qb2ludGVyRXZlbnQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzRHJhZ2dpbmdTdGFydGVkKSB7XG4gICAgICAgIHRoaXMuX29uU3RvcERyYWdnaW5nKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgdGhpcy4jcHJldkRyYWdYID0gZXZlbnQuY2xpZW50WDtcbiAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IGV2ZW50LmNsaWVudFk7XG4gICAgICB0aGlzLiNkcmFnUG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xuICAgICAgdGhpcy4jZHJhZ1BvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGUgPT4ge1xuICAgICAgICBpZiAoIWhhc0RyYWdnaW5nU3RhcnRlZCkge1xuICAgICAgICAgIGhhc0RyYWdnaW5nU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLnRvZ2dsZUNvbW1lbnQodGhpcywgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX29uU3RhcnREcmFnZ2luZygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICAgIGNsaWVudFk6IHksXG4gICAgICAgICAgcG9pbnRlcklkXG4gICAgICAgIH0gPSBlO1xuICAgICAgICBpZiAocG9pbnRlcklkICE9PSB0aGlzLiNkcmFnUG9pbnRlcklkKSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24oeCAtIHRoaXMuI3ByZXZEcmFnWCwgeSAtIHRoaXMuI3ByZXZEcmFnWSk7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWCA9IHg7XG4gICAgICAgIHRoaXMuI3ByZXZEcmFnWSA9IHk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9LCBvcHRzKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHN0b3BFdmVudCwgb3B0cyk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gdGhpcy4jZHJhZ1BvaW50ZXJUeXBlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuI3RvdWNoTWFuYWdlciB8fCBlLmlzUHJpbWFyeSkge1xuICAgICAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgfSwgb3B0cyk7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXJVcENhbGxiYWNrID0gZSA9PiB7XG4gICAgICBpZiAoIXRoaXMuI2RyYWdQb2ludGVySWQgfHwgdGhpcy4jZHJhZ1BvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcbiAgICAgICAgY2FuY2VsRHJhZyhlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2ssIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHt9XG4gIF9vblN0b3BEcmFnZ2luZygpIHt9XG4gIG1vdmVJbkRPTSgpIHtcbiAgICBpZiAodGhpcy4jbW92ZUluRE9NVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI21vdmVJbkRPTVRpbWVvdXQpO1xuICAgIH1cbiAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW50Py5tb3ZlRWRpdG9ySW5ET00odGhpcyk7XG4gICAgfSwgMCk7XG4gIH1cbiAgX3NldFBhcmVudEFuZFBvc2l0aW9uKHBhcmVudCwgeCwgeSkge1xuICAgIHBhcmVudC5jaGFuZ2VQYXJlbnQodGhpcyk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLl9vblRyYW5zbGF0ZWQoKTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSwgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgLSBoZWlnaHQgKyBwYWdlWSwgeCArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRZICsgcGFnZVldO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRZICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgcGFnZVksIHggKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyB3aWR0aCArIHBhZ2VZXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFggLSB3aWR0aCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIHBhZ2VZLCB4IC0gc2hpZnRYICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgaGVpZ2h0ICsgcGFnZVldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVksIHggLSBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFggKyBwYWdlWV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkyLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeDEsIHBhZ2VIZWlnaHQgLSB5MSwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTIsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UERGUmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWN0KDAsIDApO1xuICB9XG4gIGdldE5vbkhDTUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmNvbG9yICYmIEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvcih0aGlzLmNvbG9yKSk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy4jY29tbWVudD8ub25VcGRhdGVkQ29sb3IoKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnQ6IHtcbiAgICAgICAgdGV4dDogc3RyLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgZGF0ZSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgcmljaFRleHRcbiAgICAgIH0sXG4gICAgICB1aWQ6IGlkLFxuICAgICAgcGFnZUluZGV4LFxuICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBpZCxcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcmljaFRleHQsXG4gICAgICBjb250ZW50c09iajoge1xuICAgICAgICBzdHJcbiAgICAgIH0sXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRlIHx8IG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICBwb3B1cFJlZjogIWRlbGV0ZWQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHlcbiAgICB9O1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge31cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzSW5FZGl0TW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNJbkVkaXRNb2RlO1xuICB9XG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQ7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIGdldCBpc09uU2NyZWVuKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBib3R0b20sXG4gICAgICByaWdodFxuICAgIH0gPSB0aGlzLmdldENsaWVudERpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBpbm5lckhlaWdodCxcbiAgICAgIGlubmVyV2lkdGhcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBsZWZ0IDwgaW5uZXJXaWR0aCAmJiByaWdodCA+IDAgJiYgdG9wIDwgaW5uZXJIZWlnaHQgJiYgYm90dG9tID4gMDtcbiAgfVxuICAjYWRkRm9jdXNMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI2ZvY3VzQUMgfHwgIXRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2ZvY3VzQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2ZvY3VzQUMpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIHRoaXMuI2FkZEZvY3VzTGlzdGVuZXJzKCk7XG4gIH1cbiAgcm90YXRlKF9hbmdsZSkge31cbiAgcmVzaXplKCkge31cbiAgc2VyaWFsaXplRGVsZXRlZCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGRlbGV0ZWQ6IHRydWUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UsIGNvbnRleHQgPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFubm90YXRpb25UeXBlOiB0aGlzLm1vZGUsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkLFxuICAgICAgcG9wdXBSZWY6IHRoaXMuX2luaXRpYWxEYXRhPy5wb3B1cFJlZiB8fCBcIlwiXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHVpTWFuYWdlcixcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGRhdGEuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgIGNyZWF0aW9uRGF0ZTogZGF0YS5jcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGVcbiAgICB9KTtcbiAgICBlZGl0b3Iucm90YXRpb24gPSBkYXRhLnJvdGF0aW9uO1xuICAgIGVkaXRvci4jYWNjZXNzaWJpbGl0eURhdGEgPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIGVkaXRvci5faXNDb3B5ID0gZGF0YS5pc0NvcHkgfHwgZmFsc2U7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIGdldCBoYXNCZWVuTW9kaWZpZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICh0aGlzLmRlbGV0ZWQgfHwgdGhpcy5zZXJpYWxpemUoKSAhPT0gbnVsbCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI2ZvY3VzQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZm9jdXNBQyA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVFZGl0b3IodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuaGlkZUNvbW1lbnRQb3B1cCgpO1xuICAgIGlmICh0aGlzLiNtb3ZlSW5ET01UaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy4jbW92ZUluRE9NVGltZW91dCk7XG4gICAgICB0aGlzLiNtb3ZlSW5ET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5yZW1vdmVFZGl0VG9vbGJhcigpO1xuICAgIGlmICh0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cykge1xuICAgICAgZm9yIChjb25zdCB0aW1lb3V0IG9mIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnZhbHVlcygpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI3RvdWNoTWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy4jZmFrZUFubm90YXRpb24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uID0gbnVsbDtcbiAgfVxuICBnZXQgaXNSZXNpemFibGUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1ha2VSZXNpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuaXNSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVJlc2l6ZXJzKCk7XG4gICAgICB0aGlzLiNyZXNpemVyc0Rpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgIH1cbiAgfVxuICBnZXQgdG9vbGJhclBvc2l0aW9uKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIgPyBbMSwgMF0gOiBbMCwgMF07XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Qb3NpdGlvbkluUGFnZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50QnV0dG9uUG9zaXRpb246IFtwb3NYLCBwb3NZXVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gdGhpcy5nZXRQREZSZWN0KCk7XG4gICAgcmV0dXJuIFtBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChibFggKyAodHJYIC0gYmxYKSAqIHBvc1gpLCBBbm5vdGF0aW9uRWRpdG9yLl9yb3VuZChibFkgKyAodHJZIC0gYmxZKSAqICgxIC0gcG9zWSkpXTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbkNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl91aU1hbmFnZXIubWFrZUNvbW1lbnRDb2xvcih0aGlzLmdldE5vbkhDTUNvbG9yKCksIHRoaXMub3BhY2l0eSk7XG4gIH1cbiAgZ2V0IGNvbW1lbnRQb3B1cFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50LmNvbW1lbnRQb3B1cFBvc2l0aW9uSW5MYXllcjtcbiAgfVxuICBzZXQgY29tbWVudFBvcHVwUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy4jY29tbWVudC5jb21tZW50UG9wdXBQb3NpdGlvbkluTGF5ZXIgPSBwb3M7XG4gIH1cbiAgaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnQuaGFzRGVmYXVsdFBvcHVwUG9zaXRpb24oKTtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbldpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50LmNvbW1lbnRCdXR0b25XaWR0aDtcbiAgfVxuICBnZXQgZWxlbWVudEJlZm9yZVBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBzZXRDb21tZW50QnV0dG9uU3RhdGVzKG9wdGlvbnMpIHtcbiAgICB0aGlzLiNjb21tZW50Py5zZXRDb21tZW50QnV0dG9uU3RhdGVzKG9wdGlvbnMpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuaXNSZXNpemFibGUgfHwgZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdiB8fCBldmVudC5rZXkgIT09IFwiRW50ZXJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgdGhpcy4jc2F2ZWREaW1lbnNpb25zID0ge1xuICAgICAgc2F2ZWRYOiB0aGlzLngsXG4gICAgICBzYXZlZFk6IHRoaXMueSxcbiAgICAgIHNhdmVkV2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBzYXZlZEhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy4jcmVzaXplcnNEaXYuY2hpbGRyZW47XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgdGhpcy4jYWxsUmVzaXplckRpdnMgPSBBcnJheS5mcm9tKGNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IGJvdW5kUmVzaXplcktleWRvd24gPSB0aGlzLiNyZXNpemVyS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgICAgY29uc3QgYm91bmRSZXNpemVyQmx1ciA9IHRoaXMuI3Jlc2l6ZXJCbHVyLmJpbmQodGhpcyk7XG4gICAgICBjb25zdCBzaWduYWwgPSB0aGlzLl91aU1hbmFnZXIuX3NpZ25hbDtcbiAgICAgIGZvciAoY29uc3QgZGl2IG9mIHRoaXMuI2FsbFJlc2l6ZXJEaXZzKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBkaXYuZ2V0QXR0cmlidXRlKFwiZGF0YS1yZXNpemVyLW5hbWVcIik7XG4gICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwic3BpbmJ1dHRvblwiKTtcbiAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGJvdW5kUmVzaXplcktleWRvd24sIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBib3VuZFJlc2l6ZXJCbHVyLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI3Jlc2l6ZXJGb2N1cy5iaW5kKHRoaXMsIG5hbWUpLCB7XG4gICAgICAgICAgc2lnbmFsXG4gICAgICAgIH0pO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLiNhbGxSZXNpemVyRGl2c1swXTtcbiAgICBsZXQgZmlyc3RQb3NpdGlvbiA9IDA7XG4gICAgZm9yIChjb25zdCBkaXYgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlmIChkaXYgPT09IGZpcnN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZmlyc3RQb3NpdGlvbisrO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Rmlyc3RQb3NpdGlvbiA9ICgzNjAgLSB0aGlzLnJvdGF0aW9uICsgdGhpcy5wYXJlbnRSb3RhdGlvbikgJSAzNjAgLyA5MCAqICh0aGlzLiNhbGxSZXNpemVyRGl2cy5sZW5ndGggLyA0KTtcbiAgICBpZiAobmV4dEZpcnN0UG9zaXRpb24gIT09IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgIGlmIChuZXh0Rmlyc3RQb3NpdGlvbiA8IGZpcnN0UG9zaXRpb24pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaXJzdFBvc2l0aW9uIC0gbmV4dEZpcnN0UG9zaXRpb247IGkrKykge1xuICAgICAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmFwcGVuZCh0aGlzLiNyZXNpemVyc0Rpdi5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dEZpcnN0UG9zaXRpb24gPiBmaXJzdFBvc2l0aW9uKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dEZpcnN0UG9zaXRpb24gLSBmaXJzdFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICB0aGlzLiNyZXNpemVyc0Rpdi5maXJzdEVsZW1lbnRDaGlsZC5iZWZvcmUodGhpcy4jcmVzaXplcnNEaXYubGFzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy4jYWxsUmVzaXplckRpdnNbaSsrXTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGRpdi5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlc2l6ZXItbmFtZVwiKTtcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIEFubm90YXRpb25FZGl0b3IuX2wxMG5SZXNpemVyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KDApO1xuICAgIHRoaXMuI2lzUmVzaXplckVuYWJsZWRGb3JLZXlib2FyZCA9IHRydWU7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuZmlyc3RFbGVtZW50Q2hpbGQuZm9jdXMoe1xuICAgICAgZm9jdXNWaXNpYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuICAjcmVzaXplcktleWRvd24oZXZlbnQpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9yZXNpemVyS2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gICNyZXNpemVyQmx1cihldmVudCkge1xuICAgIGlmICh0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgJiYgZXZlbnQucmVsYXRlZFRhcmdldD8ucGFyZW50Tm9kZSAhPT0gdGhpcy4jcmVzaXplcnNEaXYpIHtcbiAgICAgIHRoaXMuI3N0b3BSZXNpemluZygpO1xuICAgIH1cbiAgfVxuICAjcmVzaXplckZvY3VzKG5hbWUpIHtcbiAgICB0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUgPSB0aGlzLiNpc1Jlc2l6ZXJFbmFibGVkRm9yS2V5Ym9hcmQgPyBuYW1lIDogXCJcIjtcbiAgfVxuICAjc2V0UmVzaXplclRhYkluZGV4KHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiNhbGxSZXNpemVyRGl2cykge1xuICAgICAgZGl2LnRhYkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIF9yZXNpemVXaXRoS2V5Ym9hcmQoeCwgeSkge1xuICAgIGlmICghdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZSh0aGlzLiNmb2N1c2VkUmVzaXplck5hbWUsIHtcbiAgICAgIGRlbHRhWDogeCxcbiAgICAgIGRlbHRhWTogeSxcbiAgICAgIGZyb21LZXlib2FyZDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNzdG9wUmVzaXppbmcoKSB7XG4gICAgdGhpcy4jaXNSZXNpemVyRW5hYmxlZEZvcktleWJvYXJkID0gZmFsc2U7XG4gICAgdGhpcy4jc2V0UmVzaXplclRhYkluZGV4KC0xKTtcbiAgICB0aGlzLiNhZGRSZXNpemVUb1VuZG9TdGFjaygpO1xuICB9XG4gIF9zdG9wUmVzaXppbmdXaXRoS2V5Ym9hcmQoKSB7XG4gICAgdGhpcy4jc3RvcFJlc2l6aW5nKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgaWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5fZWRpdFRvb2xiYXIuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QuYWRkKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKCF0aGlzLl9lZGl0VG9vbGJhcikge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpKSB7XG4gICAgICAgICAgdGhpcy5fZWRpdFRvb2xiYXI/LnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VkaXRUb29sYmFyPy5zaG93KCk7XG4gICAgdGhpcy4jYWx0VGV4dD8udG9nZ2xlQWx0VGV4dEJhZGdlKGZhbHNlKTtcbiAgfVxuICBmb2N1cygpIHtcbiAgICBpZiAodGhpcy5kaXYgJiYgIXRoaXMuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGl2Py5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pLCAwKTtcbiAgICB9XG4gIH1cbiAgdW5zZWxlY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy4jcmVzaXplcnNEaXY/LmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5yZW1vdmUoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICBpZiAodGhpcy5kaXY/LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuY3VycmVudExheWVyLmRpdi5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0VG9vbGJhcj8uaGlkZSgpO1xuICAgIHRoaXMuI2FsdFRleHQ/LnRvZ2dsZUFsdFRleHRCYWRnZSh0cnVlKTtcbiAgICB0aGlzLmhpZGVDb21tZW50UG9wdXAoKTtcbiAgfVxuICBoaWRlQ29tbWVudFBvcHVwKCkge1xuICAgIGlmICh0aGlzLmhhc0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci50b2dnbGVDb21tZW50KG51bGwpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG4gIGRpc2FibGVFZGl0aW5nKCkge31cbiAgZW5hYmxlRWRpdGluZygpIHt9XG4gIGdldCBjYW5DaGFuZ2VDb250ZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmNhbkNoYW5nZUNvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cbiAgZGJsY2xpY2soZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkJVVFRPTlwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgdGhpcy5wYXJlbnQudXBkYXRlVG9vbGJhcih7XG4gICAgICBtb2RlOiB0aGlzLmNvbnN0cnVjdG9yLl9lZGl0b3JUeXBlLFxuICAgICAgZWRpdElkOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9XG4gIGdldEVsZW1lbnRGb3JBbHRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBNSU5fU0laRSgpIHtcbiAgICByZXR1cm4gMTY7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlJbml0aWFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWN0aW9uOiBcImFkZGVkXCJcbiAgICB9O1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3JlcG9ydFRlbGVtZXRyeShkYXRhLCBtdXN0V2FpdCA9IGZhbHNlKSB7XG4gICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyB8fD0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3Rpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IHRpbWVvdXQgPSB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5nZXQoYWN0aW9uKTtcbiAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KGRhdGEpO1xuICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cy5kZWxldGUoYWN0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuI3RlbGVtZXRyeVRpbWVvdXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICB0aGlzLiN0ZWxlbWV0cnlUaW1lb3V0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH0sIEFubm90YXRpb25FZGl0b3IuX3RlbGVtZXRyeVRpbWVvdXQpO1xuICAgICAgdGhpcy4jdGVsZW1ldHJ5VGltZW91dHMuc2V0KGFjdGlvbiwgdGltZW91dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEudHlwZSB8fD0gdGhpcy5lZGl0b3JUeXBlO1xuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgZGF0YVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNob3codmlzaWJsZSA9IHRoaXMuX2lzVmlzaWJsZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJoaWRkZW5cIiwgIXZpc2libGUpO1xuICAgIHRoaXMuX2lzVmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IGZhbHNlO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgICB0aGlzLiNkaXNhYmxlZCA9IHRydWU7XG4gIH1cbiAgdXBkYXRlRmFrZUFubm90YXRpb25FbGVtZW50KGFubm90YXRpb25MYXllcikge1xuICAgIGlmICghdGhpcy4jZmFrZUFubm90YXRpb24gJiYgIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24gPSBhbm5vdGF0aW9uTGF5ZXIuYWRkRmFrZUFubm90YXRpb24odGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRoaXMuI2Zha2VBbm5vdGF0aW9uLnJlbW92ZSgpO1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNFZGl0ZWRDb21tZW50IHx8IHRoaXMuX2hhc0JlZW5Nb3ZlZCB8fCB0aGlzLl9oYXNCZWVuUmVzaXplZCkge1xuICAgICAgdGhpcy4jZmFrZUFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgYW5ub3RhdGlvbi5oaWRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgbGV0IGNvbnRlbnQgPSBhbm5vdGF0aW9uLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKFwiLmFubm90YXRpb25Db250ZW50XCIpO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uQ29udGVudFwiLCB0aGlzLmVkaXRvclR5cGUpO1xuICAgICAgYW5ub3RhdGlvbi5jb250YWluZXIucHJlcGVuZChjb250ZW50KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRlbnQ7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25Db250ZW50XCIsIHRoaXMuZWRpdG9yVHlwZSk7XG4gICAgICBjYW52YXMuYmVmb3JlKGNvbnRlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICByZXNldEFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICBmaXJzdEVsZW1lbnRDaGlsZFxuICAgIH0gPSBhbm5vdGF0aW9uLmNvbnRhaW5lcjtcbiAgICBpZiAoZmlyc3RFbGVtZW50Q2hpbGQ/Lm5vZGVOYW1lID09PSBcIkRJVlwiICYmIGZpcnN0RWxlbWVudENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICBmaXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEZha2VFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBwYXJhbXMuYW5ub3RhdGlvbkVsZW1lbnRJZDtcbiAgICB0aGlzLmRlbGV0ZWQgPSB0cnVlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEZWxldGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9tdXJtdXJoYXNoMy5qc1xuY29uc3QgU0VFRCA9IDB4YzNkMmUxZjA7XG5jb25zdCBNQVNLX0hJR0ggPSAweGZmZmYwMDAwO1xuY29uc3QgTUFTS19MT1cgPSAweGZmZmY7XG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuICB1cGRhdGUoaW5wdXQpIHtcbiAgICBsZXQgZGF0YSwgbGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGggKiAyKTtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY29kZSA8PSAweGZmKSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSA+Pj4gODtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgJiAweGZmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpKSB7XG4gICAgICBkYXRhID0gaW5wdXQuc2xpY2UoKTtcbiAgICAgIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIGZvcm1hdCwgbXVzdCBiZSBhIHN0cmluZyBvciBUeXBlZEFycmF5LlwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tDb3VudHMgPSBsZW5ndGggPj4gMjtcbiAgICBjb25zdCB0YWlsTGVuZ3RoID0gbGVuZ3RoIC0gYmxvY2tDb3VudHMgKiA0O1xuICAgIGNvbnN0IGRhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGJsb2NrQ291bnRzKTtcbiAgICBsZXQgazEgPSAwLFxuICAgICAgazIgPSAwO1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgQzIgPSAweDFiODczNTkzO1xuICAgIGNvbnN0IEMxX0xPVyA9IEMxICYgTUFTS19MT1csXG4gICAgICBDMl9MT1cgPSBDMiAmIE1BU0tfTE9XO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tDb3VudHM7IGkrKykge1xuICAgICAgaWYgKGkgJiAxKSB7XG4gICAgICAgIGsxID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gaDEgPDwgMTMgfCBoMSA+Pj4gMTk7XG4gICAgICAgIGgxID0gaDEgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsyID0gZGF0YVVpbnQzMltpXTtcbiAgICAgICAgazIgPSBrMiAqIEMxICYgTUFTS19ISUdIIHwgazIgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazIgPSBrMiA8PCAxNSB8IGsyID4+PiAxNztcbiAgICAgICAgazIgPSBrMiAqIEMyICYgTUFTS19ISUdIIHwgazIgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaDIgXj0gazI7XG4gICAgICAgIGgyID0gaDIgPDwgMTMgfCBoMiA+Pj4gMTk7XG4gICAgICAgIGgyID0gaDIgKiA1ICsgMHhlNjU0NmI2NDtcbiAgICAgIH1cbiAgICB9XG4gICAgazEgPSAwO1xuICAgIHN3aXRjaCAodGFpbExlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDJdIDw8IDE2O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBrMSBePSBkYXRhW2Jsb2NrQ291bnRzICogNCArIDFdIDw8IDg7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgaWYgKGJsb2NrQ291bnRzICYgMSkge1xuICAgICAgICAgIGgxIF49IGsxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGgyIF49IGsxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cbiAgaGV4ZGlnZXN0KCkge1xuICAgIGxldCBoMSA9IHRoaXMuaDEsXG4gICAgICBoMiA9IHRoaXMuaDI7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4ZWQ1NThjY2QgJiBNQVNLX0hJR0ggfCBoMSAqIDB4OGNjZCAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGZmNTFhZmQ3ICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGFmZDdlZDU1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgaDEgPSBoMSAqIDB4MWE4NWVjNTMgJiBNQVNLX0hJR0ggfCBoMSAqIDB4ZWM1MyAmIE1BU0tfTE9XO1xuICAgIGgyID0gaDIgKiAweGM0Y2ViOWZlICYgTUFTS19ISUdIIHwgKChoMiA8PCAxNiB8IGgxID4+PiAxNikgKiAweGI5ZmUxYTg1ICYgTUFTS19ISUdIKSA+Pj4gMTY7XG4gICAgaDEgXj0gaDIgPj4+IDE7XG4gICAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKSArIChoMiA+Pj4gMCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIFwiMFwiKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9hbm5vdGF0aW9uX3N0b3JhZ2UuanNcblxuXG5cbmNvbnN0IFNlcmlhbGl6YWJsZUVtcHR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIG1hcDogbnVsbCxcbiAgaGFzaDogXCJcIixcbiAgdHJhbnNmZXI6IHVuZGVmaW5lZFxufSk7XG5jbGFzcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNtb2RpZmllZCA9IGZhbHNlO1xuICAjbW9kaWZpZWRJZHMgPSBudWxsO1xuICAjZWRpdG9yc01hcCA9IG51bGw7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICBjb25zdCBzdG9yZWRWYWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHN0b3JlZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0b3JlZFZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgdGhpcy4jZWRpdG9yc01hcC5kZWxldGUoc3RvcmVkVmFsdWUuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgfVxuICAgIHRoaXMuI3N0b3JhZ2UuZGVsZXRlKGtleSk7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgdGhpcy5yZXNldE1vZGlmaWVkKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgKHRoaXMuI2VkaXRvcnNNYXAgfHw9IG5ldyBNYXAoKSkuc2V0KHZhbHVlLmFubm90YXRpb25FbGVtZW50SWQsIHZhbHVlKTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5zaXplO1xuICB9XG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IHRydWU7XG4gICAgICBpZiAodHlwZW9mIHRoaXMub25TZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25TZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXNldE1vZGlmaWVkKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZCkge1xuICAgICAgdGhpcy4jbW9kaWZpZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgcHJpbnQoKSB7XG4gICAgcmV0dXJuIG5ldyBQcmludEFubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIGdldCBzZXJpYWxpemFibGUoKSB7XG4gICAgaWYgKHRoaXMuI3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUVtcHR5O1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCksXG4gICAgICBoYXNoID0gbmV3IE11cm11ckhhc2gzXzY0KCksXG4gICAgICB0cmFuc2ZlciA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKGZhbHNlLCBjb250ZXh0KSA6IHZhbDtcbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIG1hcC5zZXQoa2V5LCBzZXJpYWxpemVkKTtcbiAgICAgICAgaGFzaC51cGRhdGUoYCR7a2V5fToke0pTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZWQpfWApO1xuICAgICAgICBoYXNCaXRtYXAgfHw9ICEhc2VyaWFsaXplZC5iaXRtYXA7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNCaXRtYXApIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5iaXRtYXApIHtcbiAgICAgICAgICB0cmFuc2Zlci5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlclxuICAgIH0gOiBTZXJpYWxpemFibGVFbXB0eTtcbiAgfVxuICBnZXQgZWRpdG9yU3RhdHMoKSB7XG4gICAgbGV0IHN0YXRzID0gbnVsbDtcbiAgICBjb25zdCB0eXBlVG9FZGl0b3IgPSBuZXcgTWFwKCk7XG4gICAgbGV0IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPSAwO1xuICAgIGxldCBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyA9IDA7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNzdG9yYWdlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIEFubm90YXRpb25FZGl0b3IpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5wb3B1cCkge1xuICAgICAgICAgIGlmICh2YWx1ZS5wb3B1cC5kZWxldGVkKSB7XG4gICAgICAgICAgICBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlLmlzQ29tbWVudERlbGV0ZWQpIHtcbiAgICAgICAgbnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgKz0gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUuaGFzRWRpdGVkQ29tbWVudCkge1xuICAgICAgICBudW1iZXJPZkVkaXRlZENvbW1lbnRzICs9IDE7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3JTdGF0cyA9IHZhbHVlLnRlbGVtZXRyeUZpbmFsRGF0YTtcbiAgICAgIGlmICghZWRpdG9yU3RhdHMpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlZGl0b3JTdGF0cztcbiAgICAgIGlmICghdHlwZVRvRWRpdG9yLmhhcyh0eXBlKSkge1xuICAgICAgICB0eXBlVG9FZGl0b3Iuc2V0KHR5cGUsIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgICAgc3RhdHMgfHw9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBjb25zdCBtYXAgPSBzdGF0c1t0eXBlXSB8fD0gbmV3IE1hcCgpO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKGVkaXRvclN0YXRzKSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcInR5cGVcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3VudGVycyA9IG1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjb3VudGVycykge1xuICAgICAgICAgIGNvdW50ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIG1hcC5zZXQoa2V5LCBjb3VudGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY291bnQgPSBjb3VudGVycy5nZXQodmFsKSA/PyAwO1xuICAgICAgICBjb3VudGVycy5zZXQodmFsLCBjb3VudCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobnVtYmVyT2ZEZWxldGVkQ29tbWVudHMgPiAwIHx8IG51bWJlck9mRWRpdGVkQ29tbWVudHMgPiAwKSB7XG4gICAgICBzdGF0cyB8fD0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHN0YXRzLmNvbW1lbnRzID0ge1xuICAgICAgICBkZWxldGVkOiBudW1iZXJPZkRlbGV0ZWRDb21tZW50cyxcbiAgICAgICAgZWRpdGVkOiBudW1iZXJPZkVkaXRlZENvbW1lbnRzXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXN0YXRzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZWRpdG9yXSBvZiB0eXBlVG9FZGl0b3IpIHtcbiAgICAgIHN0YXRzW3R5cGVdID0gZWRpdG9yLmNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoc3RhdHNbdHlwZV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdHM7XG4gIH1cbiAgcmVzZXRNb2RpZmllZElkcygpIHtcbiAgICB0aGlzLiNtb2RpZmllZElkcyA9IG51bGw7XG4gIH1cbiAgdXBkYXRlRWRpdG9yKGFubm90YXRpb25JZCwgZGF0YSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jZWRpdG9yc01hcD8uZ2V0KGFubm90YXRpb25JZCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB2YWx1ZS51cGRhdGVGcm9tQW5ub3RhdGlvbkxheWVyKGRhdGEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRFZGl0b3IoYW5ub3RhdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRvcnNNYXA/LmdldChhbm5vdGF0aW9uSWQpIHx8IG51bGw7XG4gIH1cbiAgZ2V0IG1vZGlmaWVkSWRzKCkge1xuICAgIGlmICh0aGlzLiNtb2RpZmllZElkcykge1xuICAgICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzO1xuICAgIH1cbiAgICBjb25zdCBpZHMgPSBbXTtcbiAgICBpZiAodGhpcy4jZWRpdG9yc01hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB0aGlzLiNlZGl0b3JzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICghdmFsdWUuc2VyaWFsaXplKCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZHMucHVzaCh2YWx1ZS5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI21vZGlmaWVkSWRzID0ge1xuICAgICAgaWRzOiBuZXcgU2V0KGlkcyksXG4gICAgICBoYXNoOiBpZHMuam9pbihcIixcIilcbiAgICB9O1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmVudHJpZXMoKTtcbiAgfVxufVxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZTtcbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICBoYXNoLFxuICAgICAgdHJhbnNmZXJcbiAgICB9ID0gcGFyZW50LnNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZShtYXAsIHRyYW5zZmVyID8ge1xuICAgICAgdHJhbnNmZXJcbiAgICB9IDogbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlclxuICAgIH07XG4gIH1cbiAgZ2V0IHByaW50KCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG4gIGdldCBtb2RpZmllZElkcygpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwibW9kaWZpZWRJZHNcIiwge1xuICAgICAgaWRzOiBuZXcgU2V0KCksXG4gICAgICBoYXNoOiBcIlwiXG4gICAgfSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZm9udF9sb2FkZXIuanNcblxuXG5jbGFzcyBGb250TG9hZGVyIHtcbiAgI3N5c3RlbUZvbnRzID0gbmV3IFNldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3duZXJEb2N1bWVudCA9IGdsb2JhbFRoaXMuZG9jdW1lbnQsXG4gICAgc3R5bGVFbGVtZW50ID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmxvYWRpbmdSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICB9XG4gIGFkZE5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIHJlbW92ZU5hdGl2ZUZvbnRGYWNlKG5hdGl2ZUZvbnRGYWNlKSB7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZGVsZXRlKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICB9XG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGlmICghdGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQodGhpcy5zdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gdGhpcy5zdHlsZUVsZW1lbnQuc2hlZXQ7XG4gICAgc3R5bGVTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3N5c3RlbUZvbnRzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgYXN5bmMgbG9hZFN5c3RlbUZvbnQoe1xuICAgIHN5c3RlbUZvbnRJbmZvOiBpbmZvLFxuICAgIGRpc2FibGVGb250RmFjZSxcbiAgICBfaW5zcGVjdEZvbnRcbiAgfSkge1xuICAgIGlmICghaW5mbyB8fCB0aGlzLiNzeXN0ZW1Gb250cy5oYXMoaW5mby5sb2FkZWROYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NlcnQoIWRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgICBfaW5zcGVjdEZvbnQ/LihpbmZvKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB3YXJuKGBDYW5ub3QgbG9hZCBzeXN0ZW0gZm9udDogJHtpbmZvLmJhc2VGb250TmFtZX0sIGluc3RhbGxpbmcgaXQgY291bGQgaGVscCB0byBpbXByb3ZlIFBERiByZW5kZXJpbmcuYCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTmF0aXZlRm9udEZhY2UoZm9udEZhY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1bnJlYWNoYWJsZShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBmb250LmNyZWF0ZUZvbnRGYWNlUnVsZSgpO1xuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgICBpZiAodGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKHJlc29sdmUpO1xuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCgpIHtcbiAgICBjb25zdCBoYXNGb250cyA9ICEhdGhpcy5fZG9jdW1lbnQ/LmZvbnRzO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIGhhc0ZvbnRzKTtcbiAgfVxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsIGlzTm9kZUpTIHx8IHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICBhc3NlcnQoIXJlcXVlc3QuZG9uZSwgXCJjb21wbGV0ZVJlcXVlc3QoKSBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlLlwiKTtcbiAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG4gICAgICB3aGlsZSAobG9hZGluZ1JlcXVlc3RzLmxlbmd0aCA+IDAgJiYgbG9hZGluZ1JlcXVlc3RzWzBdLmRvbmUpIHtcbiAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gbG9hZGluZ1JlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbG9hZGluZ1JlcXVlc3RzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgY29tcGxldGU6IGNvbXBsZXRlUmVxdWVzdCxcbiAgICAgIGNhbGxiYWNrXG4gICAgfTtcbiAgICBsb2FkaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuICBnZXQgX2xvYWRUZXN0Rm9udCgpIHtcbiAgICBjb25zdCB0ZXN0Rm9udCA9IGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2xvYWRUZXN0Rm9udFwiLCB0ZXN0Rm9udCk7XG4gIH1cbiAgX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpIHtcbiAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0KSA8PCAyNCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA8PCAxNiB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAyKSA8PCA4IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDMpICYgMHhmZjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgIGNvbnN0IGNodW5rMSA9IHMuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG4gICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgcmV0dXJuIGNodW5rMSArIGluc2VydCArIGNodW5rMjtcbiAgICB9XG4gICAgbGV0IGksIGlpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gMTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGxldCBjYWxsZWQgPSAwO1xuICAgIGZ1bmN0aW9uIGlzRm9udFJlYWR5KG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoKytjYWxsZWQgPiAzMCkge1xuICAgICAgICB3YXJuKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCBzdHJpbmczMihjaGVja3N1bSkpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YTpmb250L29wZW50eXBlO2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG4gICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBbZm9udC5sb2FkZWROYW1lLCBsb2FkVGVzdEZvbnRJZF0pIHtcbiAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICBzcGFuLnN0eWxlLmZvbnRGYW1pbHkgPSBuYW1lO1xuICAgICAgZGl2LmFwcGVuZChzcGFuKTtcbiAgICB9XG4gICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICBpc0ZvbnRSZWFkeShsb2FkVGVzdEZvbnRJZCwgKCkgPT4ge1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gICNmb250RGF0YTtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIGluc3BlY3RGb250ID0gbnVsbCwgZXh0cmEsIGNoYXJQcm9jT3BlcmF0b3JMaXN0KSB7XG4gICAgdGhpcy5jb21waWxlZEdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy4jZm9udERhdGEgPSB0cmFuc2xhdGVkRGF0YTtcbiAgICB0aGlzLl9pbnNwZWN0Rm9udCA9IGluc3BlY3RGb250O1xuICAgIGlmIChleHRyYSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBleHRyYSk7XG4gICAgfVxuICAgIGlmIChjaGFyUHJvY09wZXJhdG9yTGlzdCkge1xuICAgICAgdGhpcy5jaGFyUHJvY09wZXJhdG9yTGlzdCA9IGNoYXJQcm9jT3BlcmF0b3JMaXN0O1xuICAgIH1cbiAgfVxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBuYXRpdmVGb250RmFjZTtcbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMubG9hZGVkTmFtZSwgdGhpcy5kYXRhLCB7fSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNzcyA9IHtcbiAgICAgICAgd2VpZ2h0OiB0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cbiAgICAgIG5hdGl2ZUZvbnRGYWNlID0gbmV3IEZvbnRGYWNlKHRoaXMuY3NzRm9udEluZm8uZm9udEZhbWlseSwgdGhpcy5kYXRhLCBjc3MpO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMpO1xuICAgIHJldHVybiBuYXRpdmVGb250RmFjZTtcbiAgfVxuICBjcmVhdGVGb250RmFjZVJ1bGUoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6JHt0aGlzLm1pbWV0eXBlfTtiYXNlNjQsJHt0b0Jhc2U2NFV0aWwodGhpcy5kYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmxvYWRlZE5hbWV9XCI7c3JjOiR7dXJsfX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY3NzID0gYGZvbnQtd2VpZ2h0OiAke3RoaXMuY3NzRm9udEluZm8uZm9udFdlaWdodH07YDtcbiAgICAgIGlmICh0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlKSB7XG4gICAgICAgIGNzcyArPSBgZm9udC1zdHlsZTogb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnO2A7XG4gICAgICB9XG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cbiAgICB0aGlzLl9pbnNwZWN0Rm9udD8uKHRoaXMsIHVybCk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgZ2V0UGF0aEdlbmVyYXRvcihvYmpzLCBjaGFyYWN0ZXIpIHtcbiAgICBpZiAodGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgfVxuICAgIGNvbnN0IG9iaklkID0gdGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3RlcjtcbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KG9iaklkKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgd2FybihgZ2V0UGF0aEdlbmVyYXRvciAtIGlnbm9yaW5nIGNoYXJhY3RlcjogXCIke2V4fVwiLmApO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gbWFrZVBhdGhGcm9tRHJhd09QUyhjbWRzKTtcbiAgICBpZiAoIXRoaXMuZm9udEV4dHJhUHJvcGVydGllcykge1xuICAgICAgb2Jqcy5kZWxldGUob2JqSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gcGF0aDtcbiAgfVxuICBnZXQgYmxhY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJsYWNrO1xuICB9XG4gIGdldCBib2xkKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5ib2xkO1xuICB9XG4gIGdldCBkaXNhYmxlRm9udEZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRpc2FibGVGb250RmFjZSA/PyBmYWxzZTtcbiAgfVxuICBzZXQgZGlzYWJsZUZvbnRGYWNlKHZhbHVlKSB7XG4gICAgc2hhZG93KHRoaXMsIFwiZGlzYWJsZUZvbnRGYWNlXCIsICEhdmFsdWUpO1xuICB9XG4gIGdldCBmb250RXh0cmFQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5mb250RXh0cmFQcm9wZXJ0aWVzID8/IGZhbHNlO1xuICB9XG4gIGdldCBpc0ludmFsaWRQREZqc0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmlzSW52YWxpZFBERmpzRm9udDtcbiAgfVxuICBnZXQgaXNUeXBlM0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmlzVHlwZTNGb250O1xuICB9XG4gIGdldCBpdGFsaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLml0YWxpYztcbiAgfVxuICBnZXQgbWlzc2luZ0ZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm1pc3NpbmdGaWxlO1xuICB9XG4gIGdldCByZW1lYXN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLnJlbWVhc3VyZTtcbiAgfVxuICBnZXQgdmVydGljYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLnZlcnRpY2FsO1xuICB9XG4gIGdldCBhc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmFzY2VudDtcbiAgfVxuICBnZXQgZGVmYXVsdFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZWZhdWx0V2lkdGg7XG4gIH1cbiAgZ2V0IGRlc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRlc2NlbnQ7XG4gIH1cbiAgZ2V0IGJib3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmJib3g7XG4gIH1cbiAgc2V0IGJib3goYmJveCkge1xuICAgIHNoYWRvdyh0aGlzLCBcImJib3hcIiwgYmJveCk7XG4gIH1cbiAgZ2V0IGZvbnRNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmZvbnRNYXRyaXg7XG4gIH1cbiAgZ2V0IGZhbGxiYWNrTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuZmFsbGJhY2tOYW1lO1xuICB9XG4gIGdldCBsb2FkZWROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5sb2FkZWROYW1lO1xuICB9XG4gIGdldCBtaW1ldHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEubWltZXR5cGU7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLm5hbWU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ZvbnREYXRhLmRhdGE7XG4gIH1cbiAgY2xlYXJEYXRhKCkge1xuICAgIHRoaXMuI2ZvbnREYXRhLmNsZWFyRGF0YSgpO1xuICB9XG4gIGdldCBjc3NGb250SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy4jZm9udERhdGEuY3NzRm9udEluZm87XG4gIH1cbiAgZ2V0IHN5c3RlbUZvbnRJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5zeXN0ZW1Gb250SW5mbztcbiAgfVxuICBnZXQgZGVmYXVsdFZNZXRyaWNzKCkge1xuICAgIHJldHVybiB0aGlzLiNmb250RGF0YS5kZWZhdWx0Vk1ldHJpY3M7XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9vYmotYmluLXRyYW5zZm9ybS5qc1xuXG5jbGFzcyBDc3NGb250SW5mbyB7XG4gICNidWZmZXI7XG4gICN2aWV3O1xuICAjZGVjb2RlcjtcbiAgc3RhdGljIHN0cmluZ3MgPSBbXCJmb250RmFtaWx5XCIsIFwiZm9udFdlaWdodFwiLCBcIml0YWxpY0FuZ2xlXCJdO1xuICBzdGF0aWMgd3JpdGUoaW5mbykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5ncyA9IHt9O1xuICAgIGxldCBzdHJpbmdzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgQ3NzRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKGluZm9bcHJvcF0pO1xuICAgICAgZW5jb2RlZFN0cmluZ3NbcHJvcF0gPSBlbmNvZGVkO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgZW5jb2RlZC5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzdHJpbmdzTGVuZ3RoKTtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIENzc0ZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVkU3RyaW5nc1twcm9wXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiQ3NzRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgICByZXR1cm4gYnVmZmVyO1xuICB9XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgIHRoaXMuI2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlcik7XG4gICAgdGhpcy4jZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gICNyZWFkU3RyaW5nKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgQ3NzRm9udEluZm8uc3RyaW5ncy5sZW5ndGgsIFwiSW52YWxpZCBzdHJpbmcgaW5kZXhcIik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KSArIDQ7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKSk7XG4gIH1cbiAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMCk7XG4gIH1cbiAgZ2V0IGZvbnRXZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMSk7XG4gIH1cbiAgZ2V0IGl0YWxpY0FuZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDIpO1xuICB9XG59XG5jbGFzcyBTeXN0ZW1Gb250SW5mbyB7XG4gICNidWZmZXI7XG4gICN2aWV3O1xuICAjZGVjb2RlcjtcbiAgc3RhdGljIHN0cmluZ3MgPSBbXCJjc3NcIiwgXCJsb2FkZWROYW1lXCIsIFwiYmFzZUZvbnROYW1lXCIsIFwic3JjXCJdO1xuICBzdGF0aWMgd3JpdGUoaW5mbykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICBjb25zdCBlbmNvZGVkU3RyaW5ncyA9IHt9O1xuICAgIGxldCBzdHJpbmdzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgU3lzdGVtRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZXIuZW5jb2RlKGluZm9bcHJvcF0pO1xuICAgICAgZW5jb2RlZFN0cmluZ3NbcHJvcF0gPSBlbmNvZGVkO1xuICAgICAgc3RyaW5nc0xlbmd0aCArPSA0ICsgZW5jb2RlZC5sZW5ndGg7XG4gICAgfVxuICAgIHN0cmluZ3NMZW5ndGggKz0gNDtcbiAgICBsZXQgZW5jb2RlZFN0eWxlU3R5bGUsXG4gICAgICBlbmNvZGVkU3R5bGVXZWlnaHQsXG4gICAgICBsZW5ndGhFc3RpbWF0ZSA9IDEgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGlmIChpbmZvLnN0eWxlKSB7XG4gICAgICBlbmNvZGVkU3R5bGVTdHlsZSA9IGVuY29kZXIuZW5jb2RlKGluZm8uc3R5bGUuc3R5bGUpO1xuICAgICAgZW5jb2RlZFN0eWxlV2VpZ2h0ID0gZW5jb2Rlci5lbmNvZGUoaW5mby5zdHlsZS53ZWlnaHQpO1xuICAgICAgbGVuZ3RoRXN0aW1hdGUgKz0gNCArIGVuY29kZWRTdHlsZVN0eWxlLmxlbmd0aCArIDQgKyBlbmNvZGVkU3R5bGVXZWlnaHQubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoRXN0aW1hdGUpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBpbmZvLmd1ZXNzRmFsbGJhY2sgPyAxIDogMCk7XG4gICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAwKTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBzdHJpbmdzTGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgU3lzdGVtRm9udEluZm8uc3RyaW5ncykge1xuICAgICAgY29uc3QgZW5jb2RlZCA9IGVuY29kZWRTdHJpbmdzW3Byb3BdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZW5jb2RlZC5sZW5ndGg7XG4gICAgICBzdHJpbmdzTGVuZ3RoICs9IDQgKyBsZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBkYXRhLnNldChlbmNvZGVkLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgbGVuZ3RoO1xuICAgIH1cbiAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgLSBzdHJpbmdzTGVuZ3RoIC0gNCwgc3RyaW5nc0xlbmd0aCk7XG4gICAgaWYgKGluZm8uc3R5bGUpIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgZW5jb2RlZFN0eWxlU3R5bGUubGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWRTdHlsZVN0eWxlLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgZW5jb2RlZFN0eWxlU3R5bGUubGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBlbmNvZGVkU3R5bGVXZWlnaHQubGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGVuY29kZWRTdHlsZVdlaWdodCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGVuY29kZWRTdHlsZVdlaWdodC5sZW5ndGg7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiU3Vic3RpdGlvbkluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgICByZXR1cm4gYnVmZmVyLnRyYW5zZmVyVG9GaXhlZExlbmd0aChvZmZzZXQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xuICAgIHRoaXMuI2J1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLiN2aWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuI2J1ZmZlcik7XG4gICAgdGhpcy4jZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICB9XG4gIGdldCBndWVzc0ZhbGxiYWNrKCkge1xuICAgIHJldHVybiB0aGlzLiN2aWV3LmdldFVpbnQ4KDApICE9PSAwO1xuICB9XG4gICNyZWFkU3RyaW5nKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgU3lzdGVtRm9udEluZm8uc3RyaW5ncy5sZW5ndGgsIFwiSW52YWxpZCBzdHJpbmcgaW5kZXhcIik7XG4gICAgbGV0IG9mZnNldCA9IDU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KSArIDQ7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgbGVuZ3RoKSk7XG4gIH1cbiAgZ2V0IGNzcygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygwKTtcbiAgfVxuICBnZXQgbG9hZGVkTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygxKTtcbiAgfVxuICBnZXQgYmFzZUZvbnROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkU3RyaW5nKDIpO1xuICB9XG4gIGdldCBzcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMyk7XG4gIH1cbiAgZ2V0IHN0eWxlKCkge1xuICAgIGxldCBvZmZzZXQgPSAxO1xuICAgIG9mZnNldCArPSA0ICsgdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBjb25zdCBzdHlsZUxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIHN0eWxlTGVuZ3RoKSk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHlsZUxlbmd0aDtcbiAgICBjb25zdCB3ZWlnaHRMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IHdlaWdodCA9IHRoaXMuI2RlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgd2VpZ2h0TGVuZ3RoKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlLFxuICAgICAgd2VpZ2h0XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgRm9udEluZm8ge1xuICBzdGF0aWMgYm9vbHMgPSBbXCJibGFja1wiLCBcImJvbGRcIiwgXCJkaXNhYmxlRm9udEZhY2VcIiwgXCJmb250RXh0cmFQcm9wZXJ0aWVzXCIsIFwiaXNJbnZhbGlkUERGanNGb250XCIsIFwiaXNUeXBlM0ZvbnRcIiwgXCJpdGFsaWNcIiwgXCJtaXNzaW5nRmlsZVwiLCBcInJlbWVhc3VyZVwiLCBcInZlcnRpY2FsXCJdO1xuICBzdGF0aWMgbnVtYmVycyA9IFtcImFzY2VudFwiLCBcImRlZmF1bHRXaWR0aFwiLCBcImRlc2NlbnRcIl07XG4gIHN0YXRpYyBzdHJpbmdzID0gW1wiZmFsbGJhY2tOYW1lXCIsIFwibG9hZGVkTmFtZVwiLCBcIm1pbWV0eXBlXCIsIFwibmFtZVwiXTtcbiAgc3RhdGljICNPRkZTRVRfTlVNQkVSUyA9IE1hdGguY2VpbCh0aGlzLmJvb2xzLmxlbmd0aCAqIDIgLyA4KTtcbiAgc3RhdGljICNPRkZTRVRfQkJPWCA9IHRoaXMuI09GRlNFVF9OVU1CRVJTICsgdGhpcy5udW1iZXJzLmxlbmd0aCAqIDg7XG4gIHN0YXRpYyAjT0ZGU0VUX0ZPTlRfTUFUUklYID0gdGhpcy4jT0ZGU0VUX0JCT1ggKyAxICsgMiAqIDQ7XG4gIHN0YXRpYyAjT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1MgPSB0aGlzLiNPRkZTRVRfRk9OVF9NQVRSSVggKyAxICsgOCAqIDY7XG4gIHN0YXRpYyAjT0ZGU0VUX1NUUklOR1MgPSB0aGlzLiNPRkZTRVRfREVGQVVMVF9WTUVUUklDUyArIDEgKyAyICogMztcbiAgI2J1ZmZlcjtcbiAgI2RlY29kZXI7XG4gICN2aWV3O1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBleHRyYVxuICB9KSB7XG4gICAgdGhpcy4jYnVmZmVyID0gZGF0YTtcbiAgICB0aGlzLiNkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgdGhpcy4jdmlldyA9IG5ldyBEYXRhVmlldyh0aGlzLiNidWZmZXIpO1xuICAgIGlmIChleHRyYSkge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBleHRyYSk7XG4gICAgfVxuICB9XG4gICNyZWFkQm9vbGVhbihpbmRleCkge1xuICAgIGFzc2VydChpbmRleCA8IEZvbnRJbmZvLmJvb2xzLmxlbmd0aCwgXCJJbnZhbGlkIGJvb2xlYW4gaW5kZXhcIik7XG4gICAgY29uc3QgYnl0ZU9mZnNldCA9IE1hdGguZmxvb3IoaW5kZXggLyA0KTtcbiAgICBjb25zdCBiaXRPZmZzZXQgPSBpbmRleCAqIDIgJSA4O1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmlldy5nZXRVaW50OChieXRlT2Zmc2V0KSA+PiBiaXRPZmZzZXQgJiAweDAzO1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMHgwMCA/IHVuZGVmaW5lZCA6IHZhbHVlID09PSAweDAyO1xuICB9XG4gIGdldCBibGFjaygpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oMCk7XG4gIH1cbiAgZ2V0IGJvbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDEpO1xuICB9XG4gIGdldCBkaXNhYmxlRm9udEZhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDIpO1xuICB9XG4gIGdldCBmb250RXh0cmFQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbigzKTtcbiAgfVxuICBnZXQgaXNJbnZhbGlkUERGanNGb250KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig0KTtcbiAgfVxuICBnZXQgaXNUeXBlM0ZvbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDUpO1xuICB9XG4gIGdldCBpdGFsaWMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRCb29sZWFuKDYpO1xuICB9XG4gIGdldCBtaXNzaW5nRmlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oNyk7XG4gIH1cbiAgZ2V0IHJlbWVhc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZEJvb2xlYW4oOCk7XG4gIH1cbiAgZ2V0IHZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkQm9vbGVhbig5KTtcbiAgfVxuICAjcmVhZE51bWJlcihpbmRleCkge1xuICAgIGFzc2VydChpbmRleCA8IEZvbnRJbmZvLm51bWJlcnMubGVuZ3RoLCBcIkludmFsaWQgbnVtYmVyIGluZGV4XCIpO1xuICAgIHJldHVybiB0aGlzLiN2aWV3LmdldEZsb2F0NjQoRm9udEluZm8uI09GRlNFVF9OVU1CRVJTICsgaW5kZXggKiA4KTtcbiAgfVxuICBnZXQgYXNjZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkTnVtYmVyKDApO1xuICB9XG4gIGdldCBkZWZhdWx0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWROdW1iZXIoMSk7XG4gIH1cbiAgZ2V0IGRlc2NlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWROdW1iZXIoMik7XG4gIH1cbiAgZ2V0IGJib3goKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfQkJPWDtcbiAgICBjb25zdCBudW1Db29yZHMgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KG9mZnNldCk7XG4gICAgaWYgKG51bUNvb3JkcyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgY29uc3QgYmJveCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICBiYm94LnB1c2godGhpcy4jdmlldy5nZXRJbnQxNihvZmZzZXQsIHRydWUpKTtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICBnZXQgZm9udE1hdHJpeCgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9GT05UX01BVFJJWDtcbiAgICBjb25zdCBudW1Qb2ludHMgPSB0aGlzLiN2aWV3LmdldFVpbnQ4KG9mZnNldCk7XG4gICAgaWYgKG51bVBvaW50cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2Zmc2V0ICs9IDE7XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBmb250TWF0cml4LnB1c2godGhpcy4jdmlldy5nZXRGbG9hdDY0KG9mZnNldCwgdHJ1ZSkpO1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgfVxuICAgIHJldHVybiBmb250TWF0cml4O1xuICB9XG4gIGdldCBkZWZhdWx0Vk1ldHJpY3MoKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfREVGQVVMVF9WTUVUUklDUztcbiAgICBjb25zdCBudW1NZXRyaWNzID0gdGhpcy4jdmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgIGlmIChudW1NZXRyaWNzID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvZmZzZXQgKz0gMTtcbiAgICBjb25zdCBkZWZhdWx0Vk1ldHJpY3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgZGVmYXVsdFZNZXRyaWNzLnB1c2godGhpcy4jdmlldy5nZXRJbnQxNihvZmZzZXQsIHRydWUpKTtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFZNZXRyaWNzO1xuICB9XG4gICNyZWFkU3RyaW5nKGluZGV4KSB7XG4gICAgYXNzZXJ0KGluZGV4IDwgRm9udEluZm8uc3RyaW5ncy5sZW5ndGgsIFwiSW52YWxpZCBzdHJpbmcgaW5kZXhcIik7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUyArIDQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgICBvZmZzZXQgKz0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KSArIDQ7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgY29uc3Qgc3RyaW5nRGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgc3RyaW5nRGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpKTtcbiAgICByZXR1cm4gdGhpcy4jZGVjb2Rlci5kZWNvZGUoc3RyaW5nRGF0YSk7XG4gIH1cbiAgZ2V0IGZhbGxiYWNrTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygwKTtcbiAgfVxuICBnZXQgbG9hZGVkTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jcmVhZFN0cmluZygxKTtcbiAgfVxuICBnZXQgbWltZXR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMik7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3JlYWRTdHJpbmcoMyk7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUztcbiAgICBjb25zdCBzdHJpbmdzTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN0cmluZ3NMZW5ndGg7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3lzdGVtRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgY3NzRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgY3NzRm9udEluZm9MZW5ndGg7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy4jYnVmZmVyLCBvZmZzZXQgKyA0LCBsZW5ndGgpO1xuICB9XG4gIGNsZWFyRGF0YSgpIHtcbiAgICBsZXQgb2Zmc2V0ID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTO1xuICAgIGNvbnN0IHN0cmluZ3NMZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0ICsgc3RyaW5nc0xlbmd0aDtcbiAgICBjb25zdCBzeXN0ZW1Gb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzeXN0ZW1Gb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBjc3NGb250SW5mb0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBjc3NGb250SW5mb0xlbmd0aDtcbiAgICBjb25zdCBsZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGxlbmd0aCk7XG4gICAgZGF0YS5maWxsKDApO1xuICAgIHRoaXMuI3ZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gIH1cbiAgZ2V0IGNzc0ZvbnRJbmZvKCkge1xuICAgIGxldCBvZmZzZXQgPSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1M7XG4gICAgY29uc3Qgc3RyaW5nc0xlbmd0aCA9IHRoaXMuI3ZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQgKyBzdHJpbmdzTGVuZ3RoO1xuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN5c3RlbUZvbnRJbmZvTGVuZ3RoO1xuICAgIGNvbnN0IGNzc0ZvbnRJbmZvTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBpZiAoY3NzRm9udEluZm9MZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBjc3NGb250SW5mb0RhdGEgPSBuZXcgVWludDhBcnJheShjc3NGb250SW5mb0xlbmd0aCk7XG4gICAgY3NzRm9udEluZm9EYXRhLnNldChuZXcgVWludDhBcnJheSh0aGlzLiNidWZmZXIsIG9mZnNldCArIDQsIGNzc0ZvbnRJbmZvTGVuZ3RoKSk7XG4gICAgcmV0dXJuIG5ldyBDc3NGb250SW5mbyhjc3NGb250SW5mb0RhdGEuYnVmZmVyKTtcbiAgfVxuICBnZXQgc3lzdGVtRm9udEluZm8oKSB7XG4gICAgbGV0IG9mZnNldCA9IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUztcbiAgICBjb25zdCBzdHJpbmdzTGVuZ3RoID0gdGhpcy4jdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNCArIHN0cmluZ3NMZW5ndGg7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9MZW5ndGggPSB0aGlzLiN2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgIGlmIChzeXN0ZW1Gb250SW5mb0xlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHN5c3RlbUZvbnRJbmZvRGF0YSA9IG5ldyBVaW50OEFycmF5KHN5c3RlbUZvbnRJbmZvTGVuZ3RoKTtcbiAgICBzeXN0ZW1Gb250SW5mb0RhdGEuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuI2J1ZmZlciwgb2Zmc2V0ICsgNCwgc3lzdGVtRm9udEluZm9MZW5ndGgpKTtcbiAgICByZXR1cm4gbmV3IFN5c3RlbUZvbnRJbmZvKHN5c3RlbUZvbnRJbmZvRGF0YS5idWZmZXIpO1xuICB9XG4gIHN0YXRpYyB3cml0ZShmb250KSB7XG4gICAgY29uc3Qgc3lzdGVtRm9udEluZm9CdWZmZXIgPSBmb250LnN5c3RlbUZvbnRJbmZvID8gU3lzdGVtRm9udEluZm8ud3JpdGUoZm9udC5zeXN0ZW1Gb250SW5mbykgOiBudWxsO1xuICAgIGNvbnN0IGNzc0ZvbnRJbmZvQnVmZmVyID0gZm9udC5jc3NGb250SW5mbyA/IENzc0ZvbnRJbmZvLndyaXRlKGZvbnQuY3NzRm9udEluZm8pIDogbnVsbDtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3QgZW5jb2RlZFN0cmluZ3MgPSB7fTtcbiAgICBsZXQgc3RyaW5nc0xlbmd0aCA9IDA7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIEZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGVuY29kZWRTdHJpbmdzW3Byb3BdID0gZW5jb2Rlci5lbmNvZGUoZm9udFtwcm9wXSk7XG4gICAgICBzdHJpbmdzTGVuZ3RoICs9IDQgKyBlbmNvZGVkU3RyaW5nc1twcm9wXS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aEVzdGltYXRlID0gRm9udEluZm8uI09GRlNFVF9TVFJJTkdTICsgNCArIHN0cmluZ3NMZW5ndGggKyA0ICsgKHN5c3RlbUZvbnRJbmZvQnVmZmVyID8gc3lzdGVtRm9udEluZm9CdWZmZXIuYnl0ZUxlbmd0aCA6IDApICsgNCArIChjc3NGb250SW5mb0J1ZmZlciA/IGNzc0ZvbnRJbmZvQnVmZmVyLmJ5dGVMZW5ndGggOiAwKSArIDQgKyAoZm9udC5kYXRhID8gZm9udC5kYXRhLmxlbmd0aCA6IDApO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGhFc3RpbWF0ZSk7XG4gICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IG51bUJvb2xzID0gRm9udEluZm8uYm9vbHMubGVuZ3RoO1xuICAgIGxldCBib29sQnl0ZSA9IDAsXG4gICAgICBib29sQml0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJvb2xzOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZm9udFtGb250SW5mby5ib29sc1tpXV07XG4gICAgICBjb25zdCBiaXRzID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IDB4MDAgOiB2YWx1ZSA/IDB4MDIgOiAweDAxO1xuICAgICAgYm9vbEJ5dGUgfD0gYml0cyA8PCBib29sQml0O1xuICAgICAgYm9vbEJpdCArPSAyO1xuICAgICAgaWYgKGJvb2xCaXQgPT09IDggfHwgaSA9PT0gbnVtQm9vbHMgLSAxKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGJvb2xCeXRlKTtcbiAgICAgICAgYm9vbEJ5dGUgPSAwO1xuICAgICAgICBib29sQml0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9OVU1CRVJTLCBcIkZvbnRJbmZvLndyaXRlOiBCb29sZWFuIHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBGb250SW5mby5udW1iZXJzKSB7XG4gICAgICB2aWV3LnNldEZsb2F0NjQob2Zmc2V0LCBmb250W3Byb3BdKTtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX0JCT1gsIFwiRm9udEluZm8ud3JpdGU6IE51bWJlciBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICBpZiAoZm9udC5iYm94KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCA0KTtcbiAgICAgIGZvciAoY29uc3QgY29vcmQgb2YgZm9udC5iYm94KSB7XG4gICAgICAgIHZpZXcuc2V0SW50MTYob2Zmc2V0LCBjb29yZCwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAwKTtcbiAgICAgIG9mZnNldCArPSAyICogNDtcbiAgICB9XG4gICAgYXNzZXJ0KG9mZnNldCA9PT0gRm9udEluZm8uI09GRlNFVF9GT05UX01BVFJJWCwgXCJGb250SW5mby53cml0ZTogQkJveCBwcm9wZXJ0aWVzIG9mZnNldCBtaXNtYXRjaFwiKTtcbiAgICBpZiAoZm9udC5mb250TWF0cml4KSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCA2KTtcbiAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZm9udC5mb250TWF0cml4KSB7XG4gICAgICAgIHZpZXcuc2V0RmxvYXQ2NChvZmZzZXQsIHBvaW50LCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIDApO1xuICAgICAgb2Zmc2V0ICs9IDggKiA2O1xuICAgIH1cbiAgICBhc3NlcnQob2Zmc2V0ID09PSBGb250SW5mby4jT0ZGU0VUX0RFRkFVTFRfVk1FVFJJQ1MsIFwiRm9udEluZm8ud3JpdGU6IEZvbnRNYXRyaXggcHJvcGVydGllcyBvZmZzZXQgbWlzbWF0Y2hcIik7XG4gICAgaWYgKGZvbnQuZGVmYXVsdFZNZXRyaWNzKSB7XG4gICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAxKTtcbiAgICAgIGZvciAoY29uc3QgbWV0cmljIG9mIGZvbnQuZGVmYXVsdFZNZXRyaWNzKSB7XG4gICAgICAgIHZpZXcuc2V0SW50MTYob2Zmc2V0LCBtZXRyaWMsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgMCk7XG4gICAgICBvZmZzZXQgKz0gMyAqIDI7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPT09IEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUywgXCJGb250SW5mby53cml0ZTogRGVmYXVsdFZNZXRyaWNzIHByb3BlcnRpZXMgb2Zmc2V0IG1pc21hdGNoXCIpO1xuICAgIHZpZXcuc2V0VWludDMyKEZvbnRJbmZvLiNPRkZTRVRfU1RSSU5HUywgMCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgZm9yIChjb25zdCBwcm9wIG9mIEZvbnRJbmZvLnN0cmluZ3MpIHtcbiAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVkU3RyaW5nc1twcm9wXTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgZGF0YS5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGxlbmd0aDtcbiAgICB9XG4gICAgdmlldy5zZXRVaW50MzIoRm9udEluZm8uI09GRlNFVF9TVFJJTkdTLCBvZmZzZXQgLSBGb250SW5mby4jT0ZGU0VUX1NUUklOR1MgLSA0KTtcbiAgICBpZiAoIXN5c3RlbUZvbnRJbmZvQnVmZmVyKSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IHN5c3RlbUZvbnRJbmZvQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBhc3NlcnQob2Zmc2V0ICsgNCArIGxlbmd0aCA8PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJGb250SW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93IGF0IHN5c3RlbUZvbnRJbmZvXCIpO1xuICAgICAgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoc3lzdGVtRm9udEluZm9CdWZmZXIpLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoIWNzc0ZvbnRJbmZvQnVmZmVyKSB7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIDApO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNzc0ZvbnRJbmZvQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBhc3NlcnQob2Zmc2V0ICsgNCArIGxlbmd0aCA8PSBidWZmZXIuYnl0ZUxlbmd0aCwgXCJGb250SW5mby53cml0ZTogQnVmZmVyIG92ZXJmbG93IGF0IGNzc0ZvbnRJbmZvXCIpO1xuICAgICAgZGF0YS5zZXQobmV3IFVpbnQ4QXJyYXkoY3NzRm9udEluZm9CdWZmZXIpLCBvZmZzZXQgKyA0KTtcbiAgICAgIG9mZnNldCArPSA0ICsgbGVuZ3RoO1xuICAgIH1cbiAgICBpZiAoZm9udC5kYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMCk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCBmb250LmRhdGEubGVuZ3RoKTtcbiAgICAgIGRhdGEuc2V0KGZvbnQuZGF0YSwgb2Zmc2V0ICsgNCk7XG4gICAgICBvZmZzZXQgKz0gNCArIGZvbnQuZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGFzc2VydChvZmZzZXQgPD0gYnVmZmVyLmJ5dGVMZW5ndGgsIFwiRm9udEluZm8ud3JpdGU6IEJ1ZmZlciBvdmVyZmxvd1wiKTtcbiAgICByZXR1cm4gYnVmZmVyLnRyYW5zZmVyVG9GaXhlZExlbmd0aChvZmZzZXQpO1xuICB9XG59XG5jbGFzcyBQYXR0ZXJuSW5mbyB7XG4gIHN0YXRpYyAjS0lORCA9IDA7XG4gIHN0YXRpYyAjSEFTX0JCT1ggPSAxO1xuICBzdGF0aWMgI0hBU19CQUNLR1JPVU5EID0gMjtcbiAgc3RhdGljICNTSEFESU5HX1RZUEUgPSAzO1xuICBzdGF0aWMgI05fQ09PUkQgPSA0O1xuICBzdGF0aWMgI05fQ09MT1IgPSA4O1xuICBzdGF0aWMgI05fU1RPUCA9IDEyO1xuICBzdGF0aWMgI05fRklHVVJFUyA9IDE2O1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICB9XG4gIHN0YXRpYyB3cml0ZShpcikge1xuICAgIGxldCBraW5kLFxuICAgICAgYmJveCA9IG51bGwsXG4gICAgICBjb29yZHMgPSBbXSxcbiAgICAgIGNvbG9ycyA9IFtdLFxuICAgICAgY29sb3JTdG9wcyA9IFtdLFxuICAgICAgZmlndXJlcyA9IFtdLFxuICAgICAgc2hhZGluZ1R5cGUgPSBudWxsLFxuICAgICAgYmFja2dyb3VuZCA9IG51bGw7XG4gICAgc3dpdGNoIChpclswXSkge1xuICAgICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICAgIGtpbmQgPSBpclsxXSA9PT0gXCJheGlhbFwiID8gMSA6IDI7XG4gICAgICAgIGJib3ggPSBpclsyXTtcbiAgICAgICAgY29sb3JTdG9wcyA9IGlyWzNdO1xuICAgICAgICBpZiAoa2luZCA9PT0gMSkge1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKC4uLmlyWzRdLCAuLi5pcls1XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29vcmRzLnB1c2goaXJbNF1bMF0sIGlyWzRdWzFdLCBpcls2XSwgaXJbNV1bMF0sIGlyWzVdWzFdLCBpcls3XSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICBraW5kID0gMztcbiAgICAgICAgc2hhZGluZ1R5cGUgPSBpclsxXTtcbiAgICAgICAgY29vcmRzID0gaXJbMl07XG4gICAgICAgIGNvbG9ycyA9IGlyWzNdO1xuICAgICAgICBmaWd1cmVzID0gaXJbNF0gfHwgW107XG4gICAgICAgIGJib3ggPSBpcls2XTtcbiAgICAgICAgYmFja2dyb3VuZCA9IGlyWzddO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0dGVybiB0eXBlOiAke2lyWzBdfWApO1xuICAgIH1cbiAgICBjb25zdCBuQ29vcmQgPSBNYXRoLmZsb29yKGNvb3Jkcy5sZW5ndGggLyAyKTtcbiAgICBjb25zdCBuQ29sb3IgPSBNYXRoLmZsb29yKGNvbG9ycy5sZW5ndGggLyAzKTtcbiAgICBjb25zdCBuU3RvcCA9IGNvbG9yU3RvcHMubGVuZ3RoO1xuICAgIGNvbnN0IG5GaWd1cmVzID0gZmlndXJlcy5sZW5ndGg7XG4gICAgbGV0IGZpZ3VyZXNTaXplID0gMDtcbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiBmaWd1cmVzKSB7XG4gICAgICBmaWd1cmVzU2l6ZSArPSAxO1xuICAgICAgZmlndXJlc1NpemUgPSBNYXRoLmNlaWwoZmlndXJlc1NpemUgLyA0KSAqIDQ7XG4gICAgICBmaWd1cmVzU2l6ZSArPSA0ICsgZmlndXJlLmNvb3Jkcy5sZW5ndGggKiA0O1xuICAgICAgZmlndXJlc1NpemUgKz0gNCArIGZpZ3VyZS5jb2xvcnMubGVuZ3RoICogNDtcbiAgICAgIGlmIChmaWd1cmUudmVydGljZXNQZXJSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWd1cmVzU2l6ZSArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBieXRlTGVuID0gMjAgKyBuQ29vcmQgKiA4ICsgbkNvbG9yICogMyArIG5TdG9wICogOCArIChiYm94ID8gMTYgOiAwKSArIChiYWNrZ3JvdW5kID8gMyA6IDApICsgZmlndXJlc1NpemU7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW4pO1xuICAgIGNvbnN0IGRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgY29uc3QgdThkYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBkYXRhVmlldy5zZXRVaW50OChQYXR0ZXJuSW5mby4jS0lORCwga2luZCk7XG4gICAgZGF0YVZpZXcuc2V0VWludDgoUGF0dGVybkluZm8uI0hBU19CQk9YLCBiYm94ID8gMSA6IDApO1xuICAgIGRhdGFWaWV3LnNldFVpbnQ4KFBhdHRlcm5JbmZvLiNIQVNfQkFDS0dST1VORCwgYmFja2dyb3VuZCA/IDEgOiAwKTtcbiAgICBkYXRhVmlldy5zZXRVaW50OChQYXR0ZXJuSW5mby4jU0hBRElOR19UWVBFLCBzaGFkaW5nVHlwZSk7XG4gICAgZGF0YVZpZXcuc2V0VWludDMyKFBhdHRlcm5JbmZvLiNOX0NPT1JELCBuQ29vcmQsIHRydWUpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMihQYXR0ZXJuSW5mby4jTl9DT0xPUiwgbkNvbG9yLCB0cnVlKTtcbiAgICBkYXRhVmlldy5zZXRVaW50MzIoUGF0dGVybkluZm8uI05fU1RPUCwgblN0b3AsIHRydWUpO1xuICAgIGRhdGFWaWV3LnNldFVpbnQzMihQYXR0ZXJuSW5mby4jTl9GSUdVUkVTLCBuRmlndXJlcywgdHJ1ZSk7XG4gICAgbGV0IG9mZnNldCA9IDIwO1xuICAgIGNvbnN0IGNvb3Jkc1ZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBuQ29vcmQgKiAyKTtcbiAgICBjb29yZHNWaWV3LnNldChjb29yZHMpO1xuICAgIG9mZnNldCArPSBuQ29vcmQgKiA4O1xuICAgIHU4ZGF0YS5zZXQoY29sb3JzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBuQ29sb3IgKiAzO1xuICAgIGZvciAoY29uc3QgW3BvcywgaGV4XSBvZiBjb2xvclN0b3BzKSB7XG4gICAgICBkYXRhVmlldy5zZXRGbG9hdDMyKG9mZnNldCwgcG9zLCB0cnVlKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKG9mZnNldCwgcGFyc2VJbnQoaGV4LnNsaWNlKDEpLCAxNiksIHRydWUpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuICAgIGlmIChiYm94KSB7XG4gICAgICBmb3IgKGNvbnN0IHYgb2YgYmJveCkge1xuICAgICAgICBkYXRhVmlldy5zZXRGbG9hdDMyKG9mZnNldCwgdiwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFja2dyb3VuZCkge1xuICAgICAgdThkYXRhLnNldChiYWNrZ3JvdW5kLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlndXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZmlndXJlID0gZmlndXJlc1tpXTtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQ4KG9mZnNldCwgZmlndXJlLnR5cGUpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gNCkgKiA0O1xuICAgICAgZGF0YVZpZXcuc2V0VWludDMyKG9mZnNldCwgZmlndXJlLmNvb3Jkcy5sZW5ndGgsIHRydWUpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCBmaWd1cmVDb29yZHNWaWV3ID0gbmV3IEludDMyQXJyYXkoYnVmZmVyLCBvZmZzZXQsIGZpZ3VyZS5jb29yZHMubGVuZ3RoKTtcbiAgICAgIGZpZ3VyZUNvb3Jkc1ZpZXcuc2V0KGZpZ3VyZS5jb29yZHMpO1xuICAgICAgb2Zmc2V0ICs9IGZpZ3VyZS5jb29yZHMubGVuZ3RoICogNDtcbiAgICAgIGRhdGFWaWV3LnNldFVpbnQzMihvZmZzZXQsIGZpZ3VyZS5jb2xvcnMubGVuZ3RoLCB0cnVlKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgY29uc3QgY29sb3JzVmlldyA9IG5ldyBJbnQzMkFycmF5KGJ1ZmZlciwgb2Zmc2V0LCBmaWd1cmUuY29sb3JzLmxlbmd0aCk7XG4gICAgICBjb2xvcnNWaWV3LnNldChmaWd1cmUuY29sb3JzKTtcbiAgICAgIG9mZnNldCArPSBmaWd1cmUuY29sb3JzLmxlbmd0aCAqIDQ7XG4gICAgICBpZiAoZmlndXJlLnZlcnRpY2VzUGVyUm93ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGF0YVZpZXcuc2V0VWludDMyKG9mZnNldCwgZmlndXJlLnZlcnRpY2VzUGVyUm93LCB0cnVlKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG4gIH1cbiAgZ2V0SVIoKSB7XG4gICAgY29uc3QgZGF0YVZpZXcgPSB0aGlzLnZpZXc7XG4gICAgY29uc3Qga2luZCA9IHRoaXMuZGF0YVtQYXR0ZXJuSW5mby4jS0lORF07XG4gICAgY29uc3QgaGFzQkJveCA9ICEhdGhpcy5kYXRhW1BhdHRlcm5JbmZvLiNIQVNfQkJPWF07XG4gICAgY29uc3QgaGFzQmFja2dyb3VuZCA9ICEhdGhpcy5kYXRhW1BhdHRlcm5JbmZvLiNIQVNfQkFDS0dST1VORF07XG4gICAgY29uc3QgbkNvb3JkID0gZGF0YVZpZXcuZ2V0VWludDMyKFBhdHRlcm5JbmZvLiNOX0NPT1JELCB0cnVlKTtcbiAgICBjb25zdCBuQ29sb3IgPSBkYXRhVmlldy5nZXRVaW50MzIoUGF0dGVybkluZm8uI05fQ09MT1IsIHRydWUpO1xuICAgIGNvbnN0IG5TdG9wID0gZGF0YVZpZXcuZ2V0VWludDMyKFBhdHRlcm5JbmZvLiNOX1NUT1AsIHRydWUpO1xuICAgIGNvbnN0IG5GaWd1cmVzID0gZGF0YVZpZXcuZ2V0VWludDMyKFBhdHRlcm5JbmZvLiNOX0ZJR1VSRVMsIHRydWUpO1xuICAgIGxldCBvZmZzZXQgPSAyMDtcbiAgICBjb25zdCBjb29yZHMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuYnVmZmVyLCBvZmZzZXQsIG5Db29yZCAqIDIpO1xuICAgIG9mZnNldCArPSBuQ29vcmQgKiA4O1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCBvZmZzZXQsIG5Db2xvciAqIDMpO1xuICAgIG9mZnNldCArPSBuQ29sb3IgKiAzO1xuICAgIGNvbnN0IHN0b3BzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuU3RvcDsgKytpKSB7XG4gICAgICBjb25zdCBwID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCByZ2IgPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0LCB0cnVlKTtcbiAgICAgIG9mZnNldCArPSA0O1xuICAgICAgc3RvcHMucHVzaChbcCwgYCMke3JnYi50b1N0cmluZygxNikucGFkU3RhcnQoNiwgXCIwXCIpfWBdKTtcbiAgICB9XG4gICAgbGV0IGJib3ggPSBudWxsO1xuICAgIGlmIChoYXNCQm94KSB7XG4gICAgICBiYm94ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgICBiYm94LnB1c2goZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQsIHRydWUpKTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBiYWNrZ3JvdW5kID0gbnVsbDtcbiAgICBpZiAoaGFzQmFja2dyb3VuZCkge1xuICAgICAgYmFja2dyb3VuZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuYnVmZmVyLCBvZmZzZXQsIDMpO1xuICAgICAgb2Zmc2V0ICs9IDM7XG4gICAgfVxuICAgIGNvbnN0IGZpZ3VyZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5GaWd1cmVzOyArK2kpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICBvZmZzZXQgPSBNYXRoLmNlaWwob2Zmc2V0IC8gNCkgKiA0O1xuICAgICAgY29uc3QgY29vcmRzTGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIGNvbnN0IGZpZ3VyZUNvb3JkcyA9IG5ldyBJbnQzMkFycmF5KHRoaXMuYnVmZmVyLCBvZmZzZXQsIGNvb3Jkc0xlbmd0aCk7XG4gICAgICBvZmZzZXQgKz0gY29vcmRzTGVuZ3RoICogNDtcbiAgICAgIGNvbnN0IGNvbG9yc0xlbmd0aCA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgICBjb25zdCBmaWd1cmVDb2xvcnMgPSBuZXcgSW50MzJBcnJheSh0aGlzLmJ1ZmZlciwgb2Zmc2V0LCBjb2xvcnNMZW5ndGgpO1xuICAgICAgb2Zmc2V0ICs9IGNvbG9yc0xlbmd0aCAqIDQ7XG4gICAgICBjb25zdCBmaWd1cmUgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNvb3JkczogZmlndXJlQ29vcmRzLFxuICAgICAgICBjb2xvcnM6IGZpZ3VyZUNvbG9yc1xuICAgICAgfTtcbiAgICAgIGlmICh0eXBlID09PSBNZXNoRmlndXJlVHlwZS5MQVRUSUNFKSB7XG4gICAgICAgIGZpZ3VyZS52ZXJ0aWNlc1BlclJvdyA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgIH1cbiAgICAgIGZpZ3VyZXMucHVzaChmaWd1cmUpO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gMSkge1xuICAgICAgcmV0dXJuIFtcIlJhZGlhbEF4aWFsXCIsIFwiYXhpYWxcIiwgYmJveCwgc3RvcHMsIEFycmF5LmZyb20oY29vcmRzLnNsaWNlKDAsIDIpKSwgQXJyYXkuZnJvbShjb29yZHMuc2xpY2UoMiwgNCkpLCBudWxsLCBudWxsXTtcbiAgICB9XG4gICAgaWYgKGtpbmQgPT09IDIpIHtcbiAgICAgIHJldHVybiBbXCJSYWRpYWxBeGlhbFwiLCBcInJhZGlhbFwiLCBiYm94LCBzdG9wcywgW2Nvb3Jkc1swXSwgY29vcmRzWzFdXSwgW2Nvb3Jkc1szXSwgY29vcmRzWzRdXSwgY29vcmRzWzJdLCBjb29yZHNbNV1dO1xuICAgIH1cbiAgICBpZiAoa2luZCA9PT0gMykge1xuICAgICAgY29uc3Qgc2hhZGluZ1R5cGUgPSB0aGlzLmRhdGFbUGF0dGVybkluZm8uI1NIQURJTkdfVFlQRV07XG4gICAgICBsZXQgYm91bmRzID0gbnVsbDtcbiAgICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgbWluWCA9IGNvb3Jkc1swXSxcbiAgICAgICAgICBtYXhYID0gY29vcmRzWzBdO1xuICAgICAgICBsZXQgbWluWSA9IGNvb3Jkc1sxXSxcbiAgICAgICAgICBtYXhZID0gY29vcmRzWzFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbaV0sXG4gICAgICAgICAgICB5ID0gY29vcmRzW2kgKyAxXTtcbiAgICAgICAgICBtaW5YID0gbWluWCA+IHggPyB4IDogbWluWDtcbiAgICAgICAgICBtaW5ZID0gbWluWSA+IHkgPyB5IDogbWluWTtcbiAgICAgICAgICBtYXhYID0gbWF4WCA8IHggPyB4IDogbWF4WDtcbiAgICAgICAgICBtYXhZID0gbWF4WSA8IHkgPyB5IDogbWF4WTtcbiAgICAgICAgfVxuICAgICAgICBib3VuZHMgPSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW1wiTWVzaFwiLCBzaGFkaW5nVHlwZSwgY29vcmRzLCBjb2xvcnMsIGZpZ3VyZXMsIGJvdW5kcywgYmJveCwgYmFja2dyb3VuZF07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGF0dGVybiBraW5kOiAke2tpbmR9YCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYXBpX3V0aWxzLmpzXG5cbmZ1bmN0aW9uIGdldFVybFByb3AodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICByZXR1cm4gdmFsLmhyZWY7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IFVSTC5wYXJzZSh2YWwsIHdpbmRvdy5sb2NhdGlvbik7XG4gICAgaWYgKHVybCkge1xuICAgICAgcmV0dXJuIHVybC5ocmVmO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzdHJpbmdUb0J5dGVzKHZhbCk7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpIHx8IHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgIWlzTmFOKHZhbD8ubGVuZ3RoKSkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUERGIGJpbmFyeSBkYXRhOiBlaXRoZXIgVHlwZWRBcnJheSwgXCIgKyBcInN0cmluZywgb3IgYXJyYXktbGlrZSBvYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIGRhdGEgcHJvcGVydHkuXCIpO1xufVxuZnVuY3Rpb24gZ2V0RmFjdG9yeVVybFByb3AodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHZhbC5lbmRzV2l0aChcIi9cIikpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmYWN0b3J5IHVybDogXCIke3ZhbH1cIiBtdXN0IGluY2x1ZGUgdHJhaWxpbmcgc2xhc2guYCk7XG59XG5jb25zdCBpc1JlZlByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/Lm51bSkgJiYgdi5udW0gPj0gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKHY/LmdlbikgJiYgdi5nZW4gPj0gMDtcbmNvbnN0IGlzTmFtZVByb3h5ID0gdiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdj8ubmFtZSA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IGlzVmFsaWRFeHBsaWNpdERlc3QgPSBfaXNWYWxpZEV4cGxpY2l0RGVzdC5iaW5kKG51bGwsIGlzUmVmUHJveHksIGlzTmFtZVByb3h5KTtcbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gICNsaXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICNkZWZlcnJlZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVyKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBkYXRhOiBzdHJ1Y3R1cmVkQ2xvbmUob2JqLCB0cmFuc2ZlciA/IHtcbiAgICAgICAgdHJhbnNmZXJcbiAgICAgIH0gOiBudWxsKVxuICAgIH07XG4gICAgdGhpcy4jZGVmZXJyZWQudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtsaXN0ZW5lcl0gb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgbGV0IHJtQWJvcnQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zPy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHdhcm4oXCJMb29wYmFja1BvcnQgLSBjYW5ub3QgdXNlIGFuIGBhYm9ydGVkYCBzaWduYWwuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvbkFib3J0ID0gKCkgPT4gdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIHJtQWJvcnQgPSAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICB9XG4gICAgdGhpcy4jbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgcm1BYm9ydCk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHJtQWJvcnQgPSB0aGlzLiNsaXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcbiAgICBybUFib3J0Py4oKTtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgfVxuICB0ZXJtaW5hdGUoKSB7XG4gICAgZm9yIChjb25zdCBbLCBybUFib3J0XSBvZiB0aGlzLiNsaXN0ZW5lcnMpIHtcbiAgICAgIHJtQWJvcnQ/LigpO1xuICAgIH1cbiAgICB0aGlzLiNsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvc2hhcmVkL21lc3NhZ2VfaGFuZGxlci5qc1xuXG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiBvbkZuKCkge31cbmZ1bmN0aW9uIHdyYXBSZWFzb24oZXgpIHtcbiAgaWYgKGV4IGluc3RhbmNlb2YgQWJvcnRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBJbnZhbGlkUERGRXhjZXB0aW9uIHx8IGV4IGluc3RhbmNlb2YgUGFzc3dvcmRFeGNlcHRpb24gfHwgZXggaW5zdGFuY2VvZiBSZXNwb25zZUV4Y2VwdGlvbiB8fCBleCBpbnN0YW5jZW9mIFVua25vd25FcnJvckV4Y2VwdGlvbikge1xuICAgIHJldHVybiBleDtcbiAgfVxuICBpZiAoIShleCBpbnN0YW5jZW9mIEVycm9yIHx8IHR5cGVvZiBleCA9PT0gXCJvYmplY3RcIiAmJiBleCAhPT0gbnVsbCkpIHtcbiAgICB1bnJlYWNoYWJsZSgnd3JhcFJlYXNvbjogRXhwZWN0ZWQgXCJyZWFzb25cIiB0byBiZSBhIChwb3NzaWJseSBjbG9uZWQpIEVycm9yLicpO1xuICB9XG4gIHN3aXRjaCAoZXgubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBBYm9ydEV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICBjYXNlIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBQYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICBjYXNlIFwiUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzLCBleC5taXNzaW5nKTtcbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5kZXRhaWxzKTtcbiAgfVxuICByZXR1cm4gbmV3IFVua25vd25FcnJvckV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC50b1N0cmluZygpKTtcbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgI21lc3NhZ2VBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy4jb25NZXNzYWdlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbDogdGhpcy4jbWVzc2FnZUFDLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gICNvbk1lc3NhZ2Uoe1xuICAgIGRhdGFcbiAgfSkge1xuICAgIGlmIChkYXRhLnRhcmdldE5hbWUgIT09IHRoaXMuc291cmNlTmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIHRoaXMuI3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YS5jYWxsYmFjaykge1xuICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgIGNvbnN0IGNhcGFiaWxpdHkgPSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5FUlJPUikge1xuICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNhbGxiYWNrIGNhc2VcIik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBhY3Rpb24gZnJvbSB3b3JrZXI6ICR7ZGF0YS5hY3Rpb259YCk7XG4gICAgfVxuICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFjdGlvbihkYXRhLmRhdGEpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgIGFzc2VydChyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJjYW5jZWwgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBjb25zdCBjYW5jZWxDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNhbmNlbENhbGwgPSBjYW5jZWxDYXBhYmlsaXR5O1xuICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYW5jZWxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwgcXVldWVpbmdTdHJhdGVneSk7XG4gIH1cbiAgI2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMsXG4gICAgICBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuICAgIGNvbnN0IHN0cmVhbVNpbmsgPSB7XG4gICAgICBlbnF1ZXVlKGNodW5rLCBzaXplID0gMSwgdHJhbnNmZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhc3REZXNpcmVkU2l6ZSA9IHRoaXMuZGVzaXJlZFNpemU7XG4gICAgICAgIHRoaXMuZGVzaXJlZFNpemUgLT0gc2l6ZTtcbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgICAgIHRoaXMucmVhZHkgPSB0aGlzLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG4gICAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DTE9TRSxcbiAgICAgICAgICBzdHJlYW1JZFxuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHNlbGYuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgfSxcbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICBhc3NlcnQocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiZXJyb3IgbXVzdCBoYXZlIGEgdmFsaWQgcmVhc29uXCIpO1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHNpbmtDYXBhYmlsaXR5OiBQcm9taXNlLndpdGhSZXNvbHZlcnMoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgUHJvbWlzZS50cnkoYWN0aW9uLCBkYXRhLmRhdGEsIHN0cmVhbVNpbmspLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gICNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzdHJlYW1Db250cm9sbGVyID0gdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sXG4gICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgc3dpdGNoIChkYXRhLnN0cmVhbSkge1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1TaW5rLmRlc2lyZWRTaXplID0gZGF0YS5kZXNpcmVkU2l6ZTtcbiAgICAgICAgUHJvbWlzZS50cnkoc3RyZWFtU2luay5vblB1bGwgfHwgb25GbikudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgYXNzZXJ0KHN0cmVhbUNvbnRyb2xsZXIsIFwiZW5xdWV1ZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgaWYgKHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgIGFzc2VydChzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICBhc3NlcnQoc3RyZWFtQ29udHJvbGxlciwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YVJlYXNvbiA9IHdyYXBSZWFzb24oZGF0YS5yZWFzb24pO1xuICAgICAgICBQcm9taXNlLnRyeShzdHJlYW1TaW5rLm9uQ2FuY2VsIHx8IG9uRm4sIGRhdGFSZWFzb24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdChkYXRhUmVhc29uKTtcbiAgICAgICAgc3RyZWFtU2luay5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHN0cmVhbSBjYXNlXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGw/LnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbD8ucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI21lc3NhZ2VBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNtZXNzYWdlQUMgPSBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NhbnZhc19mYWN0b3J5LmpzXG5cbmNsYXNzIEJhc2VDYW52YXNGYWN0b3J5IHtcbiAgI2VuYWJsZUhXQSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZW5hYmxlSFdBID0gZmFsc2VcbiAgfSkge1xuICAgIHRoaXMuI2VuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgfVxuICBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQ6IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLiNlbmFibGVIV0FcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICBlbmFibGVIV0EgPSBmYWxzZVxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZW5hYmxlSFdBXG4gICAgfSk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2NtYXBfcmVhZGVyX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVybCA9IG51bGwsXG4gICAgaXNDb21wcmVzc2VkID0gdHJ1ZVxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgY01hcFVybGAgYW5kIGBjTWFwUGFja2VkYCBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNNYXAgbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoKHVybCkudGhlbihjTWFwRGF0YSA9PiAoe1xuICAgICAgY01hcERhdGEsXG4gICAgICBpc0NvbXByZXNzZWQ6IHRoaXMuaXNDb21wcmVzc2VkXG4gICAgfSkpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkICR7dGhpcy5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCJ9Q01hcCBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCB0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYXJyYXlidWZmZXJcIiA6IFwidGV4dFwiKTtcbiAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IFVpbnQ4QXJyYXkoZGF0YSkgOiBzdHJpbmdUb0J5dGVzKGRhdGEpO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2ZpbHRlcl9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRIQ01GaWx0ZXIoZmdDb2xvciwgYmdDb2xvcikge1xuICAgIHJldHVybiBcIm5vbmVcIjtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICByZXR1cm4gXCJub25lXCI7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHt9XG59XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgQmFzZUZpbHRlckZhY3Rvcnkge1xuICAjYmFzZVVybDtcbiAgI19jYWNoZTtcbiAgI19kZWZzO1xuICAjZG9jSWQ7XG4gICNkb2N1bWVudDtcbiAgI19oY21DYWNoZTtcbiAgI2lkID0gMDtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI2RvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy4jZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIGdldCAjY2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19jYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjaGNtQ2FjaGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI19oY21DYWNoZSB8fD0gbmV3IE1hcCgpO1xuICB9XG4gIGdldCAjZGVmcygpIHtcbiAgICBpZiAoIXRoaXMuI19kZWZzKSB7XG4gICAgICBjb25zdCBkaXYgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHlsZVxuICAgICAgfSA9IGRpdjtcbiAgICAgIHN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgc3R5bGUuY29udGFpbiA9IFwic3RyaWN0XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHN0eWxlLmhlaWdodCA9IDA7XG4gICAgICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIHN0eWxlLnRvcCA9IHN0eWxlLmxlZnQgPSAwO1xuICAgICAgc3R5bGUuekluZGV4ID0gLTE7XG4gICAgICBjb25zdCBzdmcgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcInN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCAwKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgICB0aGlzLiNfZGVmcyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZGVmc1wiKTtcbiAgICAgIGRpdi5hcHBlbmQoc3ZnKTtcbiAgICAgIHN2Zy5hcHBlbmQodGhpcy4jX2RlZnMpO1xuICAgICAgdGhpcy4jZG9jdW1lbnQuYm9keS5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI19kZWZzO1xuICB9XG4gICNjcmVhdGVUYWJsZXMobWFwcykge1xuICAgIGlmIChtYXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgbWFwUiA9IG1hcHNbMF07XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgYnVmZmVyW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIFt0YWJsZSwgdGFibGUsIHRhYmxlXTtcbiAgICB9XG4gICAgY29uc3QgW21hcFIsIG1hcEcsIG1hcEJdID0gbWFwcztcbiAgICBjb25zdCBidWZmZXJSID0gbmV3IEFycmF5KDI1Nik7XG4gICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgIGNvbnN0IGJ1ZmZlckIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgIGJ1ZmZlckdbaV0gPSBtYXBHW2ldIC8gMjU1O1xuICAgICAgYnVmZmVyQltpXSA9IG1hcEJbaV0gLyAyNTU7XG4gICAgfVxuICAgIHJldHVybiBbYnVmZmVyUi5qb2luKFwiLFwiKSwgYnVmZmVyRy5qb2luKFwiLFwiKSwgYnVmZmVyQi5qb2luKFwiLFwiKV07XG4gIH1cbiAgI2NyZWF0ZVVybChpZCkge1xuICAgIGlmICh0aGlzLiNiYXNlVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuI2Jhc2VVcmwgPSBcIlwiO1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jZG9jdW1lbnQuVVJMO1xuICAgICAgaWYgKHVybCAhPT0gdGhpcy4jZG9jdW1lbnQuYmFzZVVSSSkge1xuICAgICAgICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAgICAgICB3YXJuKCcjY3JlYXRlVXJsOiBpZ25vcmUgXCJkYXRhOlwiLVVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNiYXNlVXJsID0gdXBkYXRlVXJsSGFzaCh1cmwsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBgdXJsKCR7dGhpcy4jYmFzZVVybH0jJHtpZH0pYDtcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IFt0YWJsZVIsIHRhYmxlRywgdGFibGVCXSA9IHRoaXMuI2NyZWF0ZVRhYmxlcyhtYXBzKTtcbiAgICBjb25zdCBrZXkgPSBtYXBzLmxlbmd0aCA9PT0gMSA/IHRhYmxlUiA6IGAke3RhYmxlUn0ke3RhYmxlR30ke3RhYmxlQn1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgY29uc3QgZmlsdGVyTmFtZSA9IFwiYmFzZVwiO1xuICAgIGxldCBpbmZvID0gdGhpcy4jaGNtQ2FjaGUuZ2V0KGZpbHRlck5hbWUpO1xuICAgIGlmIChpbmZvPy5rZXkgPT09IGtleSkge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBpZiAoaW5mbykge1xuICAgICAgaW5mby5maWx0ZXI/LnJlbW92ZSgpO1xuICAgICAgaW5mby5rZXkgPSBrZXk7XG4gICAgICBpbmZvLnVybCA9IFwibm9uZVwiO1xuICAgICAgaW5mby5maWx0ZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmZvID0ge1xuICAgICAgICBrZXksXG4gICAgICAgIHVybDogXCJub25lXCIsXG4gICAgICAgIGZpbHRlcjogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuI2hjbUNhY2hlLnNldChmaWx0ZXJOYW1lLCBpbmZvKTtcbiAgICB9XG4gICAgaWYgKCFmZ0NvbG9yIHx8ICFiZ0NvbG9yKSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IFV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIGluZm8udXJsO1xuICAgIH1cbiAgICBjb25zdCBtYXAgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAyNTU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IGkgLyAyNTU7XG4gICAgICBtYXBbaV0gPSB4IDw9IDAuMDM5MjggPyB4IC8gMTIuOTIgOiAoKHggKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICAgIH1cbiAgICBjb25zdCB0YWJsZSA9IG1hcC5qb2luKFwiLFwiKTtcbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2hjbV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGUsIHRhYmxlLCB0YWJsZSwgZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIGNvbnN0IGdldFN0ZXBzID0gKGMsIG4pID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gZmdSR0JbY10gLyAyNTU7XG4gICAgICBjb25zdCBlbmQgPSBiZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gc3RhcnQgKyBpIC8gbiAqIChlbmQgLSBzdGFydCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKGdldFN0ZXBzKDAsIDUpLCBnZXRTdGVwcygxLCA1KSwgZ2V0U3RlcHMoMiwgNSksIGZpbHRlcik7XG4gICAgaW5mby51cmwgPSB0aGlzLiNjcmVhdGVVcmwoaWQpO1xuICAgIHJldHVybiBpbmZvLnVybDtcbiAgfVxuICBhZGRBbHBoYUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlQV0gPSB0aGlzLiNjcmVhdGVUYWJsZXMoW21hcF0pO1xuICAgIGNvbnN0IGtleSA9IGBhbHBoYV8ke3RhYmxlQX1gO1xuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1fYWxwaGFfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24odGFibGVBLCBmaWx0ZXIpO1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkTHVtaW5vc2l0eUZpbHRlcihtYXApIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwIHx8IFwibHVtaW5vc2l0eVwiKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IHRhYmxlQSwga2V5O1xuICAgIGlmIChtYXApIHtcbiAgICAgIFt0YWJsZUFdID0gdGhpcy4jY3JlYXRlVGFibGVzKFttYXBdKTtcbiAgICAgIGtleSA9IGBsdW1pbm9zaXR5XyR7dGFibGVBfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwibHVtaW5vc2l0eVwiO1xuICAgIH1cbiAgICB2YWx1ZSA9IHRoaXMuI2NhY2hlLmdldChrZXkpO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X2x1bWlub3NpdHlfbWFwXyR7dGhpcy4jaWQrK31gO1xuICAgIGNvbnN0IHVybCA9IHRoaXMuI2NyZWF0ZVVybChpZCk7XG4gICAgdGhpcy4jY2FjaGUuc2V0KG1hcCwgdXJsKTtcbiAgICB0aGlzLiNjYWNoZS5zZXQoa2V5LCB1cmwpO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkTHVtaW5vc2l0eUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICBpZiAobWFwKSB7XG4gICAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcEFscGhhQ29udmVyc2lvbih0YWJsZUEsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZpbHRlck5hbWUsIGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgbGV0IGluZm8gPSB0aGlzLiNoY21DYWNoZS5nZXQoZmlsdGVyTmFtZSk7XG4gICAgaWYgKGluZm8/LmtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gaW5mby51cmw7XG4gICAgfVxuICAgIGlmIChpbmZvKSB7XG4gICAgICBpbmZvLmZpbHRlcj8ucmVtb3ZlKCk7XG4gICAgICBpbmZvLmtleSA9IGtleTtcbiAgICAgIGluZm8udXJsID0gXCJub25lXCI7XG4gICAgICBpbmZvLmZpbHRlciA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gPSB7XG4gICAgICAgIGtleSxcbiAgICAgICAgdXJsOiBcIm5vbmVcIixcbiAgICAgICAgZmlsdGVyOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy4jaGNtQ2FjaGUuc2V0KGZpbHRlck5hbWUsIGluZm8pO1xuICAgIH1cbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiBpbmZvLnVybDtcbiAgICB9XG4gICAgY29uc3QgW2ZnUkdCLCBiZ1JHQl0gPSBbZmdDb2xvciwgYmdDb2xvcl0ubWFwKHRoaXMuI2dldFJHQi5iaW5kKHRoaXMpKTtcbiAgICBsZXQgZmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBmZ1JHQlswXSArIDAuNzE1MiAqIGZnUkdCWzFdICsgMC4wNzIyICogZmdSR0JbMl0pO1xuICAgIGxldCBiZ0dyYXkgPSBNYXRoLnJvdW5kKDAuMjEyNiAqIGJnUkdCWzBdICsgMC43MTUyICogYmdSR0JbMV0gKyAwLjA3MjIgKiBiZ1JHQlsyXSk7XG4gICAgbGV0IFtuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW25ld0ZnQ29sb3IsIG5ld0JnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgaWYgKGJnR3JheSA8IGZnR3JheSkge1xuICAgICAgW2ZnR3JheSwgYmdHcmF5LCBuZXdGZ1JHQiwgbmV3QmdSR0JdID0gW2JnR3JheSwgZmdHcmF5LCBuZXdCZ1JHQiwgbmV3RmdSR0JdO1xuICAgIH1cbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBjb25zdCBnZXRTdGVwcyA9IChmZywgYmcsIG4pID0+IHtcbiAgICAgIGNvbnN0IGFyciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3Qgc3RlcCA9IChiZ0dyYXkgLSBmZ0dyYXkpIC8gbjtcbiAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gZmcgLyAyNTU7XG4gICAgICBjb25zdCBuZXdTdGVwID0gKGJnIC0gZmcpIC8gKDI1NSAqIG4pO1xuICAgICAgbGV0IHByZXYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGsgPSBNYXRoLnJvdW5kKGZnR3JheSArIGkgKiBzdGVwKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuZXdTdGFydCArIGkgKiBuZXdTdGVwO1xuICAgICAgICBmb3IgKGxldCBqID0gcHJldjsgaiA8PSBrOyBqKyspIHtcbiAgICAgICAgICBhcnJbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gayArIDE7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gcHJldjsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFycltwcmV2IC0gMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyLmpvaW4oXCIsXCIpO1xuICAgIH07XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fJHtmaWx0ZXJOYW1lfV9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IGluZm8uZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRHcmF5Q29udmVyc2lvbihmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbihnZXRTdGVwcyhuZXdGZ1JHQlswXSwgbmV3QmdSR0JbMF0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsxXSwgbmV3QmdSR0JbMV0sIDUpLCBnZXRTdGVwcyhuZXdGZ1JHQlsyXSwgbmV3QmdSR0JbMl0sIDUpLCBmaWx0ZXIpO1xuICAgIGluZm8udXJsID0gdGhpcy4jY3JlYXRlVXJsKGlkKTtcbiAgICByZXR1cm4gaW5mby51cmw7XG4gIH1cbiAgZGVzdHJveShrZWVwSENNID0gZmFsc2UpIHtcbiAgICBpZiAoa2VlcEhDTSAmJiB0aGlzLiNfaGNtQ2FjaGU/LnNpemUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jX2RlZnM/LnBhcmVudE5vZGUucGFyZW50Tm9kZS5yZW1vdmUoKTtcbiAgICB0aGlzLiNfZGVmcyA9IG51bGw7XG4gICAgdGhpcy4jX2NhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jX2hjbUNhY2hlPy5jbGVhcigpO1xuICAgIHRoaXMuI19oY21DYWNoZSA9IG51bGw7XG4gICAgdGhpcy4jaWQgPSAwO1xuICB9XG4gICNhZGRMdW1pbm9zaXR5Q29udmVyc2lvbihmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbG9yTWF0cml4ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbG9yTWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcIm1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInZhbHVlc1wiLCBcIjAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAuMyAwLjU5IDAuMTEgMCAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29sb3JNYXRyaXggPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29sb3JNYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwibWF0cml4XCIpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKFwidmFsdWVzXCIsIFwiMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMCAwIDAgMSAwXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb2xvck1hdHJpeCk7XG4gIH1cbiAgI2NyZWF0ZUZpbHRlcihpZCkge1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmlsdGVyXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIiwgXCJzUkdCXCIpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgdGhpcy4jZGVmcy5hcHBlbmQoZmlsdGVyKTtcbiAgICByZXR1cm4gZmlsdGVyO1xuICB9XG4gICNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgZnVuYywgdGFibGUpIHtcbiAgICBjb25zdCBmZUZ1bmMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBmdW5jKTtcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImRpc2NyZXRlXCIpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0YWJsZVZhbHVlc1wiLCB0YWJsZSk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmQoZmVGdW5jKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBDb252ZXJzaW9uKHJUYWJsZSwgZ1RhYmxlLCBiVGFibGUsIGZpbHRlcikge1xuICAgIGNvbnN0IGZlQ29tcG9uZW50VHJhbnNmZXIgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImZlQ29tcG9uZW50VHJhbnNmZXJcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNSXCIsIHJUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jR1wiLCBnVGFibGUpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY0JcIiwgYlRhYmxlKTtcbiAgfVxuICAjYWRkVHJhbnNmZXJNYXBBbHBoYUNvbnZlcnNpb24oYVRhYmxlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCBmZUNvbXBvbmVudFRyYW5zZmVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIpO1xuICAgIGZpbHRlci5hcHBlbmQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQVwiLCBhVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3RhbmRhcmRfZm9udGRhdGFfZmFjdG9yeS5qc1xuXG5cbmNsYXNzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaCh7XG4gICAgZmlsZW5hbWVcbiAgfSkge1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbnN1cmUgdGhhdCB0aGUgYHN0YW5kYXJkRm9udERhdGFVcmxgIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIWZpbGVuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb250IGZpbGVuYW1lIG11c3QgYmUgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2godXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIEJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgXCJhcnJheWJ1ZmZlclwiKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvd2FzbV9mYWN0b3J5LmpzXG5cblxuY2xhc3MgQmFzZVdhc21GYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG4gIGFzeW5jIGZldGNoKHtcbiAgICBmaWxlbmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmJhc2VVcmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuc3VyZSB0aGF0IHRoZSBgd2FzbVVybGAgQVBJIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldhc20gZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaCh1cmwpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBsb2FkIHdhc20gZGF0YSBhdDogJHt1cmx9YCk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfZmV0Y2hgIGNhbGxlZC5cIik7XG4gIH1cbn1cbmNsYXNzIERPTVdhc21GYWN0b3J5IGV4dGVuZHMgQmFzZVdhc21GYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBmZXRjaERhdGEodXJsLCBcImFycmF5YnVmZmVyXCIpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9ub2RlX3V0aWxzLmpzXG5cblxuXG5cblxuXG5pZiAoaXNOb2RlSlMpIHtcbiAgd2FybihcIlBsZWFzZSB1c2UgdGhlIGBsZWdhY3lgIGJ1aWxkIGluIE5vZGUuanMgZW52aXJvbm1lbnRzLlwiKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCkge1xuICBjb25zdCBmcyA9IHByb2Nlc3MuZ2V0QnVpbHRpbk1vZHVsZShcImZzXCIpO1xuICBjb25zdCBkYXRhID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUodXJsKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGRhdGEpO1xufVxuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBCYXNlRmlsdGVyRmFjdG9yeSB7fVxuY2xhc3MgTm9kZUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlcXVpcmUgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJtb2R1bGVcIikuY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHJlcXVpcmUoXCJAbmFwaS1ycy9jYW52YXNcIik7XG4gICAgcmV0dXJuIGNhbnZhcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH1cbn1cbmNsYXNzIE5vZGVDTWFwUmVhZGVyRmFjdG9yeSBleHRlbmRzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGFzeW5jIF9mZXRjaCh1cmwpIHtcbiAgICByZXR1cm4gbm9kZV91dGlsc19mZXRjaERhdGEodXJsKTtcbiAgfVxufVxuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgYXN5bmMgX2ZldGNoKHVybCkge1xuICAgIHJldHVybiBub2RlX3V0aWxzX2ZldGNoRGF0YSh1cmwpO1xuICB9XG59XG5jbGFzcyBOb2RlV2FzbUZhY3RvcnkgZXh0ZW5kcyBCYXNlV2FzbUZhY3Rvcnkge1xuICBhc3luYyBfZmV0Y2godXJsKSB7XG4gICAgcmV0dXJuIG5vZGVfdXRpbHNfZmV0Y2hEYXRhKHVybCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvY2FudmFzX2RlcGVuZGVuY3lfdHJhY2tlci5qc1xuXG5jb25zdCBGT1JDRURfREVQRU5ERU5DWV9MQUJFTCA9IFwiX19mb3JjZWREZXBlbmRlbmN5XCI7XG5jb25zdCB7XG4gIGZsb29yLFxuICBjZWlsXG59ID0gTWF0aDtcbmZ1bmN0aW9uIGV4cGFuZEJCb3goYXJyYXksIGluZGV4LCBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKSB7XG4gIGFycmF5W2luZGV4ICogNCArIDBdID0gTWF0aC5taW4oYXJyYXlbaW5kZXggKiA0ICsgMF0sIG1pblgpO1xuICBhcnJheVtpbmRleCAqIDQgKyAxXSA9IE1hdGgubWluKGFycmF5W2luZGV4ICogNCArIDFdLCBtaW5ZKTtcbiAgYXJyYXlbaW5kZXggKiA0ICsgMl0gPSBNYXRoLm1heChhcnJheVtpbmRleCAqIDQgKyAyXSwgbWF4WCk7XG4gIGFycmF5W2luZGV4ICogNCArIDNdID0gTWF0aC5tYXgoYXJyYXlbaW5kZXggKiA0ICsgM10sIG1heFkpO1xufVxuY29uc3QgRU1QVFlfQkJPWCA9IG5ldyBVaW50MzJBcnJheShuZXcgVWludDhBcnJheShbMjU1LCAyNTUsIDAsIDBdKS5idWZmZXIpWzBdO1xuY2xhc3MgQkJveFJlYWRlciB7XG4gICNiYm94ZXM7XG4gICNjb29yZHM7XG4gIGNvbnN0cnVjdG9yKGJib3hlcywgY29vcmRzKSB7XG4gICAgdGhpcy4jYmJveGVzID0gYmJveGVzO1xuICAgIHRoaXMuI2Nvb3JkcyA9IGNvb3JkcztcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94ZXMubGVuZ3RoO1xuICB9XG4gIGlzRW1wdHkoaSkge1xuICAgIHJldHVybiB0aGlzLiNiYm94ZXNbaV0gPT09IEVNUFRZX0JCT1g7XG4gIH1cbiAgbWluWChpKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Nvb3Jkc1tpICogNCArIDBdIC8gMjU2O1xuICB9XG4gIG1pblkoaSkge1xuICAgIHJldHVybiB0aGlzLiNjb29yZHNbaSAqIDQgKyAxXSAvIDI1NjtcbiAgfVxuICBtYXhYKGkpIHtcbiAgICByZXR1cm4gKHRoaXMuI2Nvb3Jkc1tpICogNCArIDJdICsgMSkgLyAyNTY7XG4gIH1cbiAgbWF4WShpKSB7XG4gICAgcmV0dXJuICh0aGlzLiNjb29yZHNbaSAqIDQgKyAzXSArIDEpIC8gMjU2O1xuICB9XG59XG5jb25zdCBlbnN1cmVEZWJ1Z01ldGFkYXRhID0gKG1hcCwga2V5KSA9PiB7XG4gIGlmICghbWFwKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgdmFsdWUgPSBtYXAuZ2V0KGtleSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICB2YWx1ZSA9IHtcbiAgICAgIGRlcGVuZGVuY2llczogbmV3IFNldCgpLFxuICAgICAgaXNSZW5kZXJpbmdPcGVyYXRpb246IGZhbHNlXG4gICAgfTtcbiAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBDYW52YXNEZXBlbmRlbmN5VHJhY2tlciB7XG4gICNzaW1wbGUgPSB7XG4gICAgX19wcm90b19fOiBudWxsXG4gIH07XG4gICNpbmNyZW1lbnRhbCA9IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgdHJhbnNmb3JtOiBbXSxcbiAgICBtb3ZlVGV4dDogW10sXG4gICAgc2FtZUxpbmVUZXh0OiBbXSxcbiAgICBbRk9SQ0VEX0RFUEVOREVOQ1lfTEFCRUxdOiBbXVxuICB9O1xuICAjbmFtZWREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKCk7XG4gICNzYXZlc1N0YWNrID0gW107XG4gICNtYXJrZWRDb250ZW50U3RhY2sgPSBbXTtcbiAgI2Jhc2VUcmFuc2Zvcm1TdGFjayA9IFtbMSwgMCwgMCwgMSwgMCwgMF1dO1xuICAjY2xpcEJveCA9IFstSW5maW5pdHksIC1JbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XTtcbiAgI3BlbmRpbmdCQm94ID0gbmV3IEZsb2F0NjRBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAjcGVuZGluZ0JCb3hJZHggPSAtMTtcbiAgI3BlbmRpbmdEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICNvcGVyYXRpb25zID0gbmV3IE1hcCgpO1xuICAjZm9udEJCb3hUcnVzdHdvcnRoeSA9IG5ldyBNYXAoKTtcbiAgI2NhbnZhc1dpZHRoO1xuICAjY2FudmFzSGVpZ2h0O1xuICAjYmJveGVzQ29vcmRzO1xuICAjYmJveGVzO1xuICAjZGVidWdNZXRhZGF0YTtcbiAgY29uc3RydWN0b3IoY2FudmFzLCBvcGVyYXRpb25zQ291bnQsIHJlY29yZERlYnVnTWV0YWRhdGEgPSBmYWxzZSkge1xuICAgIHRoaXMuI2NhbnZhc1dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHRoaXMuI2NhbnZhc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgdGhpcy4jaW5pdGlhbGl6ZUJCb3hlcyhvcGVyYXRpb25zQ291bnQpO1xuICAgIGlmIChyZWNvcmREZWJ1Z01ldGFkYXRhKSB7XG4gICAgICB0aGlzLiNkZWJ1Z01ldGFkYXRhID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgfVxuICBncm93T3BlcmF0aW9uc0NvdW50KG9wZXJhdGlvbnNDb3VudCkge1xuICAgIGlmIChvcGVyYXRpb25zQ291bnQgPj0gdGhpcy4jYmJveGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy4jaW5pdGlhbGl6ZUJCb3hlcyhvcGVyYXRpb25zQ291bnQsIHRoaXMuI2Jib3hlcyk7XG4gICAgfVxuICB9XG4gICNpbml0aWFsaXplQkJveGVzKG9wZXJhdGlvbnNDb3VudCwgb2xkQkJveGVzKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG9wZXJhdGlvbnNDb3VudCAqIDQpO1xuICAgIHRoaXMuI2Jib3hlc0Nvb3JkcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShidWZmZXIpO1xuICAgIHRoaXMuI2Jib3hlcyA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgIGlmIChvbGRCQm94ZXMgJiYgb2xkQkJveGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuI2Jib3hlcy5zZXQob2xkQkJveGVzKTtcbiAgICAgIHRoaXMuI2Jib3hlcy5maWxsKEVNUFRZX0JCT1gsIG9sZEJCb3hlcy5sZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNiYm94ZXMuZmlsbChFTVBUWV9CQk9YKTtcbiAgICB9XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIHRoaXMuI3NpbXBsZSA9IHtcbiAgICAgIF9fcHJvdG9fXzogdGhpcy4jc2ltcGxlXG4gICAgfTtcbiAgICB0aGlzLiNpbmNyZW1lbnRhbCA9IHtcbiAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwsXG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgX19wcm90b19fOiB0aGlzLiNpbmNyZW1lbnRhbC50cmFuc2Zvcm1cbiAgICAgIH0sXG4gICAgICBtb3ZlVGV4dDoge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsLm1vdmVUZXh0XG4gICAgICB9LFxuICAgICAgc2FtZUxpbmVUZXh0OiB7XG4gICAgICAgIF9fcHJvdG9fXzogdGhpcy4jaW5jcmVtZW50YWwuc2FtZUxpbmVUZXh0XG4gICAgICB9LFxuICAgICAgW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXToge1xuICAgICAgICBfX3Byb3RvX186IHRoaXMuI2luY3JlbWVudGFsW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy4jY2xpcEJveCA9IHtcbiAgICAgIF9fcHJvdG9fXzogdGhpcy4jY2xpcEJveFxuICAgIH07XG4gICAgdGhpcy4jc2F2ZXNTdGFjay5wdXNoKG9wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXN0b3JlKG9wSWR4KSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy4jc2ltcGxlKTtcbiAgICBpZiAocHJldmlvdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGlzLiNzaW1wbGUgPSBwcmV2aW91cztcbiAgICB0aGlzLiNpbmNyZW1lbnRhbCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNpbmNyZW1lbnRhbCk7XG4gICAgdGhpcy4jY2xpcEJveCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzLiNjbGlwQm94KTtcbiAgICBjb25zdCBsYXN0U2F2ZSA9IHRoaXMuI3NhdmVzU3RhY2sucG9wKCk7XG4gICAgaWYgKGxhc3RTYXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuc3VyZURlYnVnTWV0YWRhdGEodGhpcy4jZGVidWdNZXRhZGF0YSwgb3BJZHgpPy5kZXBlbmRlbmNpZXMuYWRkKGxhc3RTYXZlKTtcbiAgICAgIHRoaXMuI2Jib3hlc1tvcElkeF0gPSB0aGlzLiNiYm94ZXNbbGFzdFNhdmVdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVuTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI3NhdmVzU3RhY2sucHVzaChpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldE9wZW5NYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuI3NhdmVzU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI3NhdmVzU3RhY2suYXQoLTEpO1xuICB9XG4gIHJlY29yZENsb3NlTWFya2VyKG9wSWR4KSB7XG4gICAgY29uc3QgbGFzdFNhdmUgPSB0aGlzLiNzYXZlc1N0YWNrLnBvcCgpO1xuICAgIGlmIChsYXN0U2F2ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBlbnN1cmVEZWJ1Z01ldGFkYXRhKHRoaXMuI2RlYnVnTWV0YWRhdGEsIG9wSWR4KT8uZGVwZW5kZW5jaWVzLmFkZChsYXN0U2F2ZSk7XG4gICAgICB0aGlzLiNiYm94ZXNbb3BJZHhdID0gdGhpcy4jYmJveGVzW2xhc3RTYXZlXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgdGhpcy4jbWFya2VkQ29udGVudFN0YWNrLnB1c2gob3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICBjb25zdCBsYXN0U2F2ZSA9IHRoaXMuI21hcmtlZENvbnRlbnRTdGFjay5wb3AoKTtcbiAgICBpZiAobGFzdFNhdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5zdXJlRGVidWdNZXRhZGF0YSh0aGlzLiNkZWJ1Z01ldGFkYXRhLCBvcElkeCk/LmRlcGVuZGVuY2llcy5hZGQobGFzdFNhdmUpO1xuICAgICAgdGhpcy4jYmJveGVzW29wSWR4XSA9IHRoaXMuI2Jib3hlc1tsYXN0U2F2ZV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHB1c2hCYXNlVHJhbnNmb3JtKGN0eCkge1xuICAgIHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKFV0aWwubXVsdGlwbHlCeURPTU1hdHJpeCh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2suYXQoLTEpLCBjdHguZ2V0VHJhbnNmb3JtKCkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwb3BCYXNlVHJhbnNmb3JtKCkge1xuICAgIGlmICh0aGlzLiNiYXNlVHJhbnNmb3JtU3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI3NpbXBsZVtuYW1lXSA9IGlkeDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jaW5jcmVtZW50YWxbbmFtZV0ucHVzaChpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2V0SW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2luY3JlbWVudGFsW25hbWVdLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkTmFtZWREYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLnNldChuYW1lLCBpZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGFGcm9tTmFtZWQobmFtZSwgZGVwTmFtZSwgZmFsbGJhY2tJZHgpIHtcbiAgICB0aGlzLiNzaW1wbGVbbmFtZV0gPSB0aGlzLiNuYW1lZERlcGVuZGVuY2llcy5nZXQoZGVwTmFtZSkgPz8gZmFsbGJhY2tJZHg7XG4gIH1cbiAgcmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLnJlY29yZEluY3JlbWVudGFsRGF0YShGT1JDRURfREVQRU5ERU5DWV9MQUJFTCwgaWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKG5hbWVzKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG5hbWVzKSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLiNzaW1wbGUpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIHRoaXMuI3NpbXBsZVtuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcykge1xuICAgICAgdGhpcy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KEZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMLCBkZXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldEJCb3goaWR4KSB7XG4gICAgaWYgKHRoaXMuI3BlbmRpbmdCQm94SWR4ICE9PSBpZHgpIHtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94SWR4ID0gaWR4O1xuICAgICAgdGhpcy4jcGVuZGluZ0JCb3hbMF0gPSBJbmZpbml0eTtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94WzFdID0gSW5maW5pdHk7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveFsyXSA9IC1JbmZpbml0eTtcbiAgICAgIHRoaXMuI3BlbmRpbmdCQm94WzNdID0gLUluZmluaXR5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDbGlwQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gVXRpbC5tdWx0aXBseUJ5RE9NTWF0cml4KHRoaXMuI2Jhc2VUcmFuc2Zvcm1TdGFjay5hdCgtMSksIGN0eC5nZXRUcmFuc2Zvcm0oKSk7XG4gICAgY29uc3QgY2xpcEJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCBjbGlwQm94KTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBVdGlsLmludGVyc2VjdCh0aGlzLiNjbGlwQm94LCBjbGlwQm94KTtcbiAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gaW50ZXJzZWN0aW9uWzBdO1xuICAgICAgdGhpcy4jY2xpcEJveFsxXSA9IGludGVyc2VjdGlvblsxXTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMl0gPSBpbnRlcnNlY3Rpb25bMl07XG4gICAgICB0aGlzLiNjbGlwQm94WzNdID0gaW50ZXJzZWN0aW9uWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNjbGlwQm94WzBdID0gdGhpcy4jY2xpcEJveFsxXSA9IEluZmluaXR5O1xuICAgICAgdGhpcy4jY2xpcEJveFsyXSA9IHRoaXMuI2NsaXBCb3hbM10gPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEJCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBjb25zdCBjbGlwQm94ID0gdGhpcy4jY2xpcEJveDtcbiAgICBpZiAoY2xpcEJveFswXSA9PT0gSW5maW5pdHkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBVdGlsLm11bHRpcGx5QnlET01NYXRyaXgodGhpcy4jYmFzZVRyYW5zZm9ybVN0YWNrLmF0KC0xKSwgY3R4LmdldFRyYW5zZm9ybSgpKTtcbiAgICBpZiAoY2xpcEJveFswXSA9PT0gLUluZmluaXR5KSB7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCB0aGlzLiNwZW5kaW5nQkJveCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgYmJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSwgdHJhbnNmb3JtLCBiYm94KTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFswXSA9IE1hdGgubWluKHRoaXMuI3BlbmRpbmdCQm94WzBdLCBNYXRoLm1heChiYm94WzBdLCBjbGlwQm94WzBdKSk7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMV0gPSBNYXRoLm1pbih0aGlzLiNwZW5kaW5nQkJveFsxXSwgTWF0aC5tYXgoYmJveFsxXSwgY2xpcEJveFsxXSkpO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gTWF0aC5tYXgodGhpcy4jcGVuZGluZ0JCb3hbMl0sIE1hdGgubWluKGJib3hbMl0sIGNsaXBCb3hbMl0pKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFszXSA9IE1hdGgubWF4KHRoaXMuI3BlbmRpbmdCQm94WzNdLCBNYXRoLm1pbihiYm94WzNdLCBjbGlwQm94WzNdKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2hhcmFjdGVyQkJveChpZHgsIGN0eCwgZm9udCwgc2NhbGUgPSAxLCB4ID0gMCwgeSA9IDAsIGdldE1lYXN1cmUpIHtcbiAgICBjb25zdCBmb250QkJveCA9IGZvbnQuYmJveDtcbiAgICBsZXQgaXNCQm94VHJ1c3R3b3J0aHk7XG4gICAgbGV0IGNvbXB1dGVkQkJveDtcbiAgICBpZiAoZm9udEJCb3gpIHtcbiAgICAgIGlzQkJveFRydXN0d29ydGh5ID0gZm9udEJCb3hbMl0gIT09IGZvbnRCQm94WzBdICYmIGZvbnRCQm94WzNdICE9PSBmb250QkJveFsxXSAmJiB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LmdldChmb250KTtcbiAgICAgIGlmIChpc0JCb3hUcnVzdHdvcnRoeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29tcHV0ZWRCQm94ID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGZvbnRCQm94LCBmb250LmZvbnRNYXRyaXgsIGNvbXB1dGVkQkJveCk7XG4gICAgICAgIGlmIChzY2FsZSAhPT0gMSB8fCB4ICE9PSAwIHx8IHkgIT09IDApIHtcbiAgICAgICAgICBVdGlsLnNjYWxlTWluTWF4KFtzY2FsZSwgMCwgMCwgLXNjYWxlLCB4LCB5XSwgY29tcHV0ZWRCQm94KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvcmRCQm94KGlkeCwgY3R4LCBjb21wdXRlZEJCb3hbMF0sIGNvbXB1dGVkQkJveFsyXSwgY29tcHV0ZWRCQm94WzFdLCBjb21wdXRlZEJCb3hbM10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZ2V0TWVhc3VyZSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVjb3JkRnVsbFBhZ2VCQm94KGlkeCk7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmUgPSBnZXRNZWFzdXJlKCk7XG4gICAgaWYgKGZvbnRCQm94ICYmIGNvbXB1dGVkQkJveCAmJiBpc0JCb3hUcnVzdHdvcnRoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpc0JCb3hUcnVzdHdvcnRoeSA9IGNvbXB1dGVkQkJveFswXSA8PSB4IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveExlZnQgJiYgY29tcHV0ZWRCQm94WzJdID49IHggKyBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQgJiYgY29tcHV0ZWRCQm94WzFdIDw9IHkgLSBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICYmIGNvbXB1dGVkQkJveFszXSA+PSB5ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB0aGlzLiNmb250QkJveFRydXN0d29ydGh5LnNldChmb250LCBpc0JCb3hUcnVzdHdvcnRoeSk7XG4gICAgICBpZiAoaXNCQm94VHJ1c3R3b3J0aHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgY29tcHV0ZWRCQm94WzBdLCBjb21wdXRlZEJCb3hbMl0sIGNvbXB1dGVkQkJveFsxXSwgY29tcHV0ZWRCQm94WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVjb3JkQkJveChpZHgsIGN0eCwgeCAtIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCB4ICsgbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0LCB5IC0gbWVhc3VyZS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCwgeSArIG1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KTtcbiAgfVxuICByZWNvcmRGdWxsUGFnZUJCb3goaWR4KSB7XG4gICAgdGhpcy4jcGVuZGluZ0JCb3hbMF0gPSBNYXRoLm1heCgwLCB0aGlzLiNjbGlwQm94WzBdKTtcbiAgICB0aGlzLiNwZW5kaW5nQkJveFsxXSA9IE1hdGgubWF4KDAsIHRoaXMuI2NsaXBCb3hbMV0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzJdID0gTWF0aC5taW4odGhpcy4jY2FudmFzV2lkdGgsIHRoaXMuI2NsaXBCb3hbMl0pO1xuICAgIHRoaXMuI3BlbmRpbmdCQm94WzNdID0gTWF0aC5taW4odGhpcy4jY2FudmFzSGVpZ2h0LCB0aGlzLiNjbGlwQm94WzNdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRTaW1wbGVJbmRleChkZXBlbmRlbmN5TmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNzaW1wbGVbZGVwZW5kZW5jeU5hbWVdO1xuICB9XG4gIHJlY29yZERlcGVuZGVuY2llcyhpZHgsIGRlcGVuZGVuY3lOYW1lcykge1xuICAgIGNvbnN0IHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzO1xuICAgIGNvbnN0IHNpbXBsZSA9IHRoaXMuI3NpbXBsZTtcbiAgICBjb25zdCBpbmNyZW1lbnRhbCA9IHRoaXMuI2luY3JlbWVudGFsO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBkZXBlbmRlbmN5TmFtZXMpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuI3NpbXBsZSkge1xuICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZChzaW1wbGVbbmFtZV0pO1xuICAgICAgfSBlbHNlIGlmIChuYW1lIGluIGluY3JlbWVudGFsKSB7XG4gICAgICAgIGluY3JlbWVudGFsW25hbWVdLmZvckVhY2gocGVuZGluZ0RlcGVuZGVuY2llcy5hZGQsIHBlbmRpbmdEZXBlbmRlbmNpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERlcGVuZGVuY3koaWR4LCBuYW1lKSB7XG4gICAgaWYgKHRoaXMuI25hbWVkRGVwZW5kZW5jaWVzLmhhcyhuYW1lKSkge1xuICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5hZGQodGhpcy4jbmFtZWREZXBlbmRlbmNpZXMuZ2V0KG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkT3BlcmF0aW9uKGlkeCwgcHJlc2VydmUgPSBmYWxzZSkge1xuICAgIHRoaXMucmVjb3JkRGVwZW5kZW5jaWVzKGlkeCwgW0ZPUkNFRF9ERVBFTkRFTkNZX0xBQkVMXSk7XG4gICAgaWYgKHRoaXMuI2RlYnVnTWV0YWRhdGEpIHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhID0gZW5zdXJlRGVidWdNZXRhZGF0YSh0aGlzLiNkZWJ1Z01ldGFkYXRhLCBpZHgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXBlbmRlbmNpZXNcbiAgICAgIH0gPSBtZXRhZGF0YTtcbiAgICAgIHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXMuZm9yRWFjaChkZXBlbmRlbmNpZXMuYWRkLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgdGhpcy4jc2F2ZXNTdGFjay5mb3JFYWNoKGRlcGVuZGVuY2llcy5hZGQsIGRlcGVuZGVuY2llcyk7XG4gICAgICB0aGlzLiNtYXJrZWRDb250ZW50U3RhY2suZm9yRWFjaChkZXBlbmRlbmNpZXMuYWRkLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgZGVwZW5kZW5jaWVzLmRlbGV0ZShpZHgpO1xuICAgICAgbWV0YWRhdGEuaXNSZW5kZXJpbmdPcGVyYXRpb24gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcGVuZGluZ0JCb3hJZHggPT09IGlkeCkge1xuICAgICAgY29uc3QgbWluWCA9IGZsb29yKHRoaXMuI3BlbmRpbmdCQm94WzBdICogMjU2IC8gdGhpcy4jY2FudmFzV2lkdGgpO1xuICAgICAgY29uc3QgbWluWSA9IGZsb29yKHRoaXMuI3BlbmRpbmdCQm94WzFdICogMjU2IC8gdGhpcy4jY2FudmFzSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1heFggPSBjZWlsKHRoaXMuI3BlbmRpbmdCQm94WzJdICogMjU2IC8gdGhpcy4jY2FudmFzV2lkdGgpO1xuICAgICAgY29uc3QgbWF4WSA9IGNlaWwodGhpcy4jcGVuZGluZ0JCb3hbM10gKiAyNTYgLyB0aGlzLiNjYW52YXNIZWlnaHQpO1xuICAgICAgZXhwYW5kQkJveCh0aGlzLiNiYm94ZXNDb29yZHMsIGlkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICBmb3IgKGNvbnN0IGRlcElkeCBvZiB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKSB7XG4gICAgICAgIGlmIChkZXBJZHggIT09IGlkeCkge1xuICAgICAgICAgIGV4cGFuZEJCb3godGhpcy4jYmJveGVzQ29vcmRzLCBkZXBJZHgsIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNhdmVJZHggb2YgdGhpcy4jc2F2ZXNTdGFjaykge1xuICAgICAgICBpZiAoc2F2ZUlkeCAhPT0gaWR4KSB7XG4gICAgICAgICAgZXhwYW5kQkJveCh0aGlzLiNiYm94ZXNDb29yZHMsIHNhdmVJZHgsIG1pblgsIG1pblksIG1heFgsIG1heFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNhdmVJZHggb2YgdGhpcy4jbWFya2VkQ29udGVudFN0YWNrKSB7XG4gICAgICAgIGlmIChzYXZlSWR4ICE9PSBpZHgpIHtcbiAgICAgICAgICBleHBhbmRCQm94KHRoaXMuI2Jib3hlc0Nvb3Jkcywgc2F2ZUlkeCwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgICB0aGlzLiNwZW5kaW5nQkJveElkeCA9IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaG93VGV4dE9wZXJhdGlvbihpZHgsIHByZXNlcnZlID0gZmFsc2UpIHtcbiAgICBjb25zdCBkZXBzID0gQXJyYXkuZnJvbSh0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzKTtcbiAgICB0aGlzLnJlY29yZE9wZXJhdGlvbihpZHgsIHByZXNlcnZlKTtcbiAgICB0aGlzLnJlY29yZEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiLCBpZHgpO1xuICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgIHRoaXMucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIsIGRlcCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKGlkeCwgcHJlc2VydmUgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nQkJveElkeCA9PT0gaWR4KSB7XG4gICAgICB0aGlzLiNwZW5kaW5nQkJveElkeCA9IC0xO1xuICAgICAgdGhpcy4jY2xpcEJveFswXSA9IE1hdGgubWF4KHRoaXMuI2NsaXBCb3hbMF0sIHRoaXMuI3BlbmRpbmdCQm94WzBdKTtcbiAgICAgIHRoaXMuI2NsaXBCb3hbMV0gPSBNYXRoLm1heCh0aGlzLiNjbGlwQm94WzFdLCB0aGlzLiNwZW5kaW5nQkJveFsxXSk7XG4gICAgICB0aGlzLiNjbGlwQm94WzJdID0gTWF0aC5taW4odGhpcy4jY2xpcEJveFsyXSwgdGhpcy4jcGVuZGluZ0JCb3hbMl0pO1xuICAgICAgdGhpcy4jY2xpcEJveFszXSA9IE1hdGgubWluKHRoaXMuI2NsaXBCb3hbM10sIHRoaXMuI3BlbmRpbmdCQm94WzNdKTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBfdGFrZVBlbmRpbmdEZXBlbmRlbmNpZXMoKSB7XG4gICAgY29uc3QgcGVuZGluZ0RlcGVuZGVuY2llcyA9IHRoaXMuI3BlbmRpbmdEZXBlbmRlbmNpZXM7XG4gICAgdGhpcy4jcGVuZGluZ0RlcGVuZGVuY2llcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gcGVuZGluZ0RlcGVuZGVuY2llcztcbiAgfVxuICBfZXh0cmFjdE9wZXJhdGlvbihpZHgpIHtcbiAgICBjb25zdCBvcGVyYXRpb24gPSB0aGlzLiNvcGVyYXRpb25zLmdldChpZHgpO1xuICAgIHRoaXMuI29wZXJhdGlvbnMuZGVsZXRlKGlkeCk7XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgfVxuICBfcHVzaFBlbmRpbmdEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gICAgZm9yIChjb25zdCBkZXAgb2YgZGVwZW5kZW5jaWVzKSB7XG4gICAgICB0aGlzLiNwZW5kaW5nRGVwZW5kZW5jaWVzLmFkZChkZXApO1xuICAgIH1cbiAgfVxuICB0YWtlKCkge1xuICAgIHRoaXMuI2ZvbnRCQm94VHJ1c3R3b3J0aHkuY2xlYXIoKTtcbiAgICByZXR1cm4gbmV3IEJCb3hSZWFkZXIodGhpcy4jYmJveGVzLCB0aGlzLiNiYm94ZXNDb29yZHMpO1xuICB9XG4gIHRha2VEZWJ1Z01ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLiNkZWJ1Z01ldGFkYXRhO1xuICB9XG59XG5jbGFzcyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlciB7XG4gICNkZXBlbmRlbmN5VHJhY2tlcjtcbiAgI29wSWR4O1xuICAjaWdub3JlQkJveGVzO1xuICAjbmVzdGluZ0xldmVsID0gMDtcbiAgI3NhdmVzTGV2ZWwgPSAwO1xuICBjb25zdHJ1Y3RvcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgsIGlnbm9yZUJCb3hlcykge1xuICAgIGlmIChkZXBlbmRlbmN5VHJhY2tlciBpbnN0YW5jZW9mIENhbnZhc05lc3RlZERlcGVuZGVuY3lUcmFja2VyICYmIGRlcGVuZGVuY3lUcmFja2VyLiNpZ25vcmVCQm94ZXMgPT09ICEhaWdub3JlQkJveGVzKSB7XG4gICAgICByZXR1cm4gZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgfVxuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXI7XG4gICAgdGhpcy4jb3BJZHggPSBvcElkeDtcbiAgICB0aGlzLiNpZ25vcmVCQm94ZXMgPSAhIWlnbm9yZUJCb3hlcztcbiAgfVxuICBncm93T3BlcmF0aW9uc0NvdW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG4gIHNhdmUob3BJZHgpIHtcbiAgICB0aGlzLiNzYXZlc0xldmVsKys7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuc2F2ZSh0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzdG9yZShvcElkeCkge1xuICAgIGlmICh0aGlzLiNzYXZlc0xldmVsID4gMCkge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVzdG9yZSh0aGlzLiNvcElkeCk7XG4gICAgICB0aGlzLiNzYXZlc0xldmVsLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE9wZW5NYXJrZXIoaWR4KSB7XG4gICAgdGhpcy4jbmVzdGluZ0xldmVsKys7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0T3Blbk1hcmtlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbmVzdGluZ0xldmVsID4gMCA/IHRoaXMuI29wSWR4IDogdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpO1xuICB9XG4gIHJlY29yZENsb3NlTWFya2VyKGlkeCkge1xuICAgIHRoaXMuI25lc3RpbmdMZXZlbC0tO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJlZ2luTWFya2VkQ29udGVudChvcElkeCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGVuZE1hcmtlZENvbnRlbnQob3BJZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBwdXNoQmFzZVRyYW5zZm9ybShjdHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5wdXNoQmFzZVRyYW5zZm9ybShjdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBvcEJhc2VUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucG9wQmFzZVRyYW5zZm9ybSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZFNpbXBsZURhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkU2ltcGxlRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkSW5jcmVtZW50YWxEYXRhKG5hbWUsIGlkeCkge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZEluY3JlbWVudGFsRGF0YShuYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVzZXRJbmNyZW1lbnRhbERhdGEobmFtZSwgdGhpcy4jb3BJZHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZE5hbWVkRGF0YShuYW1lLCBpZHgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaW1wbGVEYXRhRnJvbU5hbWVkKG5hbWUsIGRlcE5hbWUsIGZhbGxiYWNrSWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChuYW1lLCBkZXBOYW1lLCB0aGlzLiNvcElkeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkRnV0dXJlRm9yY2VkRGVwZW5kZW5jeShuYW1lLCBpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KG5hbWUsIHRoaXMuI29wSWR4KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKG5hbWVzKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuaW5oZXJpdFNpbXBsZURhdGFBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcyhuYW1lcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW5oZXJpdFBlbmRpbmdEZXBlbmRlbmNpZXNBc0Z1dHVyZUZvcmNlZERlcGVuZGVuY2llcygpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5pbmhlcml0UGVuZGluZ0RlcGVuZGVuY2llc0FzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVzZXRCQm94KGlkeCkge1xuICAgIGlmICghdGhpcy4jaWdub3JlQkJveGVzKSB7XG4gICAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3godGhpcy4jb3BJZHgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRDbGlwQm94KGlkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZENsaXBCb3godGhpcy4jb3BJZHgsIGN0eCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEJCb3goaWR4LCBjdHgsIG1pblgsIG1heFgsIG1pblksIG1heFkpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQkJveCh0aGlzLiNvcElkeCwgY3R4LCBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVjb3JkQ2hhcmFjdGVyQkJveChpZHgsIGN0eCwgZm9udCwgc2NhbGUsIHgsIHksIGdldE1lYXN1cmUpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2hhcmFjdGVyQkJveCh0aGlzLiNvcElkeCwgY3R4LCBmb250LCBzY2FsZSwgeCwgeSwgZ2V0TWVhc3VyZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlY29yZEZ1bGxQYWdlQkJveChpZHgpIHtcbiAgICBpZiAoIXRoaXMuI2lnbm9yZUJCb3hlcykge1xuICAgICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkRnVsbFBhZ2VCQm94KHRoaXMuI29wSWR4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoZGVwZW5kZW5jeU5hbWUpO1xuICB9XG4gIHJlY29yZERlcGVuZGVuY2llcyhpZHgsIGRlcGVuZGVuY3lOYW1lcykge1xuICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyh0aGlzLiNvcElkeCwgZGVwZW5kZW5jeU5hbWVzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmROYW1lZERlcGVuZGVuY3koaWR4LCBuYW1lKSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkTmFtZWREZXBlbmRlbmN5KHRoaXMuI29wSWR4LCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRPcGVyYXRpb24oaWR4KSB7XG4gICAgdGhpcy4jZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkT3BlcmF0aW9uKHRoaXMuI29wSWR4LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZWNvcmRTaG93VGV4dE9wZXJhdGlvbihpZHgpIHtcbiAgICB0aGlzLiNkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbih0aGlzLiNvcElkeCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYmJveFRvQ2xpcEJveERyb3BPcGVyYXRpb24oaWR4KSB7XG4gICAgaWYgKCF0aGlzLiNpZ25vcmVCQm94ZXMpIHtcbiAgICAgIHRoaXMuI2RlcGVuZGVuY3lUcmFja2VyLmJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKHRoaXMuI29wSWR4LCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdGFrZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxuICB0YWtlRGVidWdNZXRhZGF0YSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgfVxufVxuY29uc3QgRGVwZW5kZW5jaWVzID0ge1xuICBzdHJva2U6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJzdHJva2VDb2xvclwiLCBcInN0cm9rZUFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImRhc2hcIl0sXG4gIGZpbGw6IFtcInBhdGhcIiwgXCJ0cmFuc2Zvcm1cIiwgXCJmaWx0ZXJcIiwgXCJmaWxsQ29sb3JcIiwgXCJmaWxsQWxwaGFcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJTTWFza1wiXSxcbiAgaW1hZ2VYT2JqZWN0OiBbXCJ0cmFuc2Zvcm1cIiwgXCJTTWFza1wiLCBcImZpbHRlclwiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdLFxuICByYXdGaWxsUGF0aDogW1wiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwiZmlsbEFscGhhXCJdLFxuICBzaG93VGV4dDogW1widHJhbnNmb3JtXCIsIFwibGVhZGluZ1wiLCBcImNoYXJTcGFjaW5nXCIsIFwid29yZFNwYWNpbmdcIiwgXCJoU2NhbGVcIiwgXCJ0ZXh0UmlzZVwiLCBcIm1vdmVUZXh0XCIsIFwidGV4dE1hdHJpeFwiLCBcImZvbnRcIiwgXCJmb250T2JqXCIsIFwiZmlsdGVyXCIsIFwiZmlsbENvbG9yXCIsIFwidGV4dFJlbmRlcmluZ01vZGVcIiwgXCJTTWFza1wiLCBcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIFwic2FtZUxpbmVUZXh0XCJdLFxuICB0cmFuc2Zvcm06IFtcInRyYW5zZm9ybVwiXSxcbiAgdHJhbnNmb3JtQW5kRmlsbDogW1widHJhbnNmb3JtXCIsIFwiZmlsbENvbG9yXCJdXG59O1xuXG47Ly8gLi9zcmMvZGlzcGxheS9wYXR0ZXJuX2hlbHBlci5qc1xuXG5cbmNvbnN0IFBhdGhUeXBlID0ge1xuICBGSUxMOiBcIkZpbGxcIixcbiAgU1RST0tFOiBcIlN0cm9rZVwiLFxuICBTSEFESU5HOiBcIlNoYWRpbmdcIlxufTtcbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICBjb25zdCBoZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcbiAgY29uc3QgcmVnaW9uID0gbmV3IFBhdGgyRCgpO1xuICByZWdpb24ucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmNsaXAocmVnaW9uKTtcbn1cbmNsYXNzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgZ2V0UGF0dGVybmAgY2FsbGVkLlwiKTtcbiAgfVxufVxuY2xhc3MgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGNvbnN0cnVjdG9yKElSKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl90eXBlID0gSVJbMV07XG4gICAgdGhpcy5fYmJveCA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9yU3RvcHMgPSBJUlszXTtcbiAgICB0aGlzLl9wMCA9IElSWzRdO1xuICAgIHRoaXMuX3AxID0gSVJbNV07XG4gICAgdGhpcy5fcjAgPSBJUls2XTtcbiAgICB0aGlzLl9yMSA9IElSWzddO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuICBfY3JlYXRlR3JhZGllbnQoY3R4KSB7XG4gICAgbGV0IGdyYWQ7XG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiB0aGlzLl9jb2xvclN0b3BzKSB7XG4gICAgICBncmFkLmFkZENvbG9yU3RvcChjb2xvclN0b3BbMF0sIGNvbG9yU3RvcFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBncmFkO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAocGF0aFR5cGUgPT09IFBhdGhUeXBlLlNUUk9LRSB8fCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuRklMTCkge1xuICAgICAgY29uc3Qgb3duZXJCQm94ID0gb3duZXIuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KHBhdGhUeXBlLCBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKG93bmVyQkJveFsyXSAtIG93bmVyQkJveFswXSkgfHwgMTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguY2VpbChvd25lckJCb3hbM10gLSBvd25lckJCb3hbMV0pIHx8IDE7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRtcEN0eC5yZWN0KDAsIDAsIHRtcEN0eC5jYW52YXMud2lkdGgsIHRtcEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHRtcEN0eC50cmFuc2xhdGUoLW93bmVyQkJveFswXSwgLW93bmVyQkJveFsxXSk7XG4gICAgICBpbnZlcnNlID0gVXRpbC50cmFuc2Zvcm0oaW52ZXJzZSwgWzEsIDAsIDAsIDEsIG93bmVyQkJveFswXSwgb3duZXJCQm94WzFdXSk7XG4gICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgICAgYXBwbHlCb3VuZGluZ0JveCh0bXBDdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgdG1wQ3R4LmZpbGxTdHlsZSA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KHRtcEN0eCk7XG4gICAgICB0bXBDdHguZmlsbCgpO1xuICAgICAgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRtcENhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgY29uc3QgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChpbnZlcnNlKTtcbiAgICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGx5Qm91bmRpbmdCb3goY3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLl9jcmVhdGVHcmFkaWVudChjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHAxLCBwMiwgcDMsIGMxLCBjMiwgYzMpIHtcbiAgY29uc3QgY29vcmRzID0gY29udGV4dC5jb29yZHMsXG4gICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgIHJvd1NpemUgPSBkYXRhLndpZHRoICogNDtcbiAgbGV0IHRtcDtcbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMiArIDFdID4gY29vcmRzW3AzICsgMV0pIHtcbiAgICB0bXAgPSBwMjtcbiAgICBwMiA9IHAzO1xuICAgIHAzID0gdG1wO1xuICAgIHRtcCA9IGMyO1xuICAgIGMyID0gYzM7XG4gICAgYzMgPSB0bXA7XG4gIH1cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgaWYgKHkxID49IHkzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGMxciA9IGNvbG9yc1tjMV0sXG4gICAgYzFnID0gY29sb3JzW2MxICsgMV0sXG4gICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgYzJiID0gY29sb3JzW2MyICsgMl07XG4gIGNvbnN0IGMzciA9IGNvbG9yc1tjM10sXG4gICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gIGNvbnN0IG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICBtYXhZID0gTWF0aC5yb3VuZCh5Myk7XG4gIGxldCB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgbGV0IHhiLCBjYnIsIGNiZywgY2JiO1xuICBmb3IgKGxldCB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICBpZiAoeSA8IHkyKSB7XG4gICAgICBjb25zdCBrID0geSA8IHkxID8gMCA6ICh5MSAtIHkpIC8gKHkxIC0geTIpO1xuICAgICAgeGEgPSB4MSAtICh4MSAtIHgyKSAqIGs7XG4gICAgICBjYXIgPSBjMXIgLSAoYzFyIC0gYzJyKSAqIGs7XG4gICAgICBjYWcgPSBjMWcgLSAoYzFnIC0gYzJnKSAqIGs7XG4gICAgICBjYWIgPSBjMWIgLSAoYzFiIC0gYzJiKSAqIGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBrO1xuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuICAgICAgeGEgPSB4MiAtICh4MiAtIHgzKSAqIGs7XG4gICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIGs7XG4gICAgICBjYWcgPSBjMmcgLSAoYzJnIC0gYzNnKSAqIGs7XG4gICAgICBjYWIgPSBjMmIgLSAoYzJiIC0gYzNiKSAqIGs7XG4gICAgfVxuICAgIGxldCBrO1xuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cbiAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICBjYnIgPSBjMXIgLSAoYzFyIC0gYzNyKSAqIGs7XG4gICAgY2JnID0gYzFnIC0gKGMxZyAtIGMzZykgKiBrO1xuICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICBjb25zdCB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgIGNvbnN0IHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgbGV0IGogPSByb3dTaXplICogeSArIHgxXyAqIDQ7XG4gICAgZm9yIChsZXQgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgayA9ICh4YSAtIHgpIC8gKHhhIC0geGIpO1xuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cbiAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhZyAtIChjYWcgLSBjYmcpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FiIC0gKGNhYiAtIGNiYikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCkge1xuICBjb25zdCBwcyA9IGZpZ3VyZS5jb29yZHM7XG4gIGNvbnN0IGNzID0gZmlndXJlLmNvbG9ycztcbiAgbGV0IGksIGlpO1xuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBNZXNoRmlndXJlVHlwZS5MQVRUSUNFOlxuICAgICAgY29uc3QgdmVydGljZXNQZXJSb3cgPSBmaWd1cmUudmVydGljZXNQZXJSb3c7XG4gICAgICBjb25zdCByb3dzID0gTWF0aC5mbG9vcihwcy5sZW5ndGggLyB2ZXJ0aWNlc1BlclJvdykgLSAxO1xuICAgICAgY29uc3QgY29scyA9IHZlcnRpY2VzUGVyUm93IC0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrLCBxKyspIHtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1lc2hGaWd1cmVUeXBlLlRSSUFOR0xFUzpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls2XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBkYXRhID0gdG1wQ3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiYWNrZ3JvdW5kQ29sb3JbMF07XG4gICAgICAgIGJ5dGVzW2kgKyAxXSA9IGJhY2tncm91bmRDb2xvclsxXTtcbiAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICBieXRlc1tpICsgM10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgZmlndXJlIG9mIHRoaXMuX2ZpZ3VyZXMpIHtcbiAgICAgIGRyYXdGaWd1cmUoZGF0YSwgZmlndXJlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCksIHNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgICBjb25zdCBbbWF0cml4U2NhbGVYLCBtYXRyaXhTY2FsZVldID0gc2NhbGU7XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0sIHNjYWxlKTtcbiAgICAgIHNjYWxlWzBdICo9IG1hdHJpeFNjYWxlWDtcbiAgICAgIHNjYWxlWzFdICo9IG1hdHJpeFNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSB0aGlzLl9jcmVhdGVNZXNoQ2FudmFzKHNjYWxlLCBwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORyA/IG51bGwgOiB0aGlzLl9iYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcyk7XG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBjdHguc2NhbGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICB9XG59XG5jbGFzcyBEdW1teVNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgZ2V0UGF0dGVybigpIHtcbiAgICByZXR1cm4gXCJob3RwaW5rXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgIHJldHVybiBuZXcgTWVzaFNoYWRpbmdQYXR0ZXJuKElSKTtcbiAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgIHJldHVybiBuZXcgRHVtbXlTaGFkaW5nUGF0dGVybigpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuY29uc3QgUGFpbnRUeXBlID0ge1xuICBDT0xPUkVEOiAxLFxuICBVTkNPTE9SRUQ6IDJcbn07XG5jbGFzcyBUaWxpbmdQYXR0ZXJuIHtcbiAgc3RhdGljIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICBjb25zdHJ1Y3RvcihJUiwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmNvbG9yID0gSVJbMV07XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBJUlsyXTtcbiAgICB0aGlzLm1hdHJpeCA9IElSWzNdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIsIG9wSWR4KSB7XG4gICAgY29uc3Qge1xuICAgICAgYmJveCxcbiAgICAgIG9wZXJhdG9yTGlzdCxcbiAgICAgIHBhaW50VHlwZSxcbiAgICAgIHRpbGluZ1R5cGUsXG4gICAgICBjb2xvcixcbiAgICAgIGNhbnZhc0dyYXBoaWNzRmFjdG9yeVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB4c3RlcCxcbiAgICAgIHlzdGVwXG4gICAgfSA9IHRoaXM7XG4gICAgeHN0ZXAgPSBNYXRoLmFicyh4c3RlcCk7XG4gICAgeXN0ZXAgPSBNYXRoLmFicyh5c3RlcCk7XG4gICAgaW5mbyhcIlRpbGluZ1R5cGU6IFwiICsgdGlsaW5nVHlwZSk7XG4gICAgY29uc3QgeDAgPSBiYm94WzBdLFxuICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgeTEgPSBiYm94WzNdO1xuICAgIGNvbnN0IHdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBoZWlnaHQgPSB5MSAtIHkwO1xuICAgIGNvbnN0IHNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4LCBzY2FsZSk7XG4gICAgY29uc3QgW21hdHJpeFNjYWxlWCwgbWF0cml4U2NhbGVZXSA9IHNjYWxlO1xuICAgIFV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtLCBzY2FsZSk7XG4gICAgY29uc3QgY29tYmluZWRTY2FsZVggPSBtYXRyaXhTY2FsZVggKiBzY2FsZVswXTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlWSA9IG1hdHJpeFNjYWxlWSAqIHNjYWxlWzFdO1xuICAgIGxldCBjYW52YXNXaWR0aCA9IHdpZHRoLFxuICAgICAgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0LFxuICAgICAgcmVkcmF3SG9yaXpvbnRhbGx5ID0gZmFsc2UsXG4gICAgICByZWRyYXdWZXJ0aWNhbGx5ID0gZmFsc2U7XG4gICAgY29uc3QgeFNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeHN0ZXAgKiBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgeVNjYWxlZFN0ZXAgPSBNYXRoLmNlaWwoeXN0ZXAgKiBjb21iaW5lZFNjYWxlWSk7XG4gICAgY29uc3QgeFNjYWxlZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogY29tYmluZWRTY2FsZVgpO1xuICAgIGNvbnN0IHlTY2FsZWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogY29tYmluZWRTY2FsZVkpO1xuICAgIGlmICh4U2NhbGVkU3RlcCA+PSB4U2NhbGVkV2lkdGgpIHtcbiAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZHJhd0hvcml6b250YWxseSA9IHRydWU7XG4gICAgfVxuICAgIGlmICh5U2NhbGVkU3RlcCA+PSB5U2NhbGVkSGVpZ2h0KSB7XG4gICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVkcmF3VmVydGljYWxseSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNXaWR0aCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWCk7XG4gICAgY29uc3QgZGlteSA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKGNhbnZhc0hlaWdodCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVkpO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCwgb3BJZHgpO1xuICAgIGdyYXBoaWNzLmdyb3VwTGV2ZWwgPSBvd25lci5ncm91cExldmVsO1xuICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC1kaW14LnNjYWxlICogeDAsIC1kaW15LnNjYWxlICogeTApO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgwLCBkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIGdyYXBoaWNzLmRlcGVuZGVuY3lUcmFja2VyPy5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgeDAsIHkwLCB4MSwgeTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCk7XG4gICAgZ3JhcGhpY3MuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgIGdyYXBoaWNzLmVuZERyYXdpbmcoKTtcbiAgICBncmFwaGljcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzdG9yZSgpO1xuICAgIHRtcEN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHJlZHJhd0hvcml6b250YWxseSB8fCByZWRyYXdWZXJ0aWNhbGx5KSB7XG4gICAgICBjb25zdCBpbWFnZSA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBpZiAocmVkcmF3SG9yaXpvbnRhbGx5KSB7XG4gICAgICAgIGNhbnZhc1dpZHRoID0geHN0ZXA7XG4gICAgICB9XG4gICAgICBpZiAocmVkcmF3VmVydGljYWxseSkge1xuICAgICAgICBjYW52YXNIZWlnaHQgPSB5c3RlcDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpbXgyID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoY2FudmFzV2lkdGgsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgY29tYmluZWRTY2FsZVgpO1xuICAgICAgY29uc3QgZGlteTIgPSB0aGlzLmdldFNpemVBbmRTY2FsZShjYW52YXNIZWlnaHQsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVZKTtcbiAgICAgIGNvbnN0IHhTaXplID0gZGlteDIuc2l6ZTtcbiAgICAgIGNvbnN0IHlTaXplID0gZGlteTIuc2l6ZTtcbiAgICAgIGNvbnN0IHRtcENhbnZhczIgPSBvd25lci5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJwYXR0ZXJuLXdvcmthcm91bmRcIiwgeFNpemUsIHlTaXplKTtcbiAgICAgIGNvbnN0IHRtcEN0eDIgPSB0bXBDYW52YXMyLmNvbnRleHQ7XG4gICAgICBjb25zdCBpaSA9IHJlZHJhd0hvcml6b250YWxseSA/IE1hdGguZmxvb3Iod2lkdGggLyB4c3RlcCkgOiAwO1xuICAgICAgY29uc3QgamogPSByZWRyYXdWZXJ0aWNhbGx5ID8gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RlcCkgOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaWk7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBqajsgaisrKSB7XG4gICAgICAgICAgdG1wQ3R4Mi5kcmF3SW1hZ2UoaW1hZ2UsIHhTaXplICogaSwgeVNpemUgKiBqLCB4U2l6ZSwgeVNpemUsIDAsIDAsIHhTaXplLCB5U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbnZhczogdG1wQ2FudmFzMi5jYW52YXMsXG4gICAgICAgIHNjYWxlWDogZGlteDIuc2NhbGUsXG4gICAgICAgIHNjYWxlWTogZGlteTIuc2NhbGUsXG4gICAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgICBvZmZzZXRZOiB5MFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IHgwLFxuICAgICAgb2Zmc2V0WTogeTBcbiAgICB9O1xuICB9XG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbeDAsIHkwLCB4MSwgeTFdLCBnZXRDdXJyZW50VHJhbnNmb3JtKGdyYXBoaWNzLmN0eCksIGdyYXBoaWNzLmN1cnJlbnQubWluTWF4KTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZpbGxTdHlsZSxcbiAgICAgICAgICBzdHJva2VTdHlsZVxuICAgICAgICB9ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3VycmVudC5maWxsQ29sb3IgPSBmaWxsU3R5bGU7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlU3R5bGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlLCBvcElkeCkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBVdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lciwgb3BJZHgpO1xuICAgIGxldCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KG1hdHJpeCk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgZG9tTWF0cml4ID0gZG9tTWF0cml4LnNjYWxlKDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVZKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwicmVwZWF0XCIpO1xuICAgIHBhdHRlcm4uc2V0VHJhbnNmb3JtKGRvbU1hdHJpeCk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9pbWFnZV91dGlscy5qc1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9SR0JBKHBhcmFtcykge1xuICBzd2l0Y2ggKHBhcmFtcy5raW5kKSB7XG4gICAgY2FzZSBJbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICByZXR1cm4gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEocGFyYW1zKTtcbiAgICBjYXNlIEltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICByZXR1cm4gY29udmVydFJHQlRvUkdCQShwYXJhbXMpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEoe1xuICBzcmMsXG4gIHNyY1BvcyA9IDAsXG4gIGRlc3QsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIG5vbkJsYWNrQ29sb3IgPSAweGZmZmZmZmZmLFxuICBpbnZlcnNlRGVjb2RlID0gZmFsc2Vcbn0pIHtcbiAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gIGNvbnN0IFt6ZXJvTWFwcGluZywgb25lTWFwcGluZ10gPSBpbnZlcnNlRGVjb2RlID8gW25vbkJsYWNrQ29sb3IsIGJsYWNrXSA6IFtibGFjaywgbm9uQmxhY2tDb2xvcl07XG4gIGNvbnN0IHdpZHRoSW5Tb3VyY2UgPSB3aWR0aCA+PiAzO1xuICBjb25zdCB3aWR0aFJlbWFpbmRlciA9IHdpZHRoICYgNztcbiAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmxlbmd0aDtcbiAgZGVzdCA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlcik7XG4gIGxldCBkZXN0UG9zID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgIGZvciAoY29uc3QgbWF4ID0gc3JjUG9zICsgd2lkdGhJblNvdXJjZTsgc3JjUG9zIDwgbWF4OyBzcmNQb3MrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHNyY1BvcyA8IHNyY0xlbmd0aCA/IHNyY1tzcmNQb3NdIDogMjU1O1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1BvcysrXSA6IDI1NTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpZHRoUmVtYWluZGVyOyBqKyspIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAxIDw8IDcgLSBqID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0UkdCVG9SR0JBKHtcbiAgc3JjLFxuICBzcmNQb3MgPSAwLFxuICBkZXN0LFxuICBkZXN0UG9zID0gMCxcbiAgd2lkdGgsXG4gIGhlaWdodFxufSkge1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGxlbiA9IHdpZHRoICogaGVpZ2h0ICogMztcbiAgY29uc3QgbGVuMzIgPSBsZW4gPj4gMjtcbiAgY29uc3Qgc3JjMzIgPSBuZXcgVWludDMyQXJyYXkoc3JjLmJ1ZmZlciwgc3JjUG9zLCBsZW4zMik7XG4gIGlmIChGZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAoOyBpIDwgbGVuMzIgLSAyOyBpICs9IDMsIGRlc3RQb3MgKz0gNCkge1xuICAgICAgY29uc3QgczEgPSBzcmMzMltpXTtcbiAgICAgIGNvbnN0IHMyID0gc3JjMzJbaSArIDFdO1xuICAgICAgY29uc3QgczMgPSBzcmMzMltpICsgMl07XG4gICAgICBkZXN0W2Rlc3RQb3NdID0gczEgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMV0gPSBzMSA+Pj4gMjQgfCBzMiA8PCA4IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDJdID0gczIgPj4+IDE2IHwgczMgPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgICAgZGVzdFtkZXN0UG9zICsgM10gPSBzMyA+Pj4gOCB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmNQb3MgKyBsZW47IGogPCBqajsgaiArPSAzKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbal0gfCBzcmNbaiArIDFdIDw8IDggfCBzcmNbaiArIDJdIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICg7IGkgPCBsZW4zMiAtIDI7IGkgKz0gMywgZGVzdFBvcyArPSA0KSB7XG4gICAgICBjb25zdCBzMSA9IHNyYzMyW2ldO1xuICAgICAgY29uc3QgczIgPSBzcmMzMltpICsgMV07XG4gICAgICBjb25zdCBzMyA9IHNyYzMyW2kgKyAyXTtcbiAgICAgIGRlc3RbZGVzdFBvc10gPSBzMSB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAxXSA9IHMxIDw8IDI0IHwgczIgPj4+IDggfCAweGZmO1xuICAgICAgZGVzdFtkZXN0UG9zICsgMl0gPSBzMiA8PCAxNiB8IHMzID4+PiAxNiB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAzXSA9IHMzIDw8IDggfCAweGZmO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjUG9zICsgbGVuOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIDw8IDI0IHwgc3JjW2ogKyAxXSA8PCAxNiB8IHNyY1tqICsgMl0gPDwgOCB8IDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zOiBzcmNQb3MgKyBsZW4sXG4gICAgZGVzdFBvc1xuICB9O1xufVxuZnVuY3Rpb24gZ3JheVRvUkdCQShzcmMsIGRlc3QpIHtcbiAgaWYgKEZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxIHwgMHhmZjAwMDAwMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGRlc3RbaV0gPSBzcmNbaV0gKiAweDEwMTAxMDAgfCAweDAwMDAwMGZmO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jYW52YXMuanNcblxuXG5cblxuXG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgRlVMTF9DSFVOS19IRUlHSFQgPSAxNjtcbmNvbnN0IFNDQUxFX01BVFJJWCA9IG5ldyBET01NYXRyaXgoKTtcbmNvbnN0IFhZID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbmNvbnN0IE1JTl9NQVhfSU5JVCA9IG5ldyBGbG9hdDMyQXJyYXkoW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldKTtcbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuICBjdHguX19vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXN0b3JlID0gY3R4LnJlc3RvcmU7XG4gIGN0eC5fX29yaWdpbmFsUm90YXRlID0gY3R4LnJvdGF0ZTtcbiAgY3R4Ll9fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGUgPSBjdHgudHJhbnNsYXRlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zZm9ybSA9IGN0eC50cmFuc2Zvcm07XG4gIGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSA9IGN0eC5yZXNldFRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxDbGlwID0gY3R4LmNsaXA7XG4gIGN0eC5fX29yaWdpbmFsTW92ZVRvID0gY3R4Lm1vdmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxMaW5lVG8gPSBjdHgubGluZVRvO1xuICBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG8gPSBjdHguYmV6aWVyQ3VydmVUbztcbiAgY3R4Ll9fb3JpZ2luYWxSZWN0ID0gY3R4LnJlY3Q7XG4gIGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoID0gY3R4LmNsb3NlUGF0aDtcbiAgY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGggPSBjdHguYmVnaW5QYXRoO1xuICBjdHguX3JlbW92ZU1pcnJvcmluZyA9ICgpID0+IHtcbiAgICBjdHguc2F2ZSA9IGN0eC5fX29yaWdpbmFsU2F2ZTtcbiAgICBjdHgucmVzdG9yZSA9IGN0eC5fX29yaWdpbmFsUmVzdG9yZTtcbiAgICBjdHgucm90YXRlID0gY3R4Ll9fb3JpZ2luYWxSb3RhdGU7XG4gICAgY3R4LnNjYWxlID0gY3R4Ll9fb3JpZ2luYWxTY2FsZTtcbiAgICBjdHgudHJhbnNsYXRlID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2xhdGU7XG4gICAgY3R4LnRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFNldFRyYW5zZm9ybTtcbiAgICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtO1xuICAgIGN0eC5jbGlwID0gY3R4Ll9fb3JpZ2luYWxDbGlwO1xuICAgIGN0eC5tb3ZlVG8gPSBjdHguX19vcmlnaW5hbE1vdmVUbztcbiAgICBjdHgubGluZVRvID0gY3R4Ll9fb3JpZ2luYWxMaW5lVG87XG4gICAgY3R4LmJlemllckN1cnZlVG8gPSBjdHguX19vcmlnaW5hbEJlemllckN1cnZlVG87XG4gICAgY3R4LnJlY3QgPSBjdHguX19vcmlnaW5hbFJlY3Q7XG4gICAgY3R4LmNsb3NlUGF0aCA9IGN0eC5fX29yaWdpbmFsQ2xvc2VQYXRoO1xuICAgIGN0eC5iZWdpblBhdGggPSBjdHguX19vcmlnaW5hbEJlZ2luUGF0aDtcbiAgICBkZWxldGUgY3R4Ll9yZW1vdmVNaXJyb3Jpbmc7XG4gIH07XG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzdG9yZSgpO1xuICB9O1xuICBjdHgudHJhbnNsYXRlID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG4gIGN0eC5zY2FsZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm0oKTtcbiAgfTtcbiAgY3R4LnJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgIGRlc3RDdHgucm90YXRlKGFuZ2xlKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuICBjdHguY2xpcCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgZGVzdEN0eC5jbGlwKHJ1bGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsaXAocnVsZSk7XG4gIH07XG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbE1vdmVUbyh4LCB5KTtcbiAgfTtcbiAgY3R4LmxpbmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5saW5lVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuICBjdHguYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uIChjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KSB7XG4gICAgZGVzdEN0eC5iZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICAgIHRoaXMuX19vcmlnaW5hbEJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gIH07XG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5fX29yaWdpbmFsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcbiAgY3R4LmNsb3NlUGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICBkZXN0Q3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuICBjdHguYmVnaW5QYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmVnaW5QYXRoKCk7XG4gIH07XG59XG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGdldENhbnZhcyhpZCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGxldCBjYW52YXNFbnRyeTtcbiAgICBpZiAodGhpcy5jYWNoZVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYW52YXNGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FjaGVbaWRdID0gY2FudmFzRW50cnk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuICBkZWxldGUoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBpZCBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICBjb25zdCBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LmRlc3Ryb3koY2FudmFzRW50cnkpO1xuICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCkge1xuICBjb25zdCBbYSwgYiwgYywgZCwgdHgsIHR5XSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuICBpZiAoYSA9PT0gMCAmJiBkID09PSAwKSB7XG4gICAgY29uc3QgdGxYID0gZGVzdFkgKiBjICsgdHg7XG4gICAgY29uc3QgclRsWCA9IE1hdGgucm91bmQodGxYKTtcbiAgICBjb25zdCB0bFkgPSBkZXN0WCAqIGIgKyB0eTtcbiAgICBjb25zdCByVGxZID0gTWF0aC5yb3VuZCh0bFkpO1xuICAgIGNvbnN0IGJyWCA9IChkZXN0WSArIGRlc3RIKSAqIGMgKyB0eDtcbiAgICBjb25zdCByV2lkdGggPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWCkgLSByVGxYKSB8fCAxO1xuICAgIGNvbnN0IGJyWSA9IChkZXN0WCArIGRlc3RXKSAqIGIgKyB0eTtcbiAgICBjb25zdCBySGVpZ2h0ID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclkpIC0gclRsWSkgfHwgMTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDAsIE1hdGguc2lnbihiKSwgTWF0aC5zaWduKGMpLCAwLCByVGxYLCByVGxZKTtcbiAgICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgMCwgMCwgckhlaWdodCwgcldpZHRoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIHR4LCB0eSk7XG4gICAgcmV0dXJuIFtySGVpZ2h0LCByV2lkdGhdO1xuICB9XG4gIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkZXN0WCwgZGVzdFksIGRlc3RXLCBkZXN0SCk7XG4gIGNvbnN0IHNjYWxlWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gIGNvbnN0IHNjYWxlWSA9IE1hdGguaHlwb3QoYywgZCk7XG4gIHJldHVybiBbc2NhbGVYICogZGVzdFcsIHNjYWxlWSAqIGRlc3RIXTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBhbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgZm9udFNpemUgPSAwO1xuICBmb250U2l6ZVNjYWxlID0gMTtcbiAgdGV4dE1hdHJpeCA9IG51bGw7XG4gIHRleHRNYXRyaXhTY2FsZSA9IDE7XG4gIGZvbnRNYXRyaXggPSBGT05UX0lERU5USVRZX01BVFJJWDtcbiAgbGVhZGluZyA9IDA7XG4gIHggPSAwO1xuICB5ID0gMDtcbiAgbGluZVggPSAwO1xuICBsaW5lWSA9IDA7XG4gIGNoYXJTcGFjaW5nID0gMDtcbiAgd29yZFNwYWNpbmcgPSAwO1xuICB0ZXh0SFNjYWxlID0gMTtcbiAgdGV4dFJlbmRlcmluZ01vZGUgPSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICB0ZXh0UmlzZSA9IDA7XG4gIGZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBzdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICBwYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICBwYXR0ZXJuU3Ryb2tlID0gZmFsc2U7XG4gIGZpbGxBbHBoYSA9IDE7XG4gIHN0cm9rZUFscGhhID0gMTtcbiAgbGluZVdpZHRoID0gMTtcbiAgYWN0aXZlU01hc2sgPSBudWxsO1xuICB0cmFuc2Zlck1hcHMgPSBcIm5vbmVcIjtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcHJlSW5pdCkge1xuICAgIHByZUluaXQ/Lih0aGlzKTtcbiAgICB0aGlzLmNsaXBCb3ggPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSk7XG4gICAgdGhpcy5taW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgY2xvbmUuY2xpcEJveCA9IHRoaXMuY2xpcEJveC5zbGljZSgpO1xuICAgIGNsb25lLm1pbk1heCA9IHRoaXMubWluTWF4LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIGdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICBjb25zdCBib3ggPSB0aGlzLm1pbk1heC5zbGljZSgpO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB1bnJlYWNoYWJsZShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICAgICAgY29uc3QgeFN0cm9rZVBhZCA9IFhZWzBdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgY29uc3QgeVN0cm9rZVBhZCA9IFhZWzFdICogdGhpcy5saW5lV2lkdGggLyAyO1xuICAgICAgYm94WzBdIC09IHhTdHJva2VQYWQ7XG4gICAgICBib3hbMV0gLT0geVN0cm9rZVBhZDtcbiAgICAgIGJveFsyXSArPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzNdICs9IHlTdHJva2VQYWQ7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG4gIH1cbiAgdXBkYXRlQ2xpcEZyb21QYXRoKCkge1xuICAgIGNvbnN0IGludGVyc2VjdCA9IFV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5zdGFydE5ld1BhdGhBbmRDbGlwQm94KGludGVyc2VjdCB8fCBbMCwgMCwgMCwgMF0pO1xuICB9XG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pbk1heFswXSA9PT0gSW5maW5pdHk7XG4gIH1cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3guc2V0KGJveCwgMCk7XG4gICAgdGhpcy5taW5NYXguc2V0KE1JTl9NQVhfSU5JVCwgMCk7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IFBhdGhUeXBlLkZJTEwsIHRyYW5zZm9ybSA9IG51bGwpIHtcbiAgICByZXR1cm4gVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSwgdHJhbnNmb3JtKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlRGF0YShjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IHV0aWxfSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgY29uc3QgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICBjb25zdCB3aGl0ZSA9IDB4ZmZmZmZmZmY7XG4gICAgY29uc3QgYmxhY2sgPSB1dGlsX0ZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG4gICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgIHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICBkZXN0UG9zID0gMDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICBjb25zdCBzcmNEaWZmID0gc3JjTGVuZ3RoIC0gc3JjUG9zO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgY29uc3Qga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICBsZXQgbWFzayA9IDA7XG4gICAgICAgIGxldCBzcmNCeXRlID0gMDtcbiAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDEyOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDMyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxNiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMiA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICBpZiAobWFzayA9PT0gMCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoZGVzdFBvcyA8IGRlc3QzMkRhdGFMZW5ndGgpIHtcbiAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgfVxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gdXRpbF9JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICBpZiAoaSA+PSBmdWxsQ2h1bmtzKSB7XG4gICAgICAgIHRoaXNDaHVua0hlaWdodCA9IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZGVzdFBvcyA9IDA7XG4gICAgICBmb3IgKGogPSBlbGVtc0luVGhpc0NodW5rOyBqLS07KSB7XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBpbWFnZSBraW5kOiAke2ltZ0RhdGEua2luZH1gKTtcbiAgfVxufVxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICBjdHguZHJhd0ltYWdlKGltZ0RhdGEuYml0bWFwLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQsXG4gICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwO1xuICBjb25zdCBzcmMgPSBpbWdEYXRhLmRhdGE7XG4gIGNvbnN0IGRlc3QgPSBjaHVua0ltZ0RhdGEuZGF0YTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgY29uc3QgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAoe1xuICAgICAgc3JjUG9zXG4gICAgfSA9IGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHtcbiAgICAgIHNyYyxcbiAgICAgIHNyY1BvcyxcbiAgICAgIGRlc3QsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogdGhpc0NodW5rSGVpZ2h0LFxuICAgICAgbm9uQmxhY2tDb2xvcjogMFxuICAgIH0pKTtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgfVxufVxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIiwgXCJmaWx0ZXJcIl07XG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgcHJvcGVydGllcykge1xuICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3RDdHhbcHJvcGVydHldID0gc291cmNlQ3R4W3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNvdXJjZUN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgZGVzdEN0eC5saW5lRGFzaE9mZnNldCA9IHNvdXJjZUN0eC5saW5lRGFzaE9mZnNldDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4KSB7XG4gIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICB9XG4gIGNvbnN0IHtcbiAgICBmaWx0ZXJcbiAgfSA9IGN0eDtcbiAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgY3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQodHJhbnNmb3JtLCBpbnRlcnBvbGF0ZSkge1xuICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSwgWFkpO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKE91dHB1dFNjYWxlLnBpeGVsUmF0aW8gKiBQaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuICByZXR1cm4gWFlbMF0gPD0gYWN0dWFsU2NhbGUgJiYgWFlbMV0gPD0gYWN0dWFsU2NhbGU7XG59XG5jb25zdCBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG5jb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuY29uc3QgTk9STUFMX0NMSVAgPSB7fTtcbmNvbnN0IEVPX0NMSVAgPSB7fTtcbmNsYXNzIENhbnZhc0dyYXBoaWNzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzQ3R4LCBjb21tb25PYmpzLCBvYmpzLCBjYW52YXNGYWN0b3J5LCBmaWx0ZXJGYWN0b3J5LCB7XG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgIG1hcmtlZENvbnRlbnRTdGFjayA9IG51bGxcbiAgfSwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycywgZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhc0N0eDtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuc3RhdGVTdGFjayA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMucmVzID0gbnVsbDtcbiAgICB0aGlzLnhvYmpzID0gbnVsbDtcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgdGhpcy5jYW52YXNGYWN0b3J5ID0gY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmaWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuZ3JvdXBTdGFjayA9IFtdO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sgPSBbXTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwgPSAwO1xuICAgIHRoaXMuc21hc2tTdGFjayA9IFtdO1xuICAgIHRoaXMuc21hc2tDb3VudGVyID0gMDtcbiAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgdGhpcy5zdXNwZW5kZWRDdHggPSBudWxsO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrID0gbWFya2VkQ29udGVudFN0YWNrIHx8IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy52aWV3cG9ydFNjYWxlID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWCA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVkgPSAxO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFstMSwgMF07XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyID0gZGVwZW5kZW5jeVRyYWNrZXIgPz8gbnVsbDtcbiAgfVxuICBnZXRPYmplY3Qob3BJZHgsIGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkTmFtZWREZXBlbmRlbmN5KG9wSWR4LCBkYXRhKTtcbiAgICAgIHJldHVybiBkYXRhLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGF0YSkgOiB0aGlzLm9ianMuZ2V0KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi5nZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY29tcG9zaXRlQ3R4KSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cbiAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSB2aWV3cG9ydC5zY2FsZTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgfVxuICBleGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCwgZXhlY3V0aW9uU3RhcnRJZHgsIGNvbnRpbnVlQ2FsbGJhY2ssIHN0ZXBwZXIsIG9wZXJhdGlvbnNGaWx0ZXIpIHtcbiAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICBsZXQgaSA9IGV4ZWN1dGlvblN0YXJ0SWR4IHx8IDA7XG4gICAgY29uc3QgYXJnc0FycmF5TGVuID0gYXJnc0FycmF5Lmxlbmd0aDtcbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtPcGVyYXRpb25zID0gYXJnc0FycmF5TGVuIC0gaSA+IEVYRUNVVElPTl9TVEVQUyAmJiB0eXBlb2YgY29udGludWVDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiO1xuICAgIGNvbnN0IGVuZFRpbWUgPSBjaHVua09wZXJhdGlvbnMgPyBEYXRlLm5vdygpICsgRVhFQ1VUSU9OX1RJTUUgOiAwO1xuICAgIGxldCBzdGVwcyA9IDA7XG4gICAgY29uc3QgY29tbW9uT2JqcyA9IHRoaXMuY29tbW9uT2JqcztcbiAgICBjb25zdCBvYmpzID0gdGhpcy5vYmpzO1xuICAgIGxldCBmbklkLCBmbkFyZ3M7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChzdGVwcGVyICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gc3RlcHBlci5uZXh0QnJlYWtQb2ludCkge1xuICAgICAgICBzdGVwcGVyLmJyZWFrSXQoaSwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcGVyYXRpb25zRmlsdGVyIHx8IG9wZXJhdGlvbnNGaWx0ZXIoaSkpIHtcbiAgICAgICAgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICAgIGZuQXJncyA9IGFyZ3NBcnJheVtpXSA/PyBudWxsO1xuICAgICAgICBpZiAoZm5JZCAhPT0gT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgICBpZiAoZm5BcmdzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ZuSWRdKGksIC4uLmZuQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVwT2JqSWQgb2YgZm5BcmdzKSB7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmROYW1lZERhdGEoZGVwT2JqSWQsIGkpO1xuICAgICAgICAgICAgY29uc3Qgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcbiAgICAgICAgICAgIGlmICghb2Jqc1Bvb2wuaGFzKGRlcE9iaklkKSkge1xuICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICAgIGlmIChpID09PSBhcmdzQXJyYXlMZW4pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgPiBlbmRUaW1lKSB7XG4gICAgICAgICAgY29udGludWVDYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI3Jlc3RvcmVJbml0aWFsU3RhdGUoKSB7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggfHwgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgIGlmICh0aGlzLnRyYW5zcGFyZW50Q2FudmFzKSB7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuY29tcG9zaXRlQ3R4O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMudHJhbnNwYXJlbnRDYW52YXMsIDAsIDApO1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNhbnZhcyBvZiBjYWNoZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gIH1cbiAgI2RyYXdGaWx0ZXIoKSB7XG4gICAgaWYgKHRoaXMucGFnZUNvbG9ycykge1xuICAgICAgY29uc3QgaGNtRmlsdGVySWQgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMucGFnZUNvbG9ycy5mb3JlZ3JvdW5kLCB0aGlzLnBhZ2VDb2xvcnMuYmFja2dyb3VuZCk7XG4gICAgICBpZiAoaGNtRmlsdGVySWQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkRmlsdGVyID0gdGhpcy5jdHguZmlsdGVyO1xuICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSBoY21GaWx0ZXJJZDtcbiAgICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKHRoaXMuY3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IHNhdmVkRmlsdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aCA/PyBpbWcuZGlzcGxheVdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQgPz8gaW1nLmRpc3BsYXlIZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBpbWc7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgbGV0IGNhY2hlLCBjYWNoZUtleSwgc2NhbGVkLCBtYXNrQ2FudmFzO1xuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY2FjaGVLZXkgPSBKU09OLnN0cmluZ2lmeShpc1BhdHRlcm5GaWxsID8gY3VycmVudFRyYW5zZm9ybSA6IFtjdXJyZW50VHJhbnNmb3JtLnNsaWNlKDAsIDQpLCBmaWxsQ29sb3JdKTtcbiAgICAgIGNhY2hlID0gdGhpcy5fY2FjaGVkQml0bWFwc01hcC5nZXQobWFpbktleSk7XG4gICAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWNoZWRJbWFnZSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVswXSwgY3VycmVudFRyYW5zZm9ybVsyXSkgKyBjdXJyZW50VHJhbnNmb3JtWzRdKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgucm91bmQoTWF0aC5taW4oY3VycmVudFRyYW5zZm9ybVsxXSwgY3VycmVudFRyYW5zZm9ybVszXSkgKyBjdXJyZW50VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBVdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IFV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBtaW5NYXggPSBNSU5fTUFYX0lOSVQuc2xpY2UoKTtcbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgbWFza1RvQ2FudmFzLCBtaW5NYXgpO1xuICAgIGNvbnN0IFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSA9IG1pbk1heDtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChtYXhYIC0gbWluWCkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQobWF4WSAtIG1pblkpIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gbWluWDtcbiAgICBjb25zdCBvZmZzZXRZID0gbWluWTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpKTtcbiAgICAgIHNjYWxlZCA9IHNjYWxlZC5pbWc7XG4gICAgICBpZiAoY2FjaGUgJiYgaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIHNjYWxlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKGdldEN1cnJlbnRUcmFuc2Zvcm0oZmlsbEN0eCksIGltZy5pbnRlcnBvbGF0ZSk7XG4gICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGZpbGxDdHgsIHNjYWxlZCwgMCwgMCwgc2NhbGVkLndpZHRoLCBzY2FsZWQuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBmaWxsQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgY29uc3QgaW52ZXJzZSA9IFV0aWwudHJhbnNmb3JtKGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBQYXRoVHlwZS5GSUxMLCBvcElkeCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm1BbmRGaWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgob3BJZHgsIHdpZHRoKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxpbmVXaWR0aFwiLCBvcElkeCk7XG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLmN1cnJlbnQubGluZVdpZHRoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmN0eC5saW5lV2lkdGggPSB3aWR0aDtcbiAgfVxuICBzZXRMaW5lQ2FwKG9wSWR4LCBzdHlsZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJsaW5lQ2FwXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihvcElkeCwgc3R5bGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibGluZUpvaW5cIiwgb3BJZHgpO1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChvcElkeCwgbGltaXQpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwibWl0ZXJMaW1pdFwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICB9XG4gIHNldERhc2gob3BJZHgsIGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImRhc2hcIiwgb3BJZHgpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG4gIHNldFJlbmRlcmluZ0ludGVudChvcElkeCwgaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhvcElkeCwgZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShvcElkeCwgc3RhdGVzKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3RhdGVzKSB7XG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aChvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbihvcElkeCwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2gob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KG9wSWR4LCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3Mob3BJZHgsIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQob3BJZHgsIHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VBbHBoYVwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQWxwaGFcIiwgb3BJZHgpO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcIlNNYXNrXCIsIG9wSWR4KTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcbiAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbHRlclwiLCBvcElkeCk7XG4gICAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRGaWx0ZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgaW5TTWFza01vZGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5zdXNwZW5kZWRDdHg7XG4gIH1cbiAgY2hlY2tTTWFza1N0YXRlKCkge1xuICAgIGNvbnN0IGluU01hc2tNb2RlID0gdGhpcy5pblNNYXNrTW9kZTtcbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cbiAgYmVnaW5TTWFza01vZGUob3BJZHgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5zdXNwZW5kZWRDdHguZ2V0VHJhbnNmb3JtKCkpO1xuICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgY3R4KTtcbiAgICBtaXJyb3JDb250ZXh0T3BlcmF0aW9ucyhjdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLmNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG4gIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgICBjb25zdCBsYXllck9mZnNldFggPSBsYXllckJveFswXTtcbiAgICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gICAgY29uc3QgbGF5ZXJIZWlnaHQgPSBsYXllckJveFszXSAtIGxheWVyT2Zmc2V0WTtcbiAgICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdlbmVyaWNDb21wb3NlU01hc2soc21hc2suY29udGV4dCwgbGF5ZXJDdHgsIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBzbWFzay5iYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICAgIGxldCBtYXNrQ2FudmFzID0gbWFza0N0eC5jYW52YXM7XG4gICAgbGV0IG1hc2tYID0gbGF5ZXJPZmZzZXRYIC0gbWFza09mZnNldFg7XG4gICAgbGV0IG1hc2tZID0gbGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFk7XG4gICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICBpZiAobWFza1ggPCAwIHx8IG1hc2tZIDwgMCB8fCBtYXNrWCArIHdpZHRoID4gbWFza0NhbnZhcy53aWR0aCB8fCBtYXNrWSArIGhlaWdodCA+IG1hc2tDYW52YXMuaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0V4dGVuc2lvblwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmNvbnRleHQ7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgLW1hc2tYLCAtbWFza1kpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1hdG9wXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcDtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICAgICAgICBtYXNrQ2FudmFzID0gY2FudmFzLmNhbnZhcztcbiAgICAgICAgbWFza1ggPSBtYXNrWSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgICAgIG1hc2tDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBjbGlwLnJlY3QobWFza1gsIG1hc2tZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5jbGlwKGNsaXApO1xuICAgICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwiZGVzdGluYXRpb24tYXRvcFwiO1xuICAgICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wO1xuICAgICAgICBtYXNrQ3R4LmZpbGxSZWN0KG1hc2tYLCBtYXNrWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXllckN0eC5zYXZlKCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGxheWVyQ3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBpZiAoc3VidHlwZSA9PT0gXCJBbHBoYVwiICYmIHRyYW5zZmVyTWFwKSB7XG4gICAgICBsYXllckN0eC5maWx0ZXIgPSB0aGlzLmZpbHRlckZhY3RvcnkuYWRkQWxwaGFGaWx0ZXIodHJhbnNmZXJNYXApO1xuICAgIH0gZWxzZSBpZiAoc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIpIHtcbiAgICAgIGxheWVyQ3R4LmZpbHRlciA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRMdW1pbm9zaXR5RmlsdGVyKHRyYW5zZmVyTWFwKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIHdpZHRoLCBoZWlnaHQpO1xuICAgIGxheWVyQ3R4LmNsaXAoY2xpcCk7XG4gICAgbGF5ZXJDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJkZXN0aW5hdGlvbi1pblwiO1xuICAgIGxheWVyQ3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrWCwgbWFza1ksIHdpZHRoLCBoZWlnaHQsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBsYXllckN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgc2F2ZShvcElkeCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICB9XG4gIHJlc3RvcmUob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXN0b3JlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCB0aGlzLmN0eCk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG4gIHRyYW5zZm9ybShvcElkeCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcInRyYW5zZm9ybVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wSWR4LCBvcCwgZGF0YSwgbWluTWF4KSB7XG4gICAgbGV0IFtwYXRoXSA9IGRhdGE7XG4gICAgaWYgKCFtaW5NYXgpIHtcbiAgICAgIHBhdGggfHw9IGRhdGFbMF0gPSBuZXcgUGF0aDJEKCk7XG4gICAgICB0aGlzW29wXShvcElkeCwgcGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBvdXRlckV4dHJhU2l6ZSA9IG9wID09PSBPUFMuc3Ryb2tlID8gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCAvIDIgOiAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBtaW5NYXhbMF0gLSBvdXRlckV4dHJhU2l6ZSwgbWluTWF4WzJdICsgb3V0ZXJFeHRyYVNpemUsIG1pbk1heFsxXSAtIG91dGVyRXh0cmFTaXplLCBtaW5NYXhbM10gKyBvdXRlckV4dHJhU2l6ZSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBbXCJ0cmFuc2Zvcm1cIl0pO1xuICAgIH1cbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgUGF0aDJEKSkge1xuICAgICAgcGF0aCA9IGRhdGFbMF0gPSBtYWtlUGF0aEZyb21EcmF3T1BTKHBhdGgpO1xuICAgIH1cbiAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KG1pbk1heCwgZ2V0Q3VycmVudFRyYW5zZm9ybSh0aGlzLmN0eCksIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgIHRoaXNbb3BdKG9wSWR4LCBwYXRoKTtcbiAgICB0aGlzLl9wYXRoU3RhcnRJZHggPSBvcElkeDtcbiAgfVxuICBjbG9zZVBhdGgob3BJZHgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuICBzdHJva2Uob3BJZHgsIHBhdGgsIGNvbnN1bWVQYXRoID0gdHJ1ZSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcbiAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgaWYgKHR5cGVvZiBzdHJva2VDb2xvciA9PT0gXCJvYmplY3RcIiAmJiBzdHJva2VDb2xvcj8uZ2V0UGF0dGVybikge1xuICAgICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3Ryb2tlQ29sb3IuaXNNb2RpZnlpbmdDdXJyZW50VHJhbnNmb3JtKCkgPyBjdHguZ2V0VHJhbnNmb3JtKCkgOiBudWxsO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuU1RST0tFLCBvcElkeCk7XG4gICAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgY3R4LmdldFRyYW5zZm9ybSgpLmludmVydFNlbGYoKS5tdWx0aXBseVNlbGYoYmFzZVRyYW5zZm9ybSkpO1xuICAgICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzY2FsZUFuZFN0cm9rZShwYXRoLCBmYWxzZSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UocGF0aCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnN0cm9rZSk7XG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChQYXRoVHlwZS5TVFJPS0UsIGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgZmlsbChvcElkeCwgcGF0aCwgY29uc3VtZVBhdGggPSB0cnVlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGxldCBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gZmlsbENvbG9yLmlzTW9kaWZ5aW5nQ3VycmVudFRyYW5zZm9ybSgpID8gY3R4LmdldFRyYW5zZm9ybSgpIDogbnVsbDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnNhdmUob3BJZHgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIGlmIChiYXNlVHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihiYXNlVHJhbnNmb3JtKSk7XG4gICAgICAgIHBhdGggPSBuZXdQYXRoO1xuICAgICAgfVxuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChwYXRoLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwocGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpO1xuICAgIGlmIChuZWVkUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc3RvcmUob3BJZHgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgob3BJZHgsIHBhdGgsIGludGVyc2VjdCk7XG4gICAgfVxuICB9XG4gIGVvRmlsbChvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsKG9wSWR4LCBwYXRoLCBmYWxzZSk7XG4gICAgdGhpcy5zdHJva2Uob3BJZHgsIHBhdGgsIGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlb0ZpbGxTdHJva2Uob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZShvcElkeCwgcGF0aCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBjbG9zZUVPRmlsbFN0cm9rZShvcElkeCwgcGF0aCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKG9wSWR4LCBwYXRoKTtcbiAgfVxuICBlbmRQYXRoKG9wSWR4LCBwYXRoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aChvcElkeCwgcGF0aCk7XG4gIH1cbiAgcmF3RmlsbFBhdGgob3BJZHgsIHBhdGgpIHtcbiAgICB0aGlzLmN0eC5maWxsKHBhdGgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnJhd0ZpbGxQYXRoKS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIGNsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBOT1JNQUxfQ0xJUDtcbiAgfVxuICBlb0NsaXAob3BJZHgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcE1vZGVcIiwgb3BJZHgpO1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG4gIGJlZ2luVGV4dChvcElkeCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZW5NYXJrZXIob3BJZHgpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwic2FtZUxpbmVUZXh0XCIpLnJlc2V0SW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICB9XG4gIGVuZFRleHQob3BJZHgpIHtcbiAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlclxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgZGVwZW5kZW5jeVRyYWNrZXIuZ2V0T3Blbk1hcmtlcigpKS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpO1xuICAgICAgfVxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXIucmVjb3JkQ2xvc2VNYXJrZXIob3BJZHgpO1xuICAgIH1cbiAgICBpZiAocGF0aHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgIGNvbnN0IGludlRyYW5zZiA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgcGF0aFxuICAgICAgfSBvZiBwYXRocykge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdQYXRoLmFkZFBhdGgocGF0aCwgbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pLnByZU11bHRpcGx5U2VsZihpbnZUcmFuc2YpLnRyYW5zbGF0ZSh4LCB5KS5zY2FsZShmb250U2l6ZSwgLWZvbnRTaXplKSk7XG4gICAgICB9XG4gICAgICBjdHguY2xpcChuZXdQYXRoKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJjaGFyU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhvcElkeCwgc3BhY2luZykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJ3b3JkU3BhY2luZ1wiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUob3BJZHgsIHNjYWxlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImhTY2FsZVwiLCBvcElkeCk7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRMZWFkaW5nKG9wSWR4LCBsZWFkaW5nKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImxlYWRpbmdcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChvcElkeCwgZm9udFJlZk5hbWUsIHNpemUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZm9udFwiLCBvcElkeCkucmVjb3JkU2ltcGxlRGF0YUZyb21OYW1lZChcImZvbnRPYmpcIiwgZm9udFJlZk5hbWUsIG9wSWR4KTtcbiAgICBjb25zdCBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChmb250UmVmTmFtZSk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBpZiAoIWZvbnRPYmopIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBmb250IGZvciAke2ZvbnRSZWZOYW1lfWApO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGZvbnQgbWF0cml4IGZvciBmb250IFwiICsgZm9udFJlZk5hbWUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGNvbnN0IHR5cGVmYWNlID0gZm9udE9iai5zeXN0ZW1Gb250SW5mbz8uY3NzIHx8IGBcIiR7bmFtZX1cIiwgJHtmb250T2JqLmZhbGxiYWNrTmFtZX1gO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcbiAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgfSBlbHNlIGlmIChmb250T2JqLmJvbGQpIHtcbiAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICB9XG4gICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcbiAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1JTl9GT05UX1NJWkU7XG4gICAgfSBlbHNlIGlmIChzaXplID4gTUFYX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgIHRoaXMuY3R4LmZvbnQgPSBgJHtpdGFsaWN9ICR7Ym9sZH0gJHticm93c2VyRm9udFNpemV9cHggJHt0eXBlZmFjZX1gO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG9wSWR4LCBtb2RlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSZW5kZXJpbmdNb2RlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG4gIHNldFRleHRSaXNlKG9wSWR4LCByaXNlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInRleHRSaXNlXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSByaXNlO1xuICB9XG4gIG1vdmVUZXh0KG9wSWR4LCB4LCB5KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRJbmNyZW1lbnRhbERhdGEoXCJzYW1lTGluZVRleHRcIikucmVjb3JkSW5jcmVtZW50YWxEYXRhKFwibW92ZVRleHRcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYICs9IHg7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgKz0geTtcbiAgfVxuICBzZXRMZWFkaW5nTW92ZVRleHQob3BJZHgsIHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcob3BJZHgsIC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KG9wSWR4LCB4LCB5KTtcbiAgfVxuICBzZXRUZXh0TWF0cml4KG9wSWR4LCBtYXRyaXgpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEluY3JlbWVudGFsRGF0YShcInNhbWVMaW5lVGV4dFwiKS5yZWNvcmRTaW1wbGVEYXRhKFwidGV4dE1hdHJpeFwiLCBvcElkeCk7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFxuICAgIH0gPSB0aGlzO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IG1hdHJpeDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IE1hdGguaHlwb3QobWF0cml4WzBdLCBtYXRyaXhbMV0pO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICB9XG4gIG5leHRMaW5lKG9wSWR4KSB7XG4gICAgdGhpcy5tb3ZlVGV4dChvcElkeCwgMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEluY3JlbWVudGFsRGF0YShcIm1vdmVUZXh0XCIsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIuZ2V0U2ltcGxlSW5kZXgoXCJsZWFkaW5nXCIpID8/IG9wSWR4KTtcbiAgfVxuICAjZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCB0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCBuZXdQYXRoID0gbmV3IFBhdGgyRCgpO1xuICAgIG5ld1BhdGguYWRkUGF0aChwYXRoLCBuZXcgRE9NTWF0cml4KHRyYW5zZm9ybSkuaW52ZXJ0U2VsZigpLm11bHRpcGx5U2VsZihjdXJyZW50VHJhbnNmb3JtKSk7XG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH1cbiAgcGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBjb25zdCBwYXR0ZXJuU3Ryb2tlID0gY3VycmVudC5wYXR0ZXJuU3Ryb2tlICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgIGxldCBwYXRoO1xuICAgIGlmICgoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkgJiYgIWZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgIHBhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cbiAgICBpZiAocGF0aCAmJiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgcGF0dGVybkZpbGwgfHwgcGF0dGVyblN0cm9rZSkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCAtZm9udFNpemUpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250KTtcbiAgICAgIGxldCBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBpZiAocGF0dGVybkZpbGxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVybkZpbGxUcmFuc2Zvcm0pO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFBhdGggPSB0aGlzLiNnZXRTY2FsZWRQYXRoKHBhdGgsIGN1cnJlbnRUcmFuc2Zvcm0sIHBhdHRlcm5GaWxsVHJhbnNmb3JtKTtcbiAgICAgICAgICBjdHguZmlsbChzY2FsZWRQYXRoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSB8fD0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIGIsXG4gICAgICAgICAgICBjLFxuICAgICAgICAgICAgZFxuICAgICAgICAgIH0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICAgIGNvbnN0IGludlBhdHRlcm5UcmFuc2Zvcm0gPSBVdGlsLmludmVyc2VUcmFuc2Zvcm0ocGF0dGVyblN0cm9rZVRyYW5zZm9ybSk7XG4gICAgICAgICAgY29uc3QgdHJhbnNmID0gVXRpbC50cmFuc2Zvcm0oW2EsIGIsIGMsIGQsIDAsIDBdLCBpbnZQYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZiwgWFkpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggKj0gTWF0aC5tYXgoWFlbMF0sIFhZWzFdKSAvIGZvbnRTaXplO1xuICAgICAgICAgIGN0eC5zdHJva2UodGhpcy4jZ2V0U2NhbGVkUGF0aChwYXRoLCBjdXJyZW50VHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCAvPSBmb250U2l6ZTtcbiAgICAgICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5maWxsVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRDaGFyYWN0ZXJCQm94KG9wSWR4LCBjdHgsIGZvbnQsIGZvbnRTaXplLCB4LCB5LCAoKSA9PiBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKSkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMuc3Ryb2tlKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlVGV4dChjaGFyYWN0ZXIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNBZGRUb1BhdGhTZXQpIHtcbiAgICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzIHx8PSBbXTtcbiAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICB0cmFuc2Zvcm06IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIHBhdGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBmb250LCBmb250U2l6ZSwgeCwgeSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cbiAgc2hvd1RleHQob3BJZHgsIGdseXBocykge1xuICAgIGlmICh0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLnNob3dUZXh0KS5yZXNldEJCb3gob3BJZHgpO1xuICAgICAgaWYgKHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIFRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwidGV4dENsaXBcIiwgb3BJZHgpLmluaGVyaXRQZW5kaW5nRGVwZW5kZW5jaWVzQXNGdXR1cmVGb3JjZWREZXBlbmRlbmNpZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICB0aGlzLnNob3dUeXBlM1RleHQob3BJZHgsIGdseXBocyk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG4gICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChjdXJyZW50LnRleHRNYXRyaXgpIHtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSArIGN1cnJlbnQudGV4dFJpc2UpO1xuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cbiAgICBsZXQgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm07XG4gICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLkZJTEwsIG9wSWR4KTtcbiAgICAgIHBhdHRlcm5GaWxsVHJhbnNmb3JtID0gZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudC5wYXR0ZXJuU3Ryb2tlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCksIFBhdGhUeXBlLlNUUk9LRSwgb3BJZHgpO1xuICAgICAgcGF0dGVyblN0cm9rZVRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBsZXQgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgY29uc3Qgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcbiAgICBpZiAoc2NhbGUgPT09IDAgfHwgbGluZVdpZHRoID09PSAwKSB7XG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBUZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBUZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IFRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuICAgIGlmIChmb250U2l6ZVNjYWxlICE9PSAxLjApIHtcbiAgICAgIGN0eC5zY2FsZShmb250U2l6ZVNjYWxlLCBmb250U2l6ZVNjYWxlKTtcbiAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgIH1cbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGlmIChmb250LmlzSW52YWxpZFBERmpzRm9udCkge1xuICAgICAgY29uc3QgY2hhcnMgPSBbXTtcbiAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xuICAgICAgICBjaGFycy5wdXNoKGdseXBoLnVuaWNvZGUpO1xuICAgICAgICB3aWR0aCArPSBnbHlwaC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvaW5lZENoYXJzID0gY2hhcnMuam9pbihcIlwiKTtcbiAgICAgIGN0eC5maWxsVGV4dChqb2luZWRDaGFycywgMCwgMCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlciAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGpvaW5lZENoYXJzKTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlci5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgLW1lYXN1cmUuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQsIC1tZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LCBtZWFzdXJlLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCkucmVjb3JkU2hvd1RleHRPcGVyYXRpb24ob3BJZHgpO1xuICAgICAgfVxuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKiB0ZXh0SFNjYWxlO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZSgpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IHggPSAwLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBjb25zdCBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBtZWFzdXJlO1xuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBtZWFzdXJlID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcik7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVkV2lkdGggPSBtZWFzdXJlLndpZHRoICogMTAwMCAvIGZvbnRTaXplICogZm9udFNpemVTY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoIDwgbWVhc3VyZWRXaWR0aCAmJiB0aGlzLmlzRm9udFN1YnBpeGVsQUFFbmFibGVkKSB7XG4gICAgICAgICAgY29uc3QgY2hhcmFjdGVyU2NhbGVYID0gd2lkdGggLyBtZWFzdXJlZFdpZHRoO1xuICAgICAgICAgIHJlc3RvcmVOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGNoYXJhY3RlclNjYWxlWCwgMSk7XG4gICAgICAgICAgc2NhbGVkWCAvPSBjaGFyYWN0ZXJTY2FsZVg7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICBzY2FsZWRYICs9ICh3aWR0aCAtIG1lYXN1cmVkV2lkdGgpIC8gMjAwMCAqIGZvbnRTaXplIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2hhcmFjdGVyQkJveChvcElkeCwgY3R4LCBtZWFzdXJlID8ge1xuICAgICAgICAgICAgYmJveDogbnVsbFxuICAgICAgICAgIH0gOiBmb250LCBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGUsIHNjYWxlZFgsIHNjYWxlZFksICgpID0+IG1lYXN1cmUgPz8gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3RlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFpbnRDaGFyKG9wSWR4LCBjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5GaWxsVHJhbnNmb3JtLCBwYXR0ZXJuU3Ryb2tlVHJhbnNmb3JtKTtcbiAgICAgICAgICBpZiAoYWNjZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFkgPSBzY2FsZWRZIC0gZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIob3BJZHgsIGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVybkZpbGxUcmFuc2Zvcm0sIHBhdHRlcm5TdHJva2VUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaG93VGV4dE9wZXJhdGlvbihvcElkeCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBzaG93VHlwZTNUZXh0KG9wSWR4LCBnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG4gICAgaWYgKGlzVGV4dEludmlzaWJsZSB8fCBmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID0gLTE7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBpZiAoY3VycmVudC50ZXh0TWF0cml4KSB7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgfVxuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcbiAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgZm9udERpcmVjdGlvbik7XG4gICAgY29uc3QgZGVwZW5kZW5jeVRyYWNrZXIgPSB0aGlzLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlciA/IG5ldyBDYW52YXNOZXN0ZWREZXBlbmRlbmN5VHJhY2tlcihkZXBlbmRlbmN5VHJhY2tlciwgb3BJZHgpIDogbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgIHdhcm4oYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZm9udE1hdHJpeCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHAgPSBbZ2x5cGgud2lkdGgsIDBdO1xuICAgICAgVXRpbC5hcHBseVRyYW5zZm9ybShwLCBmb250TWF0cml4KTtcbiAgICAgIHdpZHRoID0gcFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBpZiAoZGVwZW5kZW5jeVRyYWNrZXIpIHtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPSBkZXBlbmRlbmN5VHJhY2tlcjtcbiAgICB9XG4gIH1cbiAgc2V0Q2hhcldpZHRoKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCkge31cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKG9wSWR4LCB4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgY29uc3QgY2xpcCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjbGlwLnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpLnJlY29yZENsaXBCb3gob3BJZHgsIHRoaXMuY3R4LCBsbHgsIHVyeCwgbGx5LCB1cnkpO1xuICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4ob3BJZHgsIElSKSB7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGNvbnN0IGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHtcbiAgICAgICAgY3JlYXRlQ2FudmFzR3JhcGhpY3M6IChjdHgsIHJlbmRlcmluZ09wSWR4KSA9PiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgIG1hcmtlZENvbnRlbnRTdGFjazogdGhpcy5tYXJrZWRDb250ZW50U3RhY2tcbiAgICAgICAgfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXIgPyBuZXcgQ2FudmFzTmVzdGVkRGVwZW5kZW5jeVRyYWNrZXIodGhpcy5kZXBlbmRlbmN5VHJhY2tlciwgcmVuZGVyaW5nT3BJZHgsIHRydWUpIDogbnVsbClcbiAgICAgIH07XG4gICAgICBwYXR0ZXJuID0gbmV3IFRpbGluZ1BhdHRlcm4oSVIsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgSVJbMV0sIElSWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKG9wSWR4LCAuLi5hcmdzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IHRydWU7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihvcElkeCwgLi4uYXJncykge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJmaWxsQ29sb3JcIiwgb3BJZHgpO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKG9wSWR4LCBhcmdzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKG9wSWR4LCBjb2xvcikge1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZFNpbXBsZURhdGEoXCJzdHJva2VDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldFN0cm9rZVRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcInN0cm9rZUNvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVyblN0cm9rZSA9IGZhbHNlO1xuICB9XG4gIHNldEZpbGxSR0JDb2xvcihvcElkeCwgY29sb3IpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRTaW1wbGVEYXRhKFwiZmlsbENvbG9yXCIsIG9wSWR4KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gIH1cbiAgc2V0RmlsbFRyYW5zcGFyZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkU2ltcGxlRGF0YShcImZpbGxDb2xvclwiLCBvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvcElkeCwgb2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAodGhpcy5jYWNoZWRQYXR0ZXJucy5oYXMob2JqSWQpKSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5jYWNoZWRQYXR0ZXJucy5nZXQob2JqSWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gZ2V0U2hhZGluZ1BhdHRlcm4odGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvcElkeCwgb2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvcElkeCwgb2JqSWQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpLCBQYXRoVHlwZS5TSEFESU5HLCBvcElkeCk7XG4gICAgY29uc3QgaW52ID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgbWluTWF4ID0gTUlOX01BWF9JTklULnNsaWNlKCk7XG4gICAgICBVdGlsLmF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52LCBtaW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IG1pbk1heDtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KC0xZTEwLCAtMWUxMCwgMmUxMCwgMmUxMCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRnVsbFBhZ2VCQm94KG9wSWR4KS5yZWNvcmREZXBlbmRlbmNpZXMob3BJZHgsIERlcGVuZGVuY2llcy50cmFuc2Zvcm0pLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gIH1cbiAgYmVnaW5JbmxpbmVJbWFnZSgpIHtcbiAgICB1bnJlYWNoYWJsZShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgIHVucmVhY2hhYmxlKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbihvcElkeCwgbWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZShvcElkeCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKG9wSWR4LCAuLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICBpZiAoYmJveCkge1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChiYm94LCB0aGlzLmJhc2VUcmFuc2Zvcm0sIHRoaXMuY3VycmVudC5taW5NYXgpO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IGJib3g7XG4gICAgICBjb25zdCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgICAgY2xpcC5yZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB0aGlzLmN0eC5jbGlwKGNsaXApO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQ2xpcEJveChvcElkeCwgdGhpcy5jdHgsIHgwLCB4MSwgeTAsIHkxKTtcbiAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQob3BJZHgpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlKG9wSWR4KTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgIGluZm8oXCJUT0RPOiBTdXBwb3J0IG5vbi1pc29sYXRlZCBncm91cHMuXCIpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAua25vY2tvdXQpIHtcbiAgICAgIHdhcm4oXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgIFV0aWwuYXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgZ2V0Q3VycmVudFRyYW5zZm9ybShjdXJyZW50Q3R4KSwgYm91bmRzKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICBjYWNoZUlkICs9IFwiX3NtYXNrX1wiICsgdGhpcy5zbWFza0NvdW50ZXIrKyAlIDI7XG4gICAgfVxuICAgIGNvbnN0IHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgZ3JvdXBDdHgudHJhbnNsYXRlKC1vZmZzZXRYLCAtb2Zmc2V0WSk7XG4gICAgZ3JvdXBDdHgudHJhbnNmb3JtKC4uLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIGxldCBjbGlwID0gbmV3IFBhdGgyRCgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBncm91cC5iYm94O1xuICAgIGNsaXAucmVjdCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoLmFkZFBhdGgoY2xpcCwgbmV3IERPTU1hdHJpeChncm91cC5tYXRyaXgpKTtcbiAgICAgIGNsaXAgPSBwYXRoO1xuICAgIH1cbiAgICBncm91cEN0eC5jbGlwKGNsaXApO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc3VidHlwZTogZ3JvdXAuc21hc2suc3VidHlwZSxcbiAgICAgICAgYmFja2Ryb3A6IGdyb3VwLnNtYXNrLmJhY2tkcm9wLFxuICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRUcmFuc2Zvcm1JbnZlcnNlOiBudWxsXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFncm91cC5zbWFzayB8fCB0aGlzLmRlcGVuZGVuY3lUcmFja2VyKSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zYXZlKCk7XG4gICAgfVxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5pbmhlcml0U2ltcGxlRGF0YUFzRnV0dXJlRm9yY2VkRGVwZW5kZW5jaWVzKFtcImZpbGxBbHBoYVwiLCBcInN0cm9rZUFscGhhXCIsIFwiZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uXCJdKS5wdXNoQmFzZVRyYW5zZm9ybShjdXJyZW50Q3R4KTtcbiAgICB0aGlzLnNldEdTdGF0ZShvcElkeCwgW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCsrO1xuICB9XG4gIGVuZEdyb3VwKG9wSWR4LCBncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5wb3BCYXNlVHJhbnNmb3JtKCk7XG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICBpZiAodGhpcy5kZXBlbmRlbmN5VHJhY2tlcikge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZShvcElkeCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IE1JTl9NQVhfSU5JVC5zbGljZSgpO1xuICAgICAgVXRpbC5heGlhbEFsaWduZWRCb3VuZGluZ0JveChbMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0XSwgY3VycmVudE10eCwgZGlydHlCb3gpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24ob3BJZHgsIGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5zYXZlKG9wSWR4KTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBVdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKGdldEN1cnJlbnRUcmFuc2Zvcm0odGhpcy5jdHgpLCBYWSk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB2aWV3cG9ydFNjYWxlXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHRoaXMub3V0cHV0U2NhbGVYICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiB0aGlzLm91dHB1dFNjYWxlWSAqIHZpZXdwb3J0U2NhbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2FudmFzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwLnNldChpZCwgY2FudmFzKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oWFlbMF0sIDAsIDAsIC1YWVsxXSwgMCwgaGVpZ2h0ICogWFlbMV0pO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICAgIHRoaXMuZW5kUGF0aChvcElkeCk7XG4gICAgICAgIGNvbnN0IGNsaXAgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIGNsaXAucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcChjbGlwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4udHJhbnNmb3JtKTtcbiAgICB0aGlzLnRyYW5zZm9ybShvcElkeCwgLi4ubWF0cml4KTtcbiAgfVxuICBlbmRBbm5vdGF0aW9uKG9wSWR4KSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy4jZHJhd0ZpbHRlcigpO1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0KG9wSWR4LCBpbWcpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKG9wSWR4LCBpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KS5yZWNvcmRCQm94KG9wSWR4LCB0aGlzLmN0eCwgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFggKyBtYXNrQ2FudmFzLndpZHRoLCBtYXNrLm9mZnNldFksIG1hc2sub2Zmc2V0WSArIG1hc2tDYW52YXMuaGVpZ2h0KS5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0KG9wSWR4LCBpbWcsIHNjYWxlWCwgc2tld1ggPSAwLCBza2V3WSA9IDAsIHNjYWxlWSwgcG9zaXRpb25zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KG9wSWR4LCBpbWcuZGF0YSwgaW1nKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LnRyYW5zZm9ybShzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCAwLCAwKTtcbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhvcElkeCwgaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IHRyYW5zID0gVXRpbC50cmFuc2Zvcm0oY3VycmVudFRyYW5zZm9ybSwgW3NjYWxlWCwgc2tld1gsIHNrZXdZLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0pO1xuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgdHJhbnNbNF0sIHRyYW5zWzVdKTtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZEJCb3gob3BJZHgsIHRoaXMuY3R4LCB0cmFuc1s0XSwgdHJhbnNbNF0gKyBtYXNrLmNhbnZhcy53aWR0aCwgdHJhbnNbNV0sIHRyYW5zWzVdICsgbWFzay5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKG9wSWR4LCBpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkRGVwZW5kZW5jaWVzKG9wSWR4LCBEZXBlbmRlbmNpZXMudHJhbnNmb3JtQW5kRmlsbCk7XG4gICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgdHJhbnNmb3JtXG4gICAgICB9ID0gaW1hZ2U7XG4gICAgICBjb25zdCBtYXNrQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJtYXNrQ2FudmFzXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgY29uc3QgaW1nID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoY3R4KSwgUGF0aFR5cGUuRklMTCwgb3BJZHgpIDogZmlsbENvbG9yO1xuICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIG1hc2tDdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVjb3JkQkJveChvcElkeCwgY3R4LCAwLCB3aWR0aCwgMCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gIH1cbiAgcGFpbnRJbWFnZVhPYmplY3Qob3BJZHgsIG9iaklkKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvcElkeCwgb2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgd2FybihcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Qob3BJZHgsIGltZ0RhdGEpO1xuICB9XG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0KG9wSWR4LCBvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob3BJZHgsIG9iaklkKTtcbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgIHdhcm4oXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgbWFwID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KG9wSWR4LCBpbWdEYXRhKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUob3BJZHgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbHRlclxuICAgIH0gPSBjdHg7XG4gICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICBjdHguZmlsdGVyID0gXCJub25lXCI7XG4gICAgfVxuICAgIGN0eC5zY2FsZSgxIC8gd2lkdGgsIC0xIC8gaGVpZ2h0KTtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9CaXRtYXAoaW1nRGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgPT09IFwiZnVuY3Rpb25cIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgIWltZ0RhdGEuZGF0YSkge1xuICAgICAgaW1nVG9QYWludCA9IGltZ0RhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiaW5saW5lSW1hZ2VcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICAgIHB1dEJpbmFyeUltYWdlRGF0YSh0bXBDdHgsIGltZ0RhdGEpO1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyh0bXBDdHgpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWQgPSB0aGlzLl9zY2FsZUltYWdlKGltZ1RvUGFpbnQsIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkpO1xuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoZ2V0Q3VycmVudFRyYW5zZm9ybShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZXNldEJCb3gob3BJZHgpLnJlY29yZEJCb3gob3BJZHgsIGN0eCwgMCwgd2lkdGgsIC1oZWlnaHQsIDApLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmltYWdlWE9iamVjdCkucmVjb3JkT3BlcmF0aW9uKG9wSWR4KTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUob3BJZHgpO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXAob3BJZHgsIGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8ucmVzZXRCQm94KG9wSWR4KTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIG1hcCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0oLi4uZW50cnkudHJhbnNmb3JtKTtcbiAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBpbWdUb1BhaW50LCBlbnRyeS54LCBlbnRyeS55LCBlbnRyeS53LCBlbnRyeS5oLCAwLCAtMSwgMSwgMSk7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRCQm94KG9wSWR4LCBjdHgsIDAsIDEsIC0xLCAwKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKG9wSWR4KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LnJlc2V0QkJveChvcElkeCkucmVjb3JkQkJveChvcElkeCwgdGhpcy5jdHgsIDAsIDEsIDAsIDEpLnJlY29yZERlcGVuZGVuY2llcyhvcElkeCwgRGVwZW5kZW5jaWVzLmZpbGwpLnJlY29yZE9wZXJhdGlvbihvcElkeCk7XG4gICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgbWFya1BvaW50KG9wSWR4LCB0YWcpIHt9XG4gIG1hcmtQb2ludFByb3BzKG9wSWR4LCB0YWcsIHByb3BlcnRpZXMpIHt9XG4gIGJlZ2luTWFya2VkQ29udGVudChvcElkeCwgdGFnKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyhvcElkeCwgdGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uYmVnaW5NYXJrZWRDb250ZW50KG9wSWR4KTtcbiAgICBpZiAodGFnID09PSBcIk9DXCIpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KG9wSWR4KSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5VHJhY2tlcj8uZW5kTWFya2VkQ29udGVudChvcElkeCk7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG4gIGJlZ2luQ29tcGF0KG9wSWR4KSB7fVxuICBlbmRDb21wYXQob3BJZHgpIHt9XG4gIGNvbnN1bWVQYXRoKG9wSWR4LCBwYXRoLCBjbGlwQm94KSB7XG4gICAgY29uc3QgaXNFbXB0eSA9IHRoaXMuY3VycmVudC5pc0VtcHR5Q2xpcCgpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgdGhpcy5jb21wb3NlKGNsaXBCb3gpO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAocGF0aCwgXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jeVRyYWNrZXI/LmJib3hUb0NsaXBCb3hEcm9wT3BlcmF0aW9uKG9wSWR4KS5yZWNvcmRGdXR1cmVGb3JjZWREZXBlbmRlbmN5KFwiY2xpcFBhdGhcIiwgb3BJZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcGVuZGVuY3lUcmFja2VyPy5yZWNvcmRPcGVyYXRpb24ob3BJZHgpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveCh0aGlzLmN1cnJlbnQuY2xpcEJveCk7XG4gIH1cbiAgZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgpIHtcbiAgICAgIGNvbnN0IG0gPSBnZXRDdXJyZW50VHJhbnNmb3JtKHRoaXMuY3R4KTtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IDEgLyBNYXRoLm1pbihNYXRoLmFicyhtWzBdKSwgTWF0aC5hYnMobVszXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMobVswXSAqIG1bM10gLSBtWzJdICogbVsxXSk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChtWzBdLCBtWzJdKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KG1bMV0sIG1bM10pO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gTWF0aC5tYXgobm9ybVgsIG5vcm1ZKSAvIGFic0RldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGg7XG4gIH1cbiAgZ2V0U2NhbGVGb3JTdHJva2luZygpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhLFxuICAgICAgICBiLFxuICAgICAgICBjLFxuICAgICAgICBkXG4gICAgICB9ID0gdGhpcy5jdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgICBsZXQgc2NhbGVYLCBzY2FsZVk7XG4gICAgICBpZiAoYiA9PT0gMCAmJiBjID09PSAwKSB7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5hYnMoYSk7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5hYnMoZCk7XG4gICAgICAgIGlmIChub3JtWCA9PT0gbm9ybVkpIHtcbiAgICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSAxIC8gbm9ybVg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgICAgc2NhbGVYID0gc2NhbGVZID0gc2NhbGVkTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICBzY2FsZVggPSAxIC8gbm9ybVg7XG4gICAgICAgICAgc2NhbGVZID0gMSAvIG5vcm1ZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFhMaW5lV2lkdGggPSBub3JtWCAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBjb25zdCBzY2FsZWRZTGluZVdpZHRoID0gbm9ybVkgKiBsaW5lV2lkdGg7XG4gICAgICAgICAgc2NhbGVYID0gc2NhbGVkWExpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgc2NhbGVZID0gc2NhbGVkWUxpbmVXaWR0aCA8IDEgPyAxIC8gc2NhbGVkWUxpbmVXaWR0aCA6IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGFic0RldCA9IE1hdGguYWJzKGEgKiBkIC0gYiAqIGMpO1xuICAgICAgICBjb25zdCBub3JtWCA9IE1hdGguaHlwb3QoYSwgYik7XG4gICAgICAgIGNvbnN0IG5vcm1ZID0gTWF0aC5oeXBvdChjLCBkKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZIC8gYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YIC8gYWJzRGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2VBcmVhID0gbGluZVdpZHRoICogYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZID4gYmFzZUFyZWEgPyBub3JtWSAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCA+IGJhc2VBcmVhID8gbm9ybVggLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSBzY2FsZVg7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzFdID0gc2NhbGVZO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZztcbiAgfVxuICByZXNjYWxlQW5kU3Ryb2tlKHBhdGgsIHNhdmVSZXN0b3JlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4LFxuICAgICAgY3VycmVudDoge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gdGhpcy5nZXRTY2FsZUZvclN0cm9raW5nKCk7XG4gICAgaWYgKHNjYWxlWCA9PT0gc2NhbGVZKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gKGxpbmVXaWR0aCB8fCAxKSAqIHNjYWxlWDtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRhc2hlcyA9IGN0eC5nZXRMaW5lRGFzaCgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBTQ0FMRV9NQVRSSVguYSA9IDEgLyBzY2FsZVg7XG4gICAgU0NBTEVfTUFUUklYLmQgPSAxIC8gc2NhbGVZO1xuICAgIGNvbnN0IG5ld1BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgbmV3UGF0aC5hZGRQYXRoKHBhdGgsIFNDQUxFX01BVFJJWCk7XG4gICAgaWYgKGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgLz0gc2NhbGU7XG4gICAgfVxuICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggfHwgMTtcbiAgICBjdHguc3Ryb2tlKG5ld1BhdGgpO1xuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZW50VmlzaWJsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5tYXJrZWRDb250ZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mb3IgKGNvbnN0IG9wIGluIE9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW09QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS93b3JrZXJfb3B0aW9ucy5qc1xuY2xhc3MgR2xvYmFsV29ya2VyT3B0aW9ucyB7XG4gIHN0YXRpYyAjcG9ydCA9IG51bGw7XG4gIHN0YXRpYyAjc3JjID0gXCJcIjtcbiAgc3RhdGljIGdldCB3b3JrZXJQb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyUG9ydCh2YWwpIHtcbiAgICBpZiAoISh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbCBpbnN0YW5jZW9mIFdvcmtlcikgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJQb3J0YCB0eXBlLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jcG9ydCA9IHZhbDtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICByZXR1cm4gdGhpcy4jc3JjO1xuICB9XG4gIHN0YXRpYyBzZXQgd29ya2VyU3JjKHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGB3b3JrZXJTcmNgIHR5cGUuXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzcmMgPSB2YWw7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbWV0YWRhdGEuanNcbmNsYXNzIE1ldGFkYXRhIHtcbiAgI21hcDtcbiAgI2RhdGE7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYXJzZWREYXRhLFxuICAgIHJhd0RhdGFcbiAgfSkge1xuICAgIHRoaXMuI21hcCA9IHBhcnNlZERhdGE7XG4gICAgdGhpcy4jZGF0YSA9IHJhd0RhdGE7XG4gIH1cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG4gIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWFwLmVudHJpZXMoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9vcHRpb25hbF9jb250ZW50X2NvbmZpZy5qc1xuXG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKFwiSU5URVJOQUxcIik7XG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICNpc0Rpc3BsYXkgPSBmYWxzZTtcbiAgI2lzUHJpbnQgPSBmYWxzZTtcbiAgI3VzZXJTZXQgPSBmYWxzZTtcbiAgI3Zpc2libGUgPSB0cnVlO1xuICBjb25zdHJ1Y3RvcihyZW5kZXJpbmdJbnRlbnQsIHtcbiAgICBuYW1lLFxuICAgIGludGVudCxcbiAgICB1c2FnZSxcbiAgICByYkdyb3Vwc1xuICB9KSB7XG4gICAgdGhpcy4jaXNEaXNwbGF5ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZKTtcbiAgICB0aGlzLiNpc1ByaW50ID0gISEocmVuZGVyaW5nSW50ZW50ICYgUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmludGVudCA9IGludGVudDtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5yYkdyb3VwcyA9IHJiR3JvdXBzO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIGlmICh0aGlzLiN1c2VyU2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy4jdmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiN2aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHByaW50LFxuICAgICAgdmlld1xuICAgIH0gPSB0aGlzLnVzYWdlO1xuICAgIGlmICh0aGlzLiNpc0Rpc3BsYXkpIHtcbiAgICAgIHJldHVybiB2aWV3Py52aWV3U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1ByaW50KSB7XG4gICAgICByZXR1cm4gcHJpbnQ/LnByaW50U3RhdGUgIT09IFwiT0ZGXCI7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIF9zZXRWaXNpYmxlKGludGVybmFsLCB2aXNpYmxlLCB1c2VyU2V0ID0gZmFsc2UpIHtcbiAgICBpZiAoaW50ZXJuYWwgIT09IElOVEVSTkFMKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkludGVybmFsIG1ldGhvZCBgX3NldFZpc2libGVgIGNhbGxlZC5cIik7XG4gICAgfVxuICAgIHRoaXMuI3VzZXJTZXQgPSB1c2VyU2V0O1xuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG59XG5jbGFzcyBPcHRpb25hbENvbnRlbnRDb25maWcge1xuICAjY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gICNncm91cHMgPSBuZXcgTWFwKCk7XG4gICNpbml0aWFsSGFzaCA9IG51bGw7XG4gICNvcmRlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGRhdGEsIHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWSkge1xuICAgIHRoaXMucmVuZGVyaW5nSW50ZW50ID0gcmVuZGVyaW5nSW50ZW50O1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAocmVuZGVyaW5nSW50ZW50LCBncm91cCkpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb24gb2YgZGF0YS5vbikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvbikuX3NldFZpc2libGUoSU5URVJOQUwsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9mZiBvZiBkYXRhLm9mZikge1xuICAgICAgdGhpcy4jZ3JvdXBzLmdldChvZmYpLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuI2luaXRpYWxIYXNoID0gdGhpcy5nZXRIYXNoKCk7XG4gIH1cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRvciA9IGFycmF5WzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy4jZ3JvdXBzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBzdGF0ZSA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbWVudCkudmlzaWJsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2VsZW1lbnR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk9yXCI6XG4gICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJOb3RcIjpcbiAgICAgICAgICByZXR1cm4gIXN0YXRlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cbiAgaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgaWYgKHRoaXMuI2dyb3Vwcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgaW5mbyhcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2dyb3VwLmlkfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgaWYgKCFncm91cC5wb2xpY3kgfHwgZ3JvdXAucG9saWN5ID09PSBcIkFueU9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB3YXJuKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFsbE9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgd2FybihgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB3YXJuKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB3YXJuKGBVbmtub3duIGdyb3VwIHR5cGUgJHtncm91cC50eXBlfS5gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSwgcHJlc2VydmVSQiA9IHRydWUpIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoaWQpO1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIHdhcm4oYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJlc2VydmVSQiAmJiB2aXNpYmxlICYmIGdyb3VwLnJiR3JvdXBzLmxlbmd0aCkge1xuICAgICAgZm9yIChjb25zdCByYkdyb3VwIG9mIGdyb3VwLnJiR3JvdXBzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiByYkdyb3VwKSB7XG4gICAgICAgICAgaWYgKG90aGVySWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aGlzLiNncm91cHMuZ2V0KG90aGVySWQpPy5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBncm91cC5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlLCB0cnVlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBzZXRPQ0dTdGF0ZSh7XG4gICAgc3RhdGUsXG4gICAgcHJlc2VydmVSQlxuICB9KSB7XG4gICAgbGV0IG9wZXJhdG9yO1xuICAgIGZvciAoY29uc3QgZWxlbSBvZiBzdGF0ZSkge1xuICAgICAgc3dpdGNoIChlbGVtKSB7XG4gICAgICAgIGNhc2UgXCJPTlwiOlxuICAgICAgICBjYXNlIFwiT0ZGXCI6XG4gICAgICAgIGNhc2UgXCJUb2dnbGVcIjpcbiAgICAgICAgICBvcGVyYXRvciA9IGVsZW07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBncm91cCA9IHRoaXMuI2dyb3Vwcy5nZXQoZWxlbSk7XG4gICAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiT05cIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgdHJ1ZSwgcHJlc2VydmVSQik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPRkZcIjpcbiAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoZWxlbSwgZmFsc2UsIHByZXNlcnZlUkIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVG9nZ2xlXCI6XG4gICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KGVsZW0sICFncm91cC52aXNpYmxlLCBwcmVzZXJ2ZVJCKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2FjaGVkR2V0SGFzaCA9IG51bGw7XG4gIH1cbiAgZ2V0IGhhc0luaXRpYWxWaXNpYmlsaXR5KCkge1xuICAgIHJldHVybiB0aGlzLiNpbml0aWFsSGFzaCA9PT0gbnVsbCB8fCB0aGlzLmdldEhhc2goKSA9PT0gdGhpcy4jaW5pdGlhbEhhc2g7XG4gIH1cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLiNvcmRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuI29yZGVyLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBbLi4udGhpcy4jZ3JvdXBzLmtleXMoKV07XG4gIH1cbiAgZ2V0R3JvdXAoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZ3JvdXBzLmdldChpZCkgfHwgbnVsbDtcbiAgfVxuICBnZXRIYXNoKCkge1xuICAgIGlmICh0aGlzLiNjYWNoZWRHZXRIYXNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaDtcbiAgICB9XG4gICAgY29uc3QgaGFzaCA9IG5ldyBNdXJtdXJIYXNoM182NCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBncm91cF0gb2YgdGhpcy4jZ3JvdXBzKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtpZH06JHtncm91cC52aXNpYmxlfWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkR2V0SGFzaCA9IGhhc2guaGV4ZGlnZXN0KCk7XG4gIH1cbiAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5lbnRyaWVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdHJhbnNwb3J0X3N0cmVhbS5qc1xuXG5cbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsIHtcbiAgICBkaXNhYmxlUmFuZ2UgPSBmYWxzZSxcbiAgICBkaXNhYmxlU3RyZWFtID0gZmFsc2VcbiAgfSkge1xuICAgIGFzc2VydChwZGZEYXRhUmFuZ2VUcmFuc3BvcnQsICdQREZEYXRhVHJhbnNwb3J0U3RyZWFtIC0gbWlzc2luZyByZXF1aXJlZCBcInBkZkRhdGFSYW5nZVRyYW5zcG9ydFwiIGFyZ3VtZW50LicpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxlbmd0aCxcbiAgICAgIGluaXRpYWxEYXRhLFxuICAgICAgcHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWVcbiAgICB9ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX3F1ZXVlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIGlmIChpbml0aWFsRGF0YT8ubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gaW5pdGlhbERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGluaXRpYWxEYXRhLmJ5dGVMZW5ndGggPT09IGluaXRpYWxEYXRhLmJ1ZmZlci5ieXRlTGVuZ3RoID8gaW5pdGlhbERhdGEuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoaW5pdGlhbERhdGEpLmJ1ZmZlcjtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFkaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhZGlzYWJsZVJhbmdlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycyA9IFtdO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRSYW5nZUxpc3RlbmVyKChiZWdpbiwgY2h1bmspID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBiZWdpbixcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGNodW5rID0+IHtcbiAgICAgIHRoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVua1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHRoaXMuX29uUHJvZ3Jlc3NpdmVEb25lKCk7XG4gICAgfSk7XG4gICAgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cbiAgX29uUmVjZWl2ZURhdGEoe1xuICAgIGJlZ2luLFxuICAgIGNodW5rXG4gIH0pIHtcbiAgICBjb25zdCBidWZmZXIgPSBjaHVuayBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgY2h1bmsuYnl0ZUxlbmd0aCA9PT0gY2h1bmsuYnVmZmVyLmJ5dGVMZW5ndGggPyBjaHVuay5idWZmZXIgOiBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIGlmIChiZWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNvbWUoZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlUmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG4gICAgICBhc3NlcnQoZm91bmQsIFwiX29uUmVjZWl2ZURhdGEgLSBubyBgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyYCBpbnN0YW5jZSBmb3VuZC5cIik7XG4gICAgfVxuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzWzBdPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX29uUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG4gIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICBjb25zdCBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIodGhpcywgcXVldWVkQ2h1bmtzLCB0aGlzLl9wcm9ncmVzc2l2ZURvbmUsIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKTtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5yZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVhZGVycy5wdXNoKHJlYWRlcik7XG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IGlzUGRmRmlsZShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9jb250ZW50X2Rpc3Bvc2l0aW9uLmpzXG5cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgbGV0IG5lZWRzRW5jb2RpbmdGaXh1cCA9IHRydWU7XG4gIGxldCB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKlwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSB1bmVzY2FwZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmM1OTg3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuICB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcbiAgaWYgKHRtcCkge1xuICAgIHRtcCA9IHRtcFsxXTtcbiAgICBsZXQgZmlsZW5hbWUgPSByZmMyNjE2dW5xdW90ZSh0bXApO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyBcIlxcXFxzKj1cXFxccypcIiArIFwiKFwiICsgJ1teXCI7XFxcXHNdW147XFxcXHNdKicgKyBcInxcIiArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFxcIj8pK1wiPycgKyBcIilcIiwgZmxhZ3MpO1xuICB9XG4gIGZ1bmN0aW9uIHRleHRkZWNvZGUoZW5jb2RpbmcsIHZhbHVlKSB7XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBpZiAoIS9eW1xceDAwLVxceEZGXSskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gZml4dXBFbmNvZGluZyh2YWx1ZSkge1xuICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXAgJiYgL1tcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJ1dGYtOFwiLCB2YWx1ZSk7XG4gICAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwKSB7XG4gICAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcImlzby04ODU5LTFcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvblN0cikge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBbXTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgaXRlciA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqKCg/ITBcXFxcZClcXFxcZCspKFxcXFwqPylcIiwgXCJpZ1wiKTtcbiAgICB3aGlsZSAoKG1hdGNoID0gaXRlci5leGVjKGNvbnRlbnREaXNwb3NpdGlvblN0cikpICE9PSBudWxsKSB7XG4gICAgICBsZXQgWywgbiwgcXVvdCwgcGFydF0gPSBtYXRjaDtcbiAgICAgIG4gPSBwYXJzZUludChuLCAxMCk7XG4gICAgICBpZiAobiBpbiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtYXRjaGVzW25dID0gW3F1b3QsIHBhcnRdO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbWF0Y2hlcy5sZW5ndGg7ICsrbikge1xuICAgICAgaWYgKCEobiBpbiBtYXRjaGVzKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGxldCBbcXVvdCwgcGFydF0gPSBtYXRjaGVzW25dO1xuICAgICAgcGFydCA9IHJmYzI2MTZ1bnF1b3RlKHBhcnQpO1xuICAgICAgaWYgKHF1b3QpIHtcbiAgICAgICAgcGFydCA9IHVuZXNjYXBlKHBhcnQpO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIHBhcnQgPSByZmM1OTg3ZGVjb2RlKHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgfVxuICBmdW5jdGlvbiByZmMyNjE2dW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KCdcXFxcXCInKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcXVvdGluZGV4ID0gcGFydHNbaV0uaW5kZXhPZignXCInKTtcbiAgICAgICAgaWYgKHF1b3RpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnNsaWNlKDAsIHF1b3RpbmRleCk7XG4gICAgICAgICAgcGFydHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5yZXBsYWNlQWxsKC9cXFxcKC4pL2csIFwiJDFcIik7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJ1wiJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiByZmM1OTg3ZGVjb2RlKGV4dHZhbHVlKSB7XG4gICAgY29uc3QgZW5jb2RpbmdlbmQgPSBleHR2YWx1ZS5pbmRleE9mKFwiJ1wiKTtcbiAgICBpZiAoZW5jb2RpbmdlbmQgPT09IC0xKSB7XG4gICAgICByZXR1cm4gZXh0dmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IGVuY29kaW5nID0gZXh0dmFsdWUuc2xpY2UoMCwgZW5jb2RpbmdlbmQpO1xuICAgIGNvbnN0IGxhbmd2YWx1ZSA9IGV4dHZhbHVlLnNsaWNlKGVuY29kaW5nZW5kICsgMSk7XG4gICAgY29uc3QgdmFsdWUgPSBsYW5ndmFsdWUucmVwbGFjZSgvXlteJ10qJy8sIFwiXCIpO1xuICAgIHJldHVybiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjA0N2RlY29kZSh2YWx1ZSkge1xuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aChcIj0/XCIpIHx8IC9bXFx4MDAtXFx4MTlcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlQWxsKC89XFw/KFtcXHctXSopXFw/KFtRcUJiXSlcXD8oKD86W14/XXxcXD8oPyE9KSkqKVxcPz0vZywgZnVuY3Rpb24gKG1hdGNoZXMsIGNoYXJzZXQsIGVuY29kaW5nLCB0ZXh0KSB7XG4gICAgICBpZiAoZW5jb2RpbmcgPT09IFwicVwiIHx8IGVuY29kaW5nID09PSBcIlFcIikge1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKFwiX1wiLCBcIiBcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2VBbGwoLz0oWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uIChtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB0ZXh0ID0gYXRvYih0ZXh0KTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9uZXR3b3JrX3V0aWxzLmpzXG5cblxuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzKGlzSHR0cCwgaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGlmICghaXNIdHRwIHx8ICFodHRwSGVhZGVycyB8fCB0eXBlb2YgaHR0cEhlYWRlcnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbCA9IGh0dHBIZWFkZXJzW2tleV07XG4gICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoZWFkZXJzO1xufVxuZnVuY3Rpb24gZ2V0UmVzcG9uc2VPcmlnaW4odXJsKSB7XG4gIHJldHVybiBVUkwucGFyc2UodXJsKT8ub3JpZ2luID8/IG51bGw7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyh7XG4gIHJlc3BvbnNlSGVhZGVycyxcbiAgaXNIdHRwLFxuICByYW5nZUNodW5rU2l6ZSxcbiAgZGlzYWJsZVJhbmdlXG59KSB7XG4gIGNvbnN0IHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKHJlc3BvbnNlSGVhZGVycy5nZXQoXCJBY2NlcHQtUmFuZ2VzXCIpICE9PSBcImJ5dGVzXCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LUVuY29kaW5nXCIpIHx8IFwiaWRlbnRpdHlcIjtcbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IHJlc3BvbnNlSGVhZGVycy5nZXQoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCB7fVxuICAgIH1cbiAgICBpZiAoaXNQZGZGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZUV4Y2VwdGlvbihgVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKCR7c3RhdHVzfSkgd2hpbGUgcmV0cmlldmluZyBQREYgXCIke3VybH1cIi5gLCBzdGF0dXMsIHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZmV0Y2hfc3RyZWFtLmpzXG5cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIHZhbC5idWZmZXI7XG4gIH1cbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB3YXJuKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIF9yZXNwb25zZU9yaWdpbiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuaXNIdHRwLCBzb3VyY2UuaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICBhc3NlcnQoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVJhbmdlO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhzdHJlYW0uaGVhZGVycyk7XG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyhoZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgc3RyZWFtLl9yZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAoIXZhbGlkYXRlUmVzcG9uc2VTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyBjcmVhdGVSZXNwb25zZUVycm9yKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZS5oZWFkZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBpc0h0dHA6IHN0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihyZXNwb25zZUhlYWRlcnMpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoc3RyZWFtLmhlYWRlcnMpO1xuICAgIGhlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCByZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHJlc3BvbnNlLnVybCk7XG4gICAgICBpZiAocmVzcG9uc2VPcmlnaW4gIT09IHN0cmVhbS5fcmVzcG9uc2VPcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCByYW5nZSByZXNwb25zZS1vcmlnaW4gXCIke3Jlc3BvbnNlT3JpZ2lufVwiIHRvIG1hdGNoIFwiJHtzdHJlYW0uX3Jlc3BvbnNlT3JpZ2lufVwiLmApO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlUmVzcG9uc2VFcnJvcihyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbmV0d29yay5qc1xuXG5cbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuZnVuY3Rpb24gbmV0d29ya19nZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgY29uc3QgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ1RvQnl0ZXMoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBfcmVzcG9uc2VPcmlnaW4gPSBudWxsO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXJsLFxuICAgIGh0dHBIZWFkZXJzLFxuICAgIHdpdGhDcmVkZW50aWFsc1xuICB9KSB7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLmlzSHR0cCwgaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGFzc2VydChhcmdzLm9uRXJyb3IsIFwiRXhwZWN0ZWQgYG9uRXJyb3JgIGNhbGxiYWNrIHRvIGJlIHByb3ZpZGVkLlwiKTtcbiAgICB4aHIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGFyZ3Mub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICB9O1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLm9uU3RhdGVDaGFuZ2UuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQgPSBhcmdzLm9uSGVhZGVyc1JlY2VpdmVkO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSA9IGFyZ3Mub25Eb25lO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IgPSBhcmdzLm9uRXJyb3I7XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcyA9IGFyZ3Mub25Qcm9ncmVzcztcbiAgICB4aHIuc2VuZChudWxsKTtcbiAgICByZXR1cm4geGhySWQ7XG4gIH1cbiAgb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzPy4oZXZ0KTtcbiAgfVxuICBvblN0YXRlQ2hhbmdlKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhociA9IHBlbmRpbmdSZXF1ZXN0LnhocjtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQoKTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICB9XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICh4aHIuc3RhdHVzID09PSAwICYmIHRoaXMuaXNIdHRwKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gbmV0d29ya19nZXRBcnJheUJ1ZmZlcih4aHIpO1xuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgICBjaHVua1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4oYE1pc3Npbmcgb3IgaW52YWxpZCBcIkNvbnRlbnQtUmFuZ2VcIiBoZWFkZXIuYCk7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25Eb25lKHtcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICB9XG4gIH1cbiAgZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICB9XG4gIGlzUGVuZGluZ1JlcXVlc3QoeGhySWQpIHtcbiAgICByZXR1cm4geGhySWQgaW4gdGhpcy5wZW5kaW5nUmVxdWVzdHM7XG4gIH1cbiAgYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIHhoci5hYm9ydCgpO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuX21hbmFnZXIgPSBuZXcgTmV0d29ya01hbmFnZXIoc291cmNlKTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgYXNzZXJ0KCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCB0aGlzLl9zb3VyY2UpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihiZWdpbiwgZW5kKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgYmVnaW4sIGVuZCk7XG4gICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3Qoe1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfSk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIHRoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2luID0gZ2V0UmVzcG9uc2VPcmlnaW4oZnVsbFJlcXVlc3RYaHIucmVzcG9uc2VVUkwpO1xuICAgIGNvbnN0IHJhd1Jlc3BvbnNlSGVhZGVycyA9IGZ1bGxSZXF1ZXN0WGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKHJhd1Jlc3BvbnNlSGVhZGVycyA/IHJhd1Jlc3BvbnNlSGVhZGVycy50cmltU3RhcnQoKS5yZXBsYWNlKC9bXlxcUyBdKyQvLCBcIlwiKS5zcGxpdCgvW1xcclxcbl0rLykubWFwKHggPT4ge1xuICAgICAgY29uc3QgW2tleSwgLi4udmFsXSA9IHguc3BsaXQoXCI6IFwiKTtcbiAgICAgIHJldHVybiBba2V5LCB2YWwuam9pbihcIjogXCIpXTtcbiAgICB9KSA6IFtdKTtcbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMoe1xuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgaXNIdHRwOiB0aGlzLl9tYW5hZ2VyLmlzSHR0cCxcbiAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgfSk7XG4gICAgaWYgKGFsbG93UmFuZ2VSZXF1ZXN0cykge1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIocmVzcG9uc2VIZWFkZXJzKTtcbiAgICBpZiAodGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgfVxuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5jaHVuayxcbiAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZENodW5rcy5wdXNoKGRhdGEuY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIF9vbkVycm9yKHN0YXR1cykge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gY3JlYXRlUmVzcG9uc2VFcnJvcihzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPSAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldnQubGVuZ3RoQ29tcHV0YWJsZSA/IGV2dC50b3RhbCA6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX2NhY2hlZENodW5rcy5zaGlmdCgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKTtcbiAgICB9XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICB9XG59XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuX3VybCA9IG1hbmFnZXIudXJsO1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdCh7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZCxcbiAgICAgIG9uSGVhZGVyc1JlY2VpdmVkOiB0aGlzLl9vbkhlYWRlcnNSZWNlaXZlZC5iaW5kKHRoaXMpLFxuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMub25DbG9zZWQgPSBudWxsO1xuICB9XG4gIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICBjb25zdCByZXNwb25zZU9yaWdpbiA9IGdldFJlc3BvbnNlT3JpZ2luKHRoaXMuX21hbmFnZXIuZ2V0UmVxdWVzdFhocih0aGlzLl9yZXF1ZXN0SWQpPy5yZXNwb25zZVVSTCk7XG4gICAgaWYgKHJlc3BvbnNlT3JpZ2luICE9PSB0aGlzLl9tYW5hZ2VyLl9yZXNwb25zZU9yaWdpbikge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBuZXcgRXJyb3IoYEV4cGVjdGVkIHJhbmdlIHJlc3BvbnNlLW9yaWdpbiBcIiR7cmVzcG9uc2VPcmlnaW59XCIgdG8gbWF0Y2ggXCIke3RoaXMuX21hbmFnZXIuX3Jlc3BvbnNlT3JpZ2lufVwiLmApO1xuICAgICAgdGhpcy5fb25FcnJvcigwKTtcbiAgICB9XG4gIH1cbiAgX2Nsb3NlKCkge1xuICAgIHRoaXMub25DbG9zZWQ/Lih0aGlzKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBjb25zdCBjaHVuayA9IGRhdGEuY2h1bms7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPz89IGNyZWF0ZVJlc3BvbnNlRXJyb3Ioc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvbm9kZV9zdHJlYW0uanNcblxuXG5jb25zdCB1cmxSZWdleCA9IC9eW2Etel1bYS16MC05XFwtKy5dKzovaTtcbmZ1bmN0aW9uIHBhcnNlVXJsT3JQYXRoKHNvdXJjZVVybCkge1xuICBpZiAodXJsUmVnZXgudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc291cmNlVXJsKTtcbiAgfVxuICBjb25zdCB1cmwgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJ1cmxcIik7XG4gIHJldHVybiBuZXcgVVJMKHVybC5wYXRoVG9GaWxlVVJMKHNvdXJjZVVybCkpO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmxPclBhdGgoc291cmNlLnVybCk7XG4gICAgYXNzZXJ0KHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCIsIFwiUERGTm9kZVN0cmVhbSBvbmx5IHN1cHBvcnRzIGZpbGU6Ly8gVVJMcy5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgIGFzc2VydCghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGTm9kZVN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByYW5nZVJlYWRlciA9IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmFuZ2VSZWFkZXIpO1xuICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgfVxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IGZzID0gcHJvY2Vzcy5nZXRCdWlsdGluTW9kdWxlKFwiZnNcIik7XG4gICAgZnMucHJvbWlzZXMubHN0YXQodGhpcy5fdXJsKS50aGVuKHN0YXQgPT4ge1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0odGhpcy5fdXJsKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgZXJyb3IgPT4ge1xuICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgZXJyb3IgPSBjcmVhdGVSZXNwb25zZUVycm9yKDAsIHRoaXMuX3VybC5ocmVmKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkLFxuICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICB9KTtcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gIH1cbiAgX2Vycm9yKHJlYXNvbikge1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwicmVhZGFibGVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0pO1xuICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgfSk7XG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG4gICAgY29uc3QgZnMgPSBwcm9jZXNzLmdldEJ1aWx0aW5Nb2R1bGUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHRoaXMuX3VybCwge1xuICAgICAgc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgIH0pO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuICBfZXJyb3IocmVhc29uKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9wZGZfb2JqZWN0cy5qc1xuY29uc3QgSU5JVElBTF9EQVRBID0gU3ltYm9sKFwiSU5JVElBTF9EQVRBXCIpO1xuY2xhc3MgUERGT2JqZWN0cyB7XG4gICNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIHJldHVybiB0aGlzLiNvYmpzW29iaklkXSB8fD0ge1xuICAgICAgLi4uUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCksXG4gICAgICBkYXRhOiBJTklUSUFMX0RBVEFcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLnByb21pc2UudGhlbigoKSA9PiBjYWxsYmFjayhvYmouZGF0YSkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuICAgIGlmICghb2JqIHx8IG9iai5kYXRhID09PSBJTklUSUFMX0RBVEEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuICAgIHJldHVybiBvYmouZGF0YTtcbiAgfVxuICBoYXMob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gISFvYmogJiYgb2JqLmRhdGEgIT09IElOSVRJQUxfREFUQTtcbiAgfVxuICBkZWxldGUob2JqSWQpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaiB8fCBvYmouZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNvbHZlKG9iaklkLCBkYXRhID0gbnVsbCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgb2JqLmRhdGEgPSBkYXRhO1xuICAgIG9iai5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAoY29uc3Qgb2JqSWQgaW4gdGhpcy4jb2Jqcykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhXG4gICAgICB9ID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgICBpZiAoZGF0YSA9PT0gSU5JVElBTF9EQVRBKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgW29iaklkLCBkYXRhXTtcbiAgICB9XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvdGV4dF9sYXllci5qc1xuXG5cbmNvbnN0IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuY29uc3QgREVGQVVMVF9GT05UX1NJWkUgPSAzMDtcbmNsYXNzIFRleHRMYXllciB7XG4gICNjYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjZGlzYWJsZVByb2Nlc3NJdGVtcyA9IGZhbHNlO1xuICAjZm9udEluc3BlY3RvckVuYWJsZWQgPSAhIWdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZDtcbiAgI2xhbmcgPSBudWxsO1xuICAjbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICNwYWdlSGVpZ2h0ID0gMDtcbiAgI3BhZ2VXaWR0aCA9IDA7XG4gICNyZWFkZXIgPSBudWxsO1xuICAjcm9vdENvbnRhaW5lciA9IG51bGw7XG4gICNyb3RhdGlvbiA9IDA7XG4gICNzY2FsZSA9IDA7XG4gICNzdHlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgI3RleHRDb250ZW50SXRlbXNTdHIgPSBbXTtcbiAgI3RleHRDb250ZW50U291cmNlID0gbnVsbDtcbiAgI3RleHREaXZzID0gW107XG4gICN0ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICN0cmFuc2Zvcm0gPSBudWxsO1xuICBzdGF0aWMgI2FzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0NvbnRleHRzID0gbmV3IE1hcCgpO1xuICBzdGF0aWMgI2NhbnZhc0N0eEZvbnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgc3RhdGljICNtaW5Gb250U2l6ZSA9IG51bGw7XG4gIHN0YXRpYyAjcGVuZGluZ1RleHRMYXllcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudFNvdXJjZSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIGlmICh0ZXh0Q29udGVudFNvdXJjZSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IHRleHRDb250ZW50U291cmNlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRleHRDb250ZW50U291cmNlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dENvbnRlbnRTb3VyY2UpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJ0ZXh0Q29udGVudFNvdXJjZVwiIHBhcmFtZXRlciBzcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI3Jvb3RDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgdGhpcy4jcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zID0ge1xuICAgICAgZGl2OiBudWxsLFxuICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgIGN0eDogbnVsbFxuICAgIH07XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICB0aGlzLiN0cmFuc2Zvcm0gPSBbMSwgMCwgMCwgLTEsIC1wYWdlWCwgcGFnZVkgKyBwYWdlSGVpZ2h0XTtcbiAgICB0aGlzLiNwYWdlV2lkdGggPSBwYWdlV2lkdGg7XG4gICAgdGhpcy4jcGFnZUhlaWdodCA9IHBhZ2VIZWlnaHQ7XG4gICAgVGV4dExheWVyLiNlbnN1cmVNaW5Gb250U2l6ZUNvbXB1dGVkKCk7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGNvbnRhaW5lciwgdmlld3BvcnQpO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgIFRleHRMYXllci4jcGVuZGluZ1RleHRMYXllcnMuZGVsZXRlKHRoaXMpO1xuICAgICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcyA9IG51bGw7XG4gICAgICB0aGlzLiNzdHlsZUNhY2hlID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgc3RhdGljIGdldCBmb250RmFtaWx5TWFwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzV2luZG93cyxcbiAgICAgIGlzRmlyZWZveFxuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJmb250RmFtaWx5TWFwXCIsIG5ldyBNYXAoW1tcInNhbnMtc2VyaWZcIiwgYCR7aXNXaW5kb3dzICYmIGlzRmlyZWZveCA/IFwiQ2FsaWJyaSwgXCIgOiBcIlwifXNhbnMtc2VyaWZgXSwgW1wibW9ub3NwYWNlXCIsIGAke2lzV2luZG93cyAmJiBpc0ZpcmVmb3ggPyBcIkx1Y2lkYSBDb25zb2xlLCBcIiA6IFwiXCJ9bW9ub3NwYWNlYF1dKSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHB1bXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNyZWFkZXIucmVhZCgpLnRoZW4oKHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLiNzdHlsZUNhY2hlLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzSXRlbXModmFsdWUuaXRlbXMpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfTtcbiAgICB0aGlzLiNyZWFkZXIgPSB0aGlzLiN0ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICBUZXh0TGF5ZXIuI3BlbmRpbmdUZXh0TGF5ZXJzLmFkZCh0aGlzKTtcbiAgICBwdW1wKCk7XG4gICAgcmV0dXJuIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICB1cGRhdGUoe1xuICAgIHZpZXdwb3J0LFxuICAgIG9uQmVmb3JlID0gbnVsbFxuICB9KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB2aWV3cG9ydC5zY2FsZSAqIE91dHB1dFNjYWxlLnBpeGVsUmF0aW87XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICBpZiAocm90YXRpb24gIT09IHRoaXMuI3JvdGF0aW9uKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuI3Jvb3RDb250YWluZXIsIHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NhbGUgIT09IHRoaXMuI3NjYWxlKSB7XG4gICAgICBvbkJlZm9yZT8uKCk7XG4gICAgICB0aGlzLiNzY2FsZSA9IHNjYWxlO1xuICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgIGN0eDogVGV4dExheWVyLiNnZXRDdHgodGhpcy4jbGFuZylcbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGRpdiBvZiB0aGlzLiN0ZXh0RGl2cykge1xuICAgICAgICBwYXJhbXMucHJvcGVydGllcyA9IHRoaXMuI3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuICAgICAgICBwYXJhbXMuZGl2ID0gZGl2O1xuICAgICAgICB0aGlzLiNsYXlvdXQocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGNvbnN0IGFib3J0RXggPSBuZXcgQWJvcnRFeGNlcHRpb24oXCJUZXh0TGF5ZXIgdGFzayBjYW5jZWxsZWQuXCIpO1xuICAgIHRoaXMuI3JlYWRlcj8uY2FuY2VsKGFib3J0RXgpLmNhdGNoKCgpID0+IHt9KTtcbiAgICB0aGlzLiNyZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KGFib3J0RXgpO1xuICB9XG4gIGdldCB0ZXh0RGl2cygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGV4dERpdnM7XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50SXRlbXNTdHIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gIH1cbiAgI3Byb2Nlc3NJdGVtcyhpdGVtcykge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2xheW91dFRleHRQYXJhbXMuY3R4ID8/PSBUZXh0TGF5ZXIuI2dldEN0eCh0aGlzLiNsYW5nKTtcbiAgICBjb25zdCB0ZXh0RGl2cyA9IHRoaXMuI3RleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRoaXMuI3RleHRDb250ZW50SXRlbXNTdHI7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAodGV4dERpdnMubGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgICAgd2FybihcIklnbm9yaW5nIGFkZGl0aW9uYWwgdGV4dERpdnMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuXCIpO1xuICAgICAgICB0aGlzLiNkaXNhYmxlUHJvY2Vzc0l0ZW1zID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLiNjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuI2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuI2NvbnRhaW5lciA9IHRoaXMuI2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIHRoaXMuI2FwcGVuZFRleHQoaXRlbSk7XG4gICAgfVxuICB9XG4gICNhcHBlbmRUZXh0KGdlb20pIHtcbiAgICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgY29uc3QgdGV4dERpdlByb3BlcnRpZXMgPSB7XG4gICAgICBhbmdsZTogMCxcbiAgICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgICBoYXNFT0w6IGdlb20uaGFzRU9MLFxuICAgICAgZm9udFNpemU6IDBcbiAgICB9O1xuICAgIHRoaXMuI3RleHREaXZzLnB1c2godGV4dERpdik7XG4gICAgY29uc3QgdHggPSBVdGlsLnRyYW5zZm9ybSh0aGlzLiN0cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgY29uc3Qgc3R5bGUgPSB0aGlzLiNzdHlsZUNhY2hlW2dlb20uZm9udE5hbWVdO1xuICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gICAgfVxuICAgIGxldCBmb250RmFtaWx5ID0gdGhpcy4jZm9udEluc3BlY3RvckVuYWJsZWQgJiYgc3R5bGUuZm9udFN1YnN0aXR1dGlvbiB8fCBzdHlsZS5mb250RmFtaWx5O1xuICAgIGZvbnRGYW1pbHkgPSBUZXh0TGF5ZXIuZm9udEZhbWlseU1hcC5nZXQoZm9udEZhbWlseSkgfHwgZm9udEZhbWlseTtcbiAgICBjb25zdCBmb250SGVpZ2h0ID0gTWF0aC5oeXBvdCh0eFsyXSwgdHhbM10pO1xuICAgIGNvbnN0IGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0ICogVGV4dExheWVyLiNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIHRoaXMuI2xhbmcpO1xuICAgIGxldCBsZWZ0LCB0b3A7XG4gICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICBsZWZ0ID0gdHhbNF07XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB0b3AgPSB0eFs1XSAtIGZvbnRBc2NlbnQgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgKlwiO1xuICAgIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgICBpZiAodGhpcy4jY29udGFpbmVyID09PSB0aGlzLiNyb290Q29udGFpbmVyKSB7XG4gICAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7KDEwMCAqIGxlZnQgLyB0aGlzLiNwYWdlV2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGhpcy4jcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2U3R5bGUubGVmdCA9IGAke3NjYWxlRmFjdG9yU3RyfSR7bGVmdC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gICAgfVxuICAgIGRpdlN0eWxlLmZvbnRTaXplID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHsoVGV4dExheWVyLiNtaW5Gb250U2l6ZSAqIGZvbnRIZWlnaHQpLnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5mb250U2l6ZSA9IGZvbnRIZWlnaHQ7XG4gICAgdGV4dERpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgICB0ZXh0RGl2LmRpciA9IGdlb20uZGlyO1xuICAgIGlmICh0aGlzLiNmb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gc3R5bGUuZm9udFN1YnN0aXR1dGlvbkxvYWRlZE5hbWUgfHwgZ2VvbS5mb250TmFtZTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkU2NhbGVUZXh0ID0gZmFsc2U7XG4gICAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNob3VsZFNjYWxlVGV4dCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChnZW9tLnN0ciAhPT0gXCIgXCIgJiYgZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcbiAgICAgIGlmIChhYnNTY2FsZVggIT09IGFic1NjYWxlWSAmJiBNYXRoLm1heChhYnNTY2FsZVgsIGFic1NjYWxlWSkgLyBNYXRoLm1pbihhYnNTY2FsZVgsIGFic1NjYWxlWSkgPiAxLjUpIHtcbiAgICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgICAgdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggPSBzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aDtcbiAgICB9XG4gICAgdGhpcy4jdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgICB0aGlzLiNsYXlvdXRUZXh0UGFyYW1zLmRpdiA9IHRleHREaXY7XG4gICAgdGhpcy4jbGF5b3V0VGV4dFBhcmFtcy5wcm9wZXJ0aWVzID0gdGV4dERpdlByb3BlcnRpZXM7XG4gICAgdGhpcy4jbGF5b3V0KHRoaXMuI2xheW91dFRleHRQYXJhbXMpO1xuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzRU9MKSB7XG4gICAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICB0aGlzLiNjb250YWluZXIuYXBwZW5kKGJyKTtcbiAgICB9XG4gIH1cbiAgI2xheW91dChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXYsXG4gICAgICBwcm9wZXJ0aWVzLFxuICAgICAgY3R4XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSBkaXY7XG4gICAgbGV0IHRyYW5zZm9ybSA9IFwiXCI7XG4gICAgaWYgKFRleHRMYXllci4jbWluRm9udFNpemUgPiAxKSB7XG4gICAgICB0cmFuc2Zvcm0gPSBgc2NhbGUoJHsxIC8gVGV4dExheWVyLiNtaW5Gb250U2l6ZX0pYDtcbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRGYW1pbHlcbiAgICAgIH0gPSBzdHlsZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FudmFzV2lkdGgsXG4gICAgICAgIGZvbnRTaXplXG4gICAgICB9ID0gcHJvcGVydGllcztcbiAgICAgIFRleHRMYXllci4jZW5zdXJlQ3R4Rm9udChjdHgsIGZvbnRTaXplICogdGhpcy4jc2NhbGUsIGZvbnRGYW1pbHkpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB3aWR0aFxuICAgICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgc2NhbGVYKCR7Y2FudmFzV2lkdGggKiB0aGlzLiNzY2FsZSAvIHdpZHRofSkgJHt0cmFuc2Zvcm19YDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHtwcm9wZXJ0aWVzLmFuZ2xlfWRlZykgJHt0cmFuc2Zvcm19YDtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICBzdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLiNwZW5kaW5nVGV4dExheWVycy5zaXplID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhc2NlbnRDYWNoZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgY2FudmFzXG4gICAgfSBvZiB0aGlzLiNjYW52YXNDb250ZXh0cy52YWx1ZXMoKSkge1xuICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNjYW52YXNDb250ZXh0cy5jbGVhcigpO1xuICB9XG4gIHN0YXRpYyAjZ2V0Q3R4KGxhbmcgPSBudWxsKSB7XG4gICAgbGV0IGN0eCA9IHRoaXMuI2NhbnZhc0NvbnRleHRzLmdldChsYW5nIHx8PSBcIlwiKTtcbiAgICBpZiAoIWN0eCkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcImhpZGRlbkNhbnZhc0VsZW1lbnRcIjtcbiAgICAgIGNhbnZhcy5sYW5nID0gbGFuZztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKGNhbnZhcyk7XG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy4jY2FudmFzQ29udGV4dHMuc2V0KGxhbmcsIGN0eCk7XG4gICAgICB0aGlzLiNjYW52YXNDdHhGb250cy5zZXQoY3R4LCB7XG4gICAgICAgIHNpemU6IDAsXG4gICAgICAgIGZhbWlseTogXCJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbiAgc3RhdGljICNlbnN1cmVDdHhGb250KGN0eCwgc2l6ZSwgZmFtaWx5KSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy4jY2FudmFzQ3R4Rm9udHMuZ2V0KGN0eCk7XG4gICAgaWYgKHNpemUgPT09IGNhY2hlZC5zaXplICYmIGZhbWlseSA9PT0gY2FjaGVkLmZhbWlseSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguZm9udCA9IGAke3NpemV9cHggJHtmYW1pbHl9YDtcbiAgICBjYWNoZWQuc2l6ZSA9IHNpemU7XG4gICAgY2FjaGVkLmZhbWlseSA9IGZhbWlseTtcbiAgfVxuICBzdGF0aWMgI2Vuc3VyZU1pbkZvbnRTaXplQ29tcHV0ZWQoKSB7XG4gICAgaWYgKHRoaXMuI21pbkZvbnRTaXplICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgZGl2LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gMTtcbiAgICBkaXYuc3R5bGUuZm9udFNpemUgPSBcIjFweFwiO1xuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBkaXYudGV4dENvbnRlbnQgPSBcIlhcIjtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIHRoaXMuI21pbkZvbnRTaXplID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICBkaXYucmVtb3ZlKCk7XG4gIH1cbiAgc3RhdGljICNnZXRBc2NlbnQoZm9udEZhbWlseSwgc3R5bGUsIGxhbmcpIHtcbiAgICBjb25zdCBjYWNoZWRBc2NlbnQgPSB0aGlzLiNhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG4gICAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgICAgcmV0dXJuIGNhY2hlZEFzY2VudDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy4jZ2V0Q3R4KGxhbmcpO1xuICAgIGN0eC5jYW52YXMud2lkdGggPSBjdHguY2FudmFzLmhlaWdodCA9IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIHRoaXMuI2Vuc3VyZUN0eEZvbnQoY3R4LCBERUZBVUxUX0ZPTlRfU0laRSwgZm9udEZhbWlseSk7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChcIlwiKTtcbiAgICBjb25zdCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIGxldCByYXRpbyA9IDAuODtcbiAgICBpZiAoYXNjZW50KSB7XG4gICAgICByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHV0aWxfRmVhdHVyZVRlc3QucGxhdGZvcm0uaXNGaXJlZm94KSB7XG4gICAgICAgIHdhcm4oXCJFbmFibGUgdGhlIGBkb20udGV4dE1ldHJpY3MuZm9udEJvdW5kaW5nQm94LmVuYWJsZWRgIHByZWZlcmVuY2UgXCIgKyBcImluIGBhYm91dDpjb25maWdgIHRvIGltcHJvdmUgVGV4dExheWVyIHJlbmRlcmluZy5cIik7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGUuYXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gc3R5bGUuYXNjZW50O1xuICAgICAgfSBlbHNlIGlmIChzdHlsZS5kZXNjZW50KSB7XG4gICAgICAgIHJhdGlvID0gMSArIHN0eWxlLmRlc2NlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2FzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2FwaS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG5mdW5jdGlvbiBnZXREb2N1bWVudChzcmMgPSB7fSkge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBjb25zdCB7XG4gICAgZG9jSWRcbiAgfSA9IHRhc2s7XG4gIGNvbnN0IHVybCA9IHNyYy51cmwgPyBnZXRVcmxQcm9wKHNyYy51cmwpIDogbnVsbDtcbiAgY29uc3QgZGF0YSA9IHNyYy5kYXRhID8gZ2V0RGF0YVByb3Aoc3JjLmRhdGEpIDogbnVsbDtcbiAgY29uc3QgaHR0cEhlYWRlcnMgPSBzcmMuaHR0cEhlYWRlcnMgfHwgbnVsbDtcbiAgY29uc3Qgd2l0aENyZWRlbnRpYWxzID0gc3JjLndpdGhDcmVkZW50aWFscyA9PT0gdHJ1ZTtcbiAgY29uc3QgcGFzc3dvcmQgPSBzcmMucGFzc3dvcmQgPz8gbnVsbDtcbiAgY29uc3QgcmFuZ2VUcmFuc3BvcnQgPSBzcmMucmFuZ2UgaW5zdGFuY2VvZiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQgPyBzcmMucmFuZ2UgOiBudWxsO1xuICBjb25zdCByYW5nZUNodW5rU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLnJhbmdlQ2h1bmtTaXplKSAmJiBzcmMucmFuZ2VDaHVua1NpemUgPiAwID8gc3JjLnJhbmdlQ2h1bmtTaXplIDogMiAqKiAxNjtcbiAgbGV0IHdvcmtlciA9IHNyYy53b3JrZXIgaW5zdGFuY2VvZiBQREZXb3JrZXIgPyBzcmMud29ya2VyIDogbnVsbDtcbiAgY29uc3QgdmVyYm9zaXR5ID0gc3JjLnZlcmJvc2l0eTtcbiAgY29uc3QgZG9jQmFzZVVybCA9IHR5cGVvZiBzcmMuZG9jQmFzZVVybCA9PT0gXCJzdHJpbmdcIiAmJiAhaXNEYXRhU2NoZW1lKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5jTWFwVXJsKTtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogRE9NQ01hcFJlYWRlckZhY3RvcnkpO1xuICBjb25zdCBpY2NVcmwgPSBnZXRGYWN0b3J5VXJsUHJvcChzcmMuaWNjVXJsKTtcbiAgY29uc3Qgc3RhbmRhcmRGb250RGF0YVVybCA9IGdldEZhY3RvcnlVcmxQcm9wKHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsKTtcbiAgY29uc3QgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBzcmMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgKGlzTm9kZUpTID8gTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkpO1xuICBjb25zdCB3YXNtVXJsID0gZ2V0RmFjdG9yeVVybFByb3Aoc3JjLndhc21VcmwpO1xuICBjb25zdCBXYXNtRmFjdG9yeSA9IHNyYy5XYXNtRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlV2FzbUZhY3RvcnkgOiBET01XYXNtRmFjdG9yeSk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFpc05vZGVKUztcbiAgY29uc3QgaXNJbWFnZURlY29kZXJTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzSW1hZ2VEZWNvZGVyU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc0ltYWdlRGVjb2RlclN1cHBvcnRlZCA6ICFpc05vZGVKUyAmJiAodXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybS5pc0ZpcmVmb3ggfHwgIWdsb2JhbFRoaXMuY2hyb21lKTtcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IGlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgQ2FudmFzRmFjdG9yeSA9IHNyYy5DYW52YXNGYWN0b3J5IHx8IChpc05vZGVKUyA/IE5vZGVDYW52YXNGYWN0b3J5IDogRE9NQ2FudmFzRmFjdG9yeSk7XG4gIGNvbnN0IEZpbHRlckZhY3RvcnkgPSBzcmMuRmlsdGVyRmFjdG9yeSB8fCAoaXNOb2RlSlMgPyBOb2RlRmlsdGVyRmFjdG9yeSA6IERPTUZpbHRlckZhY3RvcnkpO1xuICBjb25zdCBlbmFibGVIV0EgPSBzcmMuZW5hYmxlSFdBID09PSB0cnVlO1xuICBjb25zdCB1c2VXYXNtID0gc3JjLnVzZVdhc20gIT09IGZhbHNlO1xuICBjb25zdCBsZW5ndGggPSByYW5nZVRyYW5zcG9ydCA/IHJhbmdlVHJhbnNwb3J0Lmxlbmd0aCA6IHNyYy5sZW5ndGggPz8gTmFOO1xuICBjb25zdCB1c2VTeXN0ZW1Gb250cyA9IHR5cGVvZiBzcmMudXNlU3lzdGVtRm9udHMgPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVN5c3RlbUZvbnRzIDogIWlzTm9kZUpTICYmICFkaXNhYmxlRm9udEZhY2U7XG4gIGNvbnN0IHVzZVdvcmtlckZldGNoID0gdHlwZW9mIHNyYy51c2VXb3JrZXJGZXRjaCA9PT0gXCJib29sZWFuXCIgPyBzcmMudXNlV29ya2VyRmV0Y2ggOiAhIShDTWFwUmVhZGVyRmFjdG9yeSA9PT0gRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPT09IERPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ICYmIFdhc21GYWN0b3J5ID09PSBET01XYXNtRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgd2FzbVVybCAmJiBpc1ZhbGlkRmV0Y2hVcmwoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgaXNWYWxpZEZldGNoVXJsKHN0YW5kYXJkRm9udERhdGFVcmwsIGRvY3VtZW50LmJhc2VVUkkpICYmIGlzVmFsaWRGZXRjaFVybCh3YXNtVXJsLCBkb2N1bWVudC5iYXNlVVJJKSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIHNldFZlcmJvc2l0eUxldmVsKHZlcmJvc2l0eSk7XG4gIGNvbnN0IHRyYW5zcG9ydEZhY3RvcnkgPSB7XG4gICAgY2FudmFzRmFjdG9yeTogbmV3IENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudCxcbiAgICAgIGVuYWJsZUhXQVxuICAgIH0pLFxuICAgIGZpbHRlckZhY3Rvcnk6IG5ldyBGaWx0ZXJGYWN0b3J5KHtcbiAgICAgIGRvY0lkLFxuICAgICAgb3duZXJEb2N1bWVudFxuICAgIH0pLFxuICAgIGNNYXBSZWFkZXJGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pLFxuICAgIHN0YW5kYXJkRm9udERhdGFGYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pLFxuICAgIHdhc21GYWN0b3J5OiB1c2VXb3JrZXJGZXRjaCA/IG51bGwgOiBuZXcgV2FzbUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogd2FzbVVybFxuICAgIH0pXG4gIH07XG4gIGlmICghd29ya2VyKSB7XG4gICAgd29ya2VyID0gUERGV29ya2VyLmNyZWF0ZSh7XG4gICAgICB2ZXJib3NpdHksXG4gICAgICBwb3J0OiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnRcbiAgICB9KTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZG9jUGFyYW1zID0ge1xuICAgIGRvY0lkLFxuICAgIGFwaVZlcnNpb246IFwiNS40LjQ0OVwiLFxuICAgIGRhdGEsXG4gICAgcGFzc3dvcmQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICByYW5nZUNodW5rU2l6ZSxcbiAgICBsZW5ndGgsXG4gICAgZG9jQmFzZVVybCxcbiAgICBlbmFibGVYZmEsXG4gICAgZXZhbHVhdG9yT3B0aW9uczoge1xuICAgICAgbWF4SW1hZ2VTaXplLFxuICAgICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgICAgaWdub3JlRXJyb3JzLFxuICAgICAgaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQsXG4gICAgICBpc0ltYWdlRGVjb2RlclN1cHBvcnRlZCxcbiAgICAgIGNhbnZhc01heEFyZWFJbkJ5dGVzLFxuICAgICAgZm9udEV4dHJhUHJvcGVydGllcyxcbiAgICAgIHVzZVN5c3RlbUZvbnRzLFxuICAgICAgdXNlV2FzbSxcbiAgICAgIHVzZVdvcmtlckZldGNoLFxuICAgICAgY01hcFVybCxcbiAgICAgIGljY1VybCxcbiAgICAgIHN0YW5kYXJkRm9udERhdGFVcmwsXG4gICAgICB3YXNtVXJsXG4gICAgfVxuICB9O1xuICBjb25zdCB0cmFuc3BvcnRQYXJhbXMgPSB7XG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50LFxuICAgIGxvYWRpbmdQYXJhbXM6IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHdvcmtlcklkUHJvbWlzZSA9IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIGRvY1BhcmFtcywgZGF0YSA/IFtkYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICBpZiAocmFuZ2VUcmFuc3BvcnQpIHtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbShyYW5nZVRyYW5zcG9ydCwge1xuICAgICAgICBkaXNhYmxlUmFuZ2UsXG4gICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdldERvY3VtZW50IC0gbm8gYHVybGAgcGFyYW1ldGVyIHByb3ZpZGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IE5ldHdvcmtTdHJlYW0gPSBpc1ZhbGlkRmV0Y2hVcmwodXJsKSA/IFBERkZldGNoU3RyZWFtIDogaXNOb2RlSlMgPyBQREZOb2RlU3RyZWFtIDogUERGTmV0d29ya1N0cmVhbTtcbiAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgTmV0d29ya1N0cmVhbSh7XG4gICAgICAgIHVybCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgd2l0aENyZWRlbnRpYWxzLFxuICAgICAgICByYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtlcklkUHJvbWlzZS50aGVuKHdvcmtlcklkID0+IHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5LCBlbmFibGVIV0EpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuY2xhc3MgUERGRG9jdW1lbnRMb2FkaW5nVGFzayB7XG4gIHN0YXRpYyAjZG9jSWQgPSAwO1xuICBfY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICBfdHJhbnNwb3J0ID0gbnVsbDtcbiAgX3dvcmtlciA9IG51bGw7XG4gIGRvY0lkID0gYGQke1BERkRvY3VtZW50TG9hZGluZ1Rhc2suI2RvY0lkKyt9YDtcbiAgZGVzdHJveWVkID0gZmFsc2U7XG4gIG9uUGFzc3dvcmQgPSBudWxsO1xuICBvblByb2dyZXNzID0gbnVsbDtcbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy5fd29ya2VyPy5kZXN0cm95KCk7XG4gICAgdGhpcy5fd29ya2VyID0gbnVsbDtcbiAgfVxuICBhc3luYyBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG59XG5jbGFzcyBQREZEYXRhUmFuZ2VUcmFuc3BvcnQge1xuICAjY2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAjcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICNwcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgI3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICNyYW5nZUxpc3RlbmVycyA9IFtdO1xuICBjb25zdHJ1Y3RvcihsZW5ndGgsIGluaXRpYWxEYXRhLCBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSwgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gICAgdGhpcy5pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIHRoaXMucHJvZ3Jlc3NpdmVEb25lID0gcHJvZ3Jlc3NpdmVEb25lO1xuICAgIHRoaXMuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuI3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuI3Byb2dyZXNzTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG9uRGF0YVByb2dyZXNzaXZlUmVhZChjaHVuaykge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkRhdGFQcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLiNwcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLiNjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuICByZXF1ZXN0RGF0YVJhbmdlKGJlZ2luLCBlbmQpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuICBhYm9ydCgpIHt9XG59XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBjYW52YXNGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FudmFzRmFjdG9yeTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IG51bVBhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLm51bVBhZ2VzO1xuICB9XG4gIGdldCBmaW5nZXJwcmludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnRzO1xuICB9XG4gIGdldCBpc1B1cmVYZmEoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgZ2V0IGFsbFhmYUh0bWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGVzdGluYXRpb25zKCk7XG4gIH1cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuICBnZXRQYWdlTGFiZWxzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICB9XG4gIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGF5b3V0KCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG4gIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKTtcbiAgfVxuICBnZXRPcGVuQWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3BlbkFjdGlvbigpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuICBnZXRBbm5vdGF0aW9uc0J5VHlwZSh0eXBlcywgcGFnZUluZGV4ZXNUb1NraXApIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RG9jSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlbmRlcmluZ0ludGVudFxuICAgIH0gPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCk7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNZXRhZGF0YSgpO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNhdmVEb2N1bWVudCgpO1xuICB9XG4gIGV4dHJhY3RQYWdlcyhwYWdlSW5mb3MpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmV4dHJhY3RQYWdlcyhwYWdlSW5mb3MpO1xuICB9XG4gIGdldERvd25sb2FkSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzIHx8IHRoaXMuaXNQdXJlWGZhKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLmRlc3Ryb3koKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuY2FjaGVkUGFnZU51bWJlcihyZWYpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1BhcmFtcztcbiAgfVxuICBnZXQgbG9hZGluZ1Rhc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nVGFzaztcbiAgfVxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5oYXNKU0FjdGlvbnMoKTtcbiAgfVxuICBnZXRDYWxjdWxhdGlvbk9yZGVySWRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpO1xuICB9XG59XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjcGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFnZUluZGV4LCBwYWdlSW5mbywgdHJhbnNwb3J0LCBwZGZCdWcgPSBmYWxzZSkge1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLl9wYWdlSW5mbyA9IHBhZ2VJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl9zdGF0cyA9IHBkZkJ1ZyA/IG5ldyBTdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5faW50ZW50U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5yZWNvcmRlZEJCb3hlcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cbiAgZ2V0IHJvdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucm90YXRlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgfVxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby52aWV3O1xuICB9XG4gIGdldFZpZXdwb3J0KHtcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvbiA9IHRoaXMucm90YXRlLFxuICAgIG9mZnNldFggPSAwLFxuICAgIG9mZnNldFkgPSAwLFxuICAgIGRvbnRGbGlwID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgdXNlclVuaXQ6IHRoaXMudXNlclVuaXQsXG4gICAgICBzY2FsZSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFksXG4gICAgICBkb250RmxpcFxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIlxuICB9ID0ge30pIHtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnRcbiAgICB9ID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCByZW5kZXJpbmdJbnRlbnQpO1xuICB9XG4gIGdldEpTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VKU0FjdGlvbnModGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuICBnZXQgZmlsdGVyRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3Rvcnk7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNQdXJlWGZhXCIsICEhdGhpcy5fdHJhbnNwb3J0Ll9odG1sRm9yWGZhKTtcbiAgfVxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG4gIHJlbmRlcih7XG4gICAgY2FudmFzQ29udGV4dCxcbiAgICBjYW52YXMgPSBjYW52YXNDb250ZXh0LmNhbnZhcyxcbiAgICB2aWV3cG9ydCxcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICB0cmFuc2Zvcm0gPSBudWxsLFxuICAgIGJhY2tncm91bmQgPSBudWxsLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAgPSBudWxsLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlLFxuICAgIHJlY29yZE9wZXJhdGlvbnMgPSBmYWxzZSxcbiAgICBvcGVyYXRpb25zRmlsdGVyID0gbnVsbFxuICB9KSB7XG4gICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJPdmVyYWxsXCIpO1xuICAgIGNvbnN0IGludGVudEFyZ3MgPSB0aGlzLl90cmFuc3BvcnQuZ2V0UmVuZGVyaW5nSW50ZW50KGludGVudCwgYW5ub3RhdGlvbk1vZGUsIHByaW50QW5ub3RhdGlvblN0b3JhZ2UsIGlzRWRpdGluZyk7XG4gICAgY29uc3Qge1xuICAgICAgcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXlcbiAgICB9ID0gaW50ZW50QXJncztcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcocmVuZGVyaW5nSW50ZW50KTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShyZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcbiAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCByZWNvcmRGb3JEZWJ1Z2dlciA9IEJvb2xlYW4odGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpO1xuICAgIGNvbnN0IHNob3VsZFJlY29yZE9wZXJhdGlvbnMgPSAhdGhpcy5yZWNvcmRlZEJCb3hlcyAmJiAocmVjb3JkT3BlcmF0aW9ucyB8fCByZWNvcmRGb3JEZWJ1Z2dlcik7XG4gICAgY29uc3QgY29tcGxldGUgPSBlcnJvciA9PiB7XG4gICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICAgIGlmIChzaG91bGRSZWNvcmRPcGVyYXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlY29yZGVkQkJveGVzID0gaW50ZXJuYWxSZW5kZXJUYXNrLmdmeD8uZGVwZW5kZW5jeVRyYWNrZXIudGFrZSgpO1xuICAgICAgICBpZiAocmVjb3JkZWRCQm94ZXMpIHtcbiAgICAgICAgICBpZiAoaW50ZXJuYWxSZW5kZXJUYXNrLnN0ZXBwZXIpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5zdGVwcGVyLnNldE9wZXJhdG9yQkJveGVzKHJlY29yZGVkQkJveGVzLCBpbnRlcm5hbFJlbmRlclRhc2suZ2Z4LmRlcGVuZGVuY3lUcmFja2VyLnRha2VEZWJ1Z01ldGFkYXRhKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVjb3JkT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRlZEJCb3hlcyA9IHJlY29yZGVkQkJveGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGludGVudFByaW50KSB7XG4gICAgICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgcmVhc29uOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoZXJyb3IpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJPdmVyYWxsXCIpO1xuICAgICAgICBpZiAoZ2xvYmFsVGhpcy5TdGF0cz8uZW5hYmxlZCkge1xuICAgICAgICAgIGdsb2JhbFRoaXMuU3RhdHMuYWRkKHRoaXMucGFnZU51bWJlciwgdGhpcy5fc3RhdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgPSBuZXcgSW50ZXJuYWxSZW5kZXJUYXNrKHtcbiAgICAgIGNhbGxiYWNrOiBjb21wbGV0ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBjYW52YXMsXG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIGRlcGVuZGVuY3lUcmFja2VyOiBzaG91bGRSZWNvcmRPcGVyYXRpb25zID8gbmV3IENhbnZhc0RlcGVuZGVuY3lUcmFja2VyKGNhbnZhcywgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxlbmd0aCwgcmVjb3JkRm9yRGVidWdnZXIpIDogbnVsbCxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgYmFja2dyb3VuZFxuICAgICAgfSxcbiAgICAgIG9ianM6IHRoaXMub2JqcyxcbiAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgICBvcGVyYXRvckxpc3Q6IGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmNhbnZhc0ZhY3RvcnksXG4gICAgICBmaWx0ZXJGYWN0b3J5OiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzLFxuICAgICAgZW5hYmxlSFdBOiB0aGlzLl90cmFuc3BvcnQuZW5hYmxlSFdBLFxuICAgICAgb3BlcmF0aW9uc0ZpbHRlclxuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oKFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10pID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGlmICghKG9wdGlvbmFsQ29udGVudENvbmZpZy5yZW5kZXJpbmdJbnRlbnQgJiByZW5kZXJpbmdJbnRlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgdXNlIHRoZSBzYW1lIGBpbnRlbnRgLWFyZ3VtZW50IHdoZW4gY2FsbGluZyB0aGUgYFBERlBhZ2VQcm94eS5yZW5kZXJgIFwiICsgXCJhbmQgYFBERkRvY3VtZW50UHJveHkuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnYCBtZXRob2RzLlwiKTtcbiAgICAgIH1cbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsLFxuICAgIGlzRWRpdGluZyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgaXNFZGl0aW5nLCB0cnVlKTtcbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5zZXQoaW50ZW50QXJncy5jYWNoZUtleSwgaW50ZW50U3RhdGUpO1xuICAgIH1cbiAgICBsZXQgb3BMaXN0VGFzaztcbiAgICBpZiAoIWludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG9wTGlzdFRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCA9IG9wZXJhdG9yTGlzdENoYW5nZWQ7XG4gICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuICAgICAgdGhpcy5fc3RhdHM/LnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KGludGVudEFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBzdHJlYW1UZXh0Q29udGVudCh7XG4gICAgaW5jbHVkZU1hcmtlZENvbnRlbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFID0gMTAwO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50OiBpbmNsdWRlTWFya2VkQ29udGVudCA9PT0gdHJ1ZSxcbiAgICAgIGRpc2FibGVOb3JtYWxpemF0aW9uOiBkaXNhYmxlTm9ybWFsaXphdGlvbiA9PT0gdHJ1ZVxuICAgIH0sIHtcbiAgICAgIGhpZ2hXYXRlck1hcms6IFRFWFRfQ09OVEVOVF9DSFVOS19TSVpFLFxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRleHRDb250ZW50KHBhcmFtcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbih4ZmEgPT4gWGZhVGV4dC50ZXh0Q29udGVudCh4ZmEpKTtcbiAgICB9XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLnN0cmVhbVRleHRDb250ZW50KHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIHB1bXAoKSB7XG4gICAgICAgIHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRvbmVcbiAgICAgICAgfSkge1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRleHRDb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dENvbnRlbnQubGFuZyA/Pz0gdmFsdWUubGFuZztcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgbGFuZzogbnVsbFxuICAgICAgfTtcbiAgICAgIHB1bXAoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0U3RydWN0VHJlZSh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudFN0YXRlIG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVhc29uOiBuZXcgRXJyb3IoXCJQYWdlIHdhcyBkZXN0cm95ZWQuXCIpLFxuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG4gIGNsZWFudXAocmVzZXRTdGF0cyA9IGZhbHNlKSB7XG4gICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLiN0cnlDbGVhbnVwKCk7XG4gICAgaWYgKHJlc2V0U3RhdHMgJiYgc3VjY2Vzcykge1xuICAgICAgdGhpcy5fc3RhdHMgJiY9IG5ldyBTdGF0VGltZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG4gIH1cbiAgI3RyeUNsZWFudXAoKSB7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHk/LnJlc29sdmUodHJhbnNwYXJlbmN5KTtcbiAgfVxuICBfcmVuZGVyUGFnZUNodW5rKG9wZXJhdG9yTGlzdENodW5rLCBpbnRlbnRTdGF0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG9wZXJhdG9yTGlzdENodW5rLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QuYXJnc0FycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuYXJnc0FycmF5W2ldKTtcbiAgICB9XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaztcbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3Quc2VwYXJhdGVBbm5vdHMgPSBvcGVyYXRvckxpc3RDaHVuay5zZXBhcmF0ZUFubm90cztcbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG4gICAgaWYgKG9wZXJhdG9yTGlzdENodW5rLmxhc3RDaHVuaykge1xuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCgpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgcmVuZGVyaW5nSW50ZW50LFxuICAgIGNhY2hlS2V5LFxuICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgIG1vZGlmaWVkSWRzXG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlclxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9LCB0cmFuc2Zlcik7XG4gICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG4gICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgIHJlYWRlci5yZWFkKCkudGhlbigoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuICAgICAgICBwdW1wKCk7XG4gICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgZm9yIChjb25zdCBpbnRlcm5hbFJlbmRlclRhc2sgb2YgaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuI3RyeUNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgcHVtcCgpO1xuICB9XG4gIF9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgaW50ZW50U3RhdGUsXG4gICAgcmVhc29uLFxuICAgIGZvcmNlID0gZmFsc2VcbiAgfSkge1xuICAgIGlmICghaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKGludGVudFN0YXRlLnJlbmRlclRhc2tzLnNpemUgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgbGV0IGRlbGF5ID0gUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUO1xuICAgICAgICBpZiAocmVhc29uLmV4dHJhRGVsYXkgPiAwICYmIHJlYXNvbi5leHRyYURlbGF5IDwgMTAwMCkge1xuICAgICAgICAgIGRlbGF5ICs9IHJlYXNvbi5leHRyYURlbGF5O1xuICAgICAgICB9XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIuY2FuY2VsKG5ldyBBYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSkpLmNhdGNoKCgpID0+IHt9KTtcbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2N1ckNhY2hlS2V5LCBjdXJJbnRlbnRTdGF0ZV0gb2YgdGhpcy5faW50ZW50U3RhdGVzKSB7XG4gICAgICBpZiAoY3VySW50ZW50U3RhdGUgPT09IGludGVudFN0YXRlKSB7XG4gICAgICAgIHRoaXMuX2ludGVudFN0YXRlcy5kZWxldGUoY3VyQ2FjaGVLZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cztcbiAgfVxufVxuY2xhc3MgUERGV29ya2VyIHtcbiAgI2NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgI21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgI3BvcnQgPSBudWxsO1xuICAjd2ViV29ya2VyID0gbnVsbDtcbiAgc3RhdGljICNmYWtlV29ya2VySWQgPSAwO1xuICBzdGF0aWMgI2lzV29ya2VyRGlzYWJsZWQgPSBmYWxzZTtcbiAgc3RhdGljICN3b3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHN0YXRpYyB7XG4gICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICB0aGlzLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjIHx8PSBcIi4vcGRmLndvcmtlci5tanNcIjtcbiAgICB9XG4gICAgdGhpcy5faXNTYW1lT3JpZ2luID0gKGJhc2VVcmwsIG90aGVyVXJsKSA9PiB7XG4gICAgICBjb25zdCBiYXNlID0gVVJMLnBhcnNlKGJhc2VVcmwpO1xuICAgICAgaWYgKCFiYXNlPy5vcmlnaW4gfHwgYmFzZS5vcmlnaW4gPT09IFwibnVsbFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgICByZXR1cm4gYmFzZS5vcmlnaW4gPT09IG90aGVyLm9yaWdpbjtcbiAgICB9O1xuICAgIHRoaXMuX2NyZWF0ZUNETldyYXBwZXIgPSB1cmwgPT4ge1xuICAgICAgY29uc3Qgd3JhcHBlciA9IGBhd2FpdCBpbXBvcnQoXCIke3VybH1cIik7YDtcbiAgICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFt3cmFwcGVyXSwge1xuICAgICAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICB0aGlzLmZyb21Qb3J0ID0gcGFyYW1zID0+IHtcbiAgICAgIGRlcHJlY2F0ZWQoXCJgUERGV29ya2VyLmZyb21Qb3J0YCAtIHBsZWFzZSB1c2UgYFBERldvcmtlci5jcmVhdGVgIGluc3RlYWQuXCIpO1xuICAgICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShwYXJhbXMpO1xuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUgPSBudWxsLFxuICAgIHBvcnQgPSBudWxsLFxuICAgIHZlcmJvc2l0eSA9IGdldFZlcmJvc2l0eUxldmVsKClcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cy5oYXMocG9ydCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIFBERldvcmtlciBwZXIgcG9ydC5cIik7XG4gICAgICB9XG4gICAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuI2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gICNyZXNvbHZlKCkge1xuICAgIHRoaXMuI2NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgIH0pO1xuICB9XG4gIGdldCBwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3J0O1xuICB9XG4gIGdldCBtZXNzYWdlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gdGhpcy4jbWVzc2FnZUhhbmRsZXI7XG4gIH1cbiAgI2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgdGhpcy4jcG9ydCA9IHBvcnQ7XG4gICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgKCkgPT4ge30pO1xuICAgIHRoaXMuI3Jlc29sdmUoKTtcbiAgfVxuICAjaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkIHx8IFBERldvcmtlci4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHdvcmtlclNyY1xuICAgIH0gPSBQREZXb3JrZXI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghUERGV29ya2VyLl9pc1NhbWVPcmlnaW4od2luZG93LmxvY2F0aW9uLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlci5fY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjLCB7XG4gICAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG4gICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgYWMuYWJvcnQoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHRoaXMuI2NhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNzZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4jd2ViV29ya2VyKSB7XG4gICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWw6IGFjLnNpZ25hbFxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInRlc3RcIiwgZGF0YSA9PiB7XG4gICAgICAgIGFjLmFib3J0KCk7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCB8fCAhZGF0YSkge1xuICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgIHRoaXMuI3BvcnQgPSB3b3JrZXI7XG4gICAgICAgIHRoaXMuI3dlYldvcmtlciA9IHdvcmtlcjtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgICBhYy5hYm9ydCgpO1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIHRoaXMuI3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHNlbmRUZXN0ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICB9O1xuICAgICAgc2VuZFRlc3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGluZm8oXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0dXBGYWtlV29ya2VyKCk7XG4gIH1cbiAgI3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICBpZiAoIVBERldvcmtlci4jaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgd2FybihcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyLiNpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgUERGV29ya2VyLl9zZXR1cEZha2VXb3JrZXJHbG9iYWwudGhlbihXb3JrZXJNZXNzYWdlSGFuZGxlciA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgdGhpcy4jY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgdGhpcy4jcG9ydCA9IHBvcnQ7XG4gICAgICBjb25zdCBpZCA9IGBmYWtlJHtQREZXb3JrZXIuI2Zha2VXb3JrZXJJZCsrfWA7XG4gICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKGlkICsgXCJfd29ya2VyXCIsIGlkLCBwb3J0KTtcbiAgICAgIFdvcmtlck1lc3NhZ2VIYW5kbGVyLnNldHVwKHdvcmtlckhhbmRsZXIsIHBvcnQpO1xuICAgICAgdGhpcy4jbWVzc2FnZUhhbmRsZXIgPSBuZXcgTWVzc2FnZUhhbmRsZXIoaWQsIGlkICsgXCJfd29ya2VyXCIsIHBvcnQpO1xuICAgICAgdGhpcy4jcmVzb2x2ZSgpO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLiNjYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoYFNldHRpbmcgdXAgZmFrZSB3b3JrZXIgZmFpbGVkOiBcIiR7cmVhc29uLm1lc3NhZ2V9XCIuYCkpO1xuICAgIH0pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuI3dlYldvcmtlcj8udGVybWluYXRlKCk7XG4gICAgdGhpcy4jd2ViV29ya2VyID0gbnVsbDtcbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLmRlbGV0ZSh0aGlzLiNwb3J0KTtcbiAgICB0aGlzLiNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLiNtZXNzYWdlSGFuZGxlcj8uZGVzdHJveSgpO1xuICAgIHRoaXMuI21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlKHBhcmFtcykge1xuICAgIGNvbnN0IGNhY2hlZFBvcnQgPSB0aGlzLiN3b3JrZXJQb3J0cy5nZXQocGFyYW1zPy5wb3J0KTtcbiAgICBpZiAoY2FjaGVkUG9ydCkge1xuICAgICAgaWYgKGNhY2hlZFBvcnQuX3BlbmRpbmdEZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5jcmVhdGUgLSB0aGUgd29ya2VyIGlzIGJlaW5nIGRlc3Ryb3llZC5cXG5cIiArIFwiUGxlYXNlIHJlbWVtYmVyIHRvIGF3YWl0IGBQREZEb2N1bWVudExvYWRpbmdUYXNrLmRlc3Ryb3koKWAtY2FsbHMuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhY2hlZFBvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUERGV29ya2VyKHBhcmFtcyk7XG4gIH1cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuICBzdGF0aWMgZ2V0ICNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnbG9iYWxUaGlzLnBkZmpzV29ya2VyPy5Xb3JrZXJNZXNzYWdlSGFuZGxlciB8fCBudWxsO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy4jbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCBpbXBvcnQoXG4gICAgICAvKndlYnBhY2tJZ25vcmU6IHRydWUqL1xuICAgICAgLypAdml0ZS1pZ25vcmUqL1xuICAgICAgdGhpcy53b3JrZXJTcmMpO1xuICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfc2V0dXBGYWtlV29ya2VyR2xvYmFsXCIsIGxvYWRlcigpKTtcbiAgfVxufVxuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZVJlZkNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnksIGVuYWJsZUhXQSkge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgRm9udExvYWRlcih7XG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMubG9hZGluZ1BhcmFtcyA9IHBhcmFtcy5sb2FkaW5nUGFyYW1zO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBmYWN0b3J5LmNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmFjdG9yeS5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuY01hcFJlYWRlckZhY3RvcnkgPSBmYWN0b3J5LmNNYXBSZWFkZXJGYWN0b3J5O1xuICAgIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBmYWN0b3J5LnN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICAgIHRoaXMud2FzbUZhY3RvcnkgPSBmYWN0b3J5Lndhc21GYWN0b3J5O1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fbmV0d29ya1N0cmVhbSA9IG5ldHdvcmtTdHJlYW07XG4gICAgdGhpcy5fZnVsbFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGFzdFByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLmRvd25sb2FkSW5mb0NhcGFiaWxpdHkgPSBQcm9taXNlLndpdGhSZXNvbHZlcnMoKTtcbiAgICB0aGlzLmVuYWJsZUhXQSA9IGVuYWJsZUhXQTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuICAjY2FjaGVTaW1wbGVNZXRob2QobmFtZSwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIGRhdGEpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBBbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzRWRpdGluZyA9IGZhbHNlLCBpc09wTGlzdCA9IGZhbHNlKSB7XG4gICAgbGV0IHJlbmRlcmluZ0ludGVudCA9IFJlbmRlcmluZ0ludGVudEZsYWcuRElTUExBWTtcbiAgICBsZXQgYW5ub3RhdGlvblN0b3JhZ2VTZXJpYWxpemFibGUgPSBTZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHdhcm4oYGdldFJlbmRlcmluZ0ludGVudCAtIGludmFsaWQgaW50ZW50OiAke2ludGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgYW5ub3RhdGlvblN0b3JhZ2UgPSByZW5kZXJpbmdJbnRlbnQgJiBSZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UICYmIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgaW5zdGFuY2VvZiBQcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19GT1JNUztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZSA9IGFubm90YXRpb25TdG9yYWdlLnNlcmlhbGl6YWJsZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3YXJuKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cbiAgICBpZiAoaXNFZGl0aW5nKSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gUmVuZGVyaW5nSW50ZW50RmxhZy5JU19FRElUSU5HO1xuICAgIH1cbiAgICBpZiAoaXNPcExpc3QpIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCArPSBSZW5kZXJpbmdJbnRlbnRGbGFnLk9QTElTVDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaWRzOiBtb2RpZmllZElkcyxcbiAgICAgIGhhc2g6IG1vZGlmaWVkSWRzSGFzaFxuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZS5tb2RpZmllZElkcztcbiAgICBjb25zdCBjYWNoZUtleUJ1ZiA9IFtyZW5kZXJpbmdJbnRlbnQsIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2gsIG1vZGlmaWVkSWRzSGFzaF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5OiBjYWNoZUtleUJ1Zi5qb2luKFwiX1wiKSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLFxuICAgICAgbW9kaWZpZWRJZHNcbiAgICB9O1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy4jcGFzc3dvcmRDYXBhYmlsaXR5Py5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgfVxuICAgIHRoaXMuI3BhZ2VDYWNoZS5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5jbGVhcigpO1xuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXJtaW5hdGVkID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJUZXJtaW5hdGVcIiwgbnVsbCk7XG4gICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgUHJvbWlzZS5hbGwod2FpdE9uKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuY29tbW9uT2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3koKTtcbiAgICAgIFRleHRMYXllci5jbGVhbnVwKCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXI/LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSwgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5yZWplY3QpO1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgIGFzc2VydCh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhc3NlcnQodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciwgXCJHZXRSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgc2luay5yZWFkeS5jYXRjaChyZWFkeVJlYXNvbiA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJSZWFkZXJIZWFkZXJzUmVhZHlcIiwgYXN5bmMgZGF0YSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLl9mdWxsUmVhZGVyLmhlYWRlcnNSZWFkeTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH0gPSB0aGlzLl9mdWxsUmVhZGVyO1xuICAgICAgaWYgKCFpc1N0cmVhbWluZ1N1cHBvcnRlZCB8fCAhaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICBpZiAodGhpcy5fbGFzdFByb2dyZXNzKSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHRoaXMuX2xhc3RQcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgYXNzZXJ0KHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcbiAgICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRSYW5nZVJlYWRlcihkYXRhLmJlZ2luLCBkYXRhLmVuZCk7XG4gICAgICBpZiAoIXJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgc2luay5lcnJvcihyZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0RG9jXCIsICh7XG4gICAgICBwZGZJbmZvXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5fbnVtUGFnZXMgPSBwZGZJbmZvLm51bVBhZ2VzO1xuICAgICAgdGhpcy5faHRtbEZvclhmYSA9IHBkZkluZm8uaHRtbEZvclhmYTtcbiAgICAgIGRlbGV0ZSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIHRoaXMpKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY0V4Y2VwdGlvblwiLCBleCA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihleCkpO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUGFzc3dvcmRSZXF1ZXN0XCIsIGV4ID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFsb2FkaW5nVGFzay5vblBhc3N3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgd3JhcFJlYXNvbihleCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4LmNvZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCAoW2lkLCB0eXBlLCBleHBvcnRlZERhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICBpZiAoXCJlcnJvclwiIGluIGV4cG9ydGVkRGF0YSkge1xuICAgICAgICAgICAgY29uc3QgZXhwb3J0ZWRFcnJvciA9IGV4cG9ydGVkRGF0YS5lcnJvcjtcbiAgICAgICAgICAgIHdhcm4oYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmb250RGF0YSA9IG5ldyBGb250SW5mbyhleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGNvbnN0IGluc3BlY3RGb250ID0gdGhpcy5fcGFyYW1zLnBkZkJ1ZyAmJiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3I/LmVuYWJsZWQgPyAoZm9udCwgdXJsKSA9PiBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCkgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IGZvbnQgPSBuZXcgRm9udEZhY2VPYmplY3QoZm9udERhdGEsIGluc3BlY3RGb250LCBleHBvcnRlZERhdGEuZXh0cmEsIGV4cG9ydGVkRGF0YS5jaGFyUHJvY09wZXJhdG9yTGlzdCk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2goKCkgPT4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSkpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFmb250LmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgIGZvbnQuY2xlYXJEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDb3B5TG9jYWxJbWFnZVwiOlxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGltYWdlUmVmXG4gICAgICAgICAgfSA9IGV4cG9ydGVkRGF0YTtcbiAgICAgICAgICBhc3NlcnQoaW1hZ2VSZWYsIFwiVGhlIGltYWdlUmVmIG11c3QgYmUgZGVmaW5lZC5cIik7XG4gICAgICAgICAgZm9yIChjb25zdCBwYWdlUHJveHkgb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIGRhdGFdIG9mIHBhZ2VQcm94eS5vYmpzKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhPy5yZWYgIT09IGltYWdlUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhLmRhdGFMZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgc3RydWN0dXJlZENsb25lKGRhdGEpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuZGF0YUxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWREYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFBhdHRlcm5JbmZvKGV4cG9ydGVkRGF0YSk7XG4gICAgICAgICAgdGhpcy5jb21tb25PYmpzLnJlc29sdmUoaWQsIHBhdHRlcm4uZ2V0SVIoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJvYmpcIiwgKFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHBhZ2VQcm94eS5faW50ZW50U3RhdGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgaW1hZ2VEYXRhPy5iaXRtYXA/LmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jUHJvZ3Jlc3NcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCaW5hcnlEYXRhXCIsIGFzeW5jIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzW2RhdGEudHlwZV07XG4gICAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2RhdGEudHlwZX0gbm90IGluaXRpYWxpemVkLCBzZWUgdGhlIFxcYHVzZVdvcmtlckZldGNoXFxgIHBhcmFtZXRlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWN0b3J5LmZldGNoKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgfVxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2l6ZSA8PSAwKSB7XG4gICAgICB3YXJuKFwic2F2ZURvY3VtZW50IGNhbGxlZCB3aGlsZSBgYW5ub3RhdGlvblN0b3JhZ2VgIGlzIGVtcHR5LCBcIiArIFwicGxlYXNlIHVzZSB0aGUgZ2V0RGF0YS1tZXRob2QgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyXG4gICAgfSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICBpc1B1cmVYZmE6ICEhdGhpcy5faHRtbEZvclhmYSxcbiAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlOiBtYXAsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0sIHRyYW5zZmVyKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGV4dHJhY3RQYWdlcyhwYWdlSW5mb3MpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJFeHRyYWN0UGFnZXNcIiwge1xuICAgICAgcGFnZUluZm9zXG4gICAgfSk7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICBjb25zdCBwYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMSxcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNwYWdlUHJvbWlzZXMuZ2V0KHBhZ2VJbmRleCk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAocGFnZUluZm8ucmVmU3RyKSB7XG4gICAgICAgIHRoaXMuI3BhZ2VSZWZDYWNoZS5zZXQocGFnZUluZm8ucmVmU3RyLCBwYWdlTnVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5wZGZCdWcpO1xuICAgICAgdGhpcy4jcGFnZUNhY2hlLnNldChwYWdlSW5kZXgsIHBhZ2UpO1xuICAgICAgcmV0dXJuIHBhZ2U7XG4gICAgfSk7XG4gICAgdGhpcy4jcGFnZVByb21pc2VzLnNldChwYWdlSW5kZXgsIHByb21pc2UpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAoIWlzUmVmUHJveHkocmVmKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldEFubm90YXRpb25zQnlUeXBlKHR5cGVzLCBwYWdlSW5kZXhlc1RvU2tpcCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEFubm90YXRpb25zQnlUeXBlXCIsIHtcbiAgICAgIHR5cGVzLFxuICAgICAgcGFnZUluZGV4ZXNUb1NraXBcbiAgICB9KTtcbiAgfVxuICBnZXREb2NKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiR2V0RG9jSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0cnVjdFRyZWVcIiwge1xuICAgICAgcGFnZUluZGV4XG4gICAgfSk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICB9XG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZyhyZW5kZXJpbmdJbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIikudGhlbihkYXRhID0+IG5ldyBPcHRpb25hbENvbnRlbnRDb25maWcoZGF0YSwgcmVuZGVyaW5nSW50ZW50KSk7XG4gIH1cbiAgZ2V0UGVybWlzc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgY29uc3QgbmFtZSA9IFwiR2V0TWV0YWRhdGFcIixcbiAgICAgIGNhY2hlZFByb21pc2UgPSB0aGlzLiNtZXRob2RQcm9taXNlcy5nZXQobmFtZSk7XG4gICAgaWYgKGNhY2hlZFByb21pc2UpIHtcbiAgICAgIHJldHVybiBjYWNoZWRQcm9taXNlO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UobmFtZSwgbnVsbCkudGhlbihyZXN1bHRzID0+ICh7XG4gICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICBjb250ZW50TGVuZ3RoOiB0aGlzLl9mdWxsUmVhZGVyPy5jb250ZW50TGVuZ3RoID8/IG51bGwsXG4gICAgICBoYXNTdHJ1Y3RUcmVlOiByZXN1bHRzWzJdXG4gICAgfSkpO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuICAgIGZvciAoY29uc3QgcGFnZSBvZiB0aGlzLiNwYWdlQ2FjaGUudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsZWFudXBTdWNjZXNzZnVsID0gcGFnZS5jbGVhbnVwKCk7XG4gICAgICBpZiAoIWNsZWFudXBTdWNjZXNzZnVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RhcnRDbGVhbnVwOiBQYWdlICR7cGFnZS5wYWdlTnVtYmVyfSBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLmApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICBpZiAoIWtlZXBMb2FkZWRGb250cykge1xuICAgICAgdGhpcy5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLmNsZWFyKCk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5LmRlc3Ryb3kodHJ1ZSk7XG4gICAgVGV4dExheWVyLmNsZWFudXAoKTtcbiAgfVxuICBjYWNoZWRQYWdlTnVtYmVyKHJlZikge1xuICAgIGlmICghaXNSZWZQcm94eShyZWYpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVmU3RyID0gcmVmLmdlbiA9PT0gMCA/IGAke3JlZi5udW19UmAgOiBgJHtyZWYubnVtfVIke3JlZi5nZW59YDtcbiAgICByZXR1cm4gdGhpcy4jcGFnZVJlZkNhY2hlLmdldChyZWZTdHIpID8/IG51bGw7XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgb25Db250aW51ZSA9IG51bGw7XG4gIG9uRXJyb3IgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKGV4dHJhRGVsYXkgPSAwKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbChudWxsLCBleHRyYURlbGF5KTtcbiAgfVxuICBnZXQgc2VwYXJhdGVBbm5vdHMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2VwYXJhdGVBbm5vdHNcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdDtcbiAgICBpZiAoIXNlcGFyYXRlQW5ub3RzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxufVxuY2xhc3MgSW50ZXJuYWxSZW5kZXJUYXNrIHtcbiAgI3JBRiA9IG51bGw7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY2FsbGJhY2ssXG4gICAgcGFyYW1zLFxuICAgIG9ianMsXG4gICAgY29tbW9uT2JqcyxcbiAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgIG9wZXJhdG9yTGlzdCxcbiAgICBwYWdlSW5kZXgsXG4gICAgY2FudmFzRmFjdG9yeSxcbiAgICBmaWx0ZXJGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsLFxuICAgIGVuYWJsZUhXQSA9IGZhbHNlLFxuICAgIG9wZXJhdGlvbnNGaWx0ZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeSA9IGZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMucGFnZUNvbG9ycyA9IHBhZ2VDb2xvcnM7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5jYXBhYmlsaXR5ID0gUHJvbWlzZS53aXRoUmVzb2x2ZXJzKCk7XG4gICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgdGhpcy5fY2FuY2VsQm91bmQgPSB0aGlzLmNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NvbnRpbnVlQm91bmQgPSB0aGlzLl9jb250aW51ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fbmV4dEJvdW5kID0gdGhpcy5fbmV4dC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHBhcmFtcy5jYW52YXM7XG4gICAgdGhpcy5fY2FudmFzQ29udGV4dCA9IHBhcmFtcy5jYW52YXMgPyBudWxsIDogcGFyYW1zLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5fZW5hYmxlSFdBID0gZW5hYmxlSFdBO1xuICAgIHRoaXMuX2RlcGVuZGVuY3lUcmFja2VyID0gcGFyYW1zLmRlcGVuZGVuY3lUcmFja2VyO1xuICAgIHRoaXMuX29wZXJhdGlvbnNGaWx0ZXIgPSBvcGVyYXRpb25zRmlsdGVyO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3Moe1xuICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICB9KSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG4gICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmFkZCh0aGlzLl9jYW52YXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGRmQnVnICYmIGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXI/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuc3RlcHBlciA9IGdsb2JhbFRoaXMuU3RlcHBlck1hbmFnZXIuY3JlYXRlKHRoaXMuX3BhZ2VJbmRleCk7XG4gICAgICB0aGlzLnN0ZXBwZXIuaW5pdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kLFxuICAgICAgZGVwZW5kZW5jeVRyYWNrZXJcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY2FudmFzQ29udGV4dCA9IHRoaXMuX2NhbnZhc0NvbnRleHQgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2UsXG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6ICF0aGlzLl9lbmFibGVIV0FcbiAgICB9KTtcbiAgICB0aGlzLmdmeCA9IG5ldyBDYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLmZpbHRlckZhY3RvcnksIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgIH0sIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzLCBkZXBlbmRlbmN5VHJhY2tlcik7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoZXJyb3IgPSBudWxsLCBleHRyYURlbGF5ID0gMCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIGlmICh0aGlzLiNyQUYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLiNyQUYpO1xuICAgICAgdGhpcy4jckFGID0gbnVsbDtcbiAgICB9XG4gICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICBlcnJvciB8fD0gbmV3IFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbihgUmVuZGVyaW5nIGNhbmNlbGxlZCwgcGFnZSAke3RoaXMuX3BhZ2VJbmRleCArIDF9YCwgZXh0cmFEZWxheSk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvcik7XG4gICAgdGhpcy50YXNrLm9uRXJyb3I/LihlcnJvcik7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZ2Z4LmRlcGVuZGVuY3lUcmFja2VyPy5ncm93T3BlcmF0aW9uc0NvdW50KHRoaXMub3BlcmF0b3JMaXN0LmZuQXJyYXkubGVuZ3RoKTtcbiAgICB0aGlzLnN0ZXBwZXI/LnVwZGF0ZU9wZXJhdG9yTGlzdCh0aGlzLm9wZXJhdG9yTGlzdCk7XG4gICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG4gIF9jb250aW51ZSgpIHtcbiAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG4gIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3VzZVJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy4jckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuI3JBRiA9IG51bGw7XG4gICAgICAgIHRoaXMuX25leHRCb3VuZCgpLmNhdGNoKHRoaXMuX2NhbmNlbEJvdW5kKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKHRoaXMuX25leHRCb3VuZCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgIH1cbiAgfVxuICBhc3luYyBfbmV4dCgpIHtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyLCB0aGlzLl9vcGVyYXRpb25zRmlsdGVyKTtcbiAgICBpZiAodGhpcy5vcGVyYXRvckxpc3RJZHggPT09IHRoaXMub3BlcmF0b3JMaXN0LmFyZ3NBcnJheS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG4gICAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmNvbnN0IHZlcnNpb24gPSBcIjUuNC40NDlcIjtcbmNvbnN0IGJ1aWxkID0gXCJmNDRlNWYwZTZcIjtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2NvbG9yX3BpY2tlci5qc1xuXG5cblxuY2xhc3MgQ29sb3JQaWNrZXIge1xuICAjYnV0dG9uID0gbnVsbDtcbiAgI2J1dHRvblN3YXRjaCA9IG51bGw7XG4gICNkZWZhdWx0Q29sb3I7XG4gICNkcm9wZG93biA9IG51bGw7XG4gICNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGZhbHNlO1xuICAjaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgI2VkaXRvciA9IG51bGw7XG4gICNldmVudEJ1cztcbiAgI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgI3VpTWFuYWdlciA9IG51bGw7XG4gIHN0YXRpYyAjbDEwbkNvbG9yID0gbnVsbDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBLZXlib2FyZE1hbmFnZXIoW1tbXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX2hpZGVEcm9wZG93bkZyb21LZXlib2FyZF0sIFtbXCIgXCIsIFwibWFjKyBcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fY29sb3JTZWxlY3RGcm9tS2V5Ym9hcmRdLCBbW1wiQXJyb3dEb3duXCIsIFwiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dSaWdodFwiXSwgQ29sb3JQaWNrZXIucHJvdG90eXBlLl9tb3ZlVG9OZXh0XSwgW1tcIkFycm93VXBcIiwgXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dVcFwiLCBcIm1hYytBcnJvd0xlZnRcIl0sIENvbG9yUGlja2VyLnByb3RvdHlwZS5fbW92ZVRvUHJldmlvdXNdLCBbW1wiSG9tZVwiLCBcIm1hYytIb21lXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0JlZ2lubmluZ10sIFtbXCJFbmRcIiwgXCJtYWMrRW5kXCJdLCBDb2xvclBpY2tlci5wcm90b3R5cGUuX21vdmVUb0VuZF1dKSk7XG4gIH1cbiAgY29uc3RydWN0b3Ioe1xuICAgIGVkaXRvciA9IG51bGwsXG4gICAgdWlNYW5hZ2VyID0gbnVsbFxuICB9KSB7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaXNNYWluQ29sb3JQaWNrZXIgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3I/Ll91aU1hbmFnZXIgfHwgdWlNYW5hZ2VyO1xuICAgIHRoaXMuI2V2ZW50QnVzID0gdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cztcbiAgICB0aGlzLiNkZWZhdWx0Q29sb3IgPSBlZGl0b3I/LmNvbG9yPy50b1VwcGVyQ2FzZSgpIHx8IHRoaXMuI3VpTWFuYWdlcj8uaGlnaGxpZ2h0Q29sb3JzLnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCBcIiNGRkZGOThcIjtcbiAgICBDb2xvclBpY2tlci4jbDEwbkNvbG9yIHx8PSBPYmplY3QuZnJlZXplKHtcbiAgICAgIGJsdWU6IFwicGRmanMtZWRpdG9yLWNvbG9ycGlja2VyLWJsdWVcIixcbiAgICAgIGdyZWVuOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1ncmVlblwiLFxuICAgICAgcGluazogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItcGlua1wiLFxuICAgICAgcmVkOiBcInBkZmpzLWVkaXRvci1jb2xvcnBpY2tlci1yZWRcIixcbiAgICAgIHllbGxvdzogXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXIteWVsbG93XCJcbiAgICB9KTtcbiAgfVxuICByZW5kZXJCdXR0b24oKSB7XG4gICAgY29uc3QgYnV0dG9uID0gdGhpcy4jYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjb2xvclBpY2tlclwiO1xuICAgIGJ1dHRvbi50YWJJbmRleCA9IFwiMFwiO1xuICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItYnV0dG9uXCIpO1xuICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcInRydWVcIjtcbiAgICBpZiAodGhpcy4jZWRpdG9yKSB7XG4gICAgICBidXR0b24uYXJpYUNvbnRyb2xzID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jb3BlbkRyb3Bkb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNrZXlEb3duLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHN3YXRjaCA9IHRoaXMuI2J1dHRvblN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHN3YXRjaC5jbGFzc05hbWUgPSBcInN3YXRjaFwiO1xuICAgIHN3YXRjaC5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgc3dhdGNoLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICBidXR0b24uYXBwZW5kKHN3YXRjaCk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICByZW5kZXJNYWluRHJvcGRvd24oKSB7XG4gICAgY29uc3QgZHJvcGRvd24gPSB0aGlzLiNkcm9wZG93biA9IHRoaXMuI2dldERyb3Bkb3duUm9vdCgpO1xuICAgIGRyb3Bkb3duLmFyaWFPcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiO1xuICAgIGRyb3Bkb3duLmFyaWFMYWJlbGxlZEJ5ID0gXCJoaWdobGlnaHRDb2xvclBpY2tlckxhYmVsXCI7XG4gICAgcmV0dXJuIGRyb3Bkb3duO1xuICB9XG4gICNnZXREcm9wZG93blJvb3QoKSB7XG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuX3NpZ25hbDtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIG5vQ29udGV4dE1lbnUsIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIGRpdi5jbGFzc05hbWUgPSBcImRyb3Bkb3duXCI7XG4gICAgZGl2LnJvbGUgPSBcImxpc3Rib3hcIjtcbiAgICBkaXYuYXJpYU11bHRpU2VsZWN0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBkaXYuYXJpYU9yaWVudGF0aW9uID0gXCJ2ZXJ0aWNhbFwiO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1lZGl0b3ItY29sb3JwaWNrZXItZHJvcGRvd25cIik7XG4gICAgaWYgKHRoaXMuI2VkaXRvcikge1xuICAgICAgZGl2LmlkID0gYCR7dGhpcy4jZWRpdG9yLmlkfV9jb2xvcnBpY2tlcl9kcm9wZG93bmA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIGNvbG9yXSBvZiB0aGlzLiN1aU1hbmFnZXIuaGlnaGxpZ2h0Q29sb3JzKSB7XG4gICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gXCIwXCI7XG4gICAgICBidXR0b24ucm9sZSA9IFwib3B0aW9uXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiLCBjb2xvcik7XG4gICAgICBidXR0b24udGl0bGUgPSBuYW1lO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBDb2xvclBpY2tlci4jbDEwbkNvbG9yW25hbWVdKTtcbiAgICAgIGNvbnN0IHN3YXRjaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgYnV0dG9uLmFwcGVuZChzd2F0Y2gpO1xuICAgICAgc3dhdGNoLmNsYXNzTmFtZSA9IFwic3dhdGNoXCI7XG4gICAgICBzd2F0Y2guc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICBidXR0b24uYXJpYVNlbGVjdGVkID0gY29sb3IgPT09IHRoaXMuI2RlZmF1bHRDb2xvcjtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jY29sb3JTZWxlY3QuYmluZCh0aGlzLCBjb2xvciksIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGRpdi5hcHBlbmQoYnV0dG9uKTtcbiAgICB9XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2tleURvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGRpdjtcbiAgfVxuICAjY29sb3JTZWxlY3QoY29sb3IsIGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ycGFyYW1zXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIHR5cGU6IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUixcbiAgICAgIHZhbHVlOiBjb2xvclxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29sb3IoY29sb3IpO1xuICB9XG4gIF9jb2xvclNlbGVjdEZyb21LZXlib2FyZChldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuI2J1dHRvbikge1xuICAgICAgdGhpcy4jb3BlbkRyb3Bkb3duKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29sb3IgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKTtcbiAgICBpZiAoIWNvbG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbG9yU2VsZWN0KGNvbG9yLCBldmVudCk7XG4gIH1cbiAgX21vdmVUb05leHQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNidXR0b24pIHtcbiAgICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0RWxlbWVudENoaWxkPy5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC50YXJnZXQubmV4dFNpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb1ByZXZpb3VzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jZHJvcGRvd24/LmZpcnN0RWxlbWVudENoaWxkIHx8IGV2ZW50LnRhcmdldCA9PT0gdGhpcy4jYnV0dG9uKSB7XG4gICAgICBpZiAodGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgICAgdGhpcy5faGlkZURyb3Bkb3duRnJvbUtleWJvYXJkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgfVxuICAgIGV2ZW50LnRhcmdldC5wcmV2aW91c1NpYmxpbmc/LmZvY3VzKCk7XG4gIH1cbiAgX21vdmVUb0JlZ2lubmluZyhldmVudCkge1xuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI29wZW5Ecm9wZG93bihldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2Ryb3Bkb3duLmZpcnN0RWxlbWVudENoaWxkPy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlVG9FbmQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd24oZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bi5sYXN0RWxlbWVudENoaWxkPy5mb2N1cygpO1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgQ29sb3JQaWNrZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICAjb3BlbkRyb3Bkb3duKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuI2lzRHJvcGRvd25WaXNpYmxlKSB7XG4gICAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNkcm9wZG93bldhc0Zyb21LZXlib2FyZCA9IGV2ZW50LmRldGFpbCA9PT0gMDtcbiAgICBpZiAoIXRoaXMuI29wZW5Ecm9wZG93bkFDKSB7XG4gICAgICB0aGlzLiNvcGVuRHJvcGRvd25BQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jcG9pbnRlckRvd24uYmluZCh0aGlzKSwge1xuICAgICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiNvcGVuRHJvcGRvd25BQylcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJ0cnVlXCI7XG4gICAgaWYgKHRoaXMuI2Ryb3Bkb3duKSB7XG4gICAgICB0aGlzLiNkcm9wZG93bi5jbGFzc0xpc3QucmVtb3ZlKFwiaGlkZGVuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290ID0gdGhpcy4jZHJvcGRvd24gPSB0aGlzLiNnZXREcm9wZG93blJvb3QoKTtcbiAgICB0aGlzLiNidXR0b24uYXBwZW5kKHJvb3QpO1xuICB9XG4gICNwb2ludGVyRG93bihldmVudCkge1xuICAgIGlmICh0aGlzLiNkcm9wZG93bj8uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmhpZGVEcm9wZG93bigpO1xuICB9XG4gIGhpZGVEcm9wZG93bigpIHtcbiAgICB0aGlzLiNkcm9wZG93bj8uY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbiAgICB0aGlzLiNidXR0b24uYXJpYUV4cGFuZGVkID0gXCJmYWxzZVwiO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDPy5hYm9ydCgpO1xuICAgIHRoaXMuI29wZW5Ecm9wZG93bkFDID0gbnVsbDtcbiAgfVxuICBnZXQgI2lzRHJvcGRvd25WaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNkcm9wZG93biAmJiAhdGhpcy4jZHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICB9XG4gIF9oaWRlRHJvcGRvd25Gcm9tS2V5Ym9hcmQoKSB7XG4gICAgaWYgKHRoaXMuI2lzTWFpbkNvbG9yUGlja2VyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaXNEcm9wZG93blZpc2libGUpIHtcbiAgICAgIHRoaXMuI2VkaXRvcj8udW5zZWxlY3QoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5oaWRlRHJvcGRvd24oKTtcbiAgICB0aGlzLiNidXR0b24uZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZSxcbiAgICAgIGZvY3VzVmlzaWJsZTogdGhpcy4jZHJvcGRvd25XYXNGcm9tS2V5Ym9hcmRcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGlmICh0aGlzLiNidXR0b25Td2F0Y2gpIHtcbiAgICAgIHRoaXMuI2J1dHRvblN3YXRjaC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNkcm9wZG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpID0gdGhpcy4jdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycy52YWx1ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuI2Ryb3Bkb3duLmNoaWxkcmVuKSB7XG4gICAgICBjaGlsZC5hcmlhU2VsZWN0ZWQgPSBpLm5leHQoKS52YWx1ZSA9PT0gY29sb3IudG9VcHBlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNidXR0b24/LnJlbW92ZSgpO1xuICAgIHRoaXMuI2J1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYnV0dG9uU3dhdGNoID0gbnVsbDtcbiAgICB0aGlzLiNkcm9wZG93bj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jZHJvcGRvd24gPSBudWxsO1xuICB9XG59XG5jbGFzcyBCYXNpY0NvbG9yUGlja2VyIHtcbiAgI2lucHV0ID0gbnVsbDtcbiAgI2VkaXRvciA9IG51bGw7XG4gICN1aU1hbmFnZXIgPSBudWxsO1xuICBzdGF0aWMgI2wxMG5Db2xvciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSBlZGl0b3IuX3VpTWFuYWdlcjtcbiAgICBCYXNpY0NvbG9yUGlja2VyLiNsMTBuQ29sb3IgfHw9IE9iamVjdC5mcmVlemUoe1xuICAgICAgZnJlZXRleHQ6IFwicGRmanMtZWRpdG9yLWNvbG9yLXBpY2tlci1mcmVlLXRleHQtaW5wdXRcIixcbiAgICAgIGluazogXCJwZGZqcy1lZGl0b3ItY29sb3ItcGlja2VyLWluay1pbnB1dFwiXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyQnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNpbnB1dCkge1xuICAgICAgcmV0dXJuIHRoaXMuI2lucHV0O1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JUeXBlLFxuICAgICAgY29sb3JUeXBlLFxuICAgICAgY29sb3JcbiAgICB9ID0gdGhpcy4jZWRpdG9yO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy4jaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiY29sb3JcIjtcbiAgICBpbnB1dC52YWx1ZSA9IGNvbG9yIHx8IFwiIzAwMDAwMFwiO1xuICAgIGlucHV0LmNsYXNzTmFtZSA9IFwiYmFzaWNDb2xvclBpY2tlclwiO1xuICAgIGlucHV0LnRhYkluZGV4ID0gMDtcbiAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgQmFzaWNDb2xvclBpY2tlci4jbDEwbkNvbG9yW2VkaXRvclR5cGVdKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVBhcmFtcyhjb2xvclR5cGUsIGlucHV0LnZhbHVlKTtcbiAgICB9LCB7XG4gICAgICBzaWduYWw6IHRoaXMuI3VpTWFuYWdlci5fc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIHVwZGF0ZSh2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jaW5wdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaW5wdXQudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2lucHV0Py5yZW1vdmUoKTtcbiAgICB0aGlzLiNpbnB1dCA9IG51bGw7XG4gIH1cbiAgaGlkZURyb3Bkb3duKCkge31cbn1cblxuOy8vIC4vc3JjL3NoYXJlZC9zY3JpcHRpbmdfdXRpbHMuanNcbmZ1bmN0aW9uIG1ha2VDb2xvckNvbXAobikge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBuKSkgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5mdW5jdGlvbiBzY2FsZUFuZENsYW1wKHgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgMjU1ICogeCkpO1xufVxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhbZ10pIHtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKFtnXSkge1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKFtnXSkge1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhbciwgZywgYl0pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoW3IsIGcsIGJdKSB7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5jb25zdCBEYXRlRm9ybWF0cyA9ICgvKiB1bnVzZWQgcHVyZSBleHByZXNzaW9uIG9yIHN1cGVyICovIG51bGwgJiYgKFtcIm0vZFwiLCBcIm0vZC95eVwiLCBcIm1tL2RkL3l5XCIsIFwibW0veXlcIiwgXCJkLW1tbVwiLCBcImQtbW1tLXl5XCIsIFwiZGQtbW1tLXl5XCIsIFwieXktbW0tZGRcIiwgXCJtbW0teXlcIiwgXCJtbW1tLXl5XCIsIFwibW1tIGQsIHl5eXlcIiwgXCJtbW1tIGQsIHl5eXlcIiwgXCJtL2QveXkgaDpNTSB0dFwiLCBcIm0vZC95eSBISDpNTVwiXSkpO1xuY29uc3QgVGltZUZvcm1hdHMgPSAoLyogdW51c2VkIHB1cmUgZXhwcmVzc2lvbiBvciBzdXBlciAqLyBudWxsICYmIChbXCJISDpNTVwiLCBcImg6TU0gdHRcIiwgXCJISDpNTTpzc1wiLCBcImg6TU06c3MgdHRcIl0pKTtcblxuOy8vIC4vc3JjL2Rpc3BsYXkvc3ZnX2ZhY3RvcnkuanNcblxuXG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBza2lwRGltZW5zaW9ucyA9IGZhbHNlKSB7XG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGRpbWVuc2lvbnNcIik7XG4gICAgfVxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX2NyZWF0ZVNWRyhcInN2ZzpzdmdcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZlcnNpb25cIiwgXCIxLjFcIik7XG4gICAgaWYgKCFza2lwRGltZW5zaW9ucykge1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGAke3dpZHRofXB4YCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGAke2hlaWdodH1weGApO1xuICAgIH1cbiAgICBzdmcuc2V0QXR0cmlidXRlKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gIGNyZWF0ZUVsZW1lbnQodHlwZSkge1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBTVkcgZWxlbWVudCB0eXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlU1ZHKHR5cGUpO1xuICB9XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlU1ZHYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBET01TVkdGYWN0b3J5IGV4dGVuZHMgQmFzZVNWR0ZhY3Rvcnkge1xuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgdHlwZSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvYW5ub3RhdGlvbl9sYXllci5qc1xuXG5cblxuXG5cbmNvbnN0IGFubm90YXRpb25fbGF5ZXJfREVGQVVMVF9GT05UX1NJWkUgPSA5O1xuY29uc3QgR2V0RWxlbWVudHNCeU5hbWVTZXQgPSBuZXcgV2Vha1NldCgpO1xuY29uc3QgVElNRVpPTkVfT0ZGU0VUID0gbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAgKiAxMDAwO1xuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIEFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI2hhc0JvcmRlciA9IGZhbHNlO1xuICAjcG9wdXBFbGVtZW50ID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycywge1xuICAgIGlzUmVuZGVyYWJsZSA9IGZhbHNlLFxuICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5pc1JlbmRlcmFibGUgPSBpc1JlbmRlcmFibGU7XG4gICAgdGhpcy5kYXRhID0gcGFyYW1ldGVycy5kYXRhO1xuICAgIHRoaXMubGF5ZXIgPSBwYXJhbWV0ZXJzLmxheWVyO1xuICAgIHRoaXMubGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyID0gcGFyYW1ldGVycy5kb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBwYXJhbWV0ZXJzLmltYWdlUmVzb3VyY2VzUGF0aDtcbiAgICB0aGlzLnJlbmRlckZvcm1zID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgdGhpcy5lbmFibGVDb21tZW50ID0gcGFyYW1ldGVycy5lbmFibGVDb21tZW50O1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaGFzT3duQ29tbWVudEJ1dHRvbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgICBpZiAoY3JlYXRlUXVhZHJpbGF0ZXJhbHMpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfaGFzUG9wdXBEYXRhKHtcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dFxuICB9KSB7XG4gICAgcmV0dXJuICEhKGNvbnRlbnRzT2JqPy5zdHIgfHwgcmljaFRleHQ/LnN0cik7XG4gIH1cbiAgZ2V0IF9pc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEuaXNFZGl0YWJsZTtcbiAgfVxuICBnZXQgaGFzUG9wdXBEYXRhKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudC5faGFzUG9wdXBEYXRhKHRoaXMuZGF0YSkgfHwgdGhpcy5lbmFibGVDb21tZW50ICYmICEhdGhpcy5jb21tZW50VGV4dDtcbiAgfVxuICBnZXQgY29tbWVudERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U/LmdldEVkaXRvcihkYXRhLmlkKTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICByZXR1cm4gZWRpdG9yLmdldERhdGEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgZ2V0IGhhc0NvbW1lbnRCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5hYmxlQ29tbWVudCAmJiB0aGlzLmhhc1BvcHVwRWxlbWVudDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U/LmdldEVkaXRvcih0aGlzLmRhdGEuaWQpO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHJldHVybiBlZGl0b3IuY29tbWVudEJ1dHRvblBvc2l0aW9uSW5QYWdlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBxdWFkUG9pbnRzLFxuICAgICAgaW5rTGlzdHMsXG4gICAgICByZWN0XG4gICAgfSA9IHRoaXMuZGF0YTtcbiAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcbiAgICBpZiAocXVhZFBvaW50cz8ubGVuZ3RoID49IDgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVhZFBvaW50cy5sZW5ndGg7IGkgKz0gOCkge1xuICAgICAgICBpZiAocXVhZFBvaW50c1tpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgbWF4WSA9IHF1YWRQb2ludHNbaSArIDFdO1xuICAgICAgICAgIG1heFggPSBxdWFkUG9pbnRzW2kgKyAyXTtcbiAgICAgICAgfSBlbHNlIGlmIChxdWFkUG9pbnRzW2kgKyAxXSA9PT0gbWF4WSkge1xuICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBxdWFkUG9pbnRzW2kgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF4WCwgbWF4WV07XG4gICAgfVxuICAgIGlmIChpbmtMaXN0cz8ubGVuZ3RoID49IDEpIHtcbiAgICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBpbmtMaXN0cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0Lmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgICAgICBpZiAoaW5rTGlzdFtpICsgMV0gPiBtYXhZKSB7XG4gICAgICAgICAgICBtYXhZID0gaW5rTGlzdFtpICsgMV07XG4gICAgICAgICAgICBtYXhYID0gaW5rTGlzdFtpXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlua0xpc3RbaSArIDFdID09PSBtYXhZKSB7XG4gICAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgaW5rTGlzdFtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4WCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFttYXhYLCBtYXhZXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3QpIHtcbiAgICAgIHJldHVybiBbcmVjdFsyXSwgcmVjdFszXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIF9ub3JtYWxpemVQb2ludChwb2ludCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50O1xuICAgIHBvaW50WzFdID0gdmlld1szXSAtIHBvaW50WzFdICsgdmlld1sxXTtcbiAgICBwb2ludFswXSA9IDEwMCAqIChwb2ludFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICBwb2ludFsxXSA9IDEwMCAqIChwb2ludFsxXSAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHQ7XG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG4gIGdldCBjb21tZW50VGV4dCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUoYCR7QW5ub3RhdGlvbkVkaXRvclByZWZpeH0ke2RhdGEuaWR9YCk/LnBvcHVwPy5jb250ZW50cyB8fCBkYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgXCJcIjtcbiAgfVxuICBzZXQgY29tbWVudFRleHQodGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBwb3B1cCA9IHtcbiAgICAgIGRlbGV0ZWQ6ICF0ZXh0LFxuICAgICAgY29udGVudHM6IHRleHQgfHwgXCJcIlxuICAgIH07XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25TdG9yYWdlLnVwZGF0ZUVkaXRvcihkYXRhLmlkLCB7XG4gICAgICBwb3B1cFxuICAgIH0pKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGAke0Fubm90YXRpb25FZGl0b3JQcmVmaXh9JHtkYXRhLmlkfWAsIHtcbiAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgIGFubm90YXRpb25UeXBlOiBkYXRhLmFubm90YXRpb25UeXBlLFxuICAgICAgICBwYWdlSW5kZXg6IHRoaXMucGFyZW50LnBhZ2UuX3BhZ2VJbmRleCxcbiAgICAgICAgcG9wdXAsXG4gICAgICAgIHBvcHVwUmVmOiBkYXRhLnBvcHVwUmVmLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBuZXcgRGF0ZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICB0aGlzLnJlbW92ZVBvcHVwKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZVBvcHVwKCkge1xuICAgICh0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwIHx8IHRoaXMucG9wdXApPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQgPSB0aGlzLnBvcHVwID0gbnVsbDtcbiAgfVxuICB1cGRhdGVFZGl0ZWQocGFyYW1zKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLnJlY3QpIHtcbiAgICAgIHRoaXMuI3VwZGF0ZXMgfHw9IHtcbiAgICAgICAgcmVjdDogdGhpcy5kYXRhLnJlY3Quc2xpY2UoMClcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBwb3B1cDogbmV3UG9wdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNzZXRSZWN0RWRpdGVkKHJlY3QpO1xuICAgIH1cbiAgICBsZXQgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwIHx8IHRoaXMucG9wdXA7XG4gICAgaWYgKCFwb3B1cCAmJiBuZXdQb3B1cD8udGV4dCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobmV3UG9wdXApO1xuICAgICAgcG9wdXAgPSB0aGlzLiNwb3B1cEVsZW1lbnQucG9wdXA7XG4gICAgfVxuICAgIGlmICghcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcG9wdXAudXBkYXRlRWRpdGVkKHBhcmFtcyk7XG4gICAgaWYgKG5ld1BvcHVwPy5kZWxldGVkKSB7XG4gICAgICBwb3B1cC5yZW1vdmUoKTtcbiAgICAgIHRoaXMuI3BvcHVwRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldFJlY3RFZGl0ZWQodGhpcy4jdXBkYXRlcy5yZWN0KTtcbiAgICB0aGlzLiNwb3B1cEVsZW1lbnQ/LnBvcHVwLnJlc2V0RWRpdGVkKCk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgI3NldFJlY3RFZGl0ZWQocmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBzdHlsZVxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdDogY3VycmVudFJlY3QsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjdXJyZW50UmVjdD8uc3BsaWNlKDAsIDQsIC4uLnJlY3QpO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocmVjdFswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsxMDAgKiAocGFnZUhlaWdodCAtIHJlY3RbM10gKyBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGlmIChyb3RhdGlvbiA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSBgJHsxMDAgKiAocmVjdFsyXSAtIHJlY3RbMF0pIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0Um90YXRpb24ocm90YXRpb24pO1xuICAgIH1cbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkgJiYgISh0aGlzIGluc3RhbmNlb2YgTGlua0Fubm90YXRpb25FbGVtZW50KSkge1xuICAgICAgY29udGFpbmVyLnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gY29udGFpbmVyO1xuICAgIHN0eWxlLnpJbmRleCA9IHRoaXMucGFyZW50LnpJbmRleDtcbiAgICB0aGlzLnBhcmVudC56SW5kZXggKz0gMjtcbiAgICBpZiAoZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IGRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5ub1JvdGF0ZSkge1xuICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJub3JvdGF0ZVwiKTtcbiAgICB9XG4gICAgaWYgKCFkYXRhLnJlY3QgfHwgdGhpcyBpbnN0YW5jZW9mIFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSBkYXRhO1xuICAgICAgaWYgKCFkYXRhLmhhc093bkNhbnZhcyAmJiByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKHJvdGF0aW9uLCBjb250YWluZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWlnbm9yZUJvcmRlciAmJiBkYXRhLmJvcmRlclN0eWxlLndpZHRoID4gMCkge1xuICAgICAgc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG4gICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7aG9yaXpvbnRhbFJhZGl1c31weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpIC8gY2FsYygke3ZlcnRpY2FsUmFkaXVzfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgICBzdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIHN0eWxlLmJvcmRlclJhZGl1cyA9IHJhZGl1cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGJldmVsZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5JTlNFVDpcbiAgICAgICAgICB3YXJuKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBkYXRhLmJvcmRlckNvbG9yIHx8IG51bGw7XG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgdGhpcy4jaGFzQm9yZGVyID0gdHJ1ZTtcbiAgICAgICAgc3R5bGUuYm9yZGVyQ29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IFV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHBhZ2VYLFxuICAgICAgcGFnZVlcbiAgICB9ID0gdmlld3BvcnQucmF3RGltcztcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIGNvbnN0IHtcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRhdGEuaGFzT3duQ2FudmFzIHx8IHJvdGF0aW9uID09PSAwKSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRoIC8gcGFnZVdpZHRofSVgO1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSwgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5yZWN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQucmF3RGltcztcbiAgICBsZXQge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoYW5nbGUgJSAxODAgIT09IDApIHtcbiAgICAgIFt3aWR0aCwgaGVpZ2h0XSA9IFtoZWlnaHQsIHdpZHRoXTtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuICBnZXQgX2NvbW1vbkFjdGlvbnMoKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSAoanNOYW1lLCBzdHlsZU5hbWUsIGV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBjb2xvciA9IGV2ZW50LmRldGFpbFtqc05hbWVdO1xuICAgICAgY29uc3QgY29sb3JUeXBlID0gY29sb3JbMF07XG4gICAgICBjb25zdCBjb2xvckFycmF5ID0gY29sb3Iuc2xpY2UoMSk7XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IENvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBDb2xvckNvbnZlcnRlcnNbYCR7Y29sb3JUeXBlfV9yZ2JgXShjb2xvckFycmF5KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2NvbW1vbkFjdGlvbnNcIiwge1xuICAgICAgZGlzcGxheTogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZGlzcGxheVxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zdCBoaWRkZW4gPSBkaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlbixcbiAgICAgICAgICBub1ByaW50OiBkaXNwbGF5ID09PSAxIHx8IGRpc3BsYXkgPT09IDJcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBub1ByaW50OiAhZXZlbnQuZGV0YWlsLnByaW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaGlkZGVuXG4gICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogaGlkZGVuLFxuICAgICAgICAgIG5vVmlldzogaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC5kaXNhYmxlZCA9IGV2ZW50LmRldGFpbC5yZWFkb25seTtcbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9zZXRSZXF1aXJlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC5yZXF1aXJlZCk7XG4gICAgICB9LFxuICAgICAgYmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJnQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZpbGxDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZpbGxDb2xvclwiLCBcImJhY2tncm91bmRDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgZmdDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImZnQ29sb3JcIiwgXCJjb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgdGV4dENvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwidGV4dENvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGJvcmRlckNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwiYm9yZGVyQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJzdHJva2VDb2xvclwiLCBcImJvcmRlckNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICByb3RhdGlvbjogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhbmdsZSA9IGV2ZW50LmRldGFpbC5yb3RhdGlvbjtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihhbmdsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcm90YXRpb246IGFuZ2xlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhqc0V2ZW50LmRldGFpbCkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGFjdGlvbnNbbmFtZV0gfHwgY29tbW9uQWN0aW9uc1tuYW1lXTtcbiAgICAgIGFjdGlvbj8uKGpzRXZlbnQpO1xuICAgIH1cbiAgfVxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UuZ2V0UmF3VmFsdWUodGhpcy5kYXRhLmlkKTtcbiAgICBpZiAoIXN0b3JlZERhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG4gICAgZm9yIChjb25zdCBbYWN0aW9uTmFtZSwgZGV0YWlsXSBvZiBPYmplY3QuZW50cmllcyhzdG9yZWREYXRhKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gY29tbW9uQWN0aW9uc1thY3Rpb25OYW1lXTtcbiAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgZXZlbnRQcm94eSA9IHtcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIFthY3Rpb25OYW1lXTogZGV0YWlsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6IGVsZW1lbnRcbiAgICAgICAgfTtcbiAgICAgICAgYWN0aW9uKGV2ZW50UHJveHkpO1xuICAgICAgICBkZWxldGUgc3RvcmVkRGF0YVthY3Rpb25OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKCkge1xuICAgIGlmICghdGhpcy5jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcXVhZFBvaW50c1xuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgaWYgKCFxdWFkUG9pbnRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtyZWN0QmxYLCByZWN0QmxZLCByZWN0VHJYLCByZWN0VHJZXSA9IHRoaXMuZGF0YS5yZWN0Lm1hcCh4ID0+IE1hdGguZnJvdW5kKHgpKTtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDgpIHtcbiAgICAgIGNvbnN0IFt0clgsIHRyWSwgYmxYLCBibFldID0gcXVhZFBvaW50cy5zdWJhcnJheSgyLCA2KTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgc3ZnLnJvbGUgPSBcIm5vbmVcIjtcbiAgICBjb25zdCBkZWZzID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiKTtcbiAgICBzdmcuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgY29uc3QgaWQgPSBgY2xpcHBhdGhfJHt0aGlzLmRhdGEuaWR9YDtcbiAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBpZCk7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiY2xpcFBhdGhVbml0c1wiLCBcIm9iamVjdEJvdW5kaW5nQm94XCIpO1xuICAgIGRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcbiAgICBmb3IgKGxldCBpID0gMiwgaWkgPSBxdWFkUG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDgpIHtcbiAgICAgIGNvbnN0IHRyWCA9IHF1YWRQb2ludHNbaV07XG4gICAgICBjb25zdCB0clkgPSBxdWFkUG9pbnRzW2kgKyAxXTtcbiAgICAgIGNvbnN0IGJsWCA9IHF1YWRQb2ludHNbaSArIDJdO1xuICAgICAgY29uc3QgYmxZID0gcXVhZFBvaW50c1tpICsgM107XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cChwb3B1cERhdGEgPSBudWxsKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YVxuICAgIH0gPSB0aGlzO1xuICAgIGxldCBjb250ZW50c09iaiwgbW9kaWZpY2F0aW9uRGF0ZTtcbiAgICBpZiAocG9wdXBEYXRhKSB7XG4gICAgICBjb250ZW50c09iaiA9IHtcbiAgICAgICAgc3RyOiBwb3B1cERhdGEudGV4dFxuICAgICAgfTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUgPSBwb3B1cERhdGEuZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudHNPYmogPSBkYXRhLmNvbnRlbnRzT2JqO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZSA9IGRhdGEubW9kaWZpY2F0aW9uRGF0ZTtcbiAgICB9XG4gICAgdGhpcy4jcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQoe1xuICAgICAgZGF0YToge1xuICAgICAgICBjb2xvcjogZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGVPYmo6IGRhdGEudGl0bGVPYmosXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgICByaWNoVGV4dDogZGF0YS5yaWNoVGV4dCxcbiAgICAgICAgcGFyZW50UmVjdDogZGF0YS5yZWN0LFxuICAgICAgICBib3JkZXJTdHlsZTogMCxcbiAgICAgICAgaWQ6IGBwb3B1cF8ke2RhdGEuaWR9YCxcbiAgICAgICAgcm90YXRpb246IGRhdGEucm90YXRpb24sXG4gICAgICAgIG5vUm90YXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMubGlua1NlcnZpY2UsXG4gICAgICBwYXJlbnQ6IHRoaXMucGFyZW50LFxuICAgICAgZWxlbWVudHM6IFt0aGlzXVxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNQb3B1cEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICEhKHRoaXMuI3BvcHVwRWxlbWVudCB8fCB0aGlzLnBvcHVwIHx8IHRoaXMuZGF0YS5wb3B1cFJlZik7XG4gIH1cbiAgZ2V0IGV4dHJhUG9wdXBFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNwb3B1cEVsZW1lbnQ7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgbWV0aG9kIGBBbm5vdGF0aW9uRWxlbWVudC5yZW5kZXJgIGNhbGxlZFwiKTtcbiAgfVxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHdhcm4oYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIGRvbUVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpZWxkcztcbiAgICB9XG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICB9ID0gZG9tRWxlbWVudDtcbiAgICAgIGNvbnN0IGlkID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIik7XG4gICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8ubWF5YmVTaG93KCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMucG9wdXA/LmZvcmNlSGlkZSgpO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmlnZ2VycykpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2Vycykge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmlnZ2Vycy5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgICB9XG4gIH1cbiAgX2VkaXRPbkRvdWJsZUNsaWNrKCkge1xuICAgIGlmICghdGhpcy5faXNFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWRpdG9yVHlwZTogbW9kZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaWQ6IGVkaXRJZFxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcInN3aXRjaGFubm90YXRpb25lZGl0b3Jtb2RlXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBtb2RlLFxuICAgICAgICBlZGl0SWQsXG4gICAgICAgIG11c3RFbnRlckluRWRpdE1vZGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnJlY3RbMl0gLSB0aGlzLmRhdGEucmVjdFswXTtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdO1xuICB9XG59XG5jbGFzcyBFZGl0b3JBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuZWRpdG9yID0gcGFyYW1ldGVycy5lZGl0b3I7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZWRpdG9yQW5ub3RhdGlvblwiO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBjcmVhdGVPclVwZGF0ZVBvcHVwKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVkaXRvclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZWRpdG9yLmhhc0NvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY3JlYXRlUG9wdXAoZWRpdG9yLmNvbW1lbnQpO1xuICB9XG4gIGdldCBoYXNDb21tZW50QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuYWJsZUNvbW1lbnQgJiYgdGhpcy5lZGl0b3IuaGFzQ29tbWVudDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tZW50QnV0dG9uUG9zaXRpb25JblBhZ2U7XG4gIH1cbiAgZ2V0IGNvbW1lbnRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tZW50LnRleHQ7XG4gIH1cbiAgc2V0IGNvbW1lbnRUZXh0KHRleHQpIHtcbiAgICB0aGlzLmVkaXRvci5jb21tZW50ID0gdGV4dDtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHRoaXMucmVtb3ZlUG9wdXAoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGNvbW1lbnREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXREYXRhKCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMucGFyZW50LnJlbW92ZUFubm90YXRpb24odGhpcy5kYXRhLmlkKTtcbiAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICB9XG59XG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbiwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmF0dGFjaG1lbnQpIHtcbiAgICAgIHRoaXMuI2JpbmRBdHRhY2htZW50KGxpbmssIGRhdGEuYXR0YWNobWVudCwgZGF0YS5vdmVybGFpZFRleHQsIGRhdGEuYXR0YWNobWVudERlc3QpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLnNldE9DR1N0YXRlKSB7XG4gICAgICB0aGlzLiNiaW5kU2V0T0NHU3RhdGUobGluaywgZGF0YS5zZXRPQ0dTdGF0ZSwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCwgZGF0YS5vdmVybGFpZFRleHQpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnJlc2V0Rm9ybSkge1xuICAgICAgICB0aGlzLl9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIGRhdGEucmVzZXRGb3JtKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5rQW5ub3RhdGlvblwiKTtcbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250ZW50RWxlbWVudCA9IGxpbms7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24sIG92ZXJsYWlkVGV4dCA9IFwiXCIpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uLCBvdmVybGFpZFRleHQgPSBcIlwiKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGxpbmsudGl0bGUgPSBvdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50LCBvdmVybGFpZFRleHQgPSBcIlwiLCBkZXN0ID0gbnVsbCkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGlmIChhdHRhY2htZW50LmRlc2NyaXB0aW9uKSB7XG4gICAgICBsaW5rLnRpdGxlID0gYXR0YWNobWVudC5kZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YShhdHRhY2htZW50LmNvbnRlbnQsIGF0dGFjaG1lbnQuZmlsZW5hbWUsIGRlc3QpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgI2JpbmRTZXRPQ0dTdGF0ZShsaW5rLCBhY3Rpb24sIG92ZXJsYWlkVGV4dCA9IFwiXCIpIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV4ZWN1dGVTZXRPQ0dTdGF0ZShhY3Rpb24pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgbGluay50aXRsZSA9IG92ZXJsYWlkVGV4dDtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRKU0FjdGlvbihsaW5rLCBkYXRhKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcChbW1wiQWN0aW9uXCIsIFwib25jbGlja1wiXSwgW1wiTW91c2UgVXBcIiwgXCJvbm1vdXNldXBcIl0sIFtcIk1vdXNlIERvd25cIiwgXCJvbm1vdXNlZG93blwiXV0pO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuICAgICAgaWYgKCFqc05hbWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsaW5rW2pzTmFtZV0gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGRhdGEub3ZlcmxhaWRUZXh0KSB7XG4gICAgICBsaW5rLnRpdGxlID0gZGF0YS5vdmVybGFpZFRleHQ7XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBcInJlc2V0Rm9ybVwiIGFjdGlvbiBub3Qgc3VwcG9ydGVkLCBgICsgXCJlbnN1cmUgdGhhdCB0aGUgYGZpZWxkT2JqZWN0c2AgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLlwiKTtcbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgb3RoZXJDbGlja0FjdGlvbj8uKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpZWxkczogcmVzZXRGb3JtRmllbGRzLFxuICAgICAgICByZWZzOiByZXNldEZvcm1SZWZzLFxuICAgICAgICBpbmNsdWRlXG4gICAgICB9ID0gcmVzZXRGb3JtO1xuICAgICAgY29uc3QgYWxsRmllbGRzID0gW107XG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIHJlc2V0Rm9ybUZpZWxkcykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuX2ZpZWxkT2JqZWN0c1tmaWVsZE5hbWVdIHx8IFtdO1xuICAgICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICB9IG9mIGZpZWxkcykge1xuICAgICAgICAgICAgZmllbGRJZHMuYWRkKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgY29uc3QgYWxsSWRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGFsbEZpZWxkcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGZpZWxkO1xuICAgICAgICBhbGxJZHMucHVzaChpZCk7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNoZWNrYm94XCI6XG4gICAgICAgICAgY2FzZSBcInJhZGlvYnV0dG9uXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlID09PSBmaWVsZC5leHBvcnRWYWx1ZXM7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImNvbWJvYm94XCI6XG4gICAgICAgICAgY2FzZSBcImxpc3Rib3hcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICghR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgd2FybihgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRvbUVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJyZXNldGZvcm1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IFwiYXBwXCIsXG4gICAgICAgICAgICBpZHM6IGFsbElkcyxcbiAgICAgICAgICAgIG5hbWU6IFwiUmVzZXRGb3JtXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cbn1cbmNsYXNzIFRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidGV4dEFubm90YXRpb25cIik7XG4gICAgY29uc3QgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLXRleHQtYW5ub3RhdGlvbi10eXBlXCIpO1xuICAgIGltYWdlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIHR5cGU6IHRoaXMuZGF0YS5uYW1lXG4gICAgfSkpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLmhhc093bkNvbW1lbnRCdXR0b24gPSB0cnVlO1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGltYWdlKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgIGlmIChlbGVtZW50LnByZXZpb3VzU2libGluZz8ubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIpIHtcbiAgICAgICAgZWxlbWVudC5wcmV2aW91c1NpYmxpbmcuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRLZXlNb2RpZmllcihldmVudCkge1xuICAgIHJldHVybiB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtLmlzTWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7XG4gIH1cbiAgX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIHZhbHVlR2V0dGVyKSB7XG4gICAgaWYgKGJhc2VOYW1lLmluY2x1ZGVzKFwibW91c2VcIikpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpLFxuICAgICAgICAgICAgc2hpZnQ6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbW9kaWZpZXI6IHRoaXMuX2dldEtleU1vZGlmaWVyKGV2ZW50KVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGJhc2VOYW1lLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChiYXNlTmFtZSA9PT0gXCJibHVyXCIpIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGJhc2VOYW1lID09PSBcImZvY3VzXCIpIHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEuZm9jdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtZW50RGF0YS5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlR2V0dGVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZGF0YS5pZCxcbiAgICAgICAgICAgIG5hbWU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZUdldHRlcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgbmFtZXMsIGdldHRlcikge1xuICAgIGZvciAoY29uc3QgW2Jhc2VOYW1lLCBldmVudE5hbWVdIG9mIG5hbWVzKSB7XG4gICAgICBpZiAoZXZlbnROYW1lID09PSBcIkFjdGlvblwiIHx8IHRoaXMuZGF0YS5hY3Rpb25zPy5bZXZlbnROYW1lXSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcIkZvY3VzXCIgfHwgZXZlbnROYW1lID09PSBcIkJsdXJcIikge1xuICAgICAgICAgIGVsZW1lbnREYXRhIHx8PSB7XG4gICAgICAgICAgICBmb2N1c2VkOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgZ2V0dGVyKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiICYmICF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiYmx1clwiLCBcIkJsdXJcIiwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSBcIkJsdXJcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBlbGVtZW50RGF0YSwgXCJmb2N1c1wiLCBcIkZvY3VzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCkge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5kYXRhLmJhY2tncm91bmRDb2xvciB8fCBudWxsO1xuICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3IgPT09IG51bGwgPyBcInRyYW5zcGFyZW50XCIgOiBVdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgfVxuICBfc2V0VGV4dFN0eWxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBURVhUX0FMSUdOTUVOVCA9IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXTtcbiAgICBjb25zdCB7XG4gICAgICBmb250Q29sb3JcbiAgICB9ID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemUgfHwgYW5ub3RhdGlvbl9sYXllcl9ERUZBVUxUX0ZPTlRfU0laRTtcbiAgICBjb25zdCBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgbGV0IGNvbXB1dGVkRm9udFNpemU7XG4gICAgY29uc3QgQk9SREVSX1NJWkUgPSAyO1xuICAgIGNvbnN0IHJvdW5kVG9PbmVEZWNpbWFsID0geCA9PiBNYXRoLnJvdW5kKDEwICogeCkgLyAxMDtcbiAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbnN0IG51bWJlck9mTGluZXMgPSBNYXRoLnJvdW5kKGhlaWdodCAvIChMSU5FX0ZBQ1RPUiAqIGZvbnRTaXplKSkgfHwgMTtcbiAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBoZWlnaHQgLyBudW1iZXJPZkxpbmVzO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChsaW5lSGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5hYnModGhpcy5kYXRhLnJlY3RbM10gLSB0aGlzLmRhdGEucmVjdFsxXSAtIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNvbXB1dGVkRm9udFNpemUgPSBNYXRoLm1pbihmb250U2l6ZSwgcm91bmRUb09uZURlY2ltYWwoaGVpZ2h0IC8gTElORV9GQUNUT1IpKTtcbiAgICB9XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcbiAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgIHN0eWxlLnRleHRBbGlnbiA9IFRFWFRfQUxJR05NRU5UW3RoaXMuZGF0YS50ZXh0QWxpZ25tZW50XTtcbiAgICB9XG4gIH1cbiAgX3NldFJlcXVpcmVkKGVsZW1lbnQsIGlzUmVxdWlyZWQpIHtcbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG59XG5jbGFzcyBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zIHx8IHBhcmFtZXRlcnMuZGF0YS5oYXNPd25DYW52YXMgfHwgIXBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlICYmICEhcGFyYW1ldGVycy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvcGVydHlPblNpYmxpbmdzKGJhc2UsIGtleSwgdmFsdWUsIGtleUluU3RvcmFnZSkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGVsZW1lbnQuaWQsIHtcbiAgICAgICAgW2tleUluU3RvcmFnZV06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlIHx8IFwiXCI7XG4gICAgICBjb25zdCBtYXhMZW4gPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIGNoYXJMaW1pdDogdGhpcy5kYXRhLm1heExlblxuICAgICAgfSkuY2hhckxpbWl0O1xuICAgICAgaWYgKG1heExlbiAmJiB0ZXh0Q29udGVudC5sZW5ndGggPiBtYXhMZW4pIHtcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gc3RvcmVkRGF0YS5mb3JtYXR0ZWRWYWx1ZSB8fCB0aGlzLmRhdGEudGV4dENvbnRlbnQ/LmpvaW4oXCJcXG5cIikgfHwgbnVsbDtcbiAgICAgIGlmIChmaWVsZEZvcm1hdHRlZFZhbHVlcyAmJiB0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzLnJlcGxhY2VBbGwoL1xccysvZywgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgdXNlclZhbHVlOiB0ZXh0Q29udGVudCxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZpZWxkRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICBsYXN0Q29tbWl0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IHRoaXMuZGF0YS5wYXNzd29yZCA/IFwicGFzc3dvcmRcIiA6IFwidGV4dFwiO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgICAgdGhpcy5jb250ZW50RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRldGltZUZvcm1hdCxcbiAgICAgICAgZGF0ZXRpbWVUeXBlLFxuICAgICAgICB0aW1lU3RlcFxuICAgICAgfSA9IHRoaXMuZGF0YTtcbiAgICAgIGNvbnN0IGhhc0RhdGVPclRpbWUgPSAhIWRhdGV0aW1lVHlwZSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZztcbiAgICAgIGlmIChkYXRldGltZUZvcm1hdCkge1xuICAgICAgICBlbGVtZW50LnRpdGxlID0gZGF0ZXRpbWVGb3JtYXQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgICAgaWYgKG1heExlbikge1xuICAgICAgICBlbGVtZW50Lm1heExlbmd0aCA9IG1heExlbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlPblNpYmxpbmdzKGVsZW1lbnQsIFwidmFsdWVcIiwgZXZlbnQudGFyZ2V0LnZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGxldCBibHVyTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICB9ID0gZWxlbWVudERhdGE7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICB0YXJnZXQudHlwZSA9IGRhdGV0aW1lVHlwZTtcbiAgICAgICAgICAgIGlmICh0aW1lU3RlcCkge1xuICAgICAgICAgICAgICB0YXJnZXQuc3RlcCA9IHRpbWVTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgIGlmIChoYXNEYXRlT3JUaW1lKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRldGltZVR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IFtkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKV07XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gcGFydHMubWFwKHYgPT4gdi50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSkuam9pbihcIjpcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gbmV3IERhdGUodmFsdWUgLSBUSU1FWk9ORV9PRkZTRVQpLnRvSVNPU3RyaW5nKCkuc3BsaXQoZGF0ZXRpbWVUeXBlID09PSBcImRhdGVcIiA/IFwiVFwiIDogXCIuXCIsIDEpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uRm9jdXMpIHtcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICAgIHRoaXMuc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGpzRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlID8/IFwiXCI7XG4gICAgICAgICAgICAgIGlmICghaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbGVtZW50RGF0YS51c2VyVmFsdWUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGZvcm1hdHRlZFZhbHVlICE9PSBudWxsICYmIGZvcm1hdHRlZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZXZlbnQudGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCBkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLmRhdGEuYWN0aW9ucz8uQmx1cikge1xuICAgICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICBpZiAoaGFzRGF0ZU9yVGltZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIGRhdGV0aW1lVHlwZSA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zcGxpdChcIjpcIikubWFwKHYgPT4gcGFyc2VJbnQodiwgMTApKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSgyMDAwLCAwLCAxLCBwYXJ0c1swXSwgcGFydHNbMV0sIHBhcnRzWzJdIHx8IDApLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgdGFyZ2V0LnN0ZXAgPSBcIlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5pbmNsdWRlcyhcIlRcIikpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGAke3ZhbHVlfVQwMDowMGA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSkudmFsdWVPZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogZWxlbWVudERhdGEuY29tbWl0S2V5LFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuYWN0aW9ucz8uS2V5c3Ryb2tlKSB7XG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICB9ID0gZXZlbnQ7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9ID0gdGFyZ2V0O1xuICAgICAgICAgICAgbGV0IHNlbFN0YXJ0ID0gc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQuaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVXb3JkQmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkubWF0Y2goL1xcdypbXlxcd10qJC8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRGb3J3YXJkXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uU3RhcnQpLm1hdGNoKC9eW15cXHddKlxcdyovKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0IC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2U6IGRhdGEgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChibHVyTGlzdGVuZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgICBlbGVtZW50LmhpZGRlbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3NldFRleHRTdHlsZShlbGVtZW50KTtcbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6ICEhcGFyYW1ldGVycy5kYXRhLmhhc093bkNhbnZhc1xuICAgIH0pO1xuICB9XG59XG5jbGFzcyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICE9PSBcIk9mZlwiO1xuICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwiY2hlY2tCb3hcIik7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImV4cG9ydFZhbHVlXCIsIGRhdGEuZXhwb3J0VmFsdWUpO1xuICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IGNoZWNrYm94IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiBjaGVja2JveC5leHBvcnRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICAgICAgaWYgKGNoZWNrYm94LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2JveC5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoY2hlY2tib3guaWQsIHtcbiAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlIHx8IFwiT2ZmXCI7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicmFkaW9CdXR0b25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZmllbGRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBmb3IgKGNvbnN0IHJhZGlvIG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKGRhdGEuZmllbGROYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lLFxuICAgICAgICBjaGVja2VkXG4gICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgY29uc3QgcGRmQnV0dG9uVmFsdWUgPSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSBwZGZCdXR0b25WYWx1ZSA9PT0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCByYWRpbyBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShldmVudC50YXJnZXQubmFtZSkpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgcmFkaW8uaWQgPT09IGlkO1xuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShyYWRpby5pZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBudWxsLCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIExpbmtBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpZ25vcmVCb3JkZXI6IHBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvblwiLCBcInB1c2hCdXR0b25cIik7XG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucyAmJiBsaW5rRWxlbWVudCkge1xuICAgICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMobGlua0VsZW1lbnQpO1xuICAgICAgbGlua0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goe30sIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaG9pY2VXaWRnZXRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoc2VsZWN0RWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuICAgIHNlbGVjdEVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiAoe1xuICAgICAgICBkaXNwbGF5VmFsdWU6IG9wdGlvbi50ZXh0Q29udGVudCxcbiAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgfSkpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZShldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeT8uKCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gc2VsZWN0RWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kZXRhaWwucmVtb3ZlO1xuICAgICAgICAgICAgb3B0aW9uc1tpbmRleF0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgaSA9IEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXguY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluc2VydChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbC5pbnNlcnQ7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RDaGlsZCA9IHNlbGVjdEVsZW1lbnQuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgaWYgKHNlbGVjdENoaWxkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdENoaWxkLmJlZm9yZShvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpdGVtcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBpdGVtO1xuICAgICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICAgICAgb3B0aW9uRWxlbWVudC52YWx1ZSA9IGV4cG9ydFZhbHVlO1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RFbGVtZW50Lm9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50Lm9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbmRpY2VzKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gbmV3IFNldChldmVudC5kZXRhaWwuaW5kaWNlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBleHBvcnRWYWx1ZSA9IGdldFZhbHVlKHRydWUpO1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGhhc0NvbW1lbnRNYW5hZ2VyID0gISFwYXJlbnQuX2NvbW1lbnRNYW5hZ2VyO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogIWhhc0NvbW1lbnRNYW5hZ2VyICYmIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSlcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgaWYgKGhhc0NvbW1lbnRNYW5hZ2VyICYmIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEoZGF0YSkpIHtcbiAgICAgIGNvbnN0IHBvcHVwID0gdGhpcy5wb3B1cCA9IHRoaXMuI2NyZWF0ZVBvcHVwKCk7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgZWxlbWVudC5wb3B1cCA9IHBvcHVwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgI2NyZWF0ZVBvcHVwKCkge1xuICAgIHJldHVybiBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5jb250YWluZXIsXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlIHx8IHRoaXMuZGF0YS5jcmVhdGlvbkRhdGUsXG4gICAgICBjb250ZW50c09iajogdGhpcy5kYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuZGF0YS5yaWNoVGV4dCxcbiAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LFxuICAgICAgcGFyZW50UmVjdDogdGhpcy5kYXRhLnBhcmVudFJlY3QgfHwgbnVsbCxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cyxcbiAgICAgIG9wZW46IHRoaXMuZGF0YS5vcGVuLFxuICAgICAgY29tbWVudE1hbmFnZXI6IHRoaXMucGFyZW50Ll9jb21tZW50TWFuYWdlclxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXJcbiAgICB9ID0gdGhpcztcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb250YWluZXIucm9sZSA9IFwiY29tbWVudFwiO1xuICAgIGNvbnN0IHBvcHVwID0gdGhpcy5wb3B1cCA9IHRoaXMuI2NyZWF0ZVBvcHVwKCk7XG4gICAgY29uc3QgZWxlbWVudElkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LnBvcHVwID0gcG9wdXA7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lci5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgICAgZWxlbWVudElkcy5wdXNoKGVsZW1lbnQuZGF0YS5pZCk7XG4gICAgICBlbGVtZW50LmFkZEhpZ2hsaWdodEFyZWEoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCBlbGVtZW50SWRzLm1hcChpZCA9PiBgJHtBbm5vdGF0aW9uUHJlZml4fSR7aWR9YCkuam9pbihcIixcIikpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgI2NvbW1lbnRNYW5hZ2VyID0gbnVsbDtcbiAgI2JvdW5kS2V5RG93biA9IHRoaXMuI2tleURvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kSGlkZSA9IHRoaXMuI2hpZGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kU2hvdyA9IHRoaXMuI3Nob3cuYmluZCh0aGlzKTtcbiAgI2JvdW5kVG9nZ2xlID0gdGhpcy4jdG9nZ2xlLmJpbmQodGhpcyk7XG4gICNjb2xvciA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjY29udGVudHNPYmogPSBudWxsO1xuICAjZGF0ZU9iaiA9IG51bGw7XG4gICNlbGVtZW50cyA9IG51bGw7XG4gICNwYXJlbnQgPSBudWxsO1xuICAjcGFyZW50UmVjdCA9IG51bGw7XG4gICNwaW5uZWQgPSBmYWxzZTtcbiAgI3BvcHVwID0gbnVsbDtcbiAgI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgI3Bvc2l0aW9uID0gbnVsbDtcbiAgI2NvbW1lbnRCdXR0b24gPSBudWxsO1xuICAjY29tbWVudEJ1dHRvblBvc2l0aW9uID0gbnVsbDtcbiAgI3BvcHVwUG9zaXRpb24gPSBudWxsO1xuICAjcmVjdCA9IG51bGw7XG4gICNyaWNoVGV4dCA9IG51bGw7XG4gICN0aXRsZU9iaiA9IG51bGw7XG4gICN1cGRhdGVzID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgI2ZpcnN0RWxlbWVudCA9IG51bGw7XG4gICNjb21tZW50VGV4dCA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250YWluZXIsXG4gICAgY29sb3IsXG4gICAgZWxlbWVudHMsXG4gICAgdGl0bGVPYmosXG4gICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICBjb250ZW50c09iaixcbiAgICByaWNoVGV4dCxcbiAgICBwYXJlbnQsXG4gICAgcmVjdCxcbiAgICBwYXJlbnRSZWN0LFxuICAgIG9wZW4sXG4gICAgY29tbWVudE1hbmFnZXIgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jdGl0bGVPYmogPSB0aXRsZU9iajtcbiAgICB0aGlzLiNjb250ZW50c09iaiA9IGNvbnRlbnRzT2JqO1xuICAgIHRoaXMuI3JpY2hUZXh0ID0gcmljaFRleHQ7XG4gICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuI2NvbG9yID0gY29sb3I7XG4gICAgdGhpcy4jcmVjdCA9IHJlY3Q7XG4gICAgdGhpcy4jcGFyZW50UmVjdCA9IHBhcmVudFJlY3Q7XG4gICAgdGhpcy4jZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlciA9IGNvbW1lbnRNYW5hZ2VyO1xuICAgIHRoaXMuI2ZpcnN0RWxlbWVudCA9IGVsZW1lbnRzWzBdO1xuICAgIHRoaXMuI2RhdGVPYmogPSBQREZEYXRlU3RyaW5nLnRvRGF0ZU9iamVjdChtb2RpZmljYXRpb25EYXRlKTtcbiAgICB0aGlzLnRyaWdnZXIgPSBlbGVtZW50cy5mbGF0TWFwKGUgPT4gZS5nZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkpO1xuICAgIGlmICghY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuI2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAjYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hbFxuICAgIH0gPSB0aGlzLiNwb3B1cEFib3J0Q29udHJvbGxlcjtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIHRoaXMuI2JvdW5kU2hvdywge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIHRoaXMuI2JvdW5kSGlkZSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNzZXRDb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuI2VsZW1lbnRzLmZpbmQoZSA9PiBlLmhhc0NvbW1lbnRCdXR0b24pO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24gPSBlbGVtZW50Ll9ub3JtYWxpemVQb2ludChlbGVtZW50LmNvbW1lbnRCdXR0b25Qb3NpdGlvbik7XG4gIH1cbiAgcmVuZGVyQ29tbWVudEJ1dHRvbigpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudEJ1dHRvbikge1xuICAgICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy4jZmlyc3RFbGVtZW50LmNvbnRhaW5lci5hZnRlcih0aGlzLiNjb21tZW50QnV0dG9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIHRoaXMuI3NldENvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzaWduYWxcbiAgICB9ID0gdGhpcy4jcG9wdXBBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgaGFzT3duQnV0dG9uID0gdGhpcy4jZmlyc3RFbGVtZW50Lmhhc093bkNvbW1lbnRCdXR0b247XG4gICAgY29uc3QgdG9nZ2xlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgdHJ1ZSwgdW5kZWZpbmVkLCAhaGFzT3duQnV0dG9uKTtcbiAgICB9O1xuICAgIGNvbnN0IHNob3dQb3B1cCA9ICgpID0+IHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnRvZ2dsZUNvbW1lbnRQb3B1cCh0aGlzLCBmYWxzZSwgdHJ1ZSwgIWhhc093bkJ1dHRvbik7XG4gICAgfTtcbiAgICBjb25zdCBoaWRlUG9wdXAgPSAoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50TWFuYWdlci50b2dnbGVDb21tZW50UG9wdXAodGhpcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9O1xuICAgIGlmICghaGFzT3duQnV0dG9uKSB7XG4gICAgICBjb25zdCBidXR0b24gPSB0aGlzLiNjb21tZW50QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBcImFubm90YXRpb25Db21tZW50QnV0dG9uXCI7XG4gICAgICBjb25zdCBwYXJlbnRDb250YWluZXIgPSB0aGlzLiNmaXJzdEVsZW1lbnQuY29udGFpbmVyO1xuICAgICAgYnV0dG9uLnN0eWxlLnpJbmRleCA9IHBhcmVudENvbnRhaW5lci5zdHlsZS56SW5kZXggKyAxO1xuICAgICAgYnV0dG9uLnRhYkluZGV4ID0gMDtcbiAgICAgIGJ1dHRvbi5hcmlhSGFzUG9wdXAgPSBcImRpYWxvZ1wiO1xuICAgICAgYnV0dG9uLmFyaWFDb250cm9scyA9IFwiY29tbWVudFBvcHVwXCI7XG4gICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWlkXCIsIFwicGRmanMtc2hvdy1jb21tZW50LWJ1dHRvblwiKTtcbiAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKCk7XG4gICAgICB0aGlzLiN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleURvd24sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIHNob3dQb3B1cCwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgaGlkZVBvcHVwLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICBwYXJlbnRDb250YWluZXIuYWZ0ZXIoYnV0dG9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jY29tbWVudEJ1dHRvbiA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb250YWluZXI7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgIGVsZW1lbnQuYXJpYUhhc1BvcHVwID0gXCJkaWFsb2dcIjtcbiAgICAgICAgZWxlbWVudC5hcmlhQ29udHJvbHMgPSBcImNvbW1lbnRQb3B1cFwiO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93biwge1xuICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG9nZ2xlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBzaG93UG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBoaWRlUG9wdXAsIHtcbiAgICAgICAgICBzaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICN1cGRhdGVDb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCAmJiAhdGhpcy4jZmlyc3RFbGVtZW50LmVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHRoaXMucmVuZGVyQ29tbWVudEJ1dHRvbigpO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNjb21tZW50QnV0dG9uUG9zaXRpb247XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29tbWVudEJ1dHRvbjtcbiAgICBzdHlsZS5sZWZ0ID0gYGNhbGMoJHt4fSUpYDtcbiAgICBzdHlsZS50b3AgPSBgY2FsYygke3l9JSAtIHZhcigtLWNvbW1lbnQtYnV0dG9uLWRpbSkpYDtcbiAgfVxuICAjdXBkYXRlQ29sb3IoKSB7XG4gICAgaWYgKHRoaXMuI2ZpcnN0RWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHRoaXMucmVuZGVyQ29tbWVudEJ1dHRvbigpO1xuICAgIH1cbiAgICB0aGlzLiNjb21tZW50QnV0dG9uLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuY29tbWVudEJ1dHRvbkNvbG9yIHx8IFwiXCI7XG4gIH1cbiAgZ2V0IGNvbW1lbnRCdXR0b25Db2xvcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHlcbiAgICB9ID0gdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnREYXRhO1xuICAgIGlmICghY29sb3IpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4jcGFyZW50Ll9jb21tZW50TWFuYWdlci5tYWtlQ29tbWVudENvbG9yKGNvbG9yLCBvcGFjaXR5KTtcbiAgfVxuICBmb2N1c0NvbW1lbnRCdXR0b24oKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIGdldERhdGEoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmljaFRleHQsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgfSA9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50RGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudHNPYmo6IHtcbiAgICAgICAgc3RyOiB0aGlzLmNvbW1lbnRcbiAgICAgIH0sXG4gICAgICByaWNoVGV4dCxcbiAgICAgIGNvbG9yLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIGNyZWF0aW9uRGF0ZSxcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICB9O1xuICB9XG4gIGdldCBlbGVtZW50QmVmb3JlUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRCdXR0b247XG4gIH1cbiAgZ2V0IGNvbW1lbnQoKSB7XG4gICAgdGhpcy4jY29tbWVudFRleHQgfHw9IHRoaXMuI2ZpcnN0RWxlbWVudC5jb21tZW50VGV4dDtcbiAgICByZXR1cm4gdGhpcy4jY29tbWVudFRleHQ7XG4gIH1cbiAgc2V0IGNvbW1lbnQodGV4dCkge1xuICAgIGlmICh0ZXh0ID09PSB0aGlzLmNvbW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jZmlyc3RFbGVtZW50LmNvbW1lbnRUZXh0ID0gdGhpcy4jY29tbWVudFRleHQgPSB0ZXh0O1xuICB9XG4gIGZvY3VzKCkge1xuICAgIHRoaXMuI2ZpcnN0RWxlbWVudC5jb250YWluZXI/LmZvY3VzKCk7XG4gIH1cbiAgZ2V0IHBhcmVudEJvdW5kaW5nQ2xpZW50UmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy4jZmlyc3RFbGVtZW50LmxheWVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIHNldENvbW1lbnRCdXR0b25TdGF0ZXMoe1xuICAgIHNlbGVjdGVkLFxuICAgIGhhc1BvcHVwXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuI2NvbW1lbnRCdXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwic2VsZWN0ZWRcIiwgc2VsZWN0ZWQpO1xuICAgIHRoaXMuI2NvbW1lbnRCdXR0b24uYXJpYUV4cGFuZGVkID0gaGFzUG9wdXA7XG4gIH1cbiAgc2V0U2VsZWN0ZWRDb21tZW50QnV0dG9uKHNlbGVjdGVkKSB7XG4gICAgdGhpcy4jY29tbWVudEJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKFwic2VsZWN0ZWRcIiwgc2VsZWN0ZWQpO1xuICB9XG4gIGdldCBjb21tZW50UG9wdXBQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXBQb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuI3BvcHVwUG9zaXRpb247XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2NvbW1lbnRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgeDogcGFyZW50WCxcbiAgICAgIHk6IHBhcmVudFksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0aGlzLiNmaXJzdEVsZW1lbnQubGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsoeCAtIHBhcmVudFgpIC8gcGFyZW50V2lkdGgsICh5ICsgaGVpZ2h0IC0gcGFyZW50WSkgLyBwYXJlbnRIZWlnaHRdO1xuICB9XG4gIHNldCBjb21tZW50UG9wdXBQb3NpdGlvbihwb3MpIHtcbiAgICB0aGlzLiNwb3B1cFBvc2l0aW9uID0gcG9zO1xuICB9XG4gIGhhc0RlZmF1bHRQb3B1cFBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNwb3B1cFBvc2l0aW9uID09PSBudWxsO1xuICB9XG4gIGdldCBjb21tZW50QnV0dG9uUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbW1lbnRCdXR0b25Qb3NpdGlvbjtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvbldpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLiNjb21tZW50QnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gdGhpcy5wYXJlbnRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGg7XG4gIH1cbiAgZWRpdENvbW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IFtwb3NYLCBwb3NZXSA9IHRoaXMuI3BvcHVwUG9zaXRpb24gfHwgdGhpcy5jb21tZW50QnV0dG9uUG9zaXRpb24ubWFwKHggPT4geCAvIDEwMCk7XG4gICAgY29uc3QgcGFyZW50RGltZW5zaW9ucyA9IHRoaXMucGFyZW50Qm91bmRpbmdDbGllbnRSZWN0O1xuICAgIGNvbnN0IHtcbiAgICAgIHg6IHBhcmVudFgsXG4gICAgICB5OiBwYXJlbnRZLFxuICAgICAgd2lkdGg6IHBhcmVudFdpZHRoLFxuICAgICAgaGVpZ2h0OiBwYXJlbnRIZWlnaHRcbiAgICB9ID0gcGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLiNjb21tZW50TWFuYWdlci5zaG93RGlhbG9nKG51bGwsIHRoaXMsIHBhcmVudFggKyBwb3NYICogcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwb3NZICogcGFyZW50SGVpZ2h0LCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgcGFyZW50RGltZW5zaW9uc1xuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy4jcG9wdXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9wdXAgPSB0aGlzLiNwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgIGlmICh0aGlzLiNjb2xvcikge1xuICAgICAgY29uc3QgYmFzZUNvbG9yID0gcG9wdXAuc3R5bGUub3V0bGluZUNvbG9yID0gVXRpbC5tYWtlSGV4Q29sb3IoLi4udGhpcy4jY29sb3IpO1xuICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBoZWFkZXIuY2xhc3NOYW1lID0gXCJoZWFkZXJcIjtcbiAgICBpZiAodGhpcy4jdGl0bGVPYmo/LnN0cikge1xuICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHRpdGxlLmNsYXNzTmFtZSA9IFwidGl0bGVcIjtcbiAgICAgIGhlYWRlci5hcHBlbmQodGl0bGUpO1xuICAgICAgKHtcbiAgICAgICAgZGlyOiB0aXRsZS5kaXIsXG4gICAgICAgIHN0cjogdGl0bGUudGV4dENvbnRlbnRcbiAgICAgIH0gPSB0aGlzLiN0aXRsZU9iaik7XG4gICAgfVxuICAgIHBvcHVwLmFwcGVuZChoZWFkZXIpO1xuICAgIGlmICh0aGlzLiNkYXRlT2JqKSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRpbWVcIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTmFtZSA9IFwicG9wdXBEYXRlXCI7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1pZFwiLCBcInBkZmpzLWFubm90YXRpb24tZGF0ZS10aW1lLXN0cmluZ1wiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBkYXRlT2JqOiB0aGlzLiNkYXRlT2JqLnZhbHVlT2YoKVxuICAgICAgfSkpO1xuICAgICAgbW9kaWZpY2F0aW9uRGF0ZS5kYXRlVGltZSA9IHRoaXMuI2RhdGVPYmoudG9JU09TdHJpbmcoKTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIHJlbmRlclJpY2hUZXh0KHtcbiAgICAgIGh0bWw6IHRoaXMuI2h0bWwgfHwgdGhpcy4jY29udGVudHNPYmouc3RyLFxuICAgICAgZGlyOiB0aGlzLiNjb250ZW50c09iaj8uZGlyLFxuICAgICAgY2xhc3NOYW1lOiBcInBvcHVwQ29udGVudFwiXG4gICAgfSwgcG9wdXApO1xuICAgIHRoaXMuI2NvbnRhaW5lci5hcHBlbmQocG9wdXApO1xuICB9XG4gIGdldCAjaHRtbCgpIHtcbiAgICBjb25zdCByaWNoVGV4dCA9IHRoaXMuI3JpY2hUZXh0O1xuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgaWYgKHJpY2hUZXh0Py5zdHIgJiYgKCFjb250ZW50c09iaj8uc3RyIHx8IGNvbnRlbnRzT2JqLnN0ciA9PT0gcmljaFRleHQuc3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI3JpY2hUZXh0Lmh0bWwgfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0ICNmb250U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jaHRtbD8uYXR0cmlidXRlcz8uc3R5bGU/LmZvbnRTaXplIHx8IDA7XG4gIH1cbiAgZ2V0ICNmb250Q29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2h0bWw/LmF0dHJpYnV0ZXM/LnN0eWxlPy5jb2xvciB8fCBudWxsO1xuICB9XG4gICNtYWtlUG9wdXBDb250ZW50KHRleHQpIHtcbiAgICBjb25zdCBwb3B1cExpbmVzID0gW107XG4gICAgY29uc3QgcG9wdXBDb250ZW50ID0ge1xuICAgICAgc3RyOiB0ZXh0LFxuICAgICAgaHRtbDoge1xuICAgICAgICBuYW1lOiBcImRpdlwiLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgZGlyOiBcImF1dG9cIlxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3tcbiAgICAgICAgICBuYW1lOiBcInBcIixcbiAgICAgICAgICBjaGlsZHJlbjogcG9wdXBMaW5lc1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGluZUF0dHJpYnV0ZXMgPSB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBjb2xvcjogdGhpcy4jZm9udENvbG9yLFxuICAgICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUgPyBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgIDogXCJcIlxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIHBvcHVwTGluZXMucHVzaCh7XG4gICAgICAgIG5hbWU6IFwic3BhblwiLFxuICAgICAgICB2YWx1ZTogbGluZSxcbiAgICAgICAgYXR0cmlidXRlczogbGluZUF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcG9wdXBDb250ZW50O1xuICB9XG4gICNrZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiIHx8IGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiB0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVFZGl0ZWQoe1xuICAgIHJlY3QsXG4gICAgcG9wdXAsXG4gICAgZGVsZXRlZFxuICB9KSB7XG4gICAgaWYgKHRoaXMuI2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLiNjb21tZW50VGV4dCA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHBvcHVwKSB7XG4gICAgICAgIGlmIChwb3B1cC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcigpO1xuICAgICAgICAgIHRoaXMuI2NvbW1lbnRUZXh0ID0gcG9wdXAudGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlY3QpIHtcbiAgICAgICAgdGhpcy4jY29tbWVudEJ1dHRvblBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy4jc2V0Q29tbWVudEJ1dHRvblBvc2l0aW9uKCk7XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbW1lbnRCdXR0b25Qb3NpdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVsZXRlZCB8fCBwb3B1cD8uZGVsZXRlZCkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLiN1cGRhdGVzIHx8PSB7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9O1xuICAgIGlmIChyZWN0KSB7XG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChwb3B1cCAmJiBwb3B1cC50ZXh0KSB7XG4gICAgICB0aGlzLiNyaWNoVGV4dCA9IHRoaXMuI21ha2VQb3B1cENvbnRlbnQocG9wdXAudGV4dCk7XG4gICAgICB0aGlzLiNkYXRlT2JqID0gUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QocG9wdXAuZGF0ZSk7XG4gICAgICB0aGlzLiNjb250ZW50c09iaiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvcHVwPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNwb3B1cCA9IG51bGw7XG4gIH1cbiAgcmVzZXRFZGl0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLiN1cGRhdGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBjb250ZW50c09iajogdGhpcy4jY29udGVudHNPYmosXG4gICAgICByaWNoVGV4dDogdGhpcy4jcmljaFRleHRcbiAgICB9ID0gdGhpcy4jdXBkYXRlcyk7XG4gICAgdGhpcy4jdXBkYXRlcyA9IG51bGw7XG4gICAgdGhpcy4jcG9wdXA/LnJlbW92ZSgpO1xuICAgIHRoaXMuI3BvcHVwID0gbnVsbDtcbiAgICB0aGlzLiNwb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyPy5hYm9ydCgpO1xuICAgIHRoaXMuI3BvcHVwQWJvcnRDb250cm9sbGVyID0gbnVsbDtcbiAgICB0aGlzLiNwb3B1cD8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jcG9wdXAgPSBudWxsO1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNwaW5uZWQgPSBmYWxzZTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uPy5yZW1vdmUoKTtcbiAgICB0aGlzLiNjb21tZW50QnV0dG9uID0gbnVsbDtcbiAgICBpZiAodGhpcy50cmlnZ2VyKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50cmlnZ2VyKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNzZXRQb3NpdGlvbigpIHtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZToge1xuICAgICAgICB2aWV3XG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgcmF3RGltczoge1xuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgIHBhZ2VZXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcy4jcGFyZW50O1xuICAgIGxldCB1c2VQYXJlbnRSZWN0ID0gISF0aGlzLiNwYXJlbnRSZWN0O1xuICAgIGxldCByZWN0ID0gdXNlUGFyZW50UmVjdCA/IHRoaXMuI3BhcmVudFJlY3QgOiB0aGlzLiNyZWN0O1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgaWYgKCFyZWN0IHx8IFV0aWwuaW50ZXJzZWN0KGVsZW1lbnQuZGF0YS5yZWN0LCByZWN0KSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0ID0gZWxlbWVudC5kYXRhLnJlY3Q7XG4gICAgICAgIHVzZVBhcmVudFJlY3QgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJlY3QgPSBVdGlsLm5vcm1hbGl6ZVJlY3QoW3JlY3RbMF0sIHZpZXdbM10gLSByZWN0WzFdICsgdmlld1sxXSwgcmVjdFsyXSwgdmlld1szXSAtIHJlY3RbM10gKyB2aWV3WzFdXSk7XG4gICAgY29uc3QgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OID0gNTtcbiAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHVzZVBhcmVudFJlY3QgPyByZWN0WzJdIC0gcmVjdFswXSArIEhPUklaT05UQUxfU1BBQ0VfQUZURVJfQU5OT1RBVElPTiA6IDA7XG4gICAgY29uc3QgcG9wdXBMZWZ0ID0gbm9ybWFsaXplZFJlY3RbMF0gKyBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBwb3B1cFRvcCA9IG5vcm1hbGl6ZWRSZWN0WzFdO1xuICAgIHRoaXMuI3Bvc2l0aW9uID0gWzEwMCAqIChwb3B1cExlZnQgLSBwYWdlWCkgLyBwYWdlV2lkdGgsIDEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuI2NvbnRhaW5lcjtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7dGhpcy4jcG9zaXRpb25bMF19JWA7XG4gICAgc3R5bGUudG9wID0gYCR7dGhpcy4jcG9zaXRpb25bMV19JWA7XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHRoaXMuI2NvbW1lbnRNYW5hZ2VyLnRvZ2dsZUNvbW1lbnRQb3B1cCh0aGlzLCBmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3Bpbm5lZCA9ICF0aGlzLiNwaW5uZWQ7XG4gICAgaWYgKHRoaXMuI3Bpbm5lZCkge1xuICAgICAgdGhpcy4jc2hvdygpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jaGlkZSgpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLiNib3VuZFRvZ2dsZSk7XG4gICAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gIH1cbiAgI3Nob3coKSB7XG4gICAgaWYgKCF0aGlzLiNwb3B1cCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgdGhpcy4jc2V0UG9zaXRpb24oKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICh0aGlzLiNjb21tZW50TWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI3BvcHVwKSB7XG4gICAgICB0aGlzLiNzaG93KCk7XG4gICAgfVxuICAgIHRoaXMuI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgICB0aGlzLiNjb250YWluZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgZ2V0IGlzVmlzaWJsZSgpIHtcbiAgICBpZiAodGhpcy4jY29tbWVudE1hbmFnZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoXCJhbm5vdGF0aW9uVGV4dENvbnRlbnRcIik7XG4gICAgICBjb250ZW50LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoY29udGVudCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLmhhc093bkNvbW1lbnRCdXR0b24gPSB0cnVlO1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIExpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2xpbmUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuaGFzT3duQ29tbWVudEJ1dHRvbiA9IHRydWU7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jbGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3NxdWFyZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWFyZUFubm90YXRpb25cIik7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3Qgc3F1YXJlID0gdGhpcy4jc3F1YXJlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieFwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoIC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChzcXVhcmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNzcXVhcmU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNjaXJjbGUgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJjaXJjbGVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuaGFzT3duQ29tbWVudEJ1dHRvbiA9IHRydWU7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jY2lyY2xlO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNwb2x5bGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSA9IFwicG9seWxpbmVBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQodGhpcy5jb250YWluZXJDbGFzc05hbWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcmVjdCxcbiAgICAgICAgdmVydGljZXMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCF2ZXJ0aWNlcykge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB4ID0gdmVydGljZXNbaV0gLSByZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IHJlY3RbM10gLSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICBwb2ludHMucHVzaChgJHt4fSwke3l9YCk7XG4gICAgfVxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuI3BvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLmhhc093bkNvbW1lbnRCdXR0b24gPSB0cnVlO1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvbHlsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxufVxuY2xhc3MgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiY2FyZXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLmhhc093bkNvbW1lbnRCdXR0b24gPSB0cnVlO1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lc0dyb3VwRWxlbWVudCA9IG51bGw7XG4gICNwb2x5bGluZXMgPSBbXTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJpbmtBbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IHRoaXMuZGF0YS5pdCA9PT0gXCJJbmtIaWdobGlnaHRcIiA/IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCA6IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgfVxuICAjZ2V0VHJhbnNmb3JtKHJvdGF0aW9uLCByZWN0KSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoOTApIHRyYW5zbGF0ZSgkey1yZWN0WzBdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgxODApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbMV19KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbMl0gLSByZWN0WzBdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFszXSAtIHJlY3RbMV1cbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZSgyNzApIHRyYW5zbGF0ZSgkey1yZWN0WzJdfSwke3JlY3RbM119KSBzY2FsZSgxLC0xKWAsXG4gICAgICAgICAgd2lkdGg6IHJlY3RbM10gLSByZWN0WzFdLFxuICAgICAgICAgIGhlaWdodDogcmVjdFsyXSAtIHJlY3RbMF1cbiAgICAgICAgfTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7LXJlY3RbMF19LCR7cmVjdFszXX0pIHNjYWxlKDEsLTEpYCxcbiAgICAgICAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgICAgICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0LFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgaW5rTGlzdHMsXG4gICAgICAgIGJvcmRlclN0eWxlLFxuICAgICAgICBwb3B1cFJlZlxuICAgICAgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybShyb3RhdGlvbiwgcmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICBzdmcuYXBwZW5kKGcpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWxpbmVjYXBcIiwgXCJyb3VuZFwiKTtcbiAgICBnLnNldEF0dHJpYnV0ZShcInN0cm9rZS1saW5lam9pblwiLCBcInJvdW5kXCIpO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlLW1pdGVybGltaXRcIiwgMTApO1xuICAgIGcuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbmtMaXN0cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgICAgdGhpcy4jcG9seWxpbmVzLnB1c2gocG9seWxpbmUpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIGlua0xpc3RzW2ldLmpvaW4oXCIsXCIpKTtcbiAgICAgIGcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIHVwZGF0ZUVkaXRlZChwYXJhbXMpIHtcbiAgICBzdXBlci51cGRhdGVFZGl0ZWQocGFyYW1zKTtcbiAgICBjb25zdCB7XG4gICAgICB0aGlja25lc3MsXG4gICAgICBwb2ludHMsXG4gICAgICByZWN0XG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBnID0gdGhpcy4jcG9seWxpbmVzR3JvdXBFbGVtZW50O1xuICAgIGlmICh0aGlja25lc3MgPj0gMCkge1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgdGhpY2tuZXNzIHx8IDEpO1xuICAgIH1cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNwb2x5bGluZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB0aGlzLiNwb2x5bGluZXNbaV0uc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50c1tpXS5qb2luKFwiLFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWN0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHRoaXMuI2dldFRyYW5zZm9ybSh0aGlzLmRhdGEucm90YXRpb24sIHJlY3QpO1xuICAgICAgY29uc3Qgcm9vdCA9IGcucGFyZW50RWxlbWVudDtcbiAgICAgIHJvb3Quc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcbiAgICB9XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9seWxpbmVzO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIG92ZXJsYWlkVGV4dCxcbiAgICAgICAgcG9wdXBSZWZcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLmhhc093bkNvbW1lbnRCdXR0b24gPSB0cnVlO1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgdGhpcy5fZWRpdE9uRG91YmxlQ2xpY2soKTtcbiAgICBpZiAob3ZlcmxhaWRUZXh0KSB7XG4gICAgICBjb25zdCBtYXJrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1hcmtcIik7XG4gICAgICBtYXJrLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICBtYXJrLnRleHRDb250ZW50ID0gb3ZlcmxhaWRUZXh0O1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKG1hcmspO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHVuZGVybGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1XCIpO1xuICAgICAgdW5kZXJsaW5lLmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICB1bmRlcmxpbmUudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQodW5kZXJsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgaWYgKG92ZXJsYWlkVGV4dCkge1xuICAgICAgY29uc3QgdW5kZXJsaW5lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVcIik7XG4gICAgICB1bmRlcmxpbmUuY2xhc3NMaXN0LmFkZChcIm92ZXJsYWlkVGV4dFwiKTtcbiAgICAgIHVuZGVybGluZS50ZXh0Q29udGVudCA9IG92ZXJsYWlkVGV4dDtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZCh1bmRlcmxpbmUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YToge1xuICAgICAgICBvdmVybGFpZFRleHQsXG4gICAgICAgIHBvcHVwUmVmXG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFwb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChvdmVybGFpZFRleHQpIHtcbiAgICAgIGNvbnN0IHN0cmlrZW91dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzXCIpO1xuICAgICAgc3RyaWtlb3V0LmNsYXNzTGlzdC5hZGQoXCJvdmVybGFpZFRleHRcIik7XG4gICAgICBzdHJpa2VvdXQudGV4dENvbnRlbnQgPSBvdmVybGFpZFRleHQ7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3RyaWtlb3V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuaGFzT3duQ29tbWVudEJ1dHRvbiA9IHRydWU7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLl9lZGl0T25Eb3VibGVDbGljaygpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3RyaWdnZXIgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgZmlsZVxuICAgIH0gPSB0aGlzLmRhdGE7XG4gICAgdGhpcy5maWxlbmFtZSA9IGZpbGUuZmlsZW5hbWU7XG4gICAgdGhpcy5jb250ZW50ID0gZmlsZS5jb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIC4uLmZpbGVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImZpbGVBdHRhY2htZW50QW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHRyaWdnZXI7XG4gICAgaWYgKGRhdGEuaGFzQXBwZWFyYW5jZSB8fCBkYXRhLmZpbGxBbHBoYSA9PT0gMCkge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgdHJpZ2dlci5zcmMgPSBgJHt0aGlzLmltYWdlUmVzb3VyY2VzUGF0aH1hbm5vdGF0aW9uLSR7L3BhcGVyY2xpcC9pLnRlc3QoZGF0YS5uYW1lKSA/IFwicGFwZXJjbGlwXCIgOiBcInB1c2hwaW5cIn0uc3ZnYDtcbiAgICAgIGlmIChkYXRhLmZpbGxBbHBoYSAmJiBkYXRhLmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgdHJpZ2dlci5zdHlsZSA9IGBmaWx0ZXI6IG9wYWNpdHkoJHtNYXRoLnJvdW5kKGRhdGEuZmlsbEFscGhhICogMTAwKX0lKTtgO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCB0aGlzLiNkb3dubG9hZC5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLiN0cmlnZ2VyID0gdHJpZ2dlcjtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5oYXNPd25Db21tZW50QnV0dG9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwVHJpZ2dlckFyZWFcIik7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiN0cmlnZ2VyO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbiAgI2Rvd25sb2FkKCkge1xuICAgIHRoaXMuZG93bmxvYWRNYW5hZ2VyPy5vcGVuT3JEb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgI3N0cnVjdFRyZWVMYXllciA9IG51bGw7XG4gICNsaW5rU2VydmljZSA9IG51bGw7XG4gICNlbGVtZW50cyA9IFtdO1xuICAjaGFzQXJpYUF0dHJpYnV0ZXNGcm9tU3RydWN0VHJlZSA9IGZhbHNlO1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGl2LFxuICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgICBwYWdlLFxuICAgIHZpZXdwb3J0LFxuICAgIHN0cnVjdFRyZWVMYXllcixcbiAgICBjb21tZW50TWFuYWdlcixcbiAgICBsaW5rU2VydmljZSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZVxuICB9KSB7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLiNzdHJ1Y3RUcmVlTGF5ZXIgPSBzdHJ1Y3RUcmVlTGF5ZXIgfHwgbnVsbDtcbiAgICB0aGlzLiNsaW5rU2VydmljZSA9IGxpbmtTZXJ2aWNlIHx8IG51bGw7XG4gICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UgPSBhbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgdGhpcy5fYW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IGFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gICAgdGhpcy5fY29tbWVudE1hbmFnZXIgPSBjb21tZW50TWFuYWdlciB8fCBudWxsO1xuICB9XG4gIGhhc0VkaXRhYmxlQW5ub3RhdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2l6ZSA+IDA7XG4gIH1cbiAgYXN5bmMgcmVuZGVyKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25zXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHNldExheWVyRGltZW5zaW9ucyhsYXllciwgdGhpcy52aWV3cG9ydCk7XG4gICAgY29uc3QgcG9wdXBUb0VsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBvcHVwQW5ub3RhdGlvbnMgPSBbXTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBwYXJhbXMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICByZW5kZXJGb3JtczogcGFyYW1zLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBET01TVkdGYWN0b3J5KCksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICBlbmFibGVDb21tZW50OiBwYXJhbXMuZW5hYmxlQ29tbWVudCA9PT0gdHJ1ZSxcbiAgICAgIGVuYWJsZVNjcmlwdGluZzogcGFyYW1zLmVuYWJsZVNjcmlwdGluZyA9PT0gdHJ1ZSxcbiAgICAgIGhhc0pTQWN0aW9uczogcGFyYW1zLmhhc0pTQWN0aW9ucyxcbiAgICAgIGZpZWxkT2JqZWN0czogcGFyYW1zLmZpZWxkT2JqZWN0cyxcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGVsZW1lbnRzOiBudWxsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRhdGEgb2YgYW5ub3RhdGlvbnMpIHtcbiAgICAgIGlmIChkYXRhLm5vSFRNTCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzUG9wdXBBbm5vdGF0aW9uID0gZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gQW5ub3RhdGlvblR5cGUuUE9QVVA7XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmIChkYXRhLnJlY3RbMl0gPT09IGRhdGEucmVjdFswXSB8fCBkYXRhLnJlY3RbM10gPT09IGRhdGEucmVjdFsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NvbW1lbnRNYW5hZ2VyKSB7XG4gICAgICAgICAgcG9wdXBBbm5vdGF0aW9ucy5wdXNoKGRhdGEpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRQYXJhbXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgIH1cbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWlzUG9wdXBBbm5vdGF0aW9uKSB7XG4gICAgICAgIHRoaXMuI2VsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIGlmIChkYXRhLnBvcHVwUmVmKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEucG9wdXBSZWYpO1xuICAgICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICAgIHBvcHVwVG9FbGVtZW50cy5zZXQoZGF0YS5wb3B1cFJlZiwgW2VsZW1lbnRdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbmRlcmVkID0gZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICByZW5kZXJlZC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Ll9pc0VkaXRhYmxlKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnJlbmRlckFubm90YXRpb25FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLiNhZGRFbGVtZW50c1RvRE9NKCk7XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIHBvcHVwQW5ub3RhdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5pZCk7XG4gICAgICBlbGVtZW50UGFyYW1zLmRhdGEgPSBkYXRhO1xuICAgICAgY29uc3QgZWxlbWVudCA9IEFubm90YXRpb25FbGVtZW50RmFjdG9yeS5jcmVhdGUoZWxlbWVudFBhcmFtcyk7XG4gICAgICBpZiAoIWVsZW1lbnQuaXNSZW5kZXJhYmxlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgZWxlbWVudC5jb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtkYXRhLmlkfWA7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICBlbGVtZW50cy5hdCgtMSkuY29udGFpbmVyLmFmdGVyKHJlbmRlcmVkKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICB9XG4gIGFzeW5jICNhZGRFbGVtZW50c1RvRE9NKCkge1xuICAgIGlmICh0aGlzLiNlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXYucmVwbGFjZUNoaWxkcmVuKCk7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBpZiAoIXRoaXMuI2hhc0FyaWFBdHRyaWJ1dGVzRnJvbVN0cnVjdFRyZWUpIHtcbiAgICAgIHRoaXMuI2hhc0FyaWFBdHRyaWJ1dGVzRnJvbVN0cnVjdFRyZWUgPSB0cnVlO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGNvbnRlbnRFbGVtZW50LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfVxuICAgICAgfSBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uSWQgPSBjb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuI3N0cnVjdFRyZWVMYXllcj8uZ2V0QXJpYUF0dHJpYnV0ZXMoYW5ub3RhdGlvbklkKS50aGVuKGFyaWFBdHRyaWJ1dGVzID0+IHtcbiAgICAgICAgICBpZiAoYXJpYUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFyaWFBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jZWxlbWVudHMuc29ydCgoe1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0OiBbYTAsIGExLCBhMiwgYTNdXG4gICAgICB9XG4gICAgfSwge1xuICAgICAgZGF0YToge1xuICAgICAgICByZWN0OiBbYjAsIGIxLCBiMiwgYjNdXG4gICAgICB9XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKGEwID09PSBhMiAmJiBhMSA9PT0gYTMpIHtcbiAgICAgICAgcmV0dXJuICsxO1xuICAgICAgfVxuICAgICAgaWYgKGIwID09PSBiMiAmJiBiMSA9PT0gYjMpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9wMSA9IGEzO1xuICAgICAgY29uc3QgYm90MSA9IGExO1xuICAgICAgY29uc3QgbWlkMSA9IChhMSArIGEzKSAvIDI7XG4gICAgICBjb25zdCB0b3AyID0gYjM7XG4gICAgICBjb25zdCBib3QyID0gYjE7XG4gICAgICBjb25zdCBtaWQyID0gKGIxICsgYjMpIC8gMjtcbiAgICAgIGlmIChtaWQxID49IHRvcDIgJiYgbWlkMiA8PSBib3QxKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChtaWQyID49IHRvcDEgJiYgbWlkMSA8PSBib3QyKSB7XG4gICAgICAgIHJldHVybiArMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbnRlclgxID0gKGEwICsgYTIpIC8gMjtcbiAgICAgIGNvbnN0IGNlbnRlclgyID0gKGIwICsgYjIpIC8gMjtcbiAgICAgIHJldHVybiBjZW50ZXJYMSAtIGNlbnRlclgyO1xuICAgIH0pO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLiNlbGVtZW50cykge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kKGVsZW1lbnQuY29udGFpbmVyKTtcbiAgICAgIGlmICh0aGlzLl9jb21tZW50TWFuYWdlcikge1xuICAgICAgICAoZWxlbWVudC5leHRyYVBvcHVwRWxlbWVudD8ucG9wdXAgfHwgZWxlbWVudC5wb3B1cCk/LnJlbmRlckNvbW1lbnRCdXR0b24oKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5leHRyYVBvcHVwRWxlbWVudCkge1xuICAgICAgICBmcmFnbWVudC5hcHBlbmQoZWxlbWVudC5leHRyYVBvcHVwRWxlbWVudC5yZW5kZXIoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGl2LmFwcGVuZChmcmFnbWVudCk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIGlmICh0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcikge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyLmFkZFBvaW50ZXJJblRleHRMYXllcihlbGVtZW50LmNvbnRlbnRFbGVtZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFzeW5jIGFkZExpbmtBbm5vdGF0aW9ucyhhbm5vdGF0aW9ucykge1xuICAgIGNvbnN0IGVsZW1lbnRQYXJhbXMgPSB7XG4gICAgICBkYXRhOiBudWxsLFxuICAgICAgbGF5ZXI6IHRoaXMuZGl2LFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgc3ZnRmFjdG9yeTogbmV3IERPTVNWR0ZhY3RvcnkoKSxcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH07XG4gICAgZm9yIChjb25zdCBkYXRhIG9mIGFubm90YXRpb25zKSB7XG4gICAgICBkYXRhLmJvcmRlclN0eWxlIHx8PSBBbm5vdGF0aW9uTGF5ZXIuX2RlZmF1bHRCb3JkZXJTdHlsZTtcbiAgICAgIGVsZW1lbnRQYXJhbXMuZGF0YSA9IGRhdGE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZShlbGVtZW50UGFyYW1zKTtcbiAgICAgIGlmICghZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgZWxlbWVudC5jb250ZW50RWxlbWVudC5pZCA9IGAke0Fubm90YXRpb25QcmVmaXh9JHtkYXRhLmlkfWA7XG4gICAgICB0aGlzLiNlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLiNhZGRFbGVtZW50c1RvRE9NKCk7XG4gIH1cbiAgdXBkYXRlKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLmRpdjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKGxheWVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCk7XG4gICAgbGF5ZXIuaGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgI3NldEFubm90YXRpb25DYW52YXNNYXAoKSB7XG4gICAgaWYgKCF0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGxheWVyLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWFubm90YXRpb24taWQ9XCIke2lkfVwiXWApO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiYW5ub3RhdGlvbkNvbnRlbnRcIjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2UgaWYgKCFmaXJzdENoaWxkLmNsYXNzTGlzdC5jb250YWlucyhcImFubm90YXRpb25Db250ZW50XCIpKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuYmVmb3JlKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmFmdGVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0YWJsZUFubm90YXRpb24gPSB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gICAgICBpZiAoIWVkaXRhYmxlQW5ub3RhdGlvbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlZGl0YWJsZUFubm90YXRpb24uX2hhc05vQ2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25FZGl0b3JVSU1hbmFnZXI/LnNldE1pc3NpbmdDYW52YXMoaWQsIGVsZW1lbnQuaWQsIGNhbnZhcyk7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5faGFzTm9DYW52YXMgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRhYmxlQW5ub3RhdGlvbi5jYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb25zKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMudmFsdWVzKCkpO1xuICB9XG4gIGdldEVkaXRhYmxlQW5ub3RhdGlvbihpZCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLmdldChpZCk7XG4gIH1cbiAgYWRkRmFrZUFubm90YXRpb24oZWRpdG9yKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGl2XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgaWQsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgZWxlbWVudCA9IG5ldyBFZGl0b3JBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkLFxuICAgICAgICByZWN0OiBlZGl0b3IuZ2V0UERGUmVjdCgpLFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSxcbiAgICAgIGVkaXRvcixcbiAgICAgIGxheWVyOiBkaXYsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBlbmFibGVDb21tZW50OiAhIXRoaXMuX2NvbW1lbnRNYW5hZ2VyLFxuICAgICAgbGlua1NlcnZpY2U6IHRoaXMuI2xpbmtTZXJ2aWNlLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHRoaXMuI2Fubm90YXRpb25TdG9yYWdlXG4gICAgfSk7XG4gICAgZWxlbWVudC5yZW5kZXIoKTtcbiAgICBlbGVtZW50LmNvbnRlbnRFbGVtZW50LmlkID0gYCR7QW5ub3RhdGlvblByZWZpeH0ke2lkfWA7XG4gICAgZWxlbWVudC5jcmVhdGVPclVwZGF0ZVBvcHVwKCk7XG4gICAgdGhpcy4jZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZW1vdmVBbm5vdGF0aW9uKGlkKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNlbGVtZW50cy5maW5kSW5kZXgoZWwgPT4gZWwuZGF0YS5pZCA9PT0gaWQpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2VsZW1lbnRdID0gdGhpcy4jZWxlbWVudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVsZW1lbnQuY29udGVudEVsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZUZha2VBbm5vdGF0aW9ucyhlZGl0b3JzKSB7XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVGYWtlQW5ub3RhdGlvbkVsZW1lbnQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuI2FkZEVsZW1lbnRzVG9ET00oKTtcbiAgfVxuICB0b2dnbGVQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCAhZW5hYmxlZCk7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdEJvcmRlclN0eWxlKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJfZGVmYXVsdEJvcmRlclN0eWxlXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgd2lkdGg6IDEsXG4gICAgICByYXdXaWR0aDogMSxcbiAgICAgIHN0eWxlOiBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElELFxuICAgICAgZGFzaEFycmF5OiBbM10sXG4gICAgICBob3Jpem9udGFsQ29ybmVyUmFkaXVzOiAwLFxuICAgICAgdmVydGljYWxDb3JuZXJSYWRpdXM6IDBcbiAgICB9KSk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2ZyZWV0ZXh0LmpzXG5cblxuXG5cblxuY29uc3QgRU9MX1BBVFRFUk4gPSAvXFxyXFxuP3xcXG4vZztcbmNsYXNzIEZyZWVUZXh0RWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNjb250ZW50ID0gXCJcIjtcbiAgI2VkaXRvckRpdklkID0gYCR7dGhpcy5pZH0tZWRpdG9yYDtcbiAgI2VkaXRNb2RlQUMgPSBudWxsO1xuICAjZm9udFNpemU7XG4gIF9jb2xvclBpY2tlciA9IG51bGw7XG4gIHN0YXRpYyBfZnJlZVRleHREZWZhdWx0Q29udGVudCA9IFwiXCI7XG4gIHN0YXRpYyBfaW50ZXJuYWxQYWRkaW5nID0gMDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRGb250U2l6ZSA9IDEwO1xuICBzdGF0aWMgZ2V0IF9rZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgY29uc3QgcHJvdG8gPSBGcmVlVGV4dEVkaXRvci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiBzZWxmLmlzRW1wdHkoKTtcbiAgICBjb25zdCBzbWFsbCA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX1NNQUxMO1xuICAgIGNvbnN0IGJpZyA9IEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCtzXCIsIFwibWFjK21ldGErc1wiLCBcImN0cmwrcFwiLCBcIm1hYyttZXRhK3BcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfV0sIFtbXCJjdHJsK0VudGVyXCIsIFwibWFjK21ldGErRW50ZXJcIiwgXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by5jb21taXRPclJlbW92ZV0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIHN0YXRpYyBfdHlwZSA9IFwiZnJlZXRleHRcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiZnJlZVRleHRFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yO1xuICAgIHRoaXMuI2ZvbnRTaXplID0gcGFyYW1zLmZvbnRTaXplIHx8IEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemU7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5hMTF5QWxlcnQoXCJwZGZqcy1lZGl0b3ItZnJlZXRleHQtYWRkZWQtYWxlcnRcIik7XG4gICAgfVxuICAgIHRoaXMuY2FuQWRkQ29tbWVudCA9IGZhbHNlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIHRoaXMuX2ludGVybmFsUGFkZGluZyA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tZnJlZXRleHQtcGFkZGluZ1wiKSk7XG4gIH1cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRTpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZSA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICB0aGlzLiN1cGRhdGVGb250U2l6ZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl1dO1xuICB9XG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgdGhpcy4jZm9udFNpemVdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIHRoaXMuY29sb3JdXTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXIgfHw9IG5ldyBCYXNpY0NvbG9yUGlja2VyKHRoaXMpO1xuICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgdGhpcy5fY29sb3JQaWNrZXJdXTtcbiAgfVxuICBnZXQgY29sb3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjtcbiAgfVxuICAjdXBkYXRlRm9udFNpemUoZm9udFNpemUpIHtcbiAgICBjb25zdCBzZXRGb250c2l6ZSA9IHNpemUgPT4ge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3NpemV9cHggKiB2YXIoLS10b3RhbC1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSgwLCAtKHNpemUgLSB0aGlzLiNmb250U2l6ZSkgKiB0aGlzLnBhcmVudFNjYWxlKTtcbiAgICAgIHRoaXMuI2ZvbnRTaXplID0gc2l6ZTtcbiAgICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkRm9udHNpemUgPSB0aGlzLiNmb250U2l6ZTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0Rm9udHNpemUuYmluZCh0aGlzLCBmb250U2l6ZSksXG4gICAgICB1bmRvOiBzZXRGb250c2l6ZS5iaW5kKHRoaXMsIHNhdmVkRm9udHNpemUpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIG9uVXBkYXRlZENvbG9yKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLl9jb2xvclBpY2tlcj8udXBkYXRlKHRoaXMuY29sb3IpO1xuICAgIHN1cGVyLm9uVXBkYXRlZENvbG9yKCk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3IgPSBjb2wgPT4ge1xuICAgICAgdGhpcy5jb2xvciA9IGNvbDtcbiAgICAgIHRoaXMub25VcGRhdGVkQ29sb3IoKTtcbiAgICB9O1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLmNvbG9yO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvci5iaW5kKHRoaXMsIGNvbG9yKSxcbiAgICAgIHVuZG86IHNldENvbG9yLmJpbmQodGhpcywgc2F2ZWRDb2xvciksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIF90cmFuc2xhdGVFbXB0eSh4LCB5KSB7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycyh4LCB5LCB0cnVlKTtcbiAgfVxuICBnZXRJbml0aWFsVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIHJldHVybiBbLUZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiBzY2FsZSwgLShGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICsgdGhpcy4jZm9udFNpemUpICogc2NhbGVdO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKCFzdXBlci5lbmFibGVFZGl0TW9kZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCIpO1xuICAgIHRoaXMuI2VkaXRNb2RlQUMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gdGhpcy5fdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI2VkaXRNb2RlQUMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuZWRpdG9yRGl2S2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmVkaXRvckRpdkJsdXIuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuZWRpdG9yRGl2SW5wdXQuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIHRoaXMuZWRpdG9yRGl2UGFzdGUuYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuI2VkaXRNb2RlQUM/LmFib3J0KCk7XG4gICAgdGhpcy4jZWRpdE1vZGVBQyA9IG51bGw7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVldGV4dEVkaXRpbmdcIik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoZm9jdXMpIHtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgaWYgKGZvY3VzKSB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIH1cbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfVxuICAgIHRoaXMuX2luaXRpYWxPcHRpb25zID0gbnVsbDtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZXRleHRFZGl0aW5nXCIpO1xuICAgIH1cbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICAjZXh0cmFjdFRleHQoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgbGV0IHByZXZDaGlsZCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmVkaXRvckRpdi5jaGlsZE5vZGVzKSB7XG4gICAgICBpZiAocHJldkNoaWxkPy5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUgJiYgY2hpbGQubm9kZU5hbWUgPT09IFwiQlJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlci5wdXNoKEZyZWVUZXh0RWRpdG9yLiNnZXROb2RlQ29udGVudChjaGlsZCkpO1xuICAgICAgcHJldkNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIlxcblwiKTtcbiAgfVxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgbGV0IHJlY3Q7XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZWN0ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudExheWVyLFxuICAgICAgICBkaXZcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgY29uc3Qgc2F2ZWREaXNwbGF5ID0gZGl2LnN0eWxlLmRpc3BsYXk7XG4gICAgICBjb25zdCBzYXZlZFZpc2liaWxpdHkgPSBkaXYuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaGlkZGVuXCIpO1xuICAgICAgZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9IFwiaGlkZGVuXCI7XG4gICAgICBjdXJyZW50TGF5ZXIuZGl2LmFwcGVuZCh0aGlzLmRpdik7XG4gICAgICByZWN0ID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZGl2LnJlbW92ZSgpO1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBzYXZlZERpc3BsYXk7XG4gICAgICBkaXYuY2xhc3NMaXN0LnRvZ2dsZShcImhpZGRlblwiLCBzYXZlZFZpc2liaWxpdHkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yb3RhdGlvbiAlIDE4MCA9PT0gdGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCkge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LmhlaWdodCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LndpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIGNvbnN0IHNhdmVkVGV4dCA9IHRoaXMuI2NvbnRlbnQ7XG4gICAgY29uc3QgbmV3VGV4dCA9IHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICBpZiAoc2F2ZWRUZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldFRleHQgPSB0ZXh0ID0+IHtcbiAgICAgIHRoaXMuI2NvbnRlbnQgPSB0ZXh0O1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZWJ1aWxkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChuZXdUZXh0KTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQoc2F2ZWRUZXh0KTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbkVkaXRNb2RlKCk7XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRpdiAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGVkaXRvckRpdktleWRvd24oZXZlbnQpIHtcbiAgICBGcmVlVGV4dEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIGVkaXRvckRpdkZvY3VzKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSB0cnVlO1xuICB9XG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG4gIGVkaXRvckRpdklucHV0KGV2ZW50KSB7XG4gICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJmcmVldGV4dEVkaXRpbmdcIiwgdGhpcy5pc0VtcHR5KCkpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJjb21tZW50XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRleHRib3hcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIiwgdHJ1ZSk7XG4gIH1cbiAgZ2V0IGNhbkNoYW5nZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkgfHwgdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBiYXNlWCA9IHRoaXMueDtcbiAgICAgIGJhc2VZID0gdGhpcy55O1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIHRoaXMuI2VkaXRvckRpdklkKTtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWwxMG4taWRcIiwgXCJwZGZqcy1mcmVlLXRleHQyXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hdHRyc1wiLCBcImRlZmF1bHQtY29udGVudFwiKTtcbiAgICB0aGlzLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXRvdGFsLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMuZWRpdG9yRGl2KTtcbiAgICB0aGlzLm92ZXJsYXlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwib3ZlcmxheVwiLCBcImVuYWJsZWRcIik7XG4gICAgdGhpcy5kaXYuYXBwZW5kKHRoaXMub3ZlcmxheURpdik7XG4gICAgaWYgKHRoaXMuX2lzQ29weSB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgICAgfVxuICAgICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc3RhdGljICNnZXROb2RlQ29udGVudChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSA/IG5vZGUubm9kZVZhbHVlIDogbm9kZS5pbm5lclRleHQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpO1xuICB9XG4gIGVkaXRvckRpdlBhc3RlKGV2ZW50KSB7XG4gICAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGE7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gY2xpcGJvYXJkRGF0YTtcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBcInRleHQvcGxhaW5cIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHBhc3RlID0gRnJlZVRleHRFZGl0b3IuI2Rlc2VyaWFsaXplQ29udGVudChjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0XCIpIHx8IFwiXCIpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXFxuXCIpO1xuICAgIGlmICghcGFzdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uLnJhbmdlQ291bnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgc2VsZWN0aW9uLmRlbGV0ZUZyb21Eb2N1bWVudCgpO1xuICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgaWYgKCFwYXN0ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwYXN0ZSkpO1xuICAgICAgdGhpcy5lZGl0b3JEaXYubm9ybWFsaXplKCk7XG4gICAgICBzZWxlY3Rpb24uY29sbGFwc2VUb1N0YXJ0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0Q29udGFpbmVyLFxuICAgICAgc3RhcnRPZmZzZXRcbiAgICB9ID0gcmFuZ2U7XG4gICAgY29uc3QgYnVmZmVyQmVmb3JlID0gW107XG4gICAgY29uc3QgYnVmZmVyQWZ0ZXIgPSBbXTtcbiAgICBpZiAoc3RhcnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBzdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50O1xuICAgICAgYnVmZmVyQWZ0ZXIucHVzaChzdGFydENvbnRhaW5lci5ub2RlVmFsdWUuc2xpY2Uoc3RhcnRPZmZzZXQpLnJlcGxhY2VBbGwoRU9MX1BBVFRFUk4sIFwiXCIpKTtcbiAgICAgIGlmIChwYXJlbnQgIT09IHRoaXMuZWRpdG9yRGl2KSB7XG4gICAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lZGl0b3JEaXYuY2hpbGROb2Rlcykge1xuICAgICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyQmVmb3JlLnB1c2goc3RhcnRDb250YWluZXIubm9kZVZhbHVlLnNsaWNlKDAsIHN0YXJ0T2Zmc2V0KS5yZXBsYWNlQWxsKEVPTF9QQVRURVJOLCBcIlwiKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydENvbnRhaW5lciA9PT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJCZWZvcmU7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgICAgaWYgKGkrKyA9PT0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICBidWZmZXIgPSBidWZmZXJBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChGcmVlVGV4dEVkaXRvci4jZ2V0Tm9kZUNvbnRlbnQoY2hpbGQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY29udGVudCA9IGAke2J1ZmZlckJlZm9yZS5qb2luKFwiXFxuXCIpfSR7cGFzdGV9JHtidWZmZXJBZnRlci5qb2luKFwiXFxuXCIpfWA7XG4gICAgdGhpcy4jc2V0Q29udGVudCgpO1xuICAgIGNvbnN0IG5ld1JhbmdlID0gbmV3IFJhbmdlKCk7XG4gICAgbGV0IGJlZm9yZUxlbmd0aCA9IE1hdGguc3VtUHJlY2lzZShidWZmZXJCZWZvcmUubWFwKGxpbmUgPT4gbGluZS5sZW5ndGgpKTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGZpcnN0Q2hpbGRcbiAgICB9IG9mIHRoaXMuZWRpdG9yRGl2LmNoaWxkTm9kZXMpIHtcbiAgICAgIGlmIChmaXJzdENoaWxkLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBmaXJzdENoaWxkLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIGlmIChiZWZvcmVMZW5ndGggPD0gbGVuZ3RoKSB7XG4gICAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBuZXdSYW5nZS5zZXRFbmQoZmlyc3RDaGlsZCwgYmVmb3JlTGVuZ3RoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiZWZvcmVMZW5ndGggLT0gbGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKG5ld1JhbmdlKTtcbiAgfVxuICAjc2V0Q29udGVudCgpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5yZXBsYWNlQ2hpbGRyZW4oKTtcbiAgICBpZiAoIXRoaXMuI2NvbnRlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMuI2NvbnRlbnQuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICB0aGlzLmVkaXRvckRpdi5hcHBlbmQoZGl2KTtcbiAgICB9XG4gIH1cbiAgI3NlcmlhbGl6ZUNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRlbnQucmVwbGFjZUFsbChcIlxceGEwXCIsIFwiIFwiKTtcbiAgfVxuICBzdGF0aWMgI2Rlc2VyaWFsaXplQ29udGVudChjb250ZW50KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUFsbChcIiBcIiwgXCJcXHhhMFwiKTtcbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgZ2V0UERGUmVjdCgpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgZGVmYXVsdEFwcGVhcmFuY2VEYXRhOiB7XG4gICAgICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRDb2xvclxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgICBjb250ZW50c09iaixcbiAgICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgICB9LFxuICAgICAgICB0ZXh0Q29udGVudCxcbiAgICAgICAgdGV4dFBvc2l0aW9uLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghdGV4dENvbnRlbnQgfHwgdGV4dENvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaW5pdGlhbERhdGEgPSBkYXRhID0ge1xuICAgICAgICBhbm5vdGF0aW9uVHlwZTogQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGZvbnRDb2xvciksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICB2YWx1ZTogdGV4dENvbnRlbnQuam9pbihcIlxcblwiKSxcbiAgICAgICAgcG9zaXRpb246IHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICBjb21tZW50OiBjb250ZW50c09iaj8uc3RyIHx8IG51bGwsXG4gICAgICAgIHJpY2hUZXh0LFxuICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3IuI2NvbnRlbnQgPSBGcmVlVGV4dEVkaXRvci4jZGVzZXJpYWxpemVDb250ZW50KGRhdGEudmFsdWUpO1xuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLmNvbG9yKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgY29sb3IsXG4gICAgICBmb250U2l6ZTogdGhpcy4jZm9udFNpemUsXG4gICAgICB2YWx1ZTogdGhpcy4jc2VyaWFsaXplQ29udGVudCgpXG4gICAgfSk7XG4gICAgdGhpcy5hZGRDb21tZW50KHNlcmlhbGl6ZWQpO1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuaXNDb3B5ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgY29sb3IsXG4gICAgICBwYWdlSW5kZXhcbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIHRoaXMuaGFzRWRpdGVkQ29tbWVudCB8fCB0aGlzLl9oYXNCZWVuTW92ZWQgfHwgc2VyaWFsaXplZC52YWx1ZSAhPT0gdmFsdWUgfHwgc2VyaWFsaXplZC5mb250U2l6ZSAhPT0gZm9udFNpemUgfHwgc2VyaWFsaXplZC5jb2xvci5zb21lKChjLCBpKSA9PiBjICE9PSBjb2xvcltpXSkgfHwgc2VyaWFsaXplZC5wYWdlSW5kZXggIT09IHBhZ2VJbmRleDtcbiAgfVxuICByZW5kZXJBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgY29uc3QgY29udGVudCA9IHN1cGVyLnJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pO1xuICAgIGlmICghY29udGVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGNvbnRlbnQ7XG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke3RoaXMuI2ZvbnRTaXplfXB4ICogdmFyKC0tdG90YWwtc2NhbGUtZmFjdG9yKSlgO1xuICAgIHN0eWxlLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBjb250ZW50LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGZvciAoY29uc3QgbGluZSBvZiB0aGlzLiNjb250ZW50LnNwbGl0KFwiXFxuXCIpKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmFwcGVuZChsaW5lID8gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgY29udGVudC5hcHBlbmQoZGl2KTtcbiAgICB9XG4gICAgYW5ub3RhdGlvbi51cGRhdGVFZGl0ZWQoe1xuICAgICAgcmVjdDogdGhpcy5nZXRQREZSZWN0KCksXG4gICAgICBwb3B1cDogdGhpcy5fdWlNYW5hZ2VyLmhhc0NvbW1lbnRNYW5hZ2VyKCkgfHwgdGhpcy5oYXNFZGl0ZWRDb21tZW50ID8gdGhpcy5jb21tZW50IDoge1xuICAgICAgICB0ZXh0OiB0aGlzLiNjb250ZW50XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgcmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKSB7XG4gICAgc3VwZXIucmVzZXRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uKTtcbiAgICBhbm5vdGF0aW9uLnJlc2V0RWRpdGVkKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvb3V0bGluZS5qc1xuXG5jbGFzcyBPdXRsaW5lIHtcbiAgc3RhdGljIFBSRUNJU0lPTiA9IDFlLTQ7XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICB1bnJlYWNoYWJsZShcIkFic3RyYWN0IG1ldGhvZCBgdG9TVkdQYXRoYCBtdXN0IGJlIGltcGxlbWVudGVkLlwiKTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHVucmVhY2hhYmxlKFwiQWJzdHJhY3QgZ2V0dGVyIGBib3hgIG11c3QgYmUgaW1wbGVtZW50ZWQuXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShfYmJveCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJBYnN0cmFjdCBtZXRob2QgYHNlcmlhbGl6ZWAgbXVzdCBiZSBpbXBsZW1lbnRlZC5cIik7XG4gIH1cbiAgc3RhdGljIF9yZXNjYWxlKHNyYywgdHgsIHR5LCBzeCwgc3ksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaSArIDFdICogc3k7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xuICB9XG4gIHN0YXRpYyBfcmVzY2FsZUFuZFN3YXAoc3JjLCB0eCwgdHksIHN4LCBzeSwgZGVzdCkge1xuICAgIGRlc3QgfHw9IG5ldyBGbG9hdDMyQXJyYXkoc3JjLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3JjLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIGRlc3RbaV0gPSB0eCArIHNyY1tpICsgMV0gKiBzeDtcbiAgICAgIGRlc3RbaSArIDFdID0gdHkgKyBzcmNbaV0gKiBzeTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIF90cmFuc2xhdGUoc3JjLCB0eCwgdHksIGRlc3QpIHtcbiAgICBkZXN0IHx8PSBuZXcgRmxvYXQzMkFycmF5KHNyYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBkZXN0W2ldID0gdHggKyBzcmNbaV07XG4gICAgICBkZXN0W2kgKyAxXSA9IHR5ICsgc3JjW2kgKyAxXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cbiAgc3RhdGljIHN2Z1JvdW5kKHgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh4ICogMTAwMDApO1xuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUG9pbnQoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC8gcGFyZW50V2lkdGgsIHggLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHggLyBwYXJlbnRXaWR0aCwgMSAtIHkgLyBwYXJlbnRIZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSAvIHBhcmVudFdpZHRoLCAxIC0geCAvIHBhcmVudEhlaWdodF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3ggLyBwYXJlbnRXaWR0aCwgeSAvIHBhcmVudEhlaWdodF07XG4gICAgfVxuICB9XG4gIHN0YXRpYyBfbm9ybWFsaXplUGFnZVBvaW50KHgsIHksIHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geSwgeF07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHldO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeSwgMSAtIHhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUJlemllclBvaW50cyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgcmV0dXJuIFsoeDEgKyA1ICogeDIpIC8gNiwgKHkxICsgNSAqIHkyKSAvIDYsICg1ICogeDIgKyB4MykgLyA2LCAoNSAqIHkyICsgeTMpIC8gNiwgKHgyICsgeDMpIC8gMiwgKHkyICsgeTMpIC8gMl07XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvZnJlZWRyYXcuanNcblxuXG5jbGFzcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgI2JveDtcbiAgI2JvdHRvbSA9IFtdO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3RvcCA9IFtdO1xuICAjbGFzdCA9IG5ldyBGbG9hdDMyQXJyYXkoMTgpO1xuICAjbGFzdFg7XG4gICNsYXN0WTtcbiAgI21pbjtcbiAgI21pbl9kaXN0O1xuICAjc2NhbGVGYWN0b3I7XG4gICN0aGlja25lc3M7XG4gICNwb2ludHMgPSBbXTtcbiAgc3RhdGljICNNSU5fRElTVCA9IDg7XG4gIHN0YXRpYyAjTUlOX0RJRkYgPSAyO1xuICBzdGF0aWMgI01JTiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTl9ESVNUICsgRnJlZURyYXdPdXRsaW5lci4jTUlOX0RJRkY7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB4LFxuICAgIHlcbiAgfSwgYm94LCBzY2FsZUZhY3RvciwgdGhpY2tuZXNzLCBpc0xUUiwgaW5uZXJNYXJnaW4gPSAwKSB7XG4gICAgdGhpcy4jYm94ID0gYm94O1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoaWNrbmVzcyAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy4jbGFzdC5zZXQoW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV0sIDYpO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW47XG4gICAgdGhpcy4jbWluX2Rpc3QgPSBGcmVlRHJhd091dGxpbmVyLiNNSU5fRElTVCAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI21pbiA9IEZyZWVEcmF3T3V0bGluZXIuI01JTiAqIHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuI3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy4jcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy4jbGFzdFs4XSk7XG4gIH1cbiAgI2dldExhc3RDb29yZHMoKSB7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgcmV0dXJuIFsodGhpcy4jbGFzdFggKyAobGFzdFRvcFswXSAtIGxhc3RCb3R0b21bMF0pIC8gMiAtIHgpIC8gd2lkdGgsICh0aGlzLiNsYXN0WSArIChsYXN0VG9wWzFdIC0gbGFzdEJvdHRvbVsxXSkgLyAyIC0geSkgLyBoZWlnaHQsICh0aGlzLiNsYXN0WCArIChsYXN0Qm90dG9tWzBdIC0gbGFzdFRvcFswXSkgLyAyIC0geCkgLyB3aWR0aCwgKHRoaXMuI2xhc3RZICsgKGxhc3RCb3R0b21bMV0gLSBsYXN0VG9wWzFdKSAvIDIgLSB5KSAvIGhlaWdodF07XG4gIH1cbiAgYWRkKHtcbiAgICB4LFxuICAgIHlcbiAgfSkge1xuICAgIHRoaXMuI2xhc3RYID0geDtcbiAgICB0aGlzLiNsYXN0WSA9IHk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgbGV0IFt4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDgsIDEyKTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdChkaWZmWCwgZGlmZlkpO1xuICAgIGlmIChkIDwgdGhpcy4jbWluKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGRpZmZEID0gZCAtIHRoaXMuI21pbl9kaXN0O1xuICAgIGNvbnN0IEsgPSBkaWZmRCAvIGQ7XG4gICAgY29uc3Qgc2hpZnRYID0gSyAqIGRpZmZYO1xuICAgIGNvbnN0IHNoaWZ0WSA9IEsgKiBkaWZmWTtcbiAgICBsZXQgeDAgPSB4MTtcbiAgICBsZXQgeTAgPSB5MTtcbiAgICB4MSA9IHgyO1xuICAgIHkxID0geTI7XG4gICAgeDIgKz0gc2hpZnRYO1xuICAgIHkyICs9IHNoaWZ0WTtcbiAgICB0aGlzLiNwb2ludHM/LnB1c2goeCwgeSk7XG4gICAgY29uc3QgblggPSAtc2hpZnRZIC8gZGlmZkQ7XG4gICAgY29uc3QgblkgPSBzaGlmdFggLyBkaWZmRDtcbiAgICBjb25zdCB0aFggPSBuWCAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICBjb25zdCB0aFkgPSBuWSAqIHRoaXMuI3RoaWNrbmVzcztcbiAgICB0aGlzLiNsYXN0LnNldCh0aGlzLiNsYXN0LnN1YmFycmF5KDIsIDgpLCAwKTtcbiAgICB0aGlzLiNsYXN0LnNldChbeDIgKyB0aFgsIHkyICsgdGhZXSwgNCk7XG4gICAgdGhpcy4jbGFzdC5zZXQodGhpcy4jbGFzdC5zdWJhcnJheSgxNCwgMTgpLCAxMik7XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gyIC0gdGhYLCB5MiAtIHRoWV0sIDE2KTtcbiAgICBpZiAoaXNOYU4odGhpcy4jbGFzdFs2XSkpIHtcbiAgICAgIGlmICh0aGlzLiN0b3AubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MSArIHRoWCwgeTEgKyB0aFldLCAyKTtcbiAgICAgICAgdGhpcy4jdG9wLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgKyB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxICsgdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy4jbGFzdC5zZXQoW3gxIC0gdGhYLCB5MSAtIHRoWV0sIDE0KTtcbiAgICAgICAgdGhpcy4jYm90dG9tLnB1c2goTmFOLCBOYU4sIE5hTiwgTmFOLCAoeDEgLSB0aFggLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKHkxIC0gdGhZIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyXSwgNik7XG4gICAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0LnNldChbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0sIDYpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hdGFuMih5MCAtIHkxLCB4MCAtIHgxKSAtIE1hdGguYXRhbjIoc2hpZnRZLCBzaGlmdFgpKTtcbiAgICBpZiAoYW5nbGUgPCBNYXRoLlBJIC8gMikge1xuICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMiwgNik7XG4gICAgICB0aGlzLiN0b3AucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIFt4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE0LCAxOCk7XG4gICAgICB0aGlzLiNib3R0b20ucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sICgoeDAgKyB4MSkgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyB5MSkgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBbeDAsIHkwLCB4MSwgeTEsIHgyLCB5Ml0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDAsIDYpO1xuICAgIHRoaXMuI3RvcC5wdXNoKCgoeDAgKyA1ICogeDEpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKHkwICsgNSAqIHkxKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoNSAqIHgxICsgeDIpIC8gNiAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAoKDUgKiB5MSArIHkyKSAvIDYgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQsICgoeDEgKyB4MikgLyAyIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTEgKyB5MikgLyAyIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0KTtcbiAgICBbeDIsIHkyLCB4MSwgeTEsIHgwLCB5MF0gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDEyLCAxOCk7XG4gICAgdGhpcy4jYm90dG9tLnB1c2goKCh4MCArIDUgKiB4MSkgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoeTAgKyA1ICogeTEpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCg1ICogeDEgKyB4MikgLyA2IC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsICgoNSAqIHkxICsgeTIpIC8gNiAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgKCh4MSArIHgyKSAvIDIgLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKCh5MSArIHkyKSAvIDIgLSBsYXllclkpIC8gbGF5ZXJIZWlnaHQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCB0b3AgPSB0aGlzLiN0b3A7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGlmIChpc05hTih0aGlzLiNsYXN0WzZdKSAmJiAhdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiN0b1NWR1BhdGhUd29Qb2ludHMoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgYnVmZmVyLnB1c2goYE0ke3RvcFs0XX0gJHt0b3BbNV19YCk7XG4gICAgZm9yIChsZXQgaSA9IDY7IGkgPCB0b3AubGVuZ3RoOyBpICs9IDYpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0b3BbaSArIDRdfSAke3RvcFtpICsgNV19YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChgQyR7dG9wW2ldfSAke3RvcFtpICsgMV19ICR7dG9wW2kgKyAyXX0gJHt0b3BbaSArIDNdfSAke3RvcFtpICsgNF19ICR7dG9wW2kgKyA1XX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jdG9TVkdQYXRoRW5kKGJ1ZmZlcik7XG4gICAgZm9yIChsZXQgaSA9IGJvdHRvbS5sZW5ndGggLSA2OyBpID49IDY7IGkgLT0gNikge1xuICAgICAgaWYgKGlzTmFOKGJvdHRvbVtpXSkpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goYEwke2JvdHRvbVtpICsgNF19ICR7Ym90dG9tW2kgKyA1XX1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtib3R0b21baV19ICR7Ym90dG9tW2kgKyAxXX0gJHtib3R0b21baSArIDJdfSAke2JvdHRvbVtpICsgM119ICR7Ym90dG9tW2kgKyA0XX0gJHtib3R0b21baSArIDVdfWApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiN0b1NWR1BhdGhTdGFydChidWZmZXIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgI3RvU1ZHUGF0aFR3b1BvaW50cygpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICByZXR1cm4gYE0keyh0aGlzLiNsYXN0WzJdIC0geCkgLyB3aWR0aH0gJHsodGhpcy4jbGFzdFszXSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFs0XSAtIHgpIC8gd2lkdGh9ICR7KHRoaXMuI2xhc3RbNV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsodGhpcy4jbGFzdFsxNl0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE3XSAtIHkpIC8gaGVpZ2h0fSBMJHsodGhpcy4jbGFzdFsxNF0gLSB4KSAvIHdpZHRofSAkeyh0aGlzLiNsYXN0WzE1XSAtIHkpIC8gaGVpZ2h0fSBaYDtcbiAgfVxuICAjdG9TVkdQYXRoU3RhcnQoYnVmZmVyKSB7XG4gICAgY29uc3QgYm90dG9tID0gdGhpcy4jYm90dG9tO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHtib3R0b21bNF19ICR7Ym90dG9tWzVdfSBaYCk7XG4gIH1cbiAgI3RvU1ZHUGF0aEVuZChidWZmZXIpIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgbGFzdFRvcCA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoNCwgNik7XG4gICAgY29uc3QgbGFzdEJvdHRvbSA9IHRoaXMuI2xhc3Quc3ViYXJyYXkoMTYsIDE4KTtcbiAgICBjb25zdCBbbGFzdFRvcFgsIGxhc3RUb3BZLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVldID0gdGhpcy4jZ2V0TGFzdENvb3JkcygpO1xuICAgIGJ1ZmZlci5wdXNoKGBMJHsobGFzdFRvcFswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RUb3BbMV0gLSB5KSAvIGhlaWdodH0gTCR7bGFzdFRvcFh9ICR7bGFzdFRvcFl9IEwke2xhc3RCb3R0b21YfSAke2xhc3RCb3R0b21ZfSBMJHsobGFzdEJvdHRvbVswXSAtIHgpIC8gd2lkdGh9ICR7KGxhc3RCb3R0b21bMV0gLSB5KSAvIGhlaWdodH1gKTtcbiAgfVxuICBuZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbiAgZ2V0T3V0bGluZXMoKSB7XG4gICAgY29uc3QgdG9wID0gdGhpcy4jdG9wO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBjb25zdCBsYXN0ID0gdGhpcy4jbGFzdDtcbiAgICBjb25zdCBbbGF5ZXJYLCBsYXllclksIGxheWVyV2lkdGgsIGxheWVySGVpZ2h0XSA9IHRoaXMuI2JveDtcbiAgICBjb25zdCBwb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KCh0aGlzLiNwb2ludHM/Lmxlbmd0aCA/PyAwKSArIDIpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGggLSAyOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHRoaXMuI3BvaW50c1tpXSAtIGxheWVyWCkgLyBsYXllcldpZHRoO1xuICAgICAgcG9pbnRzW2kgKyAxXSA9ICh0aGlzLiNwb2ludHNbaSArIDFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0O1xuICAgIH1cbiAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdID0gKHRoaXMuI2xhc3RYIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGg7XG4gICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA9ICh0aGlzLiNsYXN0WSAtIGxheWVyWSkgLyBsYXllckhlaWdodDtcbiAgICBpZiAoaXNOYU4obGFzdFs2XSkgJiYgIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jZ2V0T3V0bGluZVR3b1BvaW50cyhwb2ludHMpO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLiN0b3AubGVuZ3RoICsgMjQgKyB0aGlzLiNib3R0b20ubGVuZ3RoKTtcbiAgICBsZXQgTiA9IHRvcC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpICs9IDIpIHtcbiAgICAgIGlmIChpc05hTih0b3BbaV0pKSB7XG4gICAgICAgIG91dGxpbmVbaV0gPSBvdXRsaW5lW2kgKyAxXSA9IE5hTjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvdXRsaW5lW2ldID0gdG9wW2ldO1xuICAgICAgb3V0bGluZVtpICsgMV0gPSB0b3BbaSArIDFdO1xuICAgIH1cbiAgICBOID0gdGhpcy4jZ2V0T3V0bGluZUVuZChvdXRsaW5lLCBOKTtcbiAgICBmb3IgKGxldCBpID0gYm90dG9tLmxlbmd0aCAtIDY7IGkgPj0gNjsgaSAtPSA2KSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY7IGogKz0gMikge1xuICAgICAgICBpZiAoaXNOYU4oYm90dG9tW2kgKyBqXSkpIHtcbiAgICAgICAgICBvdXRsaW5lW05dID0gb3V0bGluZVtOICsgMV0gPSBOYU47XG4gICAgICAgICAgTiArPSAyO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dGxpbmVbTl0gPSBib3R0b21baSArIGpdO1xuICAgICAgICBvdXRsaW5lW04gKyAxXSA9IGJvdHRvbVtpICsgaiArIDFdO1xuICAgICAgICBOICs9IDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuI2dldE91dGxpbmVTdGFydChvdXRsaW5lLCBOKTtcbiAgICByZXR1cm4gdGhpcy5uZXdGcmVlRHJhd091dGxpbmUob3V0bGluZSwgcG9pbnRzLCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlzLiNpbm5lck1hcmdpbiwgdGhpcy4jaXNMVFIpO1xuICB9XG4gICNnZXRPdXRsaW5lVHdvUG9pbnRzKHBvaW50cykge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsYXN0O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IFtsYXN0VG9wWCwgbGFzdFRvcFksIGxhc3RCb3R0b21YLCBsYXN0Qm90dG9tWV0gPSB0aGlzLiNnZXRMYXN0Q29vcmRzKCk7XG4gICAgY29uc3Qgb3V0bGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMzYpO1xuICAgIG91dGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzJdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzNdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0WzRdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0LCBOYU4sIE5hTiwgTmFOLCBOYU4sIGxhc3RUb3BYLCBsYXN0VG9wWSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0Qm90dG9tWCwgbGFzdEJvdHRvbVksIE5hTiwgTmFOLCBOYU4sIE5hTiwgKGxhc3RbMTZdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0WzE3XSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFsxNF0gLSBsYXllclgpIC8gbGF5ZXJXaWR0aCwgKGxhc3RbMTVdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgMCk7XG4gICAgcmV0dXJuIHRoaXMubmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgdGhpcy4jYm94LCB0aGlzLiNzY2FsZUZhY3RvciwgdGhpcy4jaW5uZXJNYXJnaW4sIHRoaXMuI2lzTFRSKTtcbiAgfVxuICAjZ2V0T3V0bGluZVN0YXJ0KG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGJvdHRvbSA9IHRoaXMuI2JvdHRvbTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCBib3R0b21bNF0sIGJvdHRvbVs1XV0sIHBvcyk7XG4gICAgcmV0dXJuIHBvcyArPSA2O1xuICB9XG4gICNnZXRPdXRsaW5lRW5kKG91dGxpbmUsIHBvcykge1xuICAgIGNvbnN0IGxhc3RUb3AgPSB0aGlzLiNsYXN0LnN1YmFycmF5KDQsIDYpO1xuICAgIGNvbnN0IGxhc3RCb3R0b20gPSB0aGlzLiNsYXN0LnN1YmFycmF5KDE2LCAxOCk7XG4gICAgY29uc3QgW2xheWVyWCwgbGF5ZXJZLCBsYXllcldpZHRoLCBsYXllckhlaWdodF0gPSB0aGlzLiNib3g7XG4gICAgY29uc3QgW2xhc3RUb3BYLCBsYXN0VG9wWSwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZXSA9IHRoaXMuI2dldExhc3RDb29yZHMoKTtcbiAgICBvdXRsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCAobGFzdFRvcFswXSAtIGxheWVyWCkgLyBsYXllcldpZHRoLCAobGFzdFRvcFsxXSAtIGxheWVyWSkgLyBsYXllckhlaWdodCwgTmFOLCBOYU4sIE5hTiwgTmFOLCBsYXN0VG9wWCwgbGFzdFRvcFksIE5hTiwgTmFOLCBOYU4sIE5hTiwgbGFzdEJvdHRvbVgsIGxhc3RCb3R0b21ZLCBOYU4sIE5hTiwgTmFOLCBOYU4sIChsYXN0Qm90dG9tWzBdIC0gbGF5ZXJYKSAvIGxheWVyV2lkdGgsIChsYXN0Qm90dG9tWzFdIC0gbGF5ZXJZKSAvIGxheWVySGVpZ2h0XSwgcG9zKTtcbiAgICByZXR1cm4gcG9zICs9IDI0O1xuICB9XG59XG5jbGFzcyBGcmVlRHJhd091dGxpbmUgZXh0ZW5kcyBPdXRsaW5lIHtcbiAgI2JveDtcbiAgI2Jib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAjaW5uZXJNYXJnaW47XG4gICNpc0xUUjtcbiAgI3BvaW50cztcbiAgI3NjYWxlRmFjdG9yO1xuICAjb3V0bGluZTtcbiAgY29uc3RydWN0b3Iob3V0bGluZSwgcG9pbnRzLCBib3gsIHNjYWxlRmFjdG9yLCBpbm5lck1hcmdpbiwgaXNMVFIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuI291dGxpbmUgPSBvdXRsaW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IHBvaW50cztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy4jc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvcjtcbiAgICB0aGlzLiNpbm5lck1hcmdpbiA9IGlubmVyTWFyZ2luO1xuICAgIHRoaXMuI2lzTFRSID0gaXNMVFI7XG4gICAgdGhpcy5maXJzdFBvaW50ID0gW05hTiwgTmFOXTtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtOYU4sIE5hTl07XG4gICAgdGhpcy4jY29tcHV0ZU1pbk1heChpc0xUUik7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVbaV0gPSAob3V0bGluZVtpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBvdXRsaW5lW2kgKyAxXSA9IChvdXRsaW5lW2kgKyAxXSAtIHkpIC8gaGVpZ2h0O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgcG9pbnRzW2ldID0gKHBvaW50c1tpXSAtIHgpIC8gd2lkdGg7XG4gICAgICBwb2ludHNbaSArIDFdID0gKHBvaW50c1tpICsgMV0gLSB5KSAvIGhlaWdodDtcbiAgICB9XG4gIH1cbiAgdG9TVkdQYXRoKCkge1xuICAgIGNvbnN0IGJ1ZmZlciA9IFtgTSR7dGhpcy4jb3V0bGluZVs0XX0gJHt0aGlzLiNvdXRsaW5lWzVdfWBdO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IHRoaXMuI291dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgaWYgKGlzTmFOKHRoaXMuI291dGxpbmVbaV0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBidWZmZXIucHVzaChgQyR7dGhpcy4jb3V0bGluZVtpXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAxXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAyXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyAzXX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA0XX0gJHt0aGlzLiNvdXRsaW5lW2kgKyA1XX1gKTtcbiAgICB9XG4gICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtibFgsIGJsWSwgdHJYLCB0clldLCByb3RhdGlvbikge1xuICAgIGNvbnN0IHdpZHRoID0gdHJYIC0gYmxYO1xuICAgIGNvbnN0IGhlaWdodCA9IHRyWSAtIGJsWTtcbiAgICBsZXQgb3V0bGluZTtcbiAgICBsZXQgcG9pbnRzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jb3V0bGluZSwgYmxYLCB0clksIHdpZHRoLCAtaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZSh0aGlzLiNwb2ludHMsIGJsWCwgdHJZLCB3aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgb3V0bGluZSA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI291dGxpbmUsIGJsWCwgYmxZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcG9pbnRzID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jcG9pbnRzLCBibFgsIGJsWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIG91dGxpbmUgPSBPdXRsaW5lLl9yZXNjYWxlKHRoaXMuI291dGxpbmUsIHRyWCwgYmxZLCAtd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGUodGhpcy4jcG9pbnRzLCB0clgsIGJsWSwgLXdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBvdXRsaW5lID0gT3V0bGluZS5fcmVzY2FsZUFuZFN3YXAodGhpcy4jb3V0bGluZSwgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIHBvaW50cyA9IE91dGxpbmUuX3Jlc2NhbGVBbmRTd2FwKHRoaXMuI3BvaW50cywgdHJYLCB0clksIC13aWR0aCwgLWhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZTogQXJyYXkuZnJvbShvdXRsaW5lKSxcbiAgICAgIHBvaW50czogW0FycmF5LmZyb20ocG9pbnRzKV1cbiAgICB9O1xuICB9XG4gICNjb21wdXRlTWluTWF4KGlzTFRSKSB7XG4gICAgY29uc3Qgb3V0bGluZSA9IHRoaXMuI291dGxpbmU7XG4gICAgbGV0IGxhc3RYID0gb3V0bGluZVs0XTtcbiAgICBsZXQgbGFzdFkgPSBvdXRsaW5lWzVdO1xuICAgIGNvbnN0IG1pbk1heCA9IFtsYXN0WCwgbGFzdFksIGxhc3RYLCBsYXN0WV07XG4gICAgbGV0IGZpcnN0UG9pbnRYID0gbGFzdFg7XG4gICAgbGV0IGZpcnN0UG9pbnRZID0gbGFzdFk7XG4gICAgbGV0IGxhc3RQb2ludFggPSBsYXN0WDtcbiAgICBsZXQgbGFzdFBvaW50WSA9IGxhc3RZO1xuICAgIGNvbnN0IGx0ckNhbGxiYWNrID0gaXNMVFIgPyBNYXRoLm1heCA6IE1hdGgubWluO1xuICAgIGNvbnN0IGJlemllckJib3ggPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIGZvciAobGV0IGkgPSA2LCBpaSA9IG91dGxpbmUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNikge1xuICAgICAgY29uc3QgeCA9IG91dGxpbmVbaSArIDRdLFxuICAgICAgICB5ID0gb3V0bGluZVtpICsgNV07XG4gICAgICBpZiAoaXNOYU4ob3V0bGluZVtpXSkpIHtcbiAgICAgICAgVXRpbC5wb2ludEJvdW5kaW5nQm94KHgsIHksIG1pbk1heCk7XG4gICAgICAgIGlmIChmaXJzdFBvaW50WSA+IHkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IHg7XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSB5O1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0UG9pbnRZID09PSB5KSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBsdHJDYWxsYmFjayhmaXJzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCB5KSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgICAgbGFzdFBvaW50WSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0geSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmV6aWVyQmJveFswXSA9IGJlemllckJib3hbMV0gPSBJbmZpbml0eTtcbiAgICAgICAgYmV6aWVyQmJveFsyXSA9IGJlemllckJib3hbM10gPSAtSW5maW5pdHk7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCAuLi5vdXRsaW5lLnNsaWNlKGksIGkgKyA2KSwgYmV6aWVyQmJveCk7XG4gICAgICAgIFV0aWwucmVjdEJvdW5kaW5nQm94KGJlemllckJib3hbMF0sIGJlemllckJib3hbMV0sIGJlemllckJib3hbMl0sIGJlemllckJib3hbM10sIG1pbk1heCk7XG4gICAgICAgIGlmIChmaXJzdFBvaW50WSA+IGJlemllckJib3hbMV0pIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IGJlemllckJib3hbMF07XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSBiZXppZXJCYm94WzFdO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0UG9pbnRZID09PSBiZXppZXJCYm94WzFdKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBsdHJDYWxsYmFjayhmaXJzdFBvaW50WCwgYmV6aWVyQmJveFswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQb2ludFkgPCBiZXppZXJCYm94WzNdKSB7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IGJlemllckJib3hbMl07XG4gICAgICAgICAgbGFzdFBvaW50WSA9IGJlemllckJib3hbM107XG4gICAgICAgIH0gZWxzZSBpZiAobGFzdFBvaW50WSA9PT0gYmV6aWVyQmJveFszXSkge1xuICAgICAgICAgIGxhc3RQb2ludFggPSBsdHJDYWxsYmFjayhsYXN0UG9pbnRYLCBiZXppZXJCYm94WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFggPSB4O1xuICAgICAgbGFzdFkgPSB5O1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jYmJveDtcbiAgICBiYm94WzBdID0gbWluTWF4WzBdIC0gdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFsxXSA9IG1pbk1heFsxXSAtIHRoaXMuI2lubmVyTWFyZ2luO1xuICAgIGJib3hbMl0gPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogdGhpcy4jaW5uZXJNYXJnaW47XG4gICAgYmJveFszXSA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiB0aGlzLiNpbm5lck1hcmdpbjtcbiAgICB0aGlzLmZpcnN0UG9pbnQgPSBbZmlyc3RQb2ludFgsIGZpcnN0UG9pbnRZXTtcbiAgICB0aGlzLmxhc3RQb2ludCA9IFtsYXN0UG9pbnRYLCBsYXN0UG9pbnRZXTtcbiAgfVxuICBnZXQgYm94KCkge1xuICAgIHJldHVybiB0aGlzLiNiYm94O1xuICB9XG4gIG5ld091dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbiA9IDApIHtcbiAgICByZXR1cm4gbmV3IEZyZWVEcmF3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luKTtcbiAgfVxuICBnZXROZXdPdXRsaW5lKHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFtsYXllclgsIGxheWVyWSwgbGF5ZXJXaWR0aCwgbGF5ZXJIZWlnaHRdID0gdGhpcy4jYm94O1xuICAgIGNvbnN0IHN4ID0gd2lkdGggKiBsYXllcldpZHRoO1xuICAgIGNvbnN0IHN5ID0gaGVpZ2h0ICogbGF5ZXJIZWlnaHQ7XG4gICAgY29uc3QgdHggPSB4ICogbGF5ZXJXaWR0aCArIGxheWVyWDtcbiAgICBjb25zdCB0eSA9IHkgKiBsYXllckhlaWdodCArIGxheWVyWTtcbiAgICBjb25zdCBvdXRsaW5lciA9IHRoaXMubmV3T3V0bGluZXIoe1xuICAgICAgeDogdGhpcy4jcG9pbnRzWzBdICogc3ggKyB0eCxcbiAgICAgIHk6IHRoaXMuI3BvaW50c1sxXSAqIHN5ICsgdHlcbiAgICB9LCB0aGlzLiNib3gsIHRoaXMuI3NjYWxlRmFjdG9yLCB0aGlja25lc3MsIHRoaXMuI2lzTFRSLCBpbm5lck1hcmdpbiA/PyB0aGlzLiNpbm5lck1hcmdpbik7XG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCB0aGlzLiNwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIG91dGxpbmVyLmFkZCh7XG4gICAgICAgIHg6IHRoaXMuI3BvaW50c1tpXSAqIHN4ICsgdHgsXG4gICAgICAgIHk6IHRoaXMuI3BvaW50c1tpICsgMV0gKiBzeSArIHR5XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dGxpbmVyLmdldE91dGxpbmVzKCk7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvaGlnaGxpZ2h0LmpzXG5cblxuXG5jbGFzcyBIaWdobGlnaHRPdXRsaW5lciB7XG4gICNib3g7XG4gICNmaXJzdFBvaW50O1xuICAjbGFzdFBvaW50O1xuICAjdmVydGljYWxFZGdlcyA9IFtdO1xuICAjaW50ZXJ2YWxzID0gW107XG4gIGNvbnN0cnVjdG9yKGJveGVzLCBib3JkZXJXaWR0aCA9IDAsIGlubmVyTWFyZ2luID0gMCwgaXNMVFIgPSB0cnVlKSB7XG4gICAgY29uc3QgbWluTWF4ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGNvbnN0IE5VTUJFUl9PRl9ESUdJVFMgPSA0O1xuICAgIGNvbnN0IEVQU0lMT04gPSAxMCAqKiAtTlVNQkVSX09GX0RJR0lUUztcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9IG9mIGJveGVzKSB7XG4gICAgICBjb25zdCB4MSA9IE1hdGguZmxvb3IoKHggLSBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCB4MiA9IE1hdGguY2VpbCgoeCArIHdpZHRoICsgYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKCh5IC0gYm9yZGVyV2lkdGgpIC8gRVBTSUxPTikgKiBFUFNJTE9OO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLmNlaWwoKHkgKyBoZWlnaHQgKyBib3JkZXJXaWR0aCkgLyBFUFNJTE9OKSAqIEVQU0lMT047XG4gICAgICBjb25zdCBsZWZ0ID0gW3gxLCB5MSwgeTIsIHRydWVdO1xuICAgICAgY29uc3QgcmlnaHQgPSBbeDIsIHkxLCB5MiwgZmFsc2VdO1xuICAgICAgdGhpcy4jdmVydGljYWxFZGdlcy5wdXNoKGxlZnQsIHJpZ2h0KTtcbiAgICAgIFV0aWwucmVjdEJvdW5kaW5nQm94KHgxLCB5MSwgeDIsIHkyLCBtaW5NYXgpO1xuICAgIH1cbiAgICBjb25zdCBiYm94V2lkdGggPSBtaW5NYXhbMl0gLSBtaW5NYXhbMF0gKyAyICogaW5uZXJNYXJnaW47XG4gICAgY29uc3QgYmJveEhlaWdodCA9IG1pbk1heFszXSAtIG1pbk1heFsxXSArIDIgKiBpbm5lck1hcmdpbjtcbiAgICBjb25zdCBzaGlmdGVkTWluWCA9IG1pbk1heFswXSAtIGlubmVyTWFyZ2luO1xuICAgIGNvbnN0IHNoaWZ0ZWRNaW5ZID0gbWluTWF4WzFdIC0gaW5uZXJNYXJnaW47XG4gICAgbGV0IGZpcnN0UG9pbnRYID0gaXNMVFIgPyAtSW5maW5pdHkgOiBJbmZpbml0eTtcbiAgICBsZXQgZmlyc3RQb2ludFkgPSBJbmZpbml0eTtcbiAgICBjb25zdCBsYXN0RWRnZSA9IHRoaXMuI3ZlcnRpY2FsRWRnZXMuYXQoaXNMVFIgPyAtMSA6IC0yKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBbbGFzdEVkZ2VbMF0sIGxhc3RFZGdlWzJdXTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgdGhpcy4jdmVydGljYWxFZGdlcykge1xuICAgICAgY29uc3QgW3gsIHkxLCB5MiwgbGVmdF0gPSBlZGdlO1xuICAgICAgaWYgKCFsZWZ0ICYmIGlzTFRSKSB7XG4gICAgICAgIGlmICh5MSA8IGZpcnN0UG9pbnRZKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFkgPSB5MTtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeTEgPT09IGZpcnN0UG9pbnRZKSB7XG4gICAgICAgICAgZmlyc3RQb2ludFggPSBNYXRoLm1heChmaXJzdFBvaW50WCwgeCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGVmdCAmJiAhaXNMVFIpIHtcbiAgICAgICAgaWYgKHkxIDwgZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WSA9IHkxO1xuICAgICAgICAgIGZpcnN0UG9pbnRYID0geDtcbiAgICAgICAgfSBlbHNlIGlmICh5MSA9PT0gZmlyc3RQb2ludFkpIHtcbiAgICAgICAgICBmaXJzdFBvaW50WCA9IE1hdGgubWluKGZpcnN0UG9pbnRYLCB4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWRnZVswXSA9ICh4IC0gc2hpZnRlZE1pblgpIC8gYmJveFdpZHRoO1xuICAgICAgZWRnZVsxXSA9ICh5MSAtIHNoaWZ0ZWRNaW5ZKSAvIGJib3hIZWlnaHQ7XG4gICAgICBlZGdlWzJdID0gKHkyIC0gc2hpZnRlZE1pblkpIC8gYmJveEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy4jYm94ID0gbmV3IEZsb2F0MzJBcnJheShbc2hpZnRlZE1pblgsIHNoaWZ0ZWRNaW5ZLCBiYm94V2lkdGgsIGJib3hIZWlnaHRdKTtcbiAgICB0aGlzLiNmaXJzdFBvaW50ID0gW2ZpcnN0UG9pbnRYLCBmaXJzdFBvaW50WV07XG4gICAgdGhpcy4jbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuICB9XG4gIGdldE91dGxpbmVzKCkge1xuICAgIHRoaXMuI3ZlcnRpY2FsRWRnZXMuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0gfHwgYVsxXSAtIGJbMV0gfHwgYVsyXSAtIGJbMl0pO1xuICAgIGNvbnN0IG91dGxpbmVWZXJ0aWNhbEVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBlZGdlIG9mIHRoaXMuI3ZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGlmIChlZGdlWzNdKSB7XG4gICAgICAgIG91dGxpbmVWZXJ0aWNhbEVkZ2VzLnB1c2goLi4udGhpcy4jYnJlYWtFZGdlKGVkZ2UpKTtcbiAgICAgICAgdGhpcy4jaW5zZXJ0KGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jcmVtb3ZlKGVkZ2UpO1xuICAgICAgICBvdXRsaW5lVmVydGljYWxFZGdlcy5wdXNoKC4uLnRoaXMuI2JyZWFrRWRnZShlZGdlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNnZXRPdXRsaW5lcyhvdXRsaW5lVmVydGljYWxFZGdlcyk7XG4gIH1cbiAgI2dldE91dGxpbmVzKG91dGxpbmVWZXJ0aWNhbEVkZ2VzKSB7XG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBjb25zdCBhbGxFZGdlcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2Ygb3V0bGluZVZlcnRpY2FsRWRnZXMpIHtcbiAgICAgIGNvbnN0IFt4LCB5MSwgeTJdID0gZWRnZTtcbiAgICAgIGVkZ2VzLnB1c2goW3gsIHkxLCBlZGdlXSwgW3gsIHkyLCBlZGdlXSk7XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdIHx8IGFbMF0gLSBiWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBlZGdlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCBlZGdlMSA9IGVkZ2VzW2ldWzJdO1xuICAgICAgY29uc3QgZWRnZTIgPSBlZGdlc1tpICsgMV1bMl07XG4gICAgICBlZGdlMS5wdXNoKGVkZ2UyKTtcbiAgICAgIGVkZ2UyLnB1c2goZWRnZTEpO1xuICAgICAgYWxsRWRnZXMuYWRkKGVkZ2UxKTtcbiAgICAgIGFsbEVkZ2VzLmFkZChlZGdlMik7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gW107XG4gICAgbGV0IG91dGxpbmU7XG4gICAgd2hpbGUgKGFsbEVkZ2VzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBlZGdlID0gYWxsRWRnZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgbGV0IFt4LCB5MSwgeTIsIGVkZ2UxLCBlZGdlMl0gPSBlZGdlO1xuICAgICAgYWxsRWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgbGV0IGxhc3RQb2ludFggPSB4O1xuICAgICAgbGV0IGxhc3RQb2ludFkgPSB5MTtcbiAgICAgIG91dGxpbmUgPSBbeCwgeTJdO1xuICAgICAgb3V0bGluZXMucHVzaChvdXRsaW5lKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBlO1xuICAgICAgICBpZiAoYWxsRWRnZXMuaGFzKGVkZ2UxKSkge1xuICAgICAgICAgIGUgPSBlZGdlMTtcbiAgICAgICAgfSBlbHNlIGlmIChhbGxFZGdlcy5oYXMoZWRnZTIpKSB7XG4gICAgICAgICAgZSA9IGVkZ2UyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGFsbEVkZ2VzLmRlbGV0ZShlKTtcbiAgICAgICAgW3gsIHkxLCB5MiwgZWRnZTEsIGVkZ2UyXSA9IGU7XG4gICAgICAgIGlmIChsYXN0UG9pbnRYICE9PSB4KSB7XG4gICAgICAgICAgb3V0bGluZS5wdXNoKGxhc3RQb2ludFgsIGxhc3RQb2ludFksIHgsIGxhc3RQb2ludFkgPT09IHkxID8geTEgOiB5Mik7XG4gICAgICAgICAgbGFzdFBvaW50WCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50WSA9IGxhc3RQb2ludFkgPT09IHkxID8geTIgOiB5MTtcbiAgICAgIH1cbiAgICAgIG91dGxpbmUucHVzaChsYXN0UG9pbnRYLCBsYXN0UG9pbnRZKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBIaWdobGlnaHRPdXRsaW5lKG91dGxpbmVzLCB0aGlzLiNib3gsIHRoaXMuI2ZpcnN0UG9pbnQsIHRoaXMuI2xhc3RQb2ludCk7XG4gIH1cbiAgI2JpbmFyeVNlYXJjaCh5KSB7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLiNpbnRlcnZhbHM7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICBjb25zdCBtaWRkbGUgPSBzdGFydCArIGVuZCA+PiAxO1xuICAgICAgY29uc3QgeTEgPSBhcnJheVttaWRkbGVdWzBdO1xuICAgICAgaWYgKHkxID09PSB5KSB7XG4gICAgICAgIHJldHVybiBtaWRkbGU7XG4gICAgICB9XG4gICAgICBpZiAoeTEgPCB5KSB7XG4gICAgICAgIHN0YXJ0ID0gbWlkZGxlICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IG1pZGRsZSAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbmQgKyAxO1xuICB9XG4gICNpbnNlcnQoWywgeTEsIHkyXSkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkxKTtcbiAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGluZGV4LCAwLCBbeTEsIHkyXSk7XG4gIH1cbiAgI3JlbW92ZShbLCB5MSwgeTJdKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLiNiaW5hcnlTZWFyY2goeTEpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IHRoaXMuI2ludGVydmFscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gdGhpcy4jaW50ZXJ2YWxzW2ldO1xuICAgICAgaWYgKHN0YXJ0ICE9PSB5MSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA9PT0geTEgJiYgZW5kID09PSB5Mikge1xuICAgICAgICB0aGlzLiNpbnRlcnZhbHMuc3BsaWNlKGksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSB0aGlzLiNpbnRlcnZhbHNbaV07XG4gICAgICBpZiAoc3RhcnQgIT09IHkxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ID09PSB5MSAmJiBlbmQgPT09IHkyKSB7XG4gICAgICAgIHRoaXMuI2ludGVydmFscy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2JyZWFrRWRnZShlZGdlKSB7XG4gICAgY29uc3QgW3gsIHkxLCB5Ml0gPSBlZGdlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbW3gsIHkxLCB5Ml1dO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy4jYmluYXJ5U2VhcmNoKHkyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspIHtcbiAgICAgIGNvbnN0IFtzdGFydCwgZW5kXSA9IHRoaXMuI2ludGVydmFsc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqaiA9IHJlc3VsdHMubGVuZ3RoOyBqIDwgamo7IGorKykge1xuICAgICAgICBjb25zdCBbLCB5MywgeTRdID0gcmVzdWx0c1tqXTtcbiAgICAgICAgaWYgKGVuZCA8PSB5MyB8fCB5NCA8PSBzdGFydCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh5MyA+PSBzdGFydCkge1xuICAgICAgICAgIGlmICh5NCA+IGVuZCkge1xuICAgICAgICAgICAgcmVzdWx0c1tqXVsxXSA9IGVuZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGpqID09PSAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdHMuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgamotLTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0c1tqXVsyXSA9IHN0YXJ0O1xuICAgICAgICBpZiAoeTQgPiBlbmQpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goW3gsIGVuZCwgeTRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxufVxuY2xhc3MgSGlnaGxpZ2h0T3V0bGluZSBleHRlbmRzIE91dGxpbmUge1xuICAjYm94O1xuICAjb3V0bGluZXM7XG4gIGNvbnN0cnVjdG9yKG91dGxpbmVzLCBib3gsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy4jb3V0bGluZXMgPSBvdXRsaW5lcztcbiAgICB0aGlzLiNib3ggPSBib3g7XG4gICAgdGhpcy5maXJzdFBvaW50ID0gZmlyc3RQb2ludDtcbiAgICB0aGlzLmxhc3RQb2ludCA9IGxhc3RQb2ludDtcbiAgfVxuICB0b1NWR1BhdGgoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgZm9yIChjb25zdCBwb2x5Z29uIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBsZXQgW3ByZXZYLCBwcmV2WV0gPSBwb2x5Z29uO1xuICAgICAgYnVmZmVyLnB1c2goYE0ke3ByZXZYfSAke3ByZXZZfWApO1xuICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBwb2x5Z29uLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IHggPSBwb2x5Z29uW2ldO1xuICAgICAgICBjb25zdCB5ID0gcG9seWdvbltpICsgMV07XG4gICAgICAgIGlmICh4ID09PSBwcmV2WCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBWJHt5fWApO1xuICAgICAgICAgIHByZXZZID0geTtcbiAgICAgICAgfSBlbHNlIGlmICh5ID09PSBwcmV2WSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXNoKGBIJHt4fWApO1xuICAgICAgICAgIHByZXZYID0geDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnVmZmVyLnB1c2goXCJaXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCIgXCIpO1xuICB9XG4gIHNlcmlhbGl6ZShbYmxYLCBibFksIHRyWCwgdHJZXSwgX3JvdGF0aW9uKSB7XG4gICAgY29uc3Qgb3V0bGluZXMgPSBbXTtcbiAgICBjb25zdCB3aWR0aCA9IHRyWCAtIGJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSB0clkgLSBibFk7XG4gICAgZm9yIChjb25zdCBvdXRsaW5lIG9mIHRoaXMuI291dGxpbmVzKSB7XG4gICAgICBjb25zdCBwb2ludHMgPSBuZXcgQXJyYXkob3V0bGluZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRsaW5lLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IGJsWCArIG91dGxpbmVbaV0gKiB3aWR0aDtcbiAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIG91dGxpbmVbaSArIDFdICogaGVpZ2h0O1xuICAgICAgfVxuICAgICAgb3V0bGluZXMucHVzaChwb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYm94O1xuICB9XG4gIGdldCBjbGFzc05hbWVzRm9yT3V0bGluaW5nKCkge1xuICAgIHJldHVybiBbXCJoaWdobGlnaHRPdXRsaW5lXCJdO1xuICB9XG59XG5jbGFzcyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIgZXh0ZW5kcyBGcmVlRHJhd091dGxpbmVyIHtcbiAgbmV3RnJlZURyYXdPdXRsaW5lKG91dGxpbmUsIHBvaW50cywgYm94LCBzY2FsZUZhY3RvciwgaW5uZXJNYXJnaW4sIGlzTFRSKSB7XG4gICAgcmV0dXJuIG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZShvdXRsaW5lLCBwb2ludHMsIGJveCwgc2NhbGVGYWN0b3IsIGlubmVyTWFyZ2luLCBpc0xUUik7XG4gIH1cbn1cbmNsYXNzIEZyZWVIaWdobGlnaHRPdXRsaW5lIGV4dGVuZHMgRnJlZURyYXdPdXRsaW5lIHtcbiAgbmV3T3V0bGluZXIocG9pbnQsIGJveCwgc2NhbGVGYWN0b3IsIHRoaWNrbmVzcywgaXNMVFIsIGlubmVyTWFyZ2luID0gMCkge1xuICAgIHJldHVybiBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBib3gsIHNjYWxlRmFjdG9yLCB0aGlja25lc3MsIGlzTFRSLCBpbm5lck1hcmdpbik7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2hpZ2hsaWdodC5qc1xuXG5cblxuXG5cblxuXG5jbGFzcyBIaWdobGlnaHRFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FuY2hvck5vZGUgPSBudWxsO1xuICAjYW5jaG9yT2Zmc2V0ID0gMDtcbiAgI2JveGVzO1xuICAjY2xpcFBhdGhJZCA9IG51bGw7XG4gICNjb2xvclBpY2tlciA9IG51bGw7XG4gICNmb2N1c091dGxpbmVzID0gbnVsbDtcbiAgI2ZvY3VzTm9kZSA9IG51bGw7XG4gICNmb2N1c09mZnNldCA9IDA7XG4gICNoaWdobGlnaHREaXYgPSBudWxsO1xuICAjaGlnaGxpZ2h0T3V0bGluZXMgPSBudWxsO1xuICAjaWQgPSBudWxsO1xuICAjaXNGcmVlSGlnaGxpZ2h0ID0gZmFsc2U7XG4gICNmaXJzdFBvaW50ID0gbnVsbDtcbiAgI2xhc3RQb2ludCA9IG51bGw7XG4gICNvdXRsaW5lSWQgPSBudWxsO1xuICAjdGV4dCA9IFwiXCI7XG4gICN0aGlja25lc3M7XG4gICNtZXRob2RPZkNyZWF0aW9uID0gXCJcIjtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTI7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaGlnaGxpZ2h0XCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0SWQgPSAtMTtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0ID0gbnVsbDtcbiAgc3RhdGljIF9mcmVlSGlnaGxpZ2h0Q2xpcElkID0gXCJcIjtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gSGlnaGxpZ2h0RWRpdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8uX21vdmVDYXJldCwge1xuICAgICAgYXJnczogWzBdXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFsxXVxuICAgIH1dLCBbW1wiQXJyb3dVcFwiLCBcIm1hYytBcnJvd1VwXCJdLCBwcm90by5fbW92ZUNhcmV0LCB7XG4gICAgICBhcmdzOiBbMl1cbiAgICB9XSwgW1tcIkFycm93RG93blwiLCBcIm1hYytBcnJvd0Rvd25cIl0sIHByb3RvLl9tb3ZlQ2FyZXQsIHtcbiAgICAgIGFyZ3M6IFszXVxuICAgIH1dXSkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwiaGlnaGxpZ2h0RWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLmNvbG9yID0gcGFyYW1zLmNvbG9yIHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdENvbG9yO1xuICAgIHRoaXMuI3RoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzO1xuICAgIHRoaXMub3BhY2l0eSA9IHBhcmFtcy5vcGFjaXR5IHx8IEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgdGhpcy4jYm94ZXMgPSBwYXJhbXMuYm94ZXMgfHwgbnVsbDtcbiAgICB0aGlzLiNtZXRob2RPZkNyZWF0aW9uID0gcGFyYW1zLm1ldGhvZE9mQ3JlYXRpb24gfHwgXCJcIjtcbiAgICB0aGlzLiN0ZXh0ID0gcGFyYW1zLnRleHQgfHwgXCJcIjtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1lZGl0b3JcIjtcbiAgICBpZiAocGFyYW1zLmhpZ2hsaWdodElkID4gLTEpIHtcbiAgICAgIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA9IHRydWU7XG4gICAgICB0aGlzLiNjcmVhdGVGcmVlT3V0bGluZXMocGFyYW1zKTtcbiAgICAgIHRoaXMuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNib3hlcykge1xuICAgICAgdGhpcy4jYW5jaG9yTm9kZSA9IHBhcmFtcy5hbmNob3JOb2RlO1xuICAgICAgdGhpcy4jYW5jaG9yT2Zmc2V0ID0gcGFyYW1zLmFuY2hvck9mZnNldDtcbiAgICAgIHRoaXMuI2ZvY3VzTm9kZSA9IHBhcmFtcy5mb2N1c05vZGU7XG4gICAgICB0aGlzLiNmb2N1c09mZnNldCA9IHBhcmFtcy5mb2N1c09mZnNldDtcbiAgICAgIHRoaXMuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgfVxuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KFwicGRmanMtZWRpdG9yLWhpZ2hsaWdodC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUluaXRpYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhY3Rpb246IFwiYWRkZWRcIixcbiAgICAgIHR5cGU6IHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IFwiZnJlZV9oaWdobGlnaHRcIiA6IFwiaGlnaGxpZ2h0XCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZSh0aGlzLmNvbG9yKSxcbiAgICAgIHRoaWNrbmVzczogdGhpcy4jdGhpY2tuZXNzLFxuICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogdGhpcy4jbWV0aG9kT2ZDcmVhdGlvblxuICAgIH07XG4gIH1cbiAgZ2V0IHRlbGVtZXRyeUZpbmFsRGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJoaWdobGlnaHRcIixcbiAgICAgIGNvbG9yOiB0aGlzLl91aU1hbmFnZXIuZ2V0Tm9uSENNQ29sb3JOYW1lKHRoaXMuY29sb3IpXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZVRlbGVtZXRyeUZpbmFsRGF0YShkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bWJlck9mQ29sb3JzOiBkYXRhLmdldChcImNvbG9yXCIpLnNpemVcbiAgICB9O1xuICB9XG4gICNjcmVhdGVPdXRsaW5lcygpIHtcbiAgICBjb25zdCBvdXRsaW5lciA9IG5ldyBIaWdobGlnaHRPdXRsaW5lcih0aGlzLiNib3hlcywgMC4wMDEpO1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gb3V0bGluZXIuZ2V0T3V0bGluZXMoKTtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveDtcbiAgICBjb25zdCBvdXRsaW5lckZvck91dGxpbmUgPSBuZXcgSGlnaGxpZ2h0T3V0bGluZXIodGhpcy4jYm94ZXMsIDAuMDAyNSwgMC4wMDEsIHRoaXMuX3VpTWFuYWdlci5kaXJlY3Rpb24gPT09IFwibHRyXCIpO1xuICAgIHRoaXMuI2ZvY3VzT3V0bGluZXMgPSBvdXRsaW5lckZvck91dGxpbmUuZ2V0T3V0bGluZXMoKTtcbiAgICBjb25zdCB7XG4gICAgICBmaXJzdFBvaW50XG4gICAgfSA9IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzO1xuICAgIHRoaXMuI2ZpcnN0UG9pbnQgPSBbKGZpcnN0UG9pbnRbMF0gLSB0aGlzLngpIC8gdGhpcy53aWR0aCwgKGZpcnN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0gdGhpcy54KSAvIHRoaXMud2lkdGgsIChsYXN0UG9pbnRbMV0gLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHRdO1xuICB9XG4gICNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgIGhpZ2hsaWdodE91dGxpbmVzLFxuICAgIGhpZ2hsaWdodElkLFxuICAgIGNsaXBQYXRoSWRcbiAgfSkge1xuICAgIHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgY29uc3QgZXh0cmFUaGlja25lc3MgPSAxLjU7XG4gICAgdGhpcy4jZm9jdXNPdXRsaW5lcyA9IGhpZ2hsaWdodE91dGxpbmVzLmdldE5ld091dGxpbmUodGhpcy4jdGhpY2tuZXNzIC8gMiArIGV4dHJhVGhpY2tuZXNzLCAwLjAwMjUpO1xuICAgIGlmIChoaWdobGlnaHRJZCA+PSAwKSB7XG4gICAgICB0aGlzLiNpZCA9IGhpZ2hsaWdodElkO1xuICAgICAgdGhpcy4jY2xpcFBhdGhJZCA9IGNsaXBQYXRoSWQ7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIuZmluYWxpemVEcmF3KGhpZ2hsaWdodElkLCB7XG4gICAgICAgIGJib3g6IGhpZ2hsaWdodE91dGxpbmVzLmJveCxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IGhpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy4jb3V0bGluZUlkID0gdGhpcy5wYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0T3V0bGluZTogdHJ1ZSxcbiAgICAgICAgICBmcmVlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGJib3g6IHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgICB9XG4gICAgICB9LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICBjb25zdCBhbmdsZSA9IHRoaXMucGFyZW50LnZpZXdwb3J0LnJvdGF0aW9uO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLmJveCwgKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApLFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZDogaGlnaGxpZ2h0T3V0bGluZXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLiNmb2N1c091dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSBoaWdobGlnaHRPdXRsaW5lcy5ib3g7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMueCA9IHk7XG4gICAgICAgICAgdGhpcy55ID0gMSAtIHg7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoICogcGFnZUhlaWdodCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodCAqIHBhZ2VXaWR0aCAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICB0aGlzLnggPSAxIC0geDtcbiAgICAgICAgdGhpcy55ID0gMSAtIHk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgICAgICB0aGlzLnggPSAxIC0geTtcbiAgICAgICAgICB0aGlzLnkgPSB4O1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCAqIHBhZ2VIZWlnaHQgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgKiBwYWdlV2lkdGggLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0UG9pbnRcbiAgICB9ID0gaGlnaGxpZ2h0T3V0bGluZXM7XG4gICAgdGhpcy4jZmlyc3RQb2ludCA9IFsoZmlyc3RQb2ludFswXSAtIHgpIC8gd2lkdGgsIChmaXJzdFBvaW50WzFdIC0geSkgLyBoZWlnaHRdO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RQb2ludFxuICAgIH0gPSB0aGlzLiNmb2N1c091dGxpbmVzO1xuICAgIHRoaXMuI2xhc3RQb2ludCA9IFsobGFzdFBvaW50WzBdIC0geCkgLyB3aWR0aCwgKGxhc3RQb2ludFsxXSAtIHkpIC8gaGVpZ2h0XTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fD0gdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycz8udmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IFwiI2ZmZjA2NlwiO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUjpcbiAgICAgICAgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIEhpZ2hsaWdodEVkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHt9XG4gIGdldCB0b29sYmFyUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RQb2ludDtcbiAgfVxuICBnZXQgY29tbWVudEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNmaXJzdFBvaW50O1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9DT0xPUiwgdGhpcy5jb2xvciB8fCBIaWdobGlnaHRFZGl0b3IuX2RlZmF1bHRDb2xvcl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5ISUdITElHSFRfVEhJQ0tORVNTLCB0aGlzLiN0aGlja25lc3MgfHwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW0Fubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkhJR0hMSUdIVF9GUkVFLCB0aGlzLiNpc0ZyZWVIaWdobGlnaHRdXTtcbiAgfVxuICBvblVwZGF0ZWRDb2xvcigpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgZmlsbDogdGhpcy5jb2xvcixcbiAgICAgICAgXCJmaWxsLW9wYWNpdHlcIjogdGhpcy5vcGFjaXR5XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3JQaWNrZXI/LnVwZGF0ZUNvbG9yKHRoaXMuY29sb3IpO1xuICAgIHN1cGVyLm9uVXBkYXRlZENvbG9yKCk7XG4gIH1cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2V0Q29sb3JBbmRPcGFjaXR5ID0gKGNvbCwgb3BhKSA9PiB7XG4gICAgICB0aGlzLmNvbG9yID0gY29sO1xuICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhO1xuICAgICAgdGhpcy5vblVwZGF0ZWRDb2xvcigpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3Qgc2F2ZWRPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBjb2xvciwgSGlnaGxpZ2h0RWRpdG9yLl9kZWZhdWx0T3BhY2l0eSksXG4gICAgICB1bmRvOiBzZXRDb2xvckFuZE9wYWNpdHkuYmluZCh0aGlzLCBzYXZlZENvbG9yLCBzYXZlZE9wYWNpdHkpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSElHSExJR0hUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5fcmVwb3J0VGVsZW1ldHJ5KHtcbiAgICAgIGFjdGlvbjogXCJjb2xvcl9jaGFuZ2VkXCIsXG4gICAgICBjb2xvcjogdGhpcy5fdWlNYW5hZ2VyLmdldE5vbkhDTUNvbG9yTmFtZShjb2xvcilcbiAgICB9LCB0cnVlKTtcbiAgfVxuICAjdXBkYXRlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGNvbnN0IHNhdmVkVGhpY2tuZXNzID0gdGhpcy4jdGhpY2tuZXNzO1xuICAgIGNvbnN0IHNldFRoaWNrbmVzcyA9IHRoID0+IHtcbiAgICAgIHRoaXMuI3RoaWNrbmVzcyA9IHRoO1xuICAgICAgdGhpcy4jY2hhbmdlVGhpY2tuZXNzKHRoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiBzZXRUaGlja25lc3MuYmluZCh0aGlzLCB0aGlja25lc3MpLFxuICAgICAgdW5kbzogc2V0VGhpY2tuZXNzLmJpbmQodGhpcywgc2F2ZWRUaGlja25lc3MpLFxuICAgICAgcG9zdDogdGhpcy5fdWlNYW5hZ2VyLnVwZGF0ZVVJLmJpbmQodGhpcy5fdWlNYW5hZ2VyLCB0aGlzKSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUyxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwidGhpY2tuZXNzX2NoYW5nZWRcIixcbiAgICAgIHRoaWNrbmVzc1xuICAgIH0sIHRydWUpO1xuICB9XG4gIGdldCB0b29sYmFyQnV0dG9ucygpIHtcbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLmhpZ2hsaWdodENvbG9ycykge1xuICAgICAgY29uc3QgY29sb3JQaWNrZXIgPSB0aGlzLiNjb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlcih7XG4gICAgICAgIGVkaXRvcjogdGhpc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW1tcImNvbG9yUGlja2VyXCIsIGNvbG9yUGlja2VyXV07XG4gICAgfVxuICAgIHJldHVybiBzdXBlci50b29sYmFyQnV0dG9ucztcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBzdXBlci5kaXNhYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCB0cnVlKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZGlzYWJsZWRcIiwgZmFsc2UpO1xuICB9XG4gIGZpeEFuZFNldFBvc2l0aW9uKCkge1xuICAgIHJldHVybiBzdXBlci5maXhBbmRTZXRQb3NpdGlvbih0aGlzLiNnZXRSb3RhdGlvbigpKTtcbiAgfVxuICBnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgcmV0dXJuIFswLCAwXTtcbiAgfVxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIHJldHVybiBzdXBlci5nZXRSZWN0KHR4LCB0eSwgdGhpcy4jZ2V0Um90YXRpb24oKSk7XG4gIH1cbiAgb25jZUFkZGVkKGZvY3VzKSB7XG4gICAgaWYgKCF0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLiNjbGVhbkRyYXdMYXllcigpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwiZGVsZXRlZFwiXG4gICAgfSk7XG4gICAgc3VwZXIucmVtb3ZlKCk7XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBsZXQgbXVzdEJlU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy4jYWRkVG9EcmF3TGF5ZXIocGFyZW50KTtcbiAgICAgIG11c3RCZVNlbGVjdGVkID0gIXRoaXMucGFyZW50ICYmIHRoaXMuZGl2Py5jbGFzc0xpc3QuY29udGFpbnMoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gICAgdGhpcy5zaG93KHRoaXMuX2lzVmlzaWJsZSk7XG4gICAgaWYgKG11c3RCZVNlbGVjdGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdCgpO1xuICAgIH1cbiAgfVxuICAjY2hhbmdlVGhpY2tuZXNzKHRoaWNrbmVzcykge1xuICAgIGlmICghdGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUZyZWVPdXRsaW5lcyh7XG4gICAgICBoaWdobGlnaHRPdXRsaW5lczogdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuZ2V0TmV3T3V0bGluZSh0aGlja25lc3MgLyAyKVxuICAgIH0pO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgfVxuICAjY2xlYW5EcmF3TGF5ZXIoKSB7XG4gICAgaWYgKHRoaXMuI2lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuI2lkKTtcbiAgICB0aGlzLiNpZCA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnJlbW92ZSh0aGlzLiNvdXRsaW5lSWQpO1xuICAgIHRoaXMuI291dGxpbmVJZCA9IG51bGw7XG4gIH1cbiAgI2FkZFRvRHJhd0xheWVyKHBhcmVudCA9IHRoaXMucGFyZW50KSB7XG4gICAgaWYgKHRoaXMuI2lkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICh7XG4gICAgICBpZDogdGhpcy4jaWQsXG4gICAgICBjbGlwUGF0aElkOiB0aGlzLiNjbGlwUGF0aElkXG4gICAgfSA9IHBhcmVudC5kcmF3TGF5ZXIuZHJhdyh7XG4gICAgICBiYm94OiB0aGlzLiNoaWdobGlnaHRPdXRsaW5lcy5ib3gsXG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEgMVwiLFxuICAgICAgICBmaWxsOiB0aGlzLmNvbG9yLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0aGlzLm9wYWNpdHlcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuI2hpZ2hsaWdodE91dGxpbmVzLnRvU1ZHUGF0aCgpXG4gICAgICB9XG4gICAgfSwgZmFsc2UsIHRydWUpKTtcbiAgICB0aGlzLiNvdXRsaW5lSWQgPSBwYXJlbnQuZHJhd0xheWVyLmRyYXdPdXRsaW5lKHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lOiB0cnVlLFxuICAgICAgICBmcmVlOiB0aGlzLiNpc0ZyZWVIaWdobGlnaHRcbiAgICAgIH0sXG4gICAgICBiYm94OiB0aGlzLiNmb2N1c091dGxpbmVzLmJveCxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jZm9jdXNPdXRsaW5lcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH0sIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCk7XG4gICAgaWYgKHRoaXMuI2hpZ2hsaWdodERpdikge1xuICAgICAgdGhpcy4jaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB9XG4gIH1cbiAgc3RhdGljICNyb3RhdGVCYm94KFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gaGVpZ2h0LCB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4IC0gd2lkdGgsIGhlaWdodCwgd2lkdGhdO1xuICAgIH1cbiAgICByZXR1cm4gW3gsIHksIHdpZHRoLCBoZWlnaHRdO1xuICB9XG4gIHJvdGF0ZShhbmdsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRyYXdMYXllclxuICAgIH0gPSB0aGlzLnBhcmVudDtcbiAgICBsZXQgYm94O1xuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGFuZ2xlID0gKGFuZ2xlIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjA7XG4gICAgICBib3ggPSBIaWdobGlnaHRFZGl0b3IuI3JvdGF0ZUJib3godGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuYm94LCBhbmdsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveCA9IEhpZ2hsaWdodEVkaXRvci4jcm90YXRlQmJveChbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSwgYW5nbGUpO1xuICAgIH1cbiAgICBkcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNpZCwge1xuICAgICAgYmJveDogYm94LFxuICAgICAgcm9vdDoge1xuICAgICAgICBcImRhdGEtbWFpbi1yb3RhdGlvblwiOiBhbmdsZVxuICAgICAgfVxuICAgIH0pO1xuICAgIGRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgYmJveDogSGlnaGxpZ2h0RWRpdG9yLiNyb3RhdGVCYm94KHRoaXMuI2ZvY3VzT3V0bGluZXMuYm94LCBhbmdsZSksXG4gICAgICByb290OiB7XG4gICAgICAgIFwiZGF0YS1tYWluLXJvdGF0aW9uXCI6IGFuZ2xlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBjb25zdCBkaXYgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBpZiAodGhpcy4jdGV4dCkge1xuICAgICAgZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy4jdGV4dCk7XG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm1hcmtcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLiNpc0ZyZWVIaWdobGlnaHQpIHtcbiAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4ja2V5ZG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbDogdGhpcy5fdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoaWdobGlnaHREaXYgPSB0aGlzLiNoaWdobGlnaHREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5hcHBlbmQoaGlnaGxpZ2h0RGl2KTtcbiAgICBoaWdobGlnaHREaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGhpZ2hsaWdodERpdi5jbGFzc05hbWUgPSBcImludGVybmFsXCI7XG4gICAgaGlnaGxpZ2h0RGl2LnN0eWxlLmNsaXBQYXRoID0gdGhpcy4jY2xpcFBhdGhJZDtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgICBiaW5kRXZlbnRzKHRoaXMsIHRoaXMuI2hpZ2hsaWdodERpdiwgW1wicG9pbnRlcm92ZXJcIiwgXCJwb2ludGVybGVhdmVcIl0pO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgcG9pbnRlcm92ZXIoKSB7XG4gICAgaWYgKCF0aGlzLmlzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaG92ZXJlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcG9pbnRlcmxlYXZlKCkge1xuICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKSB7XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jb3V0bGluZUlkLCB7XG4gICAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICAgIGhvdmVyZWQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAja2V5ZG93bihldmVudCkge1xuICAgIEhpZ2hsaWdodEVkaXRvci5fa2V5Ym9hcmRNYW5hZ2VyLmV4ZWModGhpcywgZXZlbnQpO1xuICB9XG4gIF9tb3ZlQ2FyZXQoZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5wYXJlbnQudW5zZWxlY3QodGhpcyk7XG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdGhpcy4jc2V0Q2FyZXQodHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgY2FzZSAzOlxuICAgICAgICB0aGlzLiNzZXRDYXJldChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAjc2V0Q2FyZXQoc3RhcnQpIHtcbiAgICBpZiAoIXRoaXMuI2FuY2hvck5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgc2VsZWN0aW9uLnNldFBvc2l0aW9uKHRoaXMuI2FuY2hvck5vZGUsIHRoaXMuI2FuY2hvck9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLiNmb2N1c05vZGUsIHRoaXMuI2ZvY3VzT2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0KCkge1xuICAgIHN1cGVyLnNlbGVjdCgpO1xuICAgIGlmICghdGhpcy4jb3V0bGluZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBob3ZlcmVkOiBmYWxzZSxcbiAgICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bnNlbGVjdCgpIHtcbiAgICBzdXBlci51bnNlbGVjdCgpO1xuICAgIGlmICghdGhpcy4jb3V0bGluZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLiNvdXRsaW5lSWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBzZWxlY3RlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRoaXMuI2lzRnJlZUhpZ2hsaWdodCkge1xuICAgICAgdGhpcy4jc2V0Q2FyZXQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBnZXQgX211c3RGaXhQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMuI2lzRnJlZUhpZ2hsaWdodDtcbiAgfVxuICBzaG93KHZpc2libGUgPSB0aGlzLl9pc1Zpc2libGUpIHtcbiAgICBzdXBlci5zaG93KHZpc2libGUpO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy4jaWQsIHtcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlkZGVuOiAhdmlzaWJsZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuI291dGxpbmVJZCwge1xuICAgICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgICBoaWRkZW46ICF2aXNpYmxlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAjZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzRnJlZUhpZ2hsaWdodCA/IHRoaXMucm90YXRpb24gOiAwO1xuICB9XG4gICNzZXJpYWxpemVCb3hlcygpIHtcbiAgICBpZiAodGhpcy4jaXNGcmVlSGlnaGxpZ2h0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgYm94ZXMgPSB0aGlzLiNib3hlcztcbiAgICBjb25zdCBxdWFkUG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShib3hlcy5sZW5ndGggKiA4KTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSBvZiBib3hlcykge1xuICAgICAgY29uc3Qgc3ggPSB4ICogcGFnZVdpZHRoICsgcGFnZVg7XG4gICAgICBjb25zdCBzeSA9ICgxIC0geSkgKiBwYWdlSGVpZ2h0ICsgcGFnZVk7XG4gICAgICBxdWFkUG9pbnRzW2ldID0gcXVhZFBvaW50c1tpICsgNF0gPSBzeDtcbiAgICAgIHF1YWRQb2ludHNbaSArIDFdID0gcXVhZFBvaW50c1tpICsgM10gPSBzeTtcbiAgICAgIHF1YWRQb2ludHNbaSArIDJdID0gcXVhZFBvaW50c1tpICsgNl0gPSBzeCArIHdpZHRoICogcGFnZVdpZHRoO1xuICAgICAgcXVhZFBvaW50c1tpICsgNV0gPSBxdWFkUG9pbnRzW2kgKyA3XSA9IHN5IC0gaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICAgIGkgKz0gODtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRQb2ludHM7XG4gIH1cbiAgI3NlcmlhbGl6ZU91dGxpbmVzKHJlY3QpIHtcbiAgICByZXR1cm4gdGhpcy4jaGlnaGxpZ2h0T3V0bGluZXMuc2VyaWFsaXplKHJlY3QsIHRoaXMuI2dldFJvdGF0aW9uKCkpO1xuICB9XG4gIHN0YXRpYyBzdGFydEhpZ2hsaWdodGluZyhwYXJlbnQsIGlzTFRSLCB7XG4gICAgdGFyZ2V0OiB0ZXh0TGF5ZXIsXG4gICAgeCxcbiAgICB5XG4gIH0pIHtcbiAgICBjb25zdCB7XG4gICAgICB4OiBsYXllclgsXG4gICAgICB5OiBsYXllclksXG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0ZXh0TGF5ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3Qgc2lnbmFsID0gcGFyZW50LmNvbWJpbmVkU2lnbmFsKGFjKTtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgYWMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI2VuZEhpZ2hsaWdodChwYXJlbnQsIGUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjaywge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdG9wRXZlbnQsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgbm9Db250ZXh0TWVudSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGV4dExheWVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNoaWdobGlnaHRNb3ZlLmJpbmQodGhpcywgcGFyZW50KSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5fZnJlZUhpZ2hsaWdodCA9IG5ldyBGcmVlSGlnaGxpZ2h0T3V0bGluZXIoe1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9LCBbbGF5ZXJYLCBsYXllclksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdLCBwYXJlbnQuc2NhbGUsIHRoaXMuX2RlZmF1bHRUaGlja25lc3MgLyAyLCBpc0xUUiwgMC4wMDEpO1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fZnJlZUhpZ2hsaWdodElkLFxuICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoe1xuICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgcm9vdDoge1xuICAgICAgICB2aWV3Qm94OiBcIjAgMCAxIDFcIixcbiAgICAgICAgZmlsbDogdGhpcy5fZGVmYXVsdENvbG9yLFxuICAgICAgICBcImZpbGwtb3BhY2l0eVwiOiB0aGlzLl9kZWZhdWx0T3BhY2l0eVxuICAgICAgfSxcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgICAgIGZyZWU6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMuX2ZyZWVIaWdobGlnaHQudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9LCB0cnVlLCB0cnVlKSk7XG4gIH1cbiAgc3RhdGljICNoaWdobGlnaHRNb3ZlKHBhcmVudCwgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fZnJlZUhpZ2hsaWdodC5hZGQoZXZlbnQpKSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZnJlZUhpZ2hsaWdodElkLCB7XG4gICAgICAgIHBhdGg6IHtcbiAgICAgICAgICBkOiB0aGlzLl9mcmVlSGlnaGxpZ2h0LnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgI2VuZEhpZ2hsaWdodChwYXJlbnQsIGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLl9mcmVlSGlnaGxpZ2h0LmlzRW1wdHkoKSkge1xuICAgICAgcGFyZW50LmNyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgZmFsc2UsIHtcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IHRoaXMuX2ZyZWVIaWdobGlnaHRJZCxcbiAgICAgICAgaGlnaGxpZ2h0T3V0bGluZXM6IHRoaXMuX2ZyZWVIaWdobGlnaHQuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgY2xpcFBhdGhJZDogdGhpcy5fZnJlZUhpZ2hsaWdodENsaXBJZCxcbiAgICAgICAgbWV0aG9kT2ZDcmVhdGlvbjogXCJtYWluX3Rvb2xiYXJcIlxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2ZyZWVIaWdobGlnaHRJZCk7XG4gICAgfVxuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRJZCA9IC0xO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHQgPSBudWxsO1xuICAgIHRoaXMuX2ZyZWVIaWdobGlnaHRDbGlwSWQgPSBcIlwiO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGxldCBpbml0aWFsRGF0YSA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5ISUdITElHSFQsXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgcXVhZFBvaW50cyxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIElua0Fubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpbmtMaXN0cyxcbiAgICAgICAgICByZWN0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIGJvcmRlclN0eWxlOiB7XG4gICAgICAgICAgICByYXdXaWR0aDogdGhpY2tuZXNzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgICBjb250ZW50c09iaixcbiAgICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLkhJR0hMSUdIVCxcbiAgICAgICAgY29sb3I6IEFycmF5LmZyb20oY29sb3IpLFxuICAgICAgICB0aGlja25lc3MsXG4gICAgICAgIGlua0xpc3RzLFxuICAgICAgICBib3hlczogbnVsbCxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlTnVtYmVyIC0gMSxcbiAgICAgICAgcmVjdDogcmVjdC5zbGljZSgwKSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWQ6IGlkLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2UsXG4gICAgICAgIHBvcHVwUmVmLFxuICAgICAgICByaWNoVGV4dCxcbiAgICAgICAgY29tbWVudDogY29udGVudHNPYmo/LnN0ciB8fCBudWxsLFxuICAgICAgICBjcmVhdGlvbkRhdGUsXG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbG9yLFxuICAgICAgcXVhZFBvaW50cyxcbiAgICAgIGlua0xpc3RzLFxuICAgICAgb3BhY2l0eVxuICAgIH0gPSBkYXRhO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY29sb3IgPSBVdGlsLm1ha2VIZXhDb2xvciguLi5jb2xvcik7XG4gICAgZWRpdG9yLm9wYWNpdHkgPSBvcGFjaXR5IHx8IDE7XG4gICAgaWYgKGlua0xpc3RzKSB7XG4gICAgICBlZGl0b3IuI3RoaWNrbmVzcyA9IGRhdGEudGhpY2tuZXNzO1xuICAgIH1cbiAgICBlZGl0b3IuX2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgaWYgKGRhdGEuY29tbWVudCkge1xuICAgICAgZWRpdG9yLnNldENvbW1lbnREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IGVkaXRvci5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IGVkaXRvci5wYWdlVHJhbnNsYXRpb247XG4gICAgaWYgKHF1YWRQb2ludHMpIHtcbiAgICAgIGNvbnN0IGJveGVzID0gZWRpdG9yLiNib3hlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFkUG9pbnRzLmxlbmd0aDsgaSArPSA4KSB7XG4gICAgICAgIGJveGVzLnB1c2goe1xuICAgICAgICAgIHg6IChxdWFkUG9pbnRzW2ldIC0gcGFnZVgpIC8gcGFnZVdpZHRoLFxuICAgICAgICAgIHk6IDEgLSAocXVhZFBvaW50c1tpICsgMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiAocXVhZFBvaW50c1tpICsgMl0gLSBxdWFkUG9pbnRzW2ldKSAvIHBhZ2VXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IChxdWFkUG9pbnRzW2kgKyAxXSAtIHF1YWRQb2ludHNbaSArIDVdKSAvIHBhZ2VIZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlZGl0b3IuI2NyZWF0ZU91dGxpbmVzKCk7XG4gICAgICBlZGl0b3IuI2FkZFRvRHJhd0xheWVyKCk7XG4gICAgICBlZGl0b3Iucm90YXRlKGVkaXRvci5yb3RhdGlvbik7XG4gICAgfSBlbHNlIGlmIChpbmtMaXN0cykge1xuICAgICAgZWRpdG9yLiNpc0ZyZWVIaWdobGlnaHQgPSB0cnVlO1xuICAgICAgY29uc3QgcG9pbnRzID0gaW5rTGlzdHNbMF07XG4gICAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnRzWzBdIC0gcGFnZVgsXG4gICAgICAgIHk6IHBhZ2VIZWlnaHQgLSAocG9pbnRzWzFdIC0gcGFnZVkpXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3V0bGluZXIgPSBuZXcgRnJlZUhpZ2hsaWdodE91dGxpbmVyKHBvaW50LCBbMCwgMCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSwgMSwgZWRpdG9yLiN0aGlja25lc3MgLyAyLCB0cnVlLCAwLjAwMSk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBwb2ludC54ID0gcG9pbnRzW2ldIC0gcGFnZVg7XG4gICAgICAgIHBvaW50LnkgPSBwYWdlSGVpZ2h0IC0gKHBvaW50c1tpICsgMV0gLSBwYWdlWSk7XG4gICAgICAgIG91dGxpbmVyLmFkZChwb2ludCk7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9ID0gcGFyZW50LmRyYXdMYXllci5kcmF3KHtcbiAgICAgICAgYmJveDogWzAsIDAsIDEsIDFdLFxuICAgICAgICByb290OiB7XG4gICAgICAgICAgdmlld0JveDogXCIwIDAgMSAxXCIsXG4gICAgICAgICAgZmlsbDogZWRpdG9yLmNvbG9yLFxuICAgICAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IGVkaXRvci5fZGVmYXVsdE9wYWNpdHlcbiAgICAgICAgfSxcbiAgICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgICAgaGlnaGxpZ2h0OiB0cnVlLFxuICAgICAgICAgIGZyZWU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IG91dGxpbmVyLnRvU1ZHUGF0aCgpXG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUsIHRydWUpO1xuICAgICAgZWRpdG9yLiNjcmVhdGVGcmVlT3V0bGluZXMoe1xuICAgICAgICBoaWdobGlnaHRPdXRsaW5lczogb3V0bGluZXIuZ2V0T3V0bGluZXMoKSxcbiAgICAgICAgaGlnaGxpZ2h0SWQ6IGlkLFxuICAgICAgICBjbGlwUGF0aElkXG4gICAgICB9KTtcbiAgICAgIGVkaXRvci4jYWRkVG9EcmF3TGF5ZXIoKTtcbiAgICAgIGVkaXRvci5yb3RhdGUoZWRpdG9yLnBhcmVudFJvdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoaXNGb3JDb3B5aW5nID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgfHwgaXNGb3JDb3B5aW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGVsZXRlZCgpO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuX3VpTWFuYWdlci5nZXROb25IQ01Db2xvcih0aGlzLmNvbG9yKSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN1cGVyLnNlcmlhbGl6ZShpc0ZvckNvcHlpbmcpO1xuICAgIE9iamVjdC5hc3NpZ24oc2VyaWFsaXplZCwge1xuICAgICAgY29sb3IsXG4gICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICB0aGlja25lc3M6IHRoaXMuI3RoaWNrbmVzcyxcbiAgICAgIHF1YWRQb2ludHM6IHRoaXMuI3NlcmlhbGl6ZUJveGVzKCksXG4gICAgICBvdXRsaW5lczogdGhpcy4jc2VyaWFsaXplT3V0bGluZXMoc2VyaWFsaXplZC5yZWN0KVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2xvclxuICAgIH0gPSB0aGlzLl9pbml0aWFsRGF0YTtcbiAgICByZXR1cm4gdGhpcy5oYXNFZGl0ZWRDb21tZW50IHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pO1xuICB9XG4gIHJlbmRlckFubm90YXRpb25FbGVtZW50KGFubm90YXRpb24pIHtcbiAgICBpZiAodGhpcy5kZWxldGVkKSB7XG4gICAgICBhbm5vdGF0aW9uLmhpZGUoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0OiB0aGlzLmdldFBERlJlY3QoKSxcbiAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9kcmF3LmpzXG5cblxuXG5cbmNsYXNzIERyYXdpbmdPcHRpb25zIHtcbiAgI3N2Z1Byb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgICB0aGlzLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0aWVzKHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllc1tuYW1lXSA9IHZhbHVlO1xuICB9XG4gIHRvU1ZHUHJvcGVydGllcygpIHtcbiAgICBjb25zdCByb290ID0gdGhpcy4jc3ZnUHJvcGVydGllcztcbiAgICB0aGlzLiNzdmdQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdFxuICAgIH07XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy4jc3ZnUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgdXBkYXRlQWxsKG9wdGlvbnMgPSB0aGlzKSB7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG59XG5jbGFzcyBEcmF3aW5nRWRpdG9yIGV4dGVuZHMgQW5ub3RhdGlvbkVkaXRvciB7XG4gICNkcmF3T3V0bGluZXMgPSBudWxsO1xuICAjbXVzdEJlQ29tbWl0dGVkO1xuICBfY29sb3JQaWNrZXIgPSBudWxsO1xuICBfZHJhd0lkID0gbnVsbDtcbiAgc3RhdGljIF9jdXJyZW50RHJhd0lkID0gLTE7XG4gIHN0YXRpYyBfY3VycmVudFBhcmVudCA9IG51bGw7XG4gIHN0YXRpYyAjY3VycmVudERyYXcgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICBzdGF0aWMgI2N1cnJlbnREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIHN0YXRpYyBfSU5ORVJfTUFSR0lOID0gMztcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIocGFyYW1zKTtcbiAgICB0aGlzLiNtdXN0QmVDb21taXR0ZWQgPSBwYXJhbXMubXVzdEJlQ29tbWl0dGVkIHx8IGZhbHNlO1xuICAgIHRoaXMuX2FkZE91dGxpbmVzKHBhcmFtcyk7XG4gIH1cbiAgb25VcGRhdGVkQ29sb3IoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXI/LnVwZGF0ZSh0aGlzLmNvbG9yKTtcbiAgICBzdXBlci5vblVwZGF0ZWRDb2xvcigpO1xuICB9XG4gIF9hZGRPdXRsaW5lcyhwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLmRyYXdPdXRsaW5lcykge1xuICAgICAgdGhpcy4jY3JlYXRlRHJhd091dGxpbmVzKHBhcmFtcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIH1cbiAgfVxuICAjY3JlYXRlRHJhd091dGxpbmVzKHtcbiAgICBkcmF3T3V0bGluZXMsXG4gICAgZHJhd0lkLFxuICAgIGRyYXdpbmdPcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLiNkcmF3T3V0bGluZXMgPSBkcmF3T3V0bGluZXM7XG4gICAgdGhpcy5fZHJhd2luZ09wdGlvbnMgfHw9IGRyYXdpbmdPcHRpb25zO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYTExeUFsZXJ0KGBwZGZqcy1lZGl0b3ItJHt0aGlzLmVkaXRvclR5cGV9LWFkZGVkLWFsZXJ0YCk7XG4gICAgfVxuICAgIGlmIChkcmF3SWQgPj0gMCkge1xuICAgICAgdGhpcy5fZHJhd0lkID0gZHJhd0lkO1xuICAgICAgdGhpcy5wYXJlbnQuZHJhd0xheWVyLmZpbmFsaXplRHJhdyhkcmF3SWQsIGRyYXdPdXRsaW5lcy5kZWZhdWx0UHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCB0aGlzLnBhcmVudCk7XG4gICAgfVxuICAgIHRoaXMuI3VwZGF0ZUJib3goZHJhd091dGxpbmVzLmJveCk7XG4gIH1cbiAgI2NyZWF0ZURyYXdpbmcoZHJhd091dGxpbmVzLCBwYXJlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcoRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpLCBkcmF3T3V0bGluZXMuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBzdGF0aWMgX21lcmdlU1ZHUHJvcGVydGllcyhwMSwgcDIpIHtcbiAgICBjb25zdCBwMUtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHAxKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocDIpKSB7XG4gICAgICBpZiAocDFLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocDFba2V5XSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcDFba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDE7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhfb3B0aW9ucykge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQgdHlwZXNNYXAoKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBpc0RyYXdlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGNvbnN0IHByb3BlcnR5TmFtZSA9IHRoaXMudHlwZXNNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2N1cnJlbnRQYXJlbnQpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnVwZGF0ZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9jdXJyZW50RHJhd0lkLCB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMudG9TVkdQcm9wZXJ0aWVzKCkpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwLmdldCh0eXBlKTtcbiAgICBpZiAocHJvcGVydHlOYW1lKSB7XG4gICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0eSh0eXBlLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zO1xuICAgIGZvciAoY29uc3QgW3R5cGUsIG5hbWVdIG9mIHRoaXMudHlwZXNNYXApIHtcbiAgICAgIHByb3BlcnRpZXMucHVzaChbdHlwZSwgb3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXTtcbiAgICBjb25zdCB7XG4gICAgICBfZHJhd2luZ09wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBuYW1lXSBvZiB0aGlzLmNvbnN0cnVjdG9yLnR5cGVzTWFwKSB7XG4gICAgICBwcm9wZXJ0aWVzLnB1c2goW3R5cGUsIF9kcmF3aW5nT3B0aW9uc1tuYW1lXV0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydGllcztcbiAgfVxuICBfdXBkYXRlUHJvcGVydHkodHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZHJhd2luZ09wdGlvbnM7XG4gICAgY29uc3Qgc2F2ZWRWYWx1ZSA9IG9wdGlvbnNbbmFtZV07XG4gICAgY29uc3Qgc2V0dGVyID0gdmFsID0+IHtcbiAgICAgIG9wdGlvbnMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUHJvcGVydHkobmFtZSwgdmFsKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHRoaXMuI3VwZGF0ZUJib3goYmJveCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBvcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgICAgIGlmICh0eXBlID09PSB0aGlzLmNvbG9yVHlwZSkge1xuICAgICAgICB0aGlzLm9uVXBkYXRlZENvbG9yKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogc2V0dGVyLmJpbmQodGhpcywgdmFsdWUpLFxuICAgICAgdW5kbzogc2V0dGVyLmJpbmQodGhpcywgc2F2ZWRWYWx1ZSksXG4gICAgICBwb3N0OiB0aGlzLl91aU1hbmFnZXIudXBkYXRlVUkuYmluZCh0aGlzLl91aU1hbmFnZXIsIHRoaXMpLFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX29uUmVzaXppbmcoKSB7XG4gICAgdGhpcy5wYXJlbnQ/LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHRoaXMuI2RyYXdPdXRsaW5lcy5nZXRQYXRoUmVzaXppbmdTVkdQcm9wZXJ0aWVzKHRoaXMuI2NvbnZlcnRUb0RyYXdTcGFjZSgpKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uUmVzaXplZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhSZXNpemVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSksIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSkpO1xuICB9XG4gIF9vblRyYW5zbGF0aW5nKF94LCBfeSkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSk7XG4gIH1cbiAgX29uVHJhbnNsYXRlZCgpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCBEcmF3aW5nRWRpdG9yLl9tZXJnZVNWR1Byb3BlcnRpZXModGhpcy4jZHJhd091dGxpbmVzLmdldFBhdGhUcmFuc2xhdGVkU1ZHUHJvcGVydGllcyh0aGlzLiNjb252ZXJ0VG9EcmF3U3BhY2UoKSwgdGhpcy5wYXJlbnREaW1lbnNpb25zKSwge1xuICAgICAgYmJveDogdGhpcy4jcm90YXRlQm94KClcbiAgICB9KSk7XG4gIH1cbiAgX29uU3RhcnREcmFnZ2luZygpIHtcbiAgICB0aGlzLnBhcmVudD8uZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fZHJhd0lkLCB7XG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgbW92aW5nOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX29uU3RvcERyYWdnaW5nKCkge1xuICAgIHRoaXMucGFyZW50Py5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyh0aGlzLl9kcmF3SWQsIHtcbiAgICAgIHJvb3RDbGFzczoge1xuICAgICAgICBtb3Zpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICB9XG4gIGRpc2FibGVFZGl0aW5nKCkge1xuICAgIHN1cGVyLmRpc2FibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsIHRydWUpO1xuICB9XG4gIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgc3VwZXIuZW5hYmxlRWRpdGluZygpO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC50b2dnbGUoXCJkaXNhYmxlZFwiLCBmYWxzZSk7XG4gIH1cbiAgZ2V0QmFzZVRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLiNtdXN0QmVDb21taXR0ZWQpIHtcbiAgICAgIHRoaXMuI211c3RCZUNvbW1pdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgaWYgKGZvY3VzICYmIHRoaXMuaXNPblNjcmVlbikge1xuICAgICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZW1vdmUoKSB7XG4gICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICByZWJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVidWlsZCgpO1xuICAgIGlmICh0aGlzLmRpdiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIHRoaXMuI3VwZGF0ZUJib3godGhpcy4jZHJhd091dGxpbmVzLmJveCk7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgbGV0IG11c3RCZVNlbGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMucGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgICAgdGhpcy4jY2xlYW5EcmF3TGF5ZXIoKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgICB0aGlzLiNhZGRUb0RyYXdMYXllcihwYXJlbnQpO1xuICAgICAgbXVzdEJlU2VsZWN0ZWQgPSAhdGhpcy5wYXJlbnQgJiYgdGhpcy5kaXY/LmNsYXNzTGlzdC5jb250YWlucyhcInNlbGVjdGVkRWRpdG9yXCIpO1xuICAgIH1cbiAgICBzdXBlci5zZXRQYXJlbnQocGFyZW50KTtcbiAgICBpZiAobXVzdEJlU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KCk7XG4gICAgfVxuICB9XG4gICNjbGVhbkRyYXdMYXllcigpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsIHx8ICF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIucmVtb3ZlKHRoaXMuX2RyYXdJZCk7XG4gICAgdGhpcy5fZHJhd0lkID0gbnVsbDtcbiAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucy5yZXNldCgpO1xuICB9XG4gICNhZGRUb0RyYXdMYXllcihwYXJlbnQgPSB0aGlzLnBhcmVudCkge1xuICAgIGlmICh0aGlzLl9kcmF3SWQgIT09IG51bGwgJiYgdGhpcy5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZHJhd0lkICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUGFyZW50KHRoaXMuX2RyYXdJZCwgcGFyZW50LmRyYXdMYXllcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zLnVwZGF0ZUFsbCgpO1xuICAgIHRoaXMuX2RyYXdJZCA9IHRoaXMuI2NyZWF0ZURyYXdpbmcodGhpcy4jZHJhd091dGxpbmVzLCBwYXJlbnQpO1xuICB9XG4gICNjb252ZXJ0VG9QYXJlbnRTcGFjZShbeCwgeSwgd2lkdGgsIGhlaWdodF0pIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCwgd2lkdGggKiAocEggLyBwVyksIGhlaWdodCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHksIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBIIC8gcFcpLCBoZWlnaHQgKiAocFcgLyBwSCldO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI2NvbnZlcnRUb0RyYXdTcGFjZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGFyZW50RGltZW5zaW9uczogW3BXLCBwSF0sXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHgsIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbMSAtIHgsIDEgLSB5LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gICN1cGRhdGVCYm94KGJib3gpIHtcbiAgICBbdGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0XSA9IHRoaXMuI2NvbnZlcnRUb1BhcmVudFNwYWNlKGJib3gpO1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgICAgdGhpcy5zZXREaW1zKCk7XG4gICAgfVxuICAgIHRoaXMuX29uUmVzaXplZCgpO1xuICB9XG4gICNyb3RhdGVCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyZW50Um90YXRpb24sXG4gICAgICBwYXJlbnREaW1lbnNpb25zOiBbcFcsIHBIXVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAoKHJvdGF0aW9uICogNCArIHBhcmVudFJvdGF0aW9uKSAvIDkwKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiBbMSAtIHkgLSBoZWlnaHQsIHgsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gWzEgLSB4IC0gd2lkdGgsIDEgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFt5LCAxIC0geCAtIHdpZHRoLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgcmV0dXJuIFt4LCB5IC0gd2lkdGggKiAocFcgLyBwSCksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gWzEgLSB5LCB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIFsxIC0geCAtIGhlaWdodCAqIChwSCAvIHBXKSwgMSAtIHksIGhlaWdodCAqIChwSCAvIHBXKSwgd2lkdGggKiAocFcgLyBwSCldO1xuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gW3kgLSB3aWR0aCAqIChwVyAvIHBIKSwgMSAtIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gW3ggLSB3aWR0aCwgeSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDk6XG4gICAgICAgIHJldHVybiBbMSAtIHksIHggLSB3aWR0aCwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gWzEgLSB4LCAxIC0geSwgd2lkdGgsIGhlaWdodF07XG4gICAgICBjYXNlIDExOlxuICAgICAgICByZXR1cm4gW3kgLSBoZWlnaHQsIDEgLSB4LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHJldHVybiBbeCAtIGhlaWdodCAqIChwSCAvIHBXKSwgeSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gWzEgLSB5IC0gd2lkdGggKiAocFcgLyBwSCksIHggLSBoZWlnaHQgKiAocEggLyBwVyksIHdpZHRoICogKHBXIC8gcEgpLCBoZWlnaHQgKiAocEggLyBwVyldO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgcmV0dXJuIFsxIC0geCwgMSAtIHkgLSB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpLCB3aWR0aCAqIChwVyAvIHBIKV07XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZXR1cm4gW3ksIDEgLSB4LCB3aWR0aCAqIChwVyAvIHBIKSwgaGVpZ2h0ICogKHBIIC8gcFcpXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbeCwgeSwgd2lkdGgsIGhlaWdodF07XG4gICAgfVxuICB9XG4gIHJvdGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RyYXdJZCwgRHJhd2luZ0VkaXRvci5fbWVyZ2VTVkdQcm9wZXJ0aWVzKHtcbiAgICAgIGJib3g6IHRoaXMuI3JvdGF0ZUJveCgpXG4gICAgfSwgdGhpcy4jZHJhd091dGxpbmVzLnVwZGF0ZVJvdGF0aW9uKCh0aGlzLnBhcmVudFJvdGF0aW9uIC0gdGhpcy5yb3RhdGlvbiArIDM2MCkgJSAzNjApKSk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdXBkYXRlQmJveCh0aGlzLiNkcmF3T3V0bGluZXMudXBkYXRlUGFyZW50RGltZW5zaW9ucyh0aGlzLnBhcmVudERpbWVuc2lvbnMsIHRoaXMucGFyZW50LnNjYWxlKSk7XG4gIH1cbiAgc3RhdGljIG9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKCkge31cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuICAgIGlmICh0aGlzLl9pc0NvcHkpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIGNvbnN0IGRpdiA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwiZHJhd1wiKTtcbiAgICBjb25zdCBkcmF3RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuYXBwZW5kKGRyYXdEaXYpO1xuICAgIGRyYXdEaXYuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpO1xuICAgIGRyYXdEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIHRoaXMuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICBpZiAodGhpcy5faXNDb3B5KSB7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gZGl2O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEcmF3ZXJJbnN0YW5jZShfeCwgX3ksIF9wYXJlbnRXaWR0aCwgX3BhcmVudEhlaWdodCwgX3JvdGF0aW9uKSB7XG4gICAgdW5yZWFjaGFibGUoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgc3RhdGljIHN0YXJ0RHJhd2luZyhwYXJlbnQsIHVpTWFuYWdlciwgX2lzTFRSLCBldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIG9mZnNldFg6IHgsXG4gICAgICBvZmZzZXRZOiB5LFxuICAgICAgcG9pbnRlcklkLFxuICAgICAgcG9pbnRlclR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgaWYgKEN1cnJlbnRQb2ludGVycy5pc0luaXRpYWxpemVkQW5kRGlmZmVyZW50UG9pbnRlclR5cGUocG9pbnRlclR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9XG4gICAgfSA9IHBhcmVudDtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogcGFyZW50V2lkdGgsXG4gICAgICBoZWlnaHQ6IHBhcmVudEhlaWdodFxuICAgIH0gPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgYWMgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ0FDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHBhcmVudC5jb21iaW5lZFNpZ25hbChhYyk7XG4gICAgQ3VycmVudFBvaW50ZXJzLnNldFBvaW50ZXIocG9pbnRlclR5cGUsIHBvaW50ZXJJZCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgZSA9PiB7XG4gICAgICBpZiAoQ3VycmVudFBvaW50ZXJzLmlzU2FtZVBvaW50ZXJJZE9yUmVtb3ZlKGUucG9pbnRlcklkKSkge1xuICAgICAgICB0aGlzLl9lbmREcmF3KGUpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBlID0+IHtcbiAgICAgIGlmIChDdXJyZW50UG9pbnRlcnMuaXNTYW1lUG9pbnRlcklkT3JSZW1vdmUoZS5wb2ludGVySWQpKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgaWYgKCFDdXJyZW50UG9pbnRlcnMuaXNTYW1lUG9pbnRlclR5cGUoZS5wb2ludGVyVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgQ3VycmVudFBvaW50ZXJzLmluaXRpYWxpemVBbmRBZGRQb2ludGVySWQoZS5wb2ludGVySWQpO1xuICAgICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmlzQ2FuY2VsbGFibGUoKSkge1xuICAgICAgICBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5yZW1vdmVMYXN0RWxlbWVudCgpO1xuICAgICAgICBpZiAoRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdGhpcy5fY3VycmVudFBhcmVudC5lbmREcmF3aW5nU2Vzc2lvbih0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lbmREcmF3KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBub0NvbnRleHRNZW51LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuX2RyYXdNb3ZlLmJpbmQodGhpcyksIHtcbiAgICAgIHNpZ25hbFxuICAgIH0pO1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGUgPT4ge1xuICAgICAgaWYgKEN1cnJlbnRQb2ludGVycy5pc1NhbWVUaW1lU3RhbXAoZS50aW1lU3RhbXApKSB7XG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICBwYXJlbnQudG9nZ2xlRHJhd2luZygpO1xuICAgIHVpTWFuYWdlci5fZWRpdG9yVW5kb0Jhcj8uaGlkZSgpO1xuICAgIGlmIChEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LnN0YXJ0TmV3KHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVpTWFuYWdlci51cGRhdGVVSUZvckRlZmF1bHRQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3ID0gdGhpcy5jcmVhdGVEcmF3ZXJJbnN0YW5jZSh4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbik7XG4gICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gdGhpcy5nZXREZWZhdWx0RHJhd2luZ09wdGlvbnMoKTtcbiAgICB0aGlzLl9jdXJyZW50UGFyZW50ID0gcGFyZW50O1xuICAgICh7XG4gICAgICBpZDogdGhpcy5fY3VycmVudERyYXdJZFxuICAgIH0gPSBwYXJlbnQuZHJhd0xheWVyLmRyYXcodGhpcy5fbWVyZ2VTVkdQcm9wZXJ0aWVzKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nT3B0aW9ucy50b1NWR1Byb3BlcnRpZXMoKSwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZGVmYXVsdFNWR1Byb3BlcnRpZXMpLCB0cnVlLCBmYWxzZSkpO1xuICB9XG4gIHN0YXRpYyBfZHJhd01vdmUoZXZlbnQpIHtcbiAgICBDdXJyZW50UG9pbnRlcnMuaXNTYW1lVGltZVN0YW1wKGV2ZW50LnRpbWVTdGFtcCk7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIHBvaW50ZXJJZFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAoIUN1cnJlbnRQb2ludGVycy5pc1NhbWVQb2ludGVySWQocG9pbnRlcklkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQ3VycmVudFBvaW50ZXJzLmlzVXNpbmdNdWx0aXBsZVBvaW50ZXJzKCkpIHtcbiAgICAgIHRoaXMuX2VuZERyYXcoZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50UGFyZW50LmRyYXdMYXllci51cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2N1cnJlbnREcmF3SWQsIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3LmFkZChvZmZzZXRYLCBvZmZzZXRZKSk7XG4gICAgQ3VycmVudFBvaW50ZXJzLnNldFRpbWVTdGFtcChldmVudC50aW1lU3RhbXApO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gIH1cbiAgc3RhdGljIF9jbGVhbnVwKGFsbCkge1xuICAgIGlmIChhbGwpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnREcmF3SWQgPSAtMTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXJlbnQgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcgPSBudWxsO1xuICAgICAgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXdpbmdPcHRpb25zID0gbnVsbDtcbiAgICAgIEN1cnJlbnRQb2ludGVycy5jbGVhclBvaW50ZXJUeXBlKCk7XG4gICAgICBDdXJyZW50UG9pbnRlcnMuY2xlYXJUaW1lU3RhbXAoKTtcbiAgICB9XG4gICAgaWYgKERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMpIHtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMuYWJvcnQoKTtcbiAgICAgIERyYXdpbmdFZGl0b3IuI2N1cnJlbnREcmF3aW5nQUMgPSBudWxsO1xuICAgICAgQ3VycmVudFBvaW50ZXJzLmNsZWFyUG9pbnRlcklkcygpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgX2VuZERyYXcoZXZlbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcmVudC50b2dnbGVEcmF3aW5nKHRydWUpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIGlmIChldmVudD8udGFyZ2V0ID09PSBwYXJlbnQuZGl2KSB7XG4gICAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZW5kKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIGNvbnN0IGRyYXcgPSBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdztcbiAgICAgIGNvbnN0IGRyYXdJZCA9IHRoaXMuX2N1cnJlbnREcmF3SWQ7XG4gICAgICBjb25zdCBsYXN0RWxlbWVudCA9IGRyYXcuZ2V0TGFzdEVsZW1lbnQoKTtcbiAgICAgIHBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcuc2V0TGFzdEVsZW1lbnQobGFzdEVsZW1lbnQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHBhcmVudC5kcmF3TGF5ZXIudXBkYXRlUHJvcGVydGllcyhkcmF3SWQsIGRyYXcucmVtb3ZlTGFzdEVsZW1lbnQoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIG11c3RFeGVjOiBmYWxzZSxcbiAgICAgICAgdHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRFJBV19TVEVQXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmREcmF3aW5nKGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgZW5kRHJhd2luZyhpc0Fib3J0ZWQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50UGFyZW50O1xuICAgIGlmICghcGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGFyZW50LnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgcGFyZW50LmNsZWFuVW5kb1N0YWNrKEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkRSQVdfU1RFUCk7XG4gICAgaWYgKCFEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhdy5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdLFxuICAgICAgICBzY2FsZVxuICAgICAgfSA9IHBhcmVudDtcbiAgICAgIGNvbnN0IGVkaXRvciA9IHBhcmVudC5jcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwXG4gICAgICB9LCBmYWxzZSwge1xuICAgICAgICBkcmF3SWQ6IHRoaXMuX2N1cnJlbnREcmF3SWQsXG4gICAgICAgIGRyYXdPdXRsaW5lczogRHJhd2luZ0VkaXRvci4jY3VycmVudERyYXcuZ2V0T3V0bGluZXMocGFnZVdpZHRoICogc2NhbGUsIHBhZ2VIZWlnaHQgKiBzY2FsZSwgc2NhbGUsIHRoaXMuX0lOTkVSX01BUkdJTiksXG4gICAgICAgIGRyYXdpbmdPcHRpb25zOiBEcmF3aW5nRWRpdG9yLiNjdXJyZW50RHJhd2luZ09wdGlvbnMsXG4gICAgICAgIG11c3RCZUNvbW1pdHRlZDogIWlzQWJvcnRlZFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbGVhbnVwKHRydWUpO1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgcGFyZW50LmRyYXdMYXllci5yZW1vdmUodGhpcy5fY3VycmVudERyYXdJZCk7XG4gICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyhfZGF0YSkge31cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhfcGFnZVgsIF9wYWdlWSwgX3BhZ2VXaWR0aCwgX3BhZ2VIZWlnaHQsIF9pbm5lcldpZHRoLCBfZGF0YSkge1xuICAgIHVucmVhY2hhYmxlKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICBwYWdlWCxcbiAgICAgICAgcGFnZVlcbiAgICAgIH1cbiAgICB9ID0gcGFyZW50LnZpZXdwb3J0O1xuICAgIGNvbnN0IGRyYXdPdXRsaW5lcyA9IHRoaXMuZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCB0aGlzLl9JTk5FUl9NQVJHSU4sIGRhdGEpO1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuY3JlYXRlRHJhd2luZ09wdGlvbnMoZGF0YSk7XG4gICAgZWRpdG9yLiNjcmVhdGVEcmF3T3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzXG4gICAgfSk7XG4gICAgZWRpdG9yLiNhZGRUb0RyYXdMYXllcigpO1xuICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICBlZGl0b3Iucm90YXRlKCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IFtwYWdlWCwgcGFnZVldID0gdGhpcy5wYWdlVHJhbnNsYXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIHJldHVybiB0aGlzLiNkcmF3T3V0bGluZXMuc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZyk7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpXG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhdGljIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9pbmtkcmF3LmpzXG5cblxuY2xhc3MgSW5rRHJhd091dGxpbmVyIHtcbiAgI2xhc3QgPSBuZXcgRmxvYXQ2NEFycmF5KDYpO1xuICAjbGluZTtcbiAgI2xpbmVzO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gICNwb2ludHM7XG4gICNsYXN0U1ZHUGF0aCA9IFwiXCI7XG4gICNsYXN0SW5kZXggPSAwO1xuICAjb3V0bGluZXMgPSBuZXcgSW5rRHJhd091dGxpbmUoKTtcbiAgI3BhcmVudFdpZHRoO1xuICAjcGFyZW50SGVpZ2h0O1xuICBjb25zdHJ1Y3Rvcih4LCB5LCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCByb3RhdGlvbiwgdGhpY2tuZXNzKSB7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy4jcm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLiN0aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgW3gsIHldID0gdGhpcy4jbm9ybWFsaXplUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgbGluZSA9IHRoaXMuI2xpbmUgPSBbTmFOLCBOYU4sIE5hTiwgTmFOLCB4LCB5XTtcbiAgICB0aGlzLiNwb2ludHMgPSBbeCwgeV07XG4gICAgdGhpcy4jbGluZXMgPSBbe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfV07XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdGhpcy4jdGhpY2tuZXNzID0gdmFsdWU7XG4gICAgfVxuICB9XG4gICNub3JtYWxpemVQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIE91dGxpbmUuX25vcm1hbGl6ZVBvaW50KHgsIHksIHRoaXMuI3BhcmVudFdpZHRoLCB0aGlzLiNwYXJlbnRIZWlnaHQsIHRoaXMuI3JvdGF0aW9uKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy4jbGluZXMgfHwgdGhpcy4jbGluZXMubGVuZ3RoID09PSAwO1xuICB9XG4gIGlzQ2FuY2VsbGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3BvaW50cy5sZW5ndGggPD0gMTA7XG4gIH1cbiAgYWRkKHgsIHkpIHtcbiAgICBbeCwgeV0gPSB0aGlzLiNub3JtYWxpemVQb2ludCh4LCB5KTtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gdGhpcy4jbGFzdC5zdWJhcnJheSgyLCA2KTtcbiAgICBjb25zdCBkaWZmWCA9IHggLSB4MjtcbiAgICBjb25zdCBkaWZmWSA9IHkgLSB5MjtcbiAgICBjb25zdCBkID0gTWF0aC5oeXBvdCh0aGlzLiNwYXJlbnRXaWR0aCAqIGRpZmZYLCB0aGlzLiNwYXJlbnRIZWlnaHQgKiBkaWZmWSk7XG4gICAgaWYgKGQgPD0gMikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3BvaW50cy5wdXNoKHgsIHkpO1xuICAgIGlmIChpc05hTih4MSkpIHtcbiAgICAgIHRoaXMuI2xhc3Quc2V0KFt4MiwgeTIsIHgsIHldLCAyKTtcbiAgICAgIHRoaXMuI2xpbmUucHVzaChOYU4sIE5hTiwgTmFOLCBOYU4sIHgsIHkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRoaXMuI2xhc3RbMF0pKSB7XG4gICAgICB0aGlzLiNsaW5lLnNwbGljZSg2LCA2KTtcbiAgICB9XG4gICAgdGhpcy4jbGFzdC5zZXQoW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSwgMCk7XG4gICAgdGhpcy4jbGluZS5wdXNoKC4uLk91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZW5kKHgsIHkpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLmFkZCh4LCB5KTtcbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICByZXR1cm4gY2hhbmdlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3RhcnROZXcoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNyb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIFt4LCB5XSA9IHRoaXMuI25vcm1hbGl6ZVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gW05hTiwgTmFOLCBOYU4sIE5hTiwgeCwgeV07XG4gICAgdGhpcy4jcG9pbnRzID0gW3gsIHldO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubGluZSA9IG5ldyBGbG9hdDMyQXJyYXkobGFzdC5saW5lKTtcbiAgICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnB1c2goe1xuICAgICAgbGluZSxcbiAgICAgIHBvaW50czogdGhpcy4jcG9pbnRzXG4gICAgfSk7XG4gICAgdGhpcy4jbGFzdC5zZXQobGluZSwgMCk7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gMDtcbiAgICB0aGlzLnRvU1ZHUGF0aCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldExhc3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gIH1cbiAgc2V0TGFzdEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy4jbGluZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLiNvdXRsaW5lcy5zZXRMYXN0RWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgdGhpcy4jbGluZXMucHVzaChlbGVtZW50KTtcbiAgICB0aGlzLiNsaW5lID0gZWxlbWVudC5saW5lO1xuICAgIHRoaXMuI3BvaW50cyA9IGVsZW1lbnQucG9pbnRzO1xuICAgIHRoaXMuI2xhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVtb3ZlTGFzdEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLiNsaW5lcykge1xuICAgICAgcmV0dXJuIHRoaXMuI291dGxpbmVzLnJlbW92ZUxhc3RFbGVtZW50KCk7XG4gICAgfVxuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSB0aGlzLiNsaW5lcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IHRoaXMuI2xpbmVzW2ldO1xuICAgICAgdGhpcy4jbGluZSA9IGxpbmU7XG4gICAgICB0aGlzLiNwb2ludHMgPSBwb2ludHM7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSAwO1xuICAgICAgdGhpcy50b1NWR1BhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy4jbGFzdFNWR1BhdGhcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBmaXJzdFggPSBPdXRsaW5lLnN2Z1JvdW5kKHRoaXMuI2xpbmVbNF0pO1xuICAgIGNvbnN0IGZpcnN0WSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVs1XSk7XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGh9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfSBaYDtcbiAgICAgIHJldHVybiB0aGlzLiNsYXN0U1ZHUGF0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3BvaW50cy5sZW5ndGggPD0gNikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuI2xhc3RTVkdQYXRoLmxhc3RJbmRleE9mKFwiTVwiKTtcbiAgICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gYCR7dGhpcy4jbGFzdFNWR1BhdGguc2xpY2UoMCwgaSl9IE0gJHtmaXJzdFh9ICR7Zmlyc3RZfWA7XG4gICAgICB0aGlzLiNsYXN0SW5kZXggPSA2O1xuICAgIH1cbiAgICBpZiAodGhpcy4jcG9pbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY29uc3Qgc2Vjb25kWCA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMF0pO1xuICAgICAgY29uc3Qgc2Vjb25kWSA9IE91dGxpbmUuc3ZnUm91bmQodGhpcy4jbGluZVsxMV0pO1xuICAgICAgdGhpcy4jbGFzdFNWR1BhdGggPSBgJHt0aGlzLiNsYXN0U1ZHUGF0aH0gTCAke3NlY29uZFh9ICR7c2Vjb25kWX1gO1xuICAgICAgdGhpcy4jbGFzdEluZGV4ID0gMTI7XG4gICAgICByZXR1cm4gdGhpcy4jbGFzdFNWR1BhdGg7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgIGlmICh0aGlzLiNsYXN0SW5kZXggPT09IDApIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGBNICR7Zmlyc3RYfSAke2ZpcnN0WX1gKTtcbiAgICAgIHRoaXMuI2xhc3RJbmRleCA9IDY7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSB0aGlzLiNsYXN0SW5kZXgsIGlpID0gdGhpcy4jbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICBjb25zdCBbYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5XSA9IHRoaXMuI2xpbmUuc2xpY2UoaSwgaSArIDYpLm1hcChPdXRsaW5lLnN2Z1JvdW5kKTtcbiAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgIH1cbiAgICB0aGlzLiNsYXN0U1ZHUGF0aCArPSBidWZmZXIuam9pbihcIiBcIik7XG4gICAgdGhpcy4jbGFzdEluZGV4ID0gdGhpcy4jbGluZS5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuI2xhc3RTVkdQYXRoO1xuICB9XG4gIGdldE91dGxpbmVzKHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCBpbm5lck1hcmdpbikge1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLiNsaW5lcy5hdCgtMSk7XG4gICAgbGFzdC5saW5lID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LmxpbmUpO1xuICAgIGxhc3QucG9pbnRzID0gbmV3IEZsb2F0MzJBcnJheShsYXN0LnBvaW50cyk7XG4gICAgdGhpcy4jb3V0bGluZXMuYnVpbGQodGhpcy4jbGluZXMsIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHNjYWxlLCB0aGlzLiNyb3RhdGlvbiwgdGhpcy4jdGhpY2tuZXNzLCBpbm5lck1hcmdpbik7XG4gICAgdGhpcy4jbGFzdCA9IG51bGw7XG4gICAgdGhpcy4jbGluZSA9IG51bGw7XG4gICAgdGhpcy4jbGluZXMgPSBudWxsO1xuICAgIHRoaXMuI2xhc3RTVkdQYXRoID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy4jb3V0bGluZXM7XG4gIH1cbiAgZ2V0IGRlZmF1bHRTVkdQcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEwMDAwIDEwMDAwXCJcbiAgICAgIH0sXG4gICAgICByb290Q2xhc3M6IHtcbiAgICAgICAgZHJhdzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGJib3g6IFswLCAwLCAxLCAxXVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIElua0RyYXdPdXRsaW5lIGV4dGVuZHMgT3V0bGluZSB7XG4gICNiYm94O1xuICAjY3VycmVudFJvdGF0aW9uID0gMDtcbiAgI2lubmVyTWFyZ2luO1xuICAjbGluZXM7XG4gICNwYXJlbnRXaWR0aDtcbiAgI3BhcmVudEhlaWdodDtcbiAgI3BhcmVudFNjYWxlO1xuICAjcm90YXRpb247XG4gICN0aGlja25lc3M7XG4gIGJ1aWxkKGxpbmVzLCBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBwYXJlbnRTY2FsZSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pIHtcbiAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IHBhcmVudFdpZHRoO1xuICAgIHRoaXMuI3BhcmVudEhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICB0aGlzLiNwYXJlbnRTY2FsZSA9IHBhcmVudFNjYWxlO1xuICAgIHRoaXMuI3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIHRoaXMuI2lubmVyTWFyZ2luID0gaW5uZXJNYXJnaW4gPz8gMDtcbiAgICB0aGlzLiNsaW5lcyA9IGxpbmVzO1xuICAgIHRoaXMuI2NvbXB1dGVCYm94KCk7XG4gIH1cbiAgZ2V0IHRoaWNrbmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy4jdGhpY2tuZXNzO1xuICB9XG4gIHNldExhc3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLiNsaW5lcy5wdXNoKGVsZW1lbnQpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJlbW92ZUxhc3RFbGVtZW50KCkge1xuICAgIHRoaXMuI2xpbmVzLnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHRvU1ZHUGF0aCgpIHtcbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIGxpbmVcbiAgICB9IG9mIHRoaXMuI2xpbmVzKSB7XG4gICAgICBidWZmZXIucHVzaChgTSR7T3V0bGluZS5zdmdSb3VuZChsaW5lWzRdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbNV0pfWApO1xuICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKFwiWlwiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobGluZS5sZW5ndGggPT09IDEyICYmIGlzTmFOKGxpbmVbNl0pKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBMJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTBdKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGxpbmVbMTFdKX1gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gNiwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgW2MxeCwgYzF5LCBjMngsIGMyeSwgeCwgeV0gPSBsaW5lLnN1YmFycmF5KGksIGkgKyA2KS5tYXAoT3V0bGluZS5zdmdSb3VuZCk7XG4gICAgICAgIGJ1ZmZlci5wdXNoKGBDJHtjMXh9ICR7YzF5fSAke2MyeH0gJHtjMnl9ICR7eH0gJHt5fWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcIik7XG4gIH1cbiAgc2VyaWFsaXplKFtwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodF0sIGlzRm9yQ29weWluZykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRMaW5lcyA9IFtdO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRQb2ludHMgPSBbXTtcbiAgICBjb25zdCBbeCwgeSwgd2lkdGgsIGhlaWdodF0gPSB0aGlzLiNnZXRCQm94V2l0aE5vTWFyZ2luKCk7XG4gICAgbGV0IHR4LCB0eSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MiwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAodGhpcy4jcm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC1wYWdlSGVpZ2h0O1xuICAgICAgICB4MSA9IHBhZ2VYICsgeCAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTEgPSBwYWdlWSArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKHggKyB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoMSAtIHkpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSBwYWdlV2lkdGg7XG4gICAgICAgIHN5ID0gcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArIHkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB4ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICh5ICsgaGVpZ2h0KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICh4ICsgd2lkdGgpICogcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWTtcbiAgICAgICAgc3ggPSAtcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IHBhZ2VIZWlnaHQ7XG4gICAgICAgIHgxID0gcGFnZVggKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyB5ICogcGFnZUhlaWdodDtcbiAgICAgICAgeDIgPSBwYWdlWCArICgxIC0geCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkyID0gcGFnZVkgKyAoeSArIGhlaWdodCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWCArIHBhZ2VXaWR0aDtcbiAgICAgICAgdHkgPSBwYWdlWSArIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN4ID0gLXBhZ2VXaWR0aDtcbiAgICAgICAgc3kgPSAtcGFnZUhlaWdodDtcbiAgICAgICAgeDEgPSBwYWdlWCArICgxIC0geSAtIGhlaWdodCkgKiBwYWdlV2lkdGg7XG4gICAgICAgIHkxID0gcGFnZVkgKyAoMSAtIHggLSB3aWR0aCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICB4MiA9IHBhZ2VYICsgKDEgLSB5KSAqIHBhZ2VXaWR0aDtcbiAgICAgICAgeTIgPSBwYWdlWSArICgxIC0geCkgKiBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBsaW5lLFxuICAgICAgcG9pbnRzXG4gICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgc2VyaWFsaXplZExpbmVzLnB1c2gocmVzY2FsZUZuKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkobGluZS5sZW5ndGgpIDogbnVsbCkpO1xuICAgICAgc2VyaWFsaXplZFBvaW50cy5wdXNoKHJlc2NhbGVGbihwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBpc0ZvckNvcHlpbmcgPyBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCkgOiBudWxsKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogc2VyaWFsaXplZExpbmVzLFxuICAgICAgcG9pbnRzOiBzZXJpYWxpemVkUG9pbnRzLFxuICAgICAgcmVjdDogW3gxLCB5MSwgeDIsIHkyXVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwge1xuICAgIHBhdGhzOiB7XG4gICAgICBsaW5lcyxcbiAgICAgIHBvaW50c1xuICAgIH0sXG4gICAgcm90YXRpb24sXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBjb25zdCBuZXdMaW5lcyA9IFtdO1xuICAgIGxldCB0eCwgdHksIHN4LCBzeSwgcmVzY2FsZUZuO1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmVzY2FsZUZuID0gT3V0bGluZS5fcmVzY2FsZTtcbiAgICAgICAgdHggPSAtcGFnZVggLyBwYWdlV2lkdGg7XG4gICAgICAgIHR5ID0gcGFnZVkgLyBwYWdlSGVpZ2h0ICsgMTtcbiAgICAgICAgc3ggPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IC0xIC8gcGFnZUhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICB0eSA9IC1wYWdlWCAvIHBhZ2VXaWR0aDtcbiAgICAgICAgc3ggPSAxIC8gcGFnZUhlaWdodDtcbiAgICAgICAgc3kgPSAxIC8gcGFnZVdpZHRoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlO1xuICAgICAgICB0eCA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgdHkgPSAtcGFnZVkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBzeCA9IC0xIC8gcGFnZVdpZHRoO1xuICAgICAgICBzeSA9IDEgLyBwYWdlSGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXNjYWxlRm4gPSBPdXRsaW5lLl9yZXNjYWxlQW5kU3dhcDtcbiAgICAgICAgdHggPSBwYWdlWSAvIHBhZ2VIZWlnaHQgKyAxO1xuICAgICAgICB0eSA9IHBhZ2VYIC8gcGFnZVdpZHRoICsgMTtcbiAgICAgICAgc3ggPSAtMSAvIHBhZ2VIZWlnaHQ7XG4gICAgICAgIHN5ID0gLTEgLyBwYWdlV2lkdGg7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoIWxpbmVzKSB7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXV0pKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSA0KSB7XG4gICAgICAgICAgbGluZXMucHVzaChuZXcgRmxvYXQzMkFycmF5KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHBvaW50WzBdLCBwb2ludFsxXSwgTmFOLCBOYU4sIE5hTiwgTmFOLCBwb2ludFsyXSwgcG9pbnRbM11dKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIChsZW4gLSAyKSk7XG4gICAgICAgIGxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gcG9pbnQuc3ViYXJyYXkoMCwgNCk7XG4gICAgICAgIGxpbmUuc2V0KFtOYU4sIE5hTiwgTmFOLCBOYU4sIHgxLCB5MV0sIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gNDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50W2ldO1xuICAgICAgICAgIGNvbnN0IHkgPSBwb2ludFtpICsgMV07XG4gICAgICAgICAgbGluZS5zZXQoT3V0bGluZS5jcmVhdGVCZXppZXJQb2ludHMoeDEsIHkxLCB4MiwgeTIsIHgsIHkpLCAoaSAtIDIpICogMyk7XG4gICAgICAgICAgW3gxLCB5MSwgeDIsIHkyXSA9IFt4MiwgeTIsIHgsIHldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIG5ld0xpbmVzLnB1c2goe1xuICAgICAgICBsaW5lOiByZXNjYWxlRm4obGluZXNbaV0ubWFwKHggPT4geCA/PyBOYU4pLCB0eCwgdHksIHN4LCBzeSksXG4gICAgICAgIHBvaW50czogcmVzY2FsZUZuKHBvaW50c1tpXS5tYXAoeCA9PiB4ID8/IE5hTiksIHR4LCB0eSwgc3gsIHN5KVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG91dGxpbmVzID0gbmV3IHRoaXMucHJvdG90eXBlLmNvbnN0cnVjdG9yKCk7XG4gICAgb3V0bGluZXMuYnVpbGQobmV3TGluZXMsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgMSwgcm90YXRpb24sIHRoaWNrbmVzcywgaW5uZXJNYXJnaW4pO1xuICAgIHJldHVybiBvdXRsaW5lcztcbiAgfVxuICAjZ2V0TWFyZ2luQ29tcG9uZW50cyh0aGlja25lc3MgPSB0aGlzLiN0aGlja25lc3MpIHtcbiAgICBjb25zdCBtYXJnaW4gPSB0aGlzLiNpbm5lck1hcmdpbiArIHRoaWNrbmVzcyAvIDIgKiB0aGlzLiNwYXJlbnRTY2FsZTtcbiAgICByZXR1cm4gdGhpcy4jcm90YXRpb24gJSAxODAgPT09IDAgPyBbbWFyZ2luIC8gdGhpcy4jcGFyZW50V2lkdGgsIG1hcmdpbiAvIHRoaXMuI3BhcmVudEhlaWdodF0gOiBbbWFyZ2luIC8gdGhpcy4jcGFyZW50SGVpZ2h0LCBtYXJnaW4gLyB0aGlzLiNwYXJlbnRXaWR0aF07XG4gIH1cbiAgI2dldEJCb3hXaXRoTm9NYXJnaW4oKSB7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKDApO1xuICAgIHJldHVybiBbeCArIG1hcmdpblgsIHkgKyBtYXJnaW5ZLCB3aWR0aCAtIDIgKiBtYXJnaW5YLCBoZWlnaHQgLSAyICogbWFyZ2luWV07XG4gIH1cbiAgI2NvbXB1dGVCYm94KCkge1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94ID0gbmV3IEZsb2F0MzJBcnJheShbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgbGluZVxuICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgIGlmIChsaW5lLmxlbmd0aCA8PSAxMikge1xuICAgICAgICBmb3IgKGxldCBpID0gNCwgaWkgPSBsaW5lLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgICBVdGlsLnBvaW50Qm91bmRpbmdCb3gobGluZVtpXSwgbGluZVtpICsgMV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IGxhc3RYID0gbGluZVs0XSxcbiAgICAgICAgbGFzdFkgPSBsaW5lWzVdO1xuICAgICAgZm9yIChsZXQgaSA9IDYsIGlpID0gbGluZS5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IFtjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHldID0gbGluZS5zdWJhcnJheShpLCBpICsgNik7XG4gICAgICAgIFV0aWwuYmV6aWVyQm91bmRpbmdCb3gobGFzdFgsIGxhc3RZLCBjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHksIGJib3gpO1xuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGJib3hbMF0gPSBNYXRoQ2xhbXAoYmJveFswXSAtIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbMV0gPSBNYXRoQ2xhbXAoYmJveFsxXSAtIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gPSBNYXRoQ2xhbXAoYmJveFsyXSArIG1hcmdpblgsIDAsIDEpO1xuICAgIGJib3hbM10gPSBNYXRoQ2xhbXAoYmJveFszXSArIG1hcmdpblksIDAsIDEpO1xuICAgIGJib3hbMl0gLT0gYmJveFswXTtcbiAgICBiYm94WzNdIC09IGJib3hbMV07XG4gIH1cbiAgZ2V0IGJveCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYmJveDtcbiAgfVxuICB1cGRhdGVQcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcInN0cm9rZS13aWR0aFwiKSB7XG4gICAgICByZXR1cm4gdGhpcy4jdXBkYXRlVGhpY2tuZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI3VwZGF0ZVRoaWNrbmVzcyh0aGlja25lc3MpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jdGhpY2tuZXNzID0gdGhpY2tuZXNzO1xuICAgIGNvbnN0IFtuZXdNYXJnaW5YLCBuZXdNYXJnaW5ZXSA9IHRoaXMuI2dldE1hcmdpbkNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBbZGlmZk1hcmdpblgsIGRpZmZNYXJnaW5ZXSA9IFtuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWCwgbmV3TWFyZ2luWSAtIG9sZE1hcmdpblldO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVQYXJlbnREaW1lbnNpb25zKFt3aWR0aCwgaGVpZ2h0XSwgc2NhbGUpIHtcbiAgICBjb25zdCBbb2xkTWFyZ2luWCwgb2xkTWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgdGhpcy4jcGFyZW50V2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNwYXJlbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy4jcGFyZW50U2NhbGUgPSBzY2FsZTtcbiAgICBjb25zdCBbbmV3TWFyZ2luWCwgbmV3TWFyZ2luWV0gPSB0aGlzLiNnZXRNYXJnaW5Db21wb25lbnRzKCk7XG4gICAgY29uc3QgZGlmZk1hcmdpblggPSBuZXdNYXJnaW5YIC0gb2xkTWFyZ2luWDtcbiAgICBjb25zdCBkaWZmTWFyZ2luWSA9IG5ld01hcmdpblkgLSBvbGRNYXJnaW5ZO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGJib3hbMF0gLT0gZGlmZk1hcmdpblg7XG4gICAgYmJveFsxXSAtPSBkaWZmTWFyZ2luWTtcbiAgICBiYm94WzJdICs9IDIgKiBkaWZmTWFyZ2luWDtcbiAgICBiYm94WzNdICs9IDIgKiBkaWZmTWFyZ2luWTtcbiAgICByZXR1cm4gYmJveDtcbiAgfVxuICB1cGRhdGVSb3RhdGlvbihyb3RhdGlvbikge1xuICAgIHRoaXMuI2N1cnJlbnRSb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0IHZpZXdCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Jib3gubWFwKE91dGxpbmUuc3ZnUm91bmQpLmpvaW4oXCIgXCIpO1xuICB9XG4gIGdldCBkZWZhdWx0UHJvcGVydGllcygpIHtcbiAgICBjb25zdCBbeCwgeV0gPSB0aGlzLiNiYm94O1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQoeCl9ICR7T3V0bGluZS5zdmdSb3VuZCh5KX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgcm90YXRpb25UcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgWywsIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jYmJveDtcbiAgICBsZXQgYSA9IDAsXG4gICAgICBiID0gMCxcbiAgICAgIGMgPSAwLFxuICAgICAgZCA9IDAsXG4gICAgICBlID0gMCxcbiAgICAgIGYgPSAwO1xuICAgIHN3aXRjaCAodGhpcy4jY3VycmVudFJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBiID0gaGVpZ2h0IC8gd2lkdGg7XG4gICAgICAgIGMgPSAtd2lkdGggLyBoZWlnaHQ7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgYSA9IC0xO1xuICAgICAgICBkID0gLTE7XG4gICAgICAgIGUgPSB3aWR0aDtcbiAgICAgICAgZiA9IGhlaWdodDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgYiA9IC1oZWlnaHQgLyB3aWR0aDtcbiAgICAgICAgYyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgICAgICBmID0gaGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gYG1hdHJpeCgke2F9ICR7Yn0gJHtjfSAke2R9ICR7T3V0bGluZS5zdmdSb3VuZChlKX0gJHtPdXRsaW5lLnN2Z1JvdW5kKGYpfSlgO1xuICB9XG4gIGdldFBhdGhSZXNpemluZ1NWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IHRoaXMuI2Jib3g7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKG5ld1gpfSAke091dGxpbmUuc3ZnUm91bmQobmV3WSl9YCxcbiAgICAgICAgICB0cmFuc2Zvcm06IGAke3RoaXMucm90YXRpb25UcmFuc2Zvcm19IHRyYW5zbGF0ZSgke3R4fSAke3R5fSlgXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHMxeCA9IChuZXdXaWR0aCAtIDIgKiBtYXJnaW5YKSAvICh3aWR0aCAtIDIgKiBtYXJnaW5YKTtcbiAgICBjb25zdCBzMXkgPSAobmV3SGVpZ2h0IC0gMiAqIG1hcmdpblkpIC8gKGhlaWdodCAtIDIgKiBtYXJnaW5ZKTtcbiAgICBjb25zdCBzMnggPSB3aWR0aCAvIG5ld1dpZHRoO1xuICAgIGNvbnN0IHMyeSA9IGhlaWdodCAvIG5ld0hlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICBcInRyYW5zZm9ybS1vcmlnaW5cIjogYCR7T3V0bGluZS5zdmdSb3VuZCh4KX0gJHtPdXRsaW5lLnN2Z1JvdW5kKHkpfWAsXG4gICAgICAgIHRyYW5zZm9ybTogYCR7dGhpcy5yb3RhdGlvblRyYW5zZm9ybX0gc2NhbGUoJHtzMnh9ICR7czJ5fSkgYCArIGB0cmFuc2xhdGUoJHtPdXRsaW5lLnN2Z1JvdW5kKG1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQobWFyZ2luWSl9KSBzY2FsZSgke3MxeH0gJHtzMXl9KSBgICsgYHRyYW5zbGF0ZSgke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblgpfSAke091dGxpbmUuc3ZnUm91bmQoLW1hcmdpblkpfSlgXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXRQYXRoUmVzaXplZFNWR1Byb3BlcnRpZXMoW25ld1gsIG5ld1ksIG5ld1dpZHRoLCBuZXdIZWlnaHRdKSB7XG4gICAgY29uc3QgW21hcmdpblgsIG1hcmdpblldID0gdGhpcy4jZ2V0TWFyZ2luQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLiNiYm94O1xuICAgIGNvbnN0IFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSA9IGJib3g7XG4gICAgYmJveFswXSA9IG5ld1g7XG4gICAgYmJveFsxXSA9IG5ld1k7XG4gICAgYmJveFsyXSA9IG5ld1dpZHRoO1xuICAgIGJib3hbM10gPSBuZXdIZWlnaHQ7XG4gICAgaWYgKE1hdGguYWJzKHdpZHRoIC0gbWFyZ2luWCkgPD0gT3V0bGluZS5QUkVDSVNJT04gfHwgTWF0aC5hYnMoaGVpZ2h0IC0gbWFyZ2luWSkgPD0gT3V0bGluZS5QUkVDSVNJT04pIHtcbiAgICAgIGNvbnN0IHR4ID0gbmV3WCArIG5ld1dpZHRoIC8gMiAtICh4ICsgd2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHR5ID0gbmV3WSArIG5ld0hlaWdodCAvIDIgLSAoeSArIGhlaWdodCAvIDIpO1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl90cmFuc2xhdGUobGluZSwgdHgsIHR5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKHBvaW50cywgdHgsIHR5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9vdDoge1xuICAgICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgICB9LFxuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5yb3RhdGlvblRyYW5zZm9ybSB8fCBudWxsLFxuICAgICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgczF4ID0gKG5ld1dpZHRoIC0gMiAqIG1hcmdpblgpIC8gKHdpZHRoIC0gMiAqIG1hcmdpblgpO1xuICAgIGNvbnN0IHMxeSA9IChuZXdIZWlnaHQgLSAyICogbWFyZ2luWSkgLyAoaGVpZ2h0IC0gMiAqIG1hcmdpblkpO1xuICAgIGNvbnN0IHR4ID0gLXMxeCAqICh4ICsgbWFyZ2luWCkgKyBuZXdYICsgbWFyZ2luWDtcbiAgICBjb25zdCB0eSA9IC1zMXkgKiAoeSArIG1hcmdpblkpICsgbmV3WSArIG1hcmdpblk7XG4gICAgaWYgKHMxeCAhPT0gMSB8fCBzMXkgIT09IDEgfHwgdHggIT09IDAgfHwgdHkgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShsaW5lLCB0eCwgdHksIHMxeCwgczF5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgczF4LCBzMXksIHBvaW50cyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gLFxuICAgICAgICB0cmFuc2Zvcm06IHRoaXMucm90YXRpb25UcmFuc2Zvcm0gfHwgbnVsbCxcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZ2V0UGF0aFRyYW5zbGF0ZWRTVkdQcm9wZXJ0aWVzKFtuZXdYLCBuZXdZXSwgcGFyZW50RGltZW5zaW9ucykge1xuICAgIGNvbnN0IFtuZXdQYXJlbnRXaWR0aCwgbmV3UGFyZW50SGVpZ2h0XSA9IHBhcmVudERpbWVuc2lvbnM7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgY29uc3QgdHggPSBuZXdYIC0gYmJveFswXTtcbiAgICBjb25zdCB0eSA9IG5ld1kgLSBiYm94WzFdO1xuICAgIGlmICh0aGlzLiNwYXJlbnRXaWR0aCA9PT0gbmV3UGFyZW50V2lkdGggJiYgdGhpcy4jcGFyZW50SGVpZ2h0ID09PSBuZXdQYXJlbnRIZWlnaHQpIHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBwb2ludHNcbiAgICAgIH0gb2YgdGhpcy4jbGluZXMpIHtcbiAgICAgICAgT3V0bGluZS5fdHJhbnNsYXRlKGxpbmUsIHR4LCB0eSwgbGluZSk7XG4gICAgICAgIE91dGxpbmUuX3RyYW5zbGF0ZShwb2ludHMsIHR4LCB0eSwgcG9pbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3ggPSB0aGlzLiNwYXJlbnRXaWR0aCAvIG5ld1BhcmVudFdpZHRoO1xuICAgICAgY29uc3Qgc3kgPSB0aGlzLiNwYXJlbnRIZWlnaHQgLyBuZXdQYXJlbnRIZWlnaHQ7XG4gICAgICB0aGlzLiNwYXJlbnRXaWR0aCA9IG5ld1BhcmVudFdpZHRoO1xuICAgICAgdGhpcy4jcGFyZW50SGVpZ2h0ID0gbmV3UGFyZW50SGVpZ2h0O1xuICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSBvZiB0aGlzLiNsaW5lcykge1xuICAgICAgICBPdXRsaW5lLl9yZXNjYWxlKGxpbmUsIHR4LCB0eSwgc3gsIHN5LCBsaW5lKTtcbiAgICAgICAgT3V0bGluZS5fcmVzY2FsZShwb2ludHMsIHR4LCB0eSwgc3gsIHN5LCBwb2ludHMpO1xuICAgICAgfVxuICAgICAgYmJveFsyXSAqPSBzeDtcbiAgICAgIGJib3hbM10gKj0gc3k7XG4gICAgfVxuICAgIGJib3hbMF0gPSBuZXdYO1xuICAgIGJib3hbMV0gPSBuZXdZO1xuICAgIHJldHVybiB7XG4gICAgICByb290OiB7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveFxuICAgICAgfSxcbiAgICAgIHBhdGg6IHtcbiAgICAgICAgZDogdGhpcy50b1NWR1BhdGgoKSxcbiAgICAgICAgXCJ0cmFuc2Zvcm0tb3JpZ2luXCI6IGAke091dGxpbmUuc3ZnUm91bmQobmV3WCl9ICR7T3V0bGluZS5zdmdSb3VuZChuZXdZKX1gXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgZGVmYXVsdFNWR1Byb3BlcnRpZXMoKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuI2Jib3g7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3Q6IHtcbiAgICAgICAgdmlld0JveDogdGhpcy52aWV3Qm94XG4gICAgICB9LFxuICAgICAgcm9vdENsYXNzOiB7XG4gICAgICAgIGRyYXc6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiB7XG4gICAgICAgIGQ6IHRoaXMudG9TVkdQYXRoKCksXG4gICAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBgJHtPdXRsaW5lLnN2Z1JvdW5kKGJib3hbMF0pfSAke091dGxpbmUuc3ZnUm91bmQoYmJveFsxXSl9YCxcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLnJvdGF0aW9uVHJhbnNmb3JtIHx8IG51bGxcbiAgICAgIH0sXG4gICAgICBiYm94XG4gICAgfTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvaW5rLmpzXG5cblxuXG5cblxuXG5jbGFzcyBJbmtEcmF3aW5nT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fdmlld1BhcmFtZXRlcnMgPSB2aWV3ZXJQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICBzdHJva2U6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS1vcGFjaXR5XCI6IDEsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAxLFxuICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICBcInN0cm9rZS1taXRlcmxpbWl0XCI6IDEwXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU1ZHUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PT0gXCJzdHJva2Utd2lkdGhcIikge1xuICAgICAgdmFsdWUgPz89IHRoaXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB2YWx1ZSAqPSB0aGlzLl92aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gICAgfVxuICAgIHN1cGVyLnVwZGF0ZVNWR1Byb3BlcnR5KG5hbWUsIHZhbHVlKTtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gIHN0YXRpYyBfdHlwZSA9IFwiaW5rXCI7XG4gIHN0YXRpYyBfZWRpdG9yVHlwZSA9IEFubm90YXRpb25FZGl0b3JUeXBlLklOSztcbiAgc3RhdGljIF9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBudWxsO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcImlua0VkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy5fd2lsbEtlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3ItaW5rLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG5ldyBJbmtEcmF3aW5nT3B0aW9ucyh1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMpO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0RHJhd2luZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGNsb25lID0gdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLmNsb25lKCk7XG4gICAgY2xvbmUudXBkYXRlUHJvcGVydGllcyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0TXVsdGlwbGVEcmF3aW5ncygpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKFtbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgXCJzdHJva2Utd2lkdGhcIl0sIFtBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1IsIFwic3Ryb2tlXCJdLCBbQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIFwic3Ryb2tlLW9wYWNpdHlcIl1dKSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZURyYXdlckluc3RhbmNlKHgsIHksIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQsIHJvdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBJbmtEcmF3T3V0bGluZXIoeCwgeSwgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCwgcm90YXRpb24sIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplRHJhdyhwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpIHtcbiAgICByZXR1cm4gSW5rRHJhd091dGxpbmUuZGVzZXJpYWxpemUocGFnZVgsIHBhZ2VZLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIGlubmVyTWFyZ2luLCBkYXRhKTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBsZXQgaW5pdGlhbERhdGEgPSBudWxsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSW5rQW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGlua0xpc3RzLFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgb3BhY2l0eSxcbiAgICAgICAgICBib3JkZXJTdHlsZToge1xuICAgICAgICAgICAgcmF3V2lkdGg6IHRoaWNrbmVzc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpbml0aWFsRGF0YSA9IGRhdGEgPSB7XG4gICAgICAgIGFubm90YXRpb25UeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkssXG4gICAgICAgIGNvbG9yOiBBcnJheS5mcm9tKGNvbG9yKSxcbiAgICAgICAgdGhpY2tuZXNzLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwYXRoczoge1xuICAgICAgICAgIHBvaW50czogaW5rTGlzdHNcbiAgICAgICAgfSxcbiAgICAgICAgYm94ZXM6IG51bGwsXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3Q6IHJlY3Quc2xpY2UoMCksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkOiBpZCxcbiAgICAgICAgaWQsXG4gICAgICAgIGRlbGV0ZWQ6IGZhbHNlLFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgZWRpdG9yLl9pbml0aWFsRGF0YSA9IGluaXRpYWxEYXRhO1xuICAgIGlmIChkYXRhLmNvbW1lbnQpIHtcbiAgICAgIGVkaXRvci5zZXRDb21tZW50RGF0YShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgdGhpcy5fY29sb3JQaWNrZXIgfHw9IG5ldyBCYXNpY0NvbG9yUGlja2VyKHRoaXMpO1xuICAgIHJldHVybiBbW1wiY29sb3JQaWNrZXJcIiwgdGhpcy5fY29sb3JQaWNrZXJdXTtcbiAgfVxuICBnZXQgY29sb3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfQ09MT1I7XG4gIH1cbiAgZ2V0IGNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmF3aW5nT3B0aW9ucy5zdHJva2U7XG4gIH1cbiAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdpbmdPcHRpb25zW1wic3Ryb2tlLW9wYWNpdHlcIl07XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIub25TY2FsZUNoYW5naW5nKCk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdJZCxcbiAgICAgIF9kcmF3aW5nT3B0aW9ucyxcbiAgICAgIHBhcmVudFxuICAgIH0gPSB0aGlzO1xuICAgIF9kcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXMoX2RyYXdJZCwgX2RyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBzdGF0aWMgb25TY2FsZUNoYW5naW5nV2hlbkRyYXdpbmcoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY3VycmVudFBhcmVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5vblNjYWxlQ2hhbmdpbmdXaGVuRHJhd2luZygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3aW5nT3B0aW9ucy51cGRhdGVTVkdQcm9wZXJ0eShcInN0cm9rZS13aWR0aFwiKTtcbiAgICBwYXJlbnQuZHJhd0xheWVyLnVwZGF0ZVByb3BlcnRpZXModGhpcy5fY3VycmVudERyYXdJZCwgdGhpcy5fZGVmYXVsdERyYXdpbmdPcHRpb25zLnRvU1ZHUHJvcGVydGllcygpKTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgY29sb3IsXG4gICAgdGhpY2tuZXNzLFxuICAgIG9wYWNpdHlcbiAgfSkge1xuICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gSW5rRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucyh7XG4gICAgICBzdHJva2U6IFV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKSxcbiAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzcyxcbiAgICAgIFwic3Ryb2tlLW9wYWNpdHlcIjogb3BhY2l0eVxuICAgIH0pO1xuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbGluZXMsXG4gICAgICBwb2ludHNcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGlzRm9yQ29weWluZyk7XG4gICAgY29uc3Qge1xuICAgICAgX2RyYXdpbmdPcHRpb25zOiB7XG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgXCJzdHJva2Utb3BhY2l0eVwiOiBvcGFjaXR5LFxuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgY29sb3I6IEFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHN0cm9rZSksXG4gICAgICBvcGFjaXR5LFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgcGF0aHM6IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiAhdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gICNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3MsXG4gICAgICBvcGFjaXR5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuX2luaXRpYWxEYXRhO1xuICAgIHJldHVybiB0aGlzLmhhc0VkaXRlZENvbW1lbnQgfHwgdGhpcy5faGFzQmVlbk1vdmVkIHx8IHRoaXMuX2hhc0JlZW5SZXNpemVkIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQudGhpY2tuZXNzICE9PSB0aGlja25lc3MgfHwgc2VyaWFsaXplZC5vcGFjaXR5ICE9PSBvcGFjaXR5IHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50cyxcbiAgICAgIHJlY3RcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVEcmF3KGZhbHNlKTtcbiAgICBhbm5vdGF0aW9uLnVwZGF0ZUVkaXRlZCh7XG4gICAgICByZWN0LFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLl9kcmF3aW5nT3B0aW9uc1tcInN0cm9rZS13aWR0aFwiXSxcbiAgICAgIHBvaW50cyxcbiAgICAgIHBvcHVwOiB0aGlzLmNvbW1lbnRcbiAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3IvZHJhd2Vycy9jb250b3VyLmpzXG5cbmNsYXNzIENvbnRvdXJEcmF3T3V0bGluZSBleHRlbmRzIElua0RyYXdPdXRsaW5lIHtcbiAgdG9TVkdQYXRoKCkge1xuICAgIGxldCBwYXRoID0gc3VwZXIudG9TVkdQYXRoKCk7XG4gICAgaWYgKCFwYXRoLmVuZHNXaXRoKFwiWlwiKSkge1xuICAgICAgcGF0aCArPSBcIlpcIjtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuOy8vIC4vc3JjL2Rpc3BsYXkvZWRpdG9yL2RyYXdlcnMvc2lnbmF0dXJlZHJhdy5qc1xuXG5cblxuXG5jb25zdCBCQVNFX0hFQURFUl9MRU5HVEggPSA4O1xuY29uc3QgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSID0gMztcbmNsYXNzIFNpZ25hdHVyZUV4dHJhY3RvciB7XG4gIHN0YXRpYyAjUEFSQU1FVEVSUyA9IHtcbiAgICBtYXhEaW06IDUxMixcbiAgICBzaWdtYVNGYWN0b3I6IDAuMDIsXG4gICAgc2lnbWFSOiAyNSxcbiAgICBrZXJuZWxTaXplOiAxNlxuICB9O1xuICBzdGF0aWMgI25laWdoYm9ySW5kZXhUb0lkKGkwLCBqMCwgaSwgaikge1xuICAgIGkgLT0gaTA7XG4gICAgaiAtPSBqMDtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0dXJuIGogPiAwID8gMCA6IDQ7XG4gICAgfVxuICAgIGlmIChpID09PSAxKSB7XG4gICAgICByZXR1cm4gaiArIDY7XG4gICAgfVxuICAgIHJldHVybiAyIC0gajtcbiAgfVxuICBzdGF0aWMgI25laWdoYm9ySWRUb0luZGV4ID0gbmV3IEludDMyQXJyYXkoWzAsIDEsIC0xLCAxLCAtMSwgMCwgLTEsIC0xLCAwLCAtMSwgMSwgLTEsIDEsIDAsIDEsIDFdKTtcbiAgc3RhdGljICNjbG9ja3dpc2VOb25aZXJvKGJ1Ziwgd2lkdGgsIGkwLCBqMCwgaSwgaiwgb2Zmc2V0KSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLiNuZWlnaGJvckluZGV4VG9JZChpMCwgajAsIGksIGopO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjb25zdCBrayA9ICgtayArIGlkIC0gb2Zmc2V0ICsgMTYpICUgODtcbiAgICAgIGNvbnN0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBra107XG4gICAgICBjb25zdCBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgIGlmIChidWZbKGkwICsgc2hpZnRJKSAqIHdpZHRoICsgKGowICsgc2hpZnRKKV0gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGtrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc3RhdGljICNjb3VudGVyQ2xvY2t3aXNlTm9uWmVybyhidWYsIHdpZHRoLCBpMCwgajAsIGksIGosIG9mZnNldCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy4jbmVpZ2hib3JJbmRleFRvSWQoaTAsIGowLCBpLCBqKTtcbiAgICBmb3IgKGxldCBrID0gMDsgayA8IDg7IGsrKykge1xuICAgICAgY29uc3Qga2sgPSAoayArIGlkICsgb2Zmc2V0ICsgMTYpICUgODtcbiAgICAgIGNvbnN0IHNoaWZ0SSA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBra107XG4gICAgICBjb25zdCBzaGlmdEogPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2sgKyAxXTtcbiAgICAgIGlmIChidWZbKGkwICsgc2hpZnRJKSAqIHdpZHRoICsgKGowICsgc2hpZnRKKV0gIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGtrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgc3RhdGljICNmaW5kQ29udG91cnMoYnVmLCB3aWR0aCwgaGVpZ2h0LCB0aHJlc2hvbGQpIHtcbiAgICBjb25zdCBOID0gYnVmLmxlbmd0aDtcbiAgICBjb25zdCB0eXBlcyA9IG5ldyBJbnQzMkFycmF5KE4pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0eXBlc1tpXSA9IGJ1ZltpXSA8PSB0aHJlc2hvbGQgPyAxIDogMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBoZWlnaHQgLSAxOyBpKyspIHtcbiAgICAgIHR5cGVzW2kgKiB3aWR0aF0gPSB0eXBlc1tpICogd2lkdGggKyB3aWR0aCAtIDFdID0gMDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgICB0eXBlc1tpXSA9IHR5cGVzW3dpZHRoICogaGVpZ2h0IC0gMSAtIGldID0gMDtcbiAgICB9XG4gICAgbGV0IG5iZCA9IDE7XG4gICAgbGV0IGxuYmQ7XG4gICAgY29uc3QgY29udG91cnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGhlaWdodCAtIDE7IGkrKykge1xuICAgICAgbG5iZCA9IDE7XG4gICAgICBmb3IgKGxldCBqID0gMTsgaiA8IHdpZHRoIC0gMTsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlqID0gaSAqIHdpZHRoICsgajtcbiAgICAgICAgY29uc3QgcGl4ID0gdHlwZXNbaWpdO1xuICAgICAgICBpZiAocGl4ID09PSAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkyID0gaTtcbiAgICAgICAgbGV0IGoyID0gajtcbiAgICAgICAgaWYgKHBpeCA9PT0gMSAmJiB0eXBlc1tpaiAtIDFdID09PSAwKSB7XG4gICAgICAgICAgbmJkICs9IDE7XG4gICAgICAgICAgajIgLT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChwaXggPj0gMSAmJiB0eXBlc1tpaiArIDFdID09PSAwKSB7XG4gICAgICAgICAgbmJkICs9IDE7XG4gICAgICAgICAgajIgKz0gMTtcbiAgICAgICAgICBpZiAocGl4ID4gMSkge1xuICAgICAgICAgICAgbG5iZCA9IHBpeDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHBpeCAhPT0gMSkge1xuICAgICAgICAgICAgbG5iZCA9IE1hdGguYWJzKHBpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtqLCBpXTtcbiAgICAgICAgY29uc3QgaXNIb2xlID0gajIgPT09IGogKyAxO1xuICAgICAgICBjb25zdCBjb250b3VyID0ge1xuICAgICAgICAgIGlzSG9sZSxcbiAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgaWQ6IG5iZCxcbiAgICAgICAgICBwYXJlbnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29udG91cnMucHVzaChjb250b3VyKTtcbiAgICAgICAgbGV0IGNvbnRvdXIwO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29udG91cnMpIHtcbiAgICAgICAgICBpZiAoYy5pZCA9PT0gbG5iZCkge1xuICAgICAgICAgICAgY29udG91cjAgPSBjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29udG91cjApIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGxuYmQgOiAwO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRvdXIwLmlzSG9sZSkge1xuICAgICAgICAgIGNvbnRvdXIucGFyZW50ID0gaXNIb2xlID8gY29udG91cjAucGFyZW50IDogbG5iZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250b3VyLnBhcmVudCA9IGlzSG9sZSA/IGxuYmQgOiBjb250b3VyMC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgayA9IHRoaXMuI2Nsb2Nrd2lzZU5vblplcm8odHlwZXMsIHdpZHRoLCBpLCBqLCBpMiwgajIsIDApO1xuICAgICAgICBpZiAoayA9PT0gLTEpIHtcbiAgICAgICAgICB0eXBlc1tpal0gPSAtbmJkO1xuICAgICAgICAgIGlmICh0eXBlc1tpal0gIT09IDEpIHtcbiAgICAgICAgICAgIGxuYmQgPSBNYXRoLmFicyh0eXBlc1tpal0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hpZnRJID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGtdO1xuICAgICAgICBsZXQgc2hpZnRKID0gdGhpcy4jbmVpZ2hib3JJZFRvSW5kZXhbMiAqIGsgKyAxXTtcbiAgICAgICAgY29uc3QgaTEgPSBpICsgc2hpZnRJO1xuICAgICAgICBjb25zdCBqMSA9IGogKyBzaGlmdEo7XG4gICAgICAgIGkyID0gaTE7XG4gICAgICAgIGoyID0gajE7XG4gICAgICAgIGxldCBpMyA9IGk7XG4gICAgICAgIGxldCBqMyA9IGo7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3Qga2sgPSB0aGlzLiNjb3VudGVyQ2xvY2t3aXNlTm9uWmVybyh0eXBlcywgd2lkdGgsIGkzLCBqMywgaTIsIGoyLCAxKTtcbiAgICAgICAgICBzaGlmdEkgPSB0aGlzLiNuZWlnaGJvcklkVG9JbmRleFsyICoga2tdO1xuICAgICAgICAgIHNoaWZ0SiA9IHRoaXMuI25laWdoYm9ySWRUb0luZGV4WzIgKiBrayArIDFdO1xuICAgICAgICAgIGNvbnN0IGk0ID0gaTMgKyBzaGlmdEk7XG4gICAgICAgICAgY29uc3QgajQgPSBqMyArIHNoaWZ0SjtcbiAgICAgICAgICBwb2ludHMucHVzaChqNCwgaTQpO1xuICAgICAgICAgIGNvbnN0IGlqMyA9IGkzICogd2lkdGggKyBqMztcbiAgICAgICAgICBpZiAodHlwZXNbaWozICsgMV0gPT09IDApIHtcbiAgICAgICAgICAgIHR5cGVzW2lqM10gPSAtbmJkO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZXNbaWozXSA9PT0gMSkge1xuICAgICAgICAgICAgdHlwZXNbaWozXSA9IG5iZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGk0ID09PSBpICYmIGo0ID09PSBqICYmIGkzID09PSBpMSAmJiBqMyA9PT0gajEpIHtcbiAgICAgICAgICAgIGlmICh0eXBlc1tpal0gIT09IDEpIHtcbiAgICAgICAgICAgICAgbG5iZCA9IE1hdGguYWJzKHR5cGVzW2lqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaTIgPSBpMztcbiAgICAgICAgICAgIGoyID0gajM7XG4gICAgICAgICAgICBpMyA9IGk0O1xuICAgICAgICAgICAgajMgPSBqNDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRvdXJzO1xuICB9XG4gIHN0YXRpYyAjZG91Z2xhc1BldWNrZXJIZWxwZXIocG9pbnRzLCBzdGFydCwgZW5kLCBvdXRwdXQpIHtcbiAgICBpZiAoZW5kIC0gc3RhcnQgPD0gNCkge1xuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kIC0gMjsgaSArPSAyKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF4ID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBheSA9IHBvaW50c1tzdGFydCArIDFdO1xuICAgIGNvbnN0IGFieCA9IHBvaW50c1tlbmQgLSA0XSAtIGF4O1xuICAgIGNvbnN0IGFieSA9IHBvaW50c1tlbmQgLSAzXSAtIGF5O1xuICAgIGNvbnN0IGRpc3QgPSBNYXRoLmh5cG90KGFieCwgYWJ5KTtcbiAgICBjb25zdCBuYWJ4ID0gYWJ4IC8gZGlzdDtcbiAgICBjb25zdCBuYWJ5ID0gYWJ5IC8gZGlzdDtcbiAgICBjb25zdCBhYSA9IG5hYnggKiBheSAtIG5hYnkgKiBheDtcbiAgICBjb25zdCBtID0gYWJ5IC8gYWJ4O1xuICAgIGNvbnN0IGludlMgPSAxIC8gZGlzdDtcbiAgICBjb25zdCBwaGkgPSBNYXRoLmF0YW4obSk7XG4gICAgY29uc3QgY29zUGhpID0gTWF0aC5jb3MocGhpKTtcbiAgICBjb25zdCBzaW5QaGkgPSBNYXRoLnNpbihwaGkpO1xuICAgIGNvbnN0IHRtYXggPSBpbnZTICogKE1hdGguYWJzKGNvc1BoaSkgKyBNYXRoLmFicyhzaW5QaGkpKTtcbiAgICBjb25zdCBwb2x5ID0gaW52UyAqICgxIC0gdG1heCArIHRtYXggKiogMik7XG4gICAgY29uc3QgcGFydGlhbFBoaSA9IE1hdGgubWF4KE1hdGguYXRhbihNYXRoLmFicyhzaW5QaGkgKyBjb3NQaGkpICogcG9seSksIE1hdGguYXRhbihNYXRoLmFicyhzaW5QaGkgLSBjb3NQaGkpICogcG9seSkpO1xuICAgIGxldCBkbWF4ID0gMDtcbiAgICBsZXQgaW5kZXggPSBzdGFydDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAyOyBpIDwgZW5kIC0gMjsgaSArPSAyKSB7XG4gICAgICBjb25zdCBkID0gTWF0aC5hYnMoYWEgLSBuYWJ4ICogcG9pbnRzW2kgKyAxXSArIG5hYnkgKiBwb2ludHNbaV0pO1xuICAgICAgaWYgKGQgPiBkbWF4KSB7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgZG1heCA9IGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkbWF4ID4gKGRpc3QgKiBwYXJ0aWFsUGhpKSAqKiAyKSB7XG4gICAgICB0aGlzLiNkb3VnbGFzUGV1Y2tlckhlbHBlcihwb2ludHMsIHN0YXJ0LCBpbmRleCArIDIsIG91dHB1dCk7XG4gICAgICB0aGlzLiNkb3VnbGFzUGV1Y2tlckhlbHBlcihwb2ludHMsIGluZGV4LCBlbmQsIG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKGF4LCBheSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyAjZG91Z2xhc1BldWNrZXIocG9pbnRzKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB0aGlzLiNkb3VnbGFzUGV1Y2tlckhlbHBlcihwb2ludHMsIDAsIGxlbiwgb3V0cHV0KTtcbiAgICBvdXRwdXQucHVzaChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSk7XG4gICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPD0gNCA/IG51bGwgOiBvdXRwdXQ7XG4gIH1cbiAgc3RhdGljICNiaWxhdGVyYWxGaWx0ZXIoYnVmLCB3aWR0aCwgaGVpZ2h0LCBzaWdtYVMsIHNpZ21hUiwga2VybmVsU2l6ZSkge1xuICAgIGNvbnN0IGtlcm5lbCA9IG5ldyBGbG9hdDMyQXJyYXkoa2VybmVsU2l6ZSAqKiAyKTtcbiAgICBjb25zdCBzaWdtYVMyID0gLTIgKiBzaWdtYVMgKiogMjtcbiAgICBjb25zdCBoYWxmU2l6ZSA9IGtlcm5lbFNpemUgPj4gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xuICAgICAgY29uc3QgeCA9IChpIC0gaGFsZlNpemUpICoqIDI7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtlcm5lbFNpemU7IGorKykge1xuICAgICAgICBrZXJuZWxbaSAqIGtlcm5lbFNpemUgKyBqXSA9IE1hdGguZXhwKCh4ICsgKGogLSBoYWxmU2l6ZSkgKiogMikgLyBzaWdtYVMyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmFuZ2VWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KDI1Nik7XG4gICAgY29uc3Qgc2lnbWFSMiA9IC0yICogc2lnbWFSICoqIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgcmFuZ2VWYWx1ZXNbaV0gPSBNYXRoLmV4cChpICoqIDIgLyBzaWdtYVIyKTtcbiAgICB9XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoTik7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gbmV3IFVpbnQzMkFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IGlqID0gaSAqIHdpZHRoICsgajtcbiAgICAgICAgY29uc3QgY2VudGVyID0gYnVmW2lqXTtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGxldCBub3JtID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBrZXJuZWxTaXplOyBrKyspIHtcbiAgICAgICAgICBjb25zdCB5ID0gaSArIGsgLSBoYWxmU2l6ZTtcbiAgICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IGtlcm5lbFNpemU7IGwrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IGogKyBsIC0gaGFsZlNpemU7XG4gICAgICAgICAgICBpZiAoeCA8IDAgfHwgeCA+PSB3aWR0aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5laWdoYm91ciA9IGJ1Zlt5ICogd2lkdGggKyB4XTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBrZXJuZWxbayAqIGtlcm5lbFNpemUgKyBsXSAqIHJhbmdlVmFsdWVzW01hdGguYWJzKG5laWdoYm91ciAtIGNlbnRlcildO1xuICAgICAgICAgICAgc3VtICs9IG5laWdoYm91ciAqIHc7XG4gICAgICAgICAgICBub3JtICs9IHc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBpeCA9IG91dFtpal0gPSBNYXRoLnJvdW5kKHN1bSAvIG5vcm0pO1xuICAgICAgICBoaXN0b2dyYW1bcGl4XSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW291dCwgaGlzdG9ncmFtXTtcbiAgfVxuICBzdGF0aWMgI2dldEhpc3RvZ3JhbShidWYpIHtcbiAgICBjb25zdCBoaXN0b2dyYW0gPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBmb3IgKGNvbnN0IGcgb2YgYnVmKSB7XG4gICAgICBoaXN0b2dyYW1bZ10rKztcbiAgICB9XG4gICAgcmV0dXJuIGhpc3RvZ3JhbTtcbiAgfVxuICBzdGF0aWMgI3RvVWludDgoYnVmKSB7XG4gICAgY29uc3QgTiA9IGJ1Zi5sZW5ndGg7XG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KE4gPj4gMik7XG4gICAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3V0Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHBpeCA9IG91dFtpXSA9IGJ1ZltpIDw8IDJdO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBwaXgpO1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBwaXgpO1xuICAgIH1cbiAgICBjb25zdCByYXRpbyA9IDI1NSAvIChtYXggLSBtaW4pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IG91dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSAob3V0W2ldIC0gbWluKSAqIHJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHN0YXRpYyAjZ3Vlc3NUaHJlc2hvbGQoaGlzdG9ncmFtKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IE0gPSAtSW5maW5pdHk7XG4gICAgbGV0IEwgPSAtSW5maW5pdHk7XG4gICAgY29uc3QgbWluID0gaGlzdG9ncmFtLmZpbmRJbmRleCh2ID0+IHYgIT09IDApO1xuICAgIGxldCBwb3MgPSBtaW47XG4gICAgbGV0IHNwb3MgPSBtaW47XG4gICAgZm9yIChpID0gbWluOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIGNvbnN0IHYgPSBoaXN0b2dyYW1baV07XG4gICAgICBpZiAodiA+IE0pIHtcbiAgICAgICAgaWYgKGkgLSBwb3MgPiBMKSB7XG4gICAgICAgICAgTCA9IGkgLSBwb3M7XG4gICAgICAgICAgc3BvcyA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIE0gPSB2O1xuICAgICAgICBwb3MgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBzcG9zIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChoaXN0b2dyYW1baV0gPiBoaXN0b2dyYW1baSArIDFdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBzdGF0aWMgI2dldEdyYXlQaXhlbHMoYml0bWFwKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxCaXRtYXAgPSBiaXRtYXA7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gYml0bWFwO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heERpbVxuICAgIH0gPSB0aGlzLiNQQVJBTUVURVJTO1xuICAgIGxldCBuZXdXaWR0aCA9IHdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHdpZHRoID4gbWF4RGltIHx8IGhlaWdodCA+IG1heERpbSkge1xuICAgICAgbGV0IHByZXZXaWR0aCA9IHdpZHRoO1xuICAgICAgbGV0IHByZXZIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICBsZXQgc3RlcHMgPSBNYXRoLmxvZzIoTWF0aC5tYXgod2lkdGgsIGhlaWdodCkgLyBtYXhEaW0pO1xuICAgICAgY29uc3QgaXN0ZXBzID0gTWF0aC5mbG9vcihzdGVwcyk7XG4gICAgICBzdGVwcyA9IHN0ZXBzID09PSBpc3RlcHMgPyBpc3RlcHMgLSAxIDogaXN0ZXBzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5jZWlsKHByZXZXaWR0aCAvIDIpO1xuICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLmNlaWwocHJldkhlaWdodCAvIDIpO1xuICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgIHByZXZIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICAgIGlmIChiaXRtYXAgIT09IG9yaWdpbmFsQml0bWFwKSB7XG4gICAgICAgICAgYml0bWFwLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0bWFwID0gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihtYXhEaW0gLyBuZXdXaWR0aCwgbWF4RGltIC8gbmV3SGVpZ2h0KTtcbiAgICAgIG5ld1dpZHRoID0gTWF0aC5yb3VuZChuZXdXaWR0aCAqIHJhdGlvKTtcbiAgICAgIG5ld0hlaWdodCA9IE1hdGgucm91bmQobmV3SGVpZ2h0ICogcmF0aW8pO1xuICAgIH1cbiAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgd2lsbFJlYWRGcmVxdWVudGx5OiB0cnVlXG4gICAgfSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY3R4LmZpbHRlciA9IFwiZ3JheXNjYWxlKDEpXCI7XG4gICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIGJpdG1hcC53aWR0aCwgYml0bWFwLmhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgY29uc3QgZ3JheUltYWdlID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KS5kYXRhO1xuICAgIGNvbnN0IHVpbnQ4QnVmID0gdGhpcy4jdG9VaW50OChncmF5SW1hZ2UpO1xuICAgIHJldHVybiBbdWludDhCdWYsIG5ld1dpZHRoLCBuZXdIZWlnaHRdO1xuICB9XG4gIHN0YXRpYyBleHRyYWN0Q29udG91cnNGcm9tVGV4dCh0ZXh0LCB7XG4gICAgZm9udEZhbWlseSxcbiAgICBmb250U3R5bGUsXG4gICAgZm9udFdlaWdodFxuICB9LCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIHJvdGF0aW9uLCBpbm5lck1hcmdpbikge1xuICAgIGxldCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDEpO1xuICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IGZvbnRTaXplID0gMjAwO1xuICAgIGNvbnN0IGZvbnQgPSBjdHguZm9udCA9IGAke2ZvbnRTdHlsZX0gJHtmb250V2VpZ2h0fSAke2ZvbnRTaXplfXB4ICR7Zm9udEZhbWlseX1gO1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94TGVmdCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94UmlnaHQsXG4gICAgICBhY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIGFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIGZvbnRCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIGZvbnRCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBjdHgubWVhc3VyZVRleHQodGV4dCk7XG4gICAgY29uc3QgU0NBTEUgPSAxLjU7XG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSArIE1hdGguYWJzKGFjdHVhbEJvdW5kaW5nQm94UmlnaHQpIHx8IDAsIHdpZHRoKSAqIFNDQUxFKTtcbiAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5tYXgoTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQpICsgTWF0aC5hYnMoYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KSB8fCBmb250U2l6ZSwgTWF0aC5hYnMoZm9udEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKGZvbnRCb3VuZGluZ0JveERlc2NlbnQpIHx8IGZvbnRTaXplKSAqIFNDQUxFKTtcbiAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiwge1xuICAgICAgYWxwaGE6IHRydWUsXG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY3R4LmZpbHRlciA9IFwiZ3JheXNjYWxlKDEpXCI7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgICBjdHguZmlsbFRleHQodGV4dCwgY2FudmFzV2lkdGggKiAoU0NBTEUgLSAxKSAvIDIsIGNhbnZhc0hlaWdodCAqICgzIC0gU0NBTEUpIC8gMik7XG4gICAgY29uc3QgdWludDhCdWYgPSB0aGlzLiN0b1VpbnQ4KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCkuZGF0YSk7XG4gICAgY29uc3QgaGlzdG9ncmFtID0gdGhpcy4jZ2V0SGlzdG9ncmFtKHVpbnQ4QnVmKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLiNndWVzc1RocmVzaG9sZChoaXN0b2dyYW0pO1xuICAgIGNvbnN0IGNvbnRvdXJMaXN0ID0gdGhpcy4jZmluZENvbnRvdXJzKHVpbnQ4QnVmLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0LCB0aHJlc2hvbGQpO1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICAgIGxpbmVzOiB7XG4gICAgICAgIGN1cnZlczogY29udG91ckxpc3QsXG4gICAgICAgIHdpZHRoOiBjYW52YXNXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXNIZWlnaHRcbiAgICAgIH0sXG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcm90YXRpb24sXG4gICAgICBpbm5lck1hcmdpbixcbiAgICAgIG11c3RTbW9vdGg6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBwcm9jZXNzKGJpdG1hcCwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgaW5uZXJNYXJnaW4pIHtcbiAgICBjb25zdCBbdWludDhCdWYsIHdpZHRoLCBoZWlnaHRdID0gdGhpcy4jZ2V0R3JheVBpeGVscyhiaXRtYXApO1xuICAgIGNvbnN0IFtidWZmZXIsIGhpc3RvZ3JhbV0gPSB0aGlzLiNiaWxhdGVyYWxGaWx0ZXIodWludDhCdWYsIHdpZHRoLCBoZWlnaHQsIE1hdGguaHlwb3Qod2lkdGgsIGhlaWdodCkgKiB0aGlzLiNQQVJBTUVURVJTLnNpZ21hU0ZhY3RvciwgdGhpcy4jUEFSQU1FVEVSUy5zaWdtYVIsIHRoaXMuI1BBUkFNRVRFUlMua2VybmVsU2l6ZSk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy4jZ3Vlc3NUaHJlc2hvbGQoaGlzdG9ncmFtKTtcbiAgICBjb25zdCBjb250b3VyTGlzdCA9IHRoaXMuI2ZpbmRDb250b3VycyhidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHRocmVzaG9sZCk7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBjb250b3VyTGlzdCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHQsXG4gICAgICByb3RhdGlvbixcbiAgICAgIGlubmVyTWFyZ2luLFxuICAgICAgbXVzdFNtb290aDogdHJ1ZSxcbiAgICAgIGFyZUNvbnRvdXJzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIHByb2Nlc3NEcmF3bkxpbmVzKHtcbiAgICBsaW5lcyxcbiAgICBwYWdlV2lkdGgsXG4gICAgcGFnZUhlaWdodCxcbiAgICByb3RhdGlvbixcbiAgICBpbm5lck1hcmdpbixcbiAgICBtdXN0U21vb3RoLFxuICAgIGFyZUNvbnRvdXJzXG4gIH0pIHtcbiAgICBpZiAocm90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gW3BhZ2VIZWlnaHQsIHBhZ2VXaWR0aF07XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGN1cnZlcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGxpbmVzO1xuICAgIGNvbnN0IHRoaWNrbmVzcyA9IGxpbmVzLnRoaWNrbmVzcyA/PyAwO1xuICAgIGNvbnN0IGxpbmVzQW5kUG9pbnRzID0gW107XG4gICAgY29uc3QgcmF0aW8gPSBNYXRoLm1pbihwYWdlV2lkdGggLyB3aWR0aCwgcGFnZUhlaWdodCAvIGhlaWdodCk7XG4gICAgY29uc3QgeFNjYWxlID0gcmF0aW8gLyBwYWdlV2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gcmF0aW8gLyBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IG5ld0N1cnZlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgcG9pbnRzXG4gICAgfSBvZiBjdXJ2ZXMpIHtcbiAgICAgIGNvbnN0IHJlZHVjZWRQb2ludHMgPSBtdXN0U21vb3RoID8gdGhpcy4jZG91Z2xhc1BldWNrZXIocG9pbnRzKSA6IHBvaW50cztcbiAgICAgIGlmICghcmVkdWNlZFBvaW50cykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIG5ld0N1cnZlcy5wdXNoKHJlZHVjZWRQb2ludHMpO1xuICAgICAgY29uc3QgbGVuID0gcmVkdWNlZFBvaW50cy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdQb2ludHMgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgICBjb25zdCBsaW5lID0gbmV3IEZsb2F0MzJBcnJheSgzICogKGxlbiA9PT0gMiA/IDIgOiBsZW4gLSAyKSk7XG4gICAgICBsaW5lc0FuZFBvaW50cy5wdXNoKHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgcG9pbnRzOiBuZXdQb2ludHNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICBuZXdQb2ludHNbMF0gPSByZWR1Y2VkUG9pbnRzWzBdICogeFNjYWxlO1xuICAgICAgICBuZXdQb2ludHNbMV0gPSByZWR1Y2VkUG9pbnRzWzFdICogeVNjYWxlO1xuICAgICAgICBsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCBuZXdQb2ludHNbMF0sIG5ld1BvaW50c1sxXV0sIDApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBbeDEsIHkxLCB4MiwgeTJdID0gcmVkdWNlZFBvaW50cztcbiAgICAgIHgxICo9IHhTY2FsZTtcbiAgICAgIHkxICo9IHlTY2FsZTtcbiAgICAgIHgyICo9IHhTY2FsZTtcbiAgICAgIHkyICo9IHlTY2FsZTtcbiAgICAgIG5ld1BvaW50cy5zZXQoW3gxLCB5MSwgeDIsIHkyXSwgMCk7XG4gICAgICBsaW5lLnNldChbTmFOLCBOYU4sIE5hTiwgTmFOLCB4MSwgeTFdLCAwKTtcbiAgICAgIGZvciAobGV0IGkgPSA0OyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgeCA9IG5ld1BvaW50c1tpXSA9IHJlZHVjZWRQb2ludHNbaV0gKiB4U2NhbGU7XG4gICAgICAgIGNvbnN0IHkgPSBuZXdQb2ludHNbaSArIDFdID0gcmVkdWNlZFBvaW50c1tpICsgMV0gKiB5U2NhbGU7XG4gICAgICAgIGxpbmUuc2V0KE91dGxpbmUuY3JlYXRlQmV6aWVyUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSwgKGkgLSAyKSAqIDMpO1xuICAgICAgICBbeDEsIHkxLCB4MiwgeTJdID0gW3gyLCB5MiwgeCwgeV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaW5lc0FuZFBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvdXRsaW5lID0gYXJlQ29udG91cnMgPyBuZXcgQ29udG91ckRyYXdPdXRsaW5lKCkgOiBuZXcgSW5rRHJhd091dGxpbmUoKTtcbiAgICBvdXRsaW5lLmJ1aWxkKGxpbmVzQW5kUG9pbnRzLCBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQsIDEsIHJvdGF0aW9uLCBhcmVDb250b3VycyA/IDAgOiB0aGlja25lc3MsIGlubmVyTWFyZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3V0bGluZSxcbiAgICAgIG5ld0N1cnZlcyxcbiAgICAgIGFyZUNvbnRvdXJzLFxuICAgICAgdGhpY2tuZXNzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBjb21wcmVzc1NpZ25hdHVyZSh7XG4gICAgb3V0bGluZXMsXG4gICAgYXJlQ29udG91cnMsXG4gICAgdGhpY2tuZXNzLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9KSB7XG4gICAgbGV0IG1pbkRpZmYgPSBJbmZpbml0eTtcbiAgICBsZXQgbWF4RGlmZiA9IC1JbmZpbml0eTtcbiAgICBsZXQgb3V0bGluZXNMZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIG91dGxpbmVzKSB7XG4gICAgICBvdXRsaW5lc0xlbmd0aCArPSBwb2ludHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgZHggPSBwb2ludHNbaV0gLSBwb2ludHNbaSAtIDJdO1xuICAgICAgICBtaW5EaWZmID0gTWF0aC5taW4obWluRGlmZiwgZHgpO1xuICAgICAgICBtYXhEaWZmID0gTWF0aC5tYXgobWF4RGlmZiwgZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgYnVmZmVyVHlwZTtcbiAgICBpZiAobWluRGlmZiA+PSAtMTI4ICYmIG1heERpZmYgPD0gMTI3KSB7XG4gICAgICBidWZmZXJUeXBlID0gSW50OEFycmF5O1xuICAgIH0gZWxzZSBpZiAobWluRGlmZiA+PSAtMzI3NjggJiYgbWF4RGlmZiA8PSAzMjc2Nykge1xuICAgICAgYnVmZmVyVHlwZSA9IEludDE2QXJyYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlclR5cGUgPSBJbnQzMkFycmF5O1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBvdXRsaW5lcy5sZW5ndGg7XG4gICAgY29uc3QgaGVhZGVyTGVuZ3RoID0gQkFTRV9IRUFERVJfTEVOR1RIICsgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSICogbGVuO1xuICAgIGNvbnN0IGhlYWRlciA9IG5ldyBVaW50MzJBcnJheShoZWFkZXJMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBoZWFkZXJMZW5ndGggKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCArIChvdXRsaW5lc0xlbmd0aCAtIDIgKiBsZW4pICogYnVmZmVyVHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gMDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gd2lkdGg7XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGhlaWdodDtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gYXJlQ29udG91cnMgPyAwIDogMTtcbiAgICBoZWFkZXJbb2Zmc2V0KytdID0gTWF0aC5tYXgoMCwgTWF0aC5mbG9vcih0aGlja25lc3MgPz8gMCkpO1xuICAgIGhlYWRlcltvZmZzZXQrK10gPSBsZW47XG4gICAgaGVhZGVyW29mZnNldCsrXSA9IGJ1ZmZlclR5cGUuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHMubGVuZ3RoIC0gMjtcbiAgICAgIGhlYWRlcltvZmZzZXQrK10gPSBwb2ludHNbMF07XG4gICAgICBoZWFkZXJbb2Zmc2V0KytdID0gcG9pbnRzWzFdO1xuICAgIH1cbiAgICBjb25zdCBjcyA9IG5ldyBDb21wcmVzc2lvblN0cmVhbShcImRlZmxhdGUtcmF3XCIpO1xuICAgIGNvbnN0IHdyaXRlciA9IGNzLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICB3cml0ZXIud3JpdGUoaGVhZGVyKTtcbiAgICBjb25zdCBCdWZmZXJDdG9yID0gYnVmZmVyVHlwZS5wcm90b3R5cGUuY29uc3RydWN0b3I7XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2Ygb3V0bGluZXMpIHtcbiAgICAgIGNvbnN0IGRpZmZzID0gbmV3IEJ1ZmZlckN0b3IocG9pbnRzLmxlbmd0aCAtIDIpO1xuICAgICAgZm9yIChsZXQgaSA9IDIsIGlpID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgZGlmZnNbaSAtIDJdID0gcG9pbnRzW2ldIC0gcG9pbnRzW2kgLSAyXTtcbiAgICAgIH1cbiAgICAgIHdyaXRlci53cml0ZShkaWZmcyk7XG4gICAgfVxuICAgIHdyaXRlci5jbG9zZSgpO1xuICAgIGNvbnN0IGJ1ZiA9IGF3YWl0IG5ldyBSZXNwb25zZShjcy5yZWFkYWJsZSkuYXJyYXlCdWZmZXIoKTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgcmV0dXJuIHRvQmFzZTY0VXRpbChieXRlcyk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlY29tcHJlc3NTaWduYXR1cmUoc2lnbmF0dXJlRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBieXRlcyA9IGZyb21CYXNlNjRVdGlsKHNpZ25hdHVyZURhdGEpO1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWFkYWJsZSxcbiAgICAgICAgd3JpdGFibGVcbiAgICAgIH0gPSBuZXcgRGVjb21wcmVzc2lvblN0cmVhbShcImRlZmxhdGUtcmF3XCIpO1xuICAgICAgY29uc3Qgd3JpdGVyID0gd3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICB3cml0ZXIud3JpdGUoYnl0ZXMpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlYWRhYmxlKSB7XG4gICAgICAgIGRhdGEgfHw9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShjaHVuay5idWZmZXIsIDAsIDQpWzBdKTtcbiAgICAgICAgZGF0YS5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWFkZXIgPSBuZXcgVWludDMyQXJyYXkoZGF0YS5idWZmZXIsIDAsIGRhdGEubGVuZ3RoID4+IDIpO1xuICAgICAgY29uc3QgdmVyc2lvbiA9IGhlYWRlclsxXTtcbiAgICAgIGlmICh2ZXJzaW9uICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uOiAke3ZlcnNpb259YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IGhlYWRlclsyXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGhlYWRlclszXTtcbiAgICAgIGNvbnN0IGFyZUNvbnRvdXJzID0gaGVhZGVyWzRdID09PSAwO1xuICAgICAgY29uc3QgdGhpY2tuZXNzID0gaGVhZGVyWzVdO1xuICAgICAgY29uc3QgbnVtYmVyT2ZEcmF3aW5ncyA9IGhlYWRlcls2XTtcbiAgICAgIGNvbnN0IGJ1ZmZlclR5cGUgPSBoZWFkZXJbN107XG4gICAgICBjb25zdCBvdXRsaW5lcyA9IFtdO1xuICAgICAgY29uc3QgZGlmZnNPZmZzZXQgPSAoQkFTRV9IRUFERVJfTEVOR1RIICsgUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSICogbnVtYmVyT2ZEcmF3aW5ncykgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgIGxldCBkaWZmcztcbiAgICAgIHN3aXRjaCAoYnVmZmVyVHlwZSkge1xuICAgICAgICBjYXNlIEludDhBcnJheS5CWVRFU19QRVJfRUxFTUVOVDpcbiAgICAgICAgICBkaWZmcyA9IG5ldyBJbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRpZmZzT2Zmc2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJbnQxNkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOlxuICAgICAgICAgIGRpZmZzID0gbmV3IEludDE2QXJyYXkoZGF0YS5idWZmZXIsIGRpZmZzT2Zmc2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBJbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UOlxuICAgICAgICAgIGRpZmZzID0gbmV3IEludDMyQXJyYXkoZGF0YS5idWZmZXIsIGRpZmZzT2Zmc2V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRHJhd2luZ3M7IGkrKykge1xuICAgICAgICBjb25zdCBsZW4gPSBoZWFkZXJbUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSICogaSArIEJBU0VfSEVBREVSX0xFTkdUSF07XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkobGVuICsgMik7XG4gICAgICAgIG91dGxpbmVzLnB1c2gocG9pbnRzKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBQT0lOVFNfUFJPUEVSVElFU19OVU1CRVIgLSAxOyBqKyspIHtcbiAgICAgICAgICBwb2ludHNbal0gPSBoZWFkZXJbUE9JTlRTX1BST1BFUlRJRVNfTlVNQkVSICogaSArIEJBU0VfSEVBREVSX0xFTkdUSCArIGogKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgcG9pbnRzW2ogKyAyXSA9IHBvaW50c1tqXSArIGRpZmZzW29mZnNldCsrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXJlQ29udG91cnMsXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgb3V0bGluZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgd2FybihgZGVjb21wcmVzc1NpZ25hdHVyZTogJHtlfWApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9zaWduYXR1cmUuanNcblxuXG5cblxuXG5cblxuY2xhc3MgU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIERyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICBzdXBlci51cGRhdGVQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IEFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3IsXG4gICAgICBcInN0cm9rZS13aWR0aFwiOiAwXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIGNsb25lLnVwZGF0ZUFsbCh0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cbmNsYXNzIERyYXduU2lnbmF0dXJlT3B0aW9ucyBleHRlbmRzIElua0RyYXdpbmdPcHRpb25zIHtcbiAgY29uc3RydWN0b3Iodmlld2VyUGFyYW1ldGVycykge1xuICAgIHN1cGVyKHZpZXdlclBhcmFtZXRlcnMpO1xuICAgIHN1cGVyLnVwZGF0ZVByb3BlcnRpZXMoe1xuICAgICAgc3Ryb2tlOiBBbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yLFxuICAgICAgXCJzdHJva2Utd2lkdGhcIjogMVxuICAgIH0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IERyYXduU2lnbmF0dXJlT3B0aW9ucyh0aGlzLl92aWV3UGFyYW1ldGVycyk7XG4gICAgY2xvbmUudXBkYXRlQWxsKHRoaXMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuY2xhc3MgU2lnbmF0dXJlRWRpdG9yIGV4dGVuZHMgRHJhd2luZ0VkaXRvciB7XG4gICNpc0V4dHJhY3RlZCA9IGZhbHNlO1xuICAjZGVzY3JpcHRpb24gPSBudWxsO1xuICAjc2lnbmF0dXJlRGF0YSA9IG51bGw7XG4gICNzaWduYXR1cmVVVUlEID0gbnVsbDtcbiAgc3RhdGljIF90eXBlID0gXCJzaWduYXR1cmVcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU0lHTkFUVVJFO1xuICBzdGF0aWMgX2RlZmF1bHREcmF3aW5nT3B0aW9ucyA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG11c3RCZUNvbW1pdHRlZDogdHJ1ZSxcbiAgICAgIG5hbWU6IFwic2lnbmF0dXJlRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLiNzaWduYXR1cmVEYXRhID0gcGFyYW1zLnNpZ25hdHVyZURhdGEgfHwgbnVsbDtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IG51bGw7XG4gICAgdGhpcy5kZWZhdWx0TDEwbklkID0gXCJwZGZqcy1lZGl0b3Itc2lnbmF0dXJlLWVkaXRvcjFcIjtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpIHtcbiAgICBBbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMgPSBuZXcgU2lnbmF0dXJlT3B0aW9ucygpO1xuICAgIHRoaXMuX2RlZmF1bHREcmF3blNpZ25hdHVyZU9wdGlvbnMgPSBuZXcgRHJhd25TaWduYXR1cmVPcHRpb25zKHVpTWFuYWdlci52aWV3UGFyYW1ldGVycyk7XG4gIH1cbiAgc3RhdGljIGdldERlZmF1bHREcmF3aW5nT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xvbmUgPSB0aGlzLl9kZWZhdWx0RHJhd2luZ09wdGlvbnMuY2xvbmUoKTtcbiAgICBjbG9uZS51cGRhdGVQcm9wZXJ0aWVzKG9wdGlvbnMpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHN1cHBvcnRNdWx0aXBsZURyYXdpbmdzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0IHR5cGVzTWFwKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJ0eXBlc01hcFwiLCBuZXcgTWFwKCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgaXNEcmF3ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldCB0ZWxlbWV0cnlGaW5hbERhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic2lnbmF0dXJlXCIsXG4gICAgICBoYXNEZXNjcmlwdGlvbjogISF0aGlzLiNkZXNjcmlwdGlvblxuICAgIH07XG4gIH1cbiAgc3RhdGljIGNvbXB1dGVUZWxlbWV0cnlGaW5hbERhdGEoZGF0YSkge1xuICAgIGNvbnN0IGhhc0Rlc2NyaXB0aW9uU3RhdHMgPSBkYXRhLmdldChcImhhc0Rlc2NyaXB0aW9uXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBoYXNBbHRUZXh0OiBoYXNEZXNjcmlwdGlvblN0YXRzLmdldCh0cnVlKSA/PyAwLFxuICAgICAgaGFzTm9BbHRUZXh0OiBoYXNEZXNjcmlwdGlvblN0YXRzLmdldChmYWxzZSkgPz8gMFxuICAgIH07XG4gIH1cbiAgZ2V0IGlzUmVzaXphYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uU2NhbGVDaGFuZ2luZygpIHtcbiAgICBpZiAodGhpcy5fZHJhd0lkID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLm9uU2NhbGVDaGFuZ2luZygpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBjb25zdCB7XG4gICAgICBfaXNDb3B5XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKF9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX2lzQ29weSA9IGZhbHNlO1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgaWYgKHRoaXMuX2RyYXdJZCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuI3NpZ25hdHVyZURhdGEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgIG11c3RTbW9vdGgsXG4gICAgICAgICAgYXJlQ29udG91cnMsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgdXVpZCxcbiAgICAgICAgICBoZWlnaHRJblBhZ2VcbiAgICAgICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByYXdEaW1zOiB7XG4gICAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICByb3RhdGlvblxuICAgICAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgICBwYWdlSGVpZ2h0LFxuICAgICAgICAgIHJvdGF0aW9uLFxuICAgICAgICAgIGlubmVyTWFyZ2luOiBTaWduYXR1cmVFZGl0b3IuX0lOTkVSX01BUkdJTixcbiAgICAgICAgICBtdXN0U21vb3RoLFxuICAgICAgICAgIGFyZUNvbnRvdXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFkZFNpZ25hdHVyZShvdXRsaW5lLCBoZWlnaHRJblBhZ2UsIGRlc2NyaXB0aW9uLCB1dWlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkZXNjcmlwdGlvbjogXCJcIlxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5nZXRTaWduYXR1cmUodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbDEwbi1hcmdzXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuI2Rlc2NyaXB0aW9uIHx8IFwiXCJcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKF9pc0NvcHkpIHtcbiAgICAgIHRoaXMuX2lzQ29weSA9IHRydWU7XG4gICAgICB0aGlzLl9tb3ZlQWZ0ZXJQYXN0ZShiYXNlWCwgYmFzZVkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgc2V0VXVpZCh1dWlkKSB7XG4gICAgdGhpcy4jc2lnbmF0dXJlVVVJRCA9IHV1aWQ7XG4gICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpO1xuICB9XG4gIGdldFV1aWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NpZ25hdHVyZVVVSUQ7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLiNkZXNjcmlwdGlvbjtcbiAgfVxuICBzZXQgZGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICB0aGlzLiNkZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGlmICghdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sMTBuLWFyZ3NcIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KSk7XG4gICAgc3VwZXIuYWRkRWRpdFRvb2xiYXIoKS50aGVuKHRvb2xiYXIgPT4ge1xuICAgICAgdG9vbGJhcj8udXBkYXRlRWRpdFNpZ25hdHVyZUJ1dHRvbihkZXNjcmlwdGlvbik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2lnbmF0dXJlUHJldmlldygpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXdDdXJ2ZXMsXG4gICAgICBhcmVDb250b3VycyxcbiAgICAgIHRoaWNrbmVzcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXMuI3NpZ25hdHVyZURhdGE7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3Qgb3V0bGluZURhdGEgPSBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2Vzc0RyYXduTGluZXMoe1xuICAgICAgbGluZXM6IHtcbiAgICAgICAgY3VydmVzOiBuZXdDdXJ2ZXMubWFwKHBvaW50cyA9PiAoe1xuICAgICAgICAgIHBvaW50c1xuICAgICAgICB9KSksXG4gICAgICAgIHRoaWNrbmVzcyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSxcbiAgICAgIHBhZ2VXaWR0aDogbWF4RGltLFxuICAgICAgcGFnZUhlaWdodDogbWF4RGltLFxuICAgICAgcm90YXRpb246IDAsXG4gICAgICBpbm5lck1hcmdpbjogMCxcbiAgICAgIG11c3RTbW9vdGg6IGZhbHNlLFxuICAgICAgYXJlQ29udG91cnNcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgYXJlQ29udG91cnMsXG4gICAgICBvdXRsaW5lOiBvdXRsaW5lRGF0YS5vdXRsaW5lXG4gICAgfTtcbiAgfVxuICBnZXQgdG9vbGJhckJ1dHRvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci5zaWduYXR1cmVNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gW1tcImVkaXRTaWduYXR1cmVcIiwgdGhpcy5fdWlNYW5hZ2VyLnNpZ25hdHVyZU1hbmFnZXJdXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnRvb2xiYXJCdXR0b25zO1xuICB9XG4gIGFkZFNpZ25hdHVyZShkYXRhLCBoZWlnaHRJblBhZ2UsIGRlc2NyaXB0aW9uLCB1dWlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgeDogc2F2ZWRYLFxuICAgICAgeTogc2F2ZWRZXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb3V0bGluZVxuICAgIH0gPSB0aGlzLiNzaWduYXR1cmVEYXRhID0gZGF0YTtcbiAgICB0aGlzLiNpc0V4dHJhY3RlZCA9IG91dGxpbmUgaW5zdGFuY2VvZiBDb250b3VyRHJhd091dGxpbmU7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgIGxldCBkcmF3aW5nT3B0aW9ucztcbiAgICBpZiAodGhpcy4jaXNFeHRyYWN0ZWQpIHtcbiAgICAgIGRyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucy5jbG9uZSgpO1xuICAgICAgZHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IG91dGxpbmUudGhpY2tuZXNzXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fYWRkT3V0bGluZXMoe1xuICAgICAgZHJhd091dGxpbmVzOiBvdXRsaW5lLFxuICAgICAgZHJhd2luZ09wdGlvbnNcbiAgICB9KTtcbiAgICBjb25zdCBbLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgbGV0IG5ld0hlaWdodCA9IGhlaWdodEluUGFnZSAvIHBhZ2VIZWlnaHQ7XG4gICAgbmV3SGVpZ2h0ID0gbmV3SGVpZ2h0ID49IDEgPyAwLjUgOiBuZXdIZWlnaHQ7XG4gICAgdGhpcy53aWR0aCAqPSBuZXdIZWlnaHQgLyB0aGlzLmhlaWdodDtcbiAgICBpZiAodGhpcy53aWR0aCA+PSAxKSB7XG4gICAgICBuZXdIZWlnaHQgKj0gMC45IC8gdGhpcy53aWR0aDtcbiAgICAgIHRoaXMud2lkdGggPSAwLjk7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcygpO1xuICAgIHRoaXMueCA9IHNhdmVkWDtcbiAgICB0aGlzLnkgPSBzYXZlZFk7XG4gICAgdGhpcy5jZW50ZXIoKTtcbiAgICB0aGlzLl9vblJlc2l6ZWQoKTtcbiAgICB0aGlzLm9uU2NhbGVDaGFuZ2luZygpO1xuICAgIHRoaXMucm90YXRlKCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gICAgdGhpcy5zZXRVdWlkKHV1aWQpO1xuICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICBhY3Rpb246IFwicGRmanMuc2lnbmF0dXJlLmluc2VydGVkXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhhc0JlZW5TYXZlZDogISF1dWlkLFxuICAgICAgICBoYXNEZXNjcmlwdGlvbjogISFkZXNjcmlwdGlvblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldEZyb21JbWFnZShiaXRtYXApIHtcbiAgICBjb25zdCB7XG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodFxuICAgICAgfSxcbiAgICAgIHJvdGF0aW9uXG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHJldHVybiBTaWduYXR1cmVFeHRyYWN0b3IucHJvY2VzcyhiaXRtYXAsIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgcm90YXRpb24sIFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOKTtcbiAgfVxuICBnZXRGcm9tVGV4dCh0ZXh0LCBmb250SW5mbykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5leHRyYWN0Q29udG91cnNGcm9tVGV4dCh0ZXh0LCBmb250SW5mbywgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCByb3RhdGlvbiwgU2lnbmF0dXJlRWRpdG9yLl9JTk5FUl9NQVJHSU4pO1xuICB9XG4gIGdldERyYXduU2lnbmF0dXJlKGN1cnZlcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgcGFnZVdpZHRoLFxuICAgICAgICBwYWdlSGVpZ2h0XG4gICAgICB9LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG4gICAgcmV0dXJuIFNpZ25hdHVyZUV4dHJhY3Rvci5wcm9jZXNzRHJhd25MaW5lcyh7XG4gICAgICBsaW5lczogY3VydmVzLFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgaW5uZXJNYXJnaW46IFNpZ25hdHVyZUVkaXRvci5fSU5ORVJfTUFSR0lOLFxuICAgICAgbXVzdFNtb290aDogZmFsc2UsXG4gICAgICBhcmVDb250b3VyczogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEcmF3aW5nT3B0aW9ucyh7XG4gICAgYXJlQ29udG91cnMsXG4gICAgdGhpY2tuZXNzXG4gIH0pIHtcbiAgICBpZiAoYXJlQ29udG91cnMpIHtcbiAgICAgIHRoaXMuX2RyYXdpbmdPcHRpb25zID0gU2lnbmF0dXJlRWRpdG9yLmdldERlZmF1bHREcmF3aW5nT3B0aW9ucygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kcmF3aW5nT3B0aW9ucyA9IFNpZ25hdHVyZUVkaXRvci5fZGVmYXVsdERyYXduU2lnbmF0dXJlT3B0aW9ucy5jbG9uZSgpO1xuICAgICAgdGhpcy5fZHJhd2luZ09wdGlvbnMudXBkYXRlUHJvcGVydGllcyh7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaWNrbmVzc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHNlcmlhbGl6ZShpc0ZvckNvcHlpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxpbmVzLFxuICAgICAgcG9pbnRzXG4gICAgfSA9IHRoaXMuc2VyaWFsaXplRHJhdyhpc0ZvckNvcHlpbmcpO1xuICAgIGNvbnN0IHtcbiAgICAgIF9kcmF3aW5nT3B0aW9uczoge1xuICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlja25lc3NcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzZXJpYWxpemVkID0gT2JqZWN0LmFzc2lnbihzdXBlci5zZXJpYWxpemUoaXNGb3JDb3B5aW5nKSwge1xuICAgICAgaXNTaWduYXR1cmU6IHRydWUsXG4gICAgICBhcmVDb250b3VyczogdGhpcy4jaXNFeHRyYWN0ZWQsXG4gICAgICBjb2xvcjogWzAsIDAsIDBdLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLiNpc0V4dHJhY3RlZCA/IDAgOiB0aGlja25lc3NcbiAgICB9KTtcbiAgICB0aGlzLmFkZENvbW1lbnQoc2VyaWFsaXplZCk7XG4gICAgaWYgKGlzRm9yQ29weWluZykge1xuICAgICAgc2VyaWFsaXplZC5wYXRocyA9IHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvaW50c1xuICAgICAgfTtcbiAgICAgIHNlcmlhbGl6ZWQudXVpZCA9IHRoaXMuI3NpZ25hdHVyZVVVSUQ7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlcmlhbGl6ZWQubGluZXMgPSBsaW5lcztcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Rlc2NyaXB0aW9uKSB7XG4gICAgICBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhID0ge1xuICAgICAgICB0eXBlOiBcIkZpZ3VyZVwiLFxuICAgICAgICBhbHQ6IHRoaXMuI2Rlc2NyaXB0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemVEcmF3KHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSkge1xuICAgIGlmIChkYXRhLmFyZUNvbnRvdXJzKSB7XG4gICAgICByZXR1cm4gQ29udG91ckRyYXdPdXRsaW5lLmRlc2VyaWFsaXplKHBhZ2VYLCBwYWdlWSwgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0LCBpbm5lck1hcmdpbiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBJbmtEcmF3T3V0bGluZS5kZXNlcmlhbGl6ZShwYWdlWCwgcGFnZVksIHBhZ2VXaWR0aCwgcGFnZUhlaWdodCwgaW5uZXJNYXJnaW4sIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBhc3luYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcikge1xuICAgIGNvbnN0IGVkaXRvciA9IGF3YWl0IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2lzRXh0cmFjdGVkID0gZGF0YS5hcmVDb250b3VycztcbiAgICBlZGl0b3IuZGVzY3JpcHRpb24gPSBkYXRhLmFjY2Vzc2liaWxpdHlEYXRhPy5hbHQgfHwgXCJcIjtcbiAgICBlZGl0b3IuI3NpZ25hdHVyZVVVSUQgPSBkYXRhLnV1aWQ7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxufVxuXG47Ly8gLi9zcmMvZGlzcGxheS9lZGl0b3Ivc3RhbXAuanNcblxuXG5cblxuY2xhc3MgU3RhbXBFZGl0b3IgZXh0ZW5kcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JpdG1hcCA9IG51bGw7XG4gICNiaXRtYXBJZCA9IG51bGw7XG4gICNiaXRtYXBQcm9taXNlID0gbnVsbDtcbiAgI2JpdG1hcFVybCA9IG51bGw7XG4gICNiaXRtYXBGaWxlID0gbnVsbDtcbiAgI2JpdG1hcEZpbGVOYW1lID0gXCJcIjtcbiAgI2NhbnZhcyA9IG51bGw7XG4gICNtaXNzaW5nQ2FudmFzID0gZmFsc2U7XG4gICNyZXNpemVUaW1lb3V0SWQgPSBudWxsO1xuICAjaXNTdmcgPSBmYWxzZTtcbiAgI2hhc0JlZW5BZGRlZEluVW5kb1N0YWNrID0gZmFsc2U7XG4gIHN0YXRpYyBfdHlwZSA9IFwic3RhbXBcIjtcbiAgc3RhdGljIF9lZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG5hbWU6IFwic3RhbXBFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuI2JpdG1hcFVybCA9IHBhcmFtcy5iaXRtYXBVcmw7XG4gICAgdGhpcy4jYml0bWFwRmlsZSA9IHBhcmFtcy5iaXRtYXBGaWxlO1xuICAgIHRoaXMuZGVmYXVsdEwxMG5JZCA9IFwicGRmanMtZWRpdG9yLXN0YW1wLWVkaXRvclwiO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4sIHVpTWFuYWdlcikge1xuICAgIEFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB1aU1hbmFnZXIpO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcy5pbmNsdWRlcyhtaW1lKTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgcGFyZW50LnBhc3RlRWRpdG9yKHtcbiAgICAgIG1vZGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QXG4gICAgfSwge1xuICAgICAgYml0bWFwRmlsZTogaXRlbS5nZXRBc0ZpbGUoKVxuICAgIH0pO1xuICB9XG4gIGFsdFRleHRGaW5pc2goKSB7XG4gICAgaWYgKHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0Rmxvdykge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICAgIHN1cGVyLmFsdFRleHRGaW5pc2goKTtcbiAgfVxuICBnZXQgdGVsZW1ldHJ5RmluYWxEYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0YW1wXCIsXG4gICAgICBoYXNBbHRUZXh0OiAhIXRoaXMuYWx0VGV4dERhdGE/LmFsdFRleHRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBjb21wdXRlVGVsZW1ldHJ5RmluYWxEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBoYXNBbHRUZXh0U3RhdHMgPSBkYXRhLmdldChcImhhc0FsdFRleHRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0FsdFRleHQ6IGhhc0FsdFRleHRTdGF0cy5nZXQodHJ1ZSkgPz8gMCxcbiAgICAgIGhhc05vQWx0VGV4dDogaGFzQWx0VGV4dFN0YXRzLmdldChmYWxzZSkgPz8gMFxuICAgIH07XG4gIH1cbiAgI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgZnJvbUlkID0gZmFsc2UpIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2JpdG1hcCA9IGRhdGEuYml0bWFwO1xuICAgIGlmICghZnJvbUlkKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLiNpc1N2ZyA9IGRhdGEuaXNTdmc7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGVOYW1lID0gZGF0YS5maWxlLm5hbWU7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICB9XG4gICNnZXRCaXRtYXBEb25lKCkge1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBpZiAoIXRoaXMuI2NhbnZhcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgJiYgdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRGbG93ICYmIHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy5hZGRFZGl0VG9vbGJhcigpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLl9lZGl0VG9vbGJhci5oaWRlKCk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5lZGl0QWx0VGV4dCh0aGlzLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0V2hlbkFkZGluZ0ltYWdlICYmIHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyAmJiB0aGlzLiNiaXRtYXApIHtcbiAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgIGFjdGlvbjogXCJwZGZqcy5pbWFnZS5pbWFnZV9hZGRlZFwiLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWx0X3RleHRfbW9kYWw6IGZhbHNlLFxuICAgICAgICAgIGFsdF90ZXh0X3R5cGU6IFwiZW1wdHlcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMubWxHdWVzc0FsdFRleHQoKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfVxuICBhc3luYyBtbEd1ZXNzQWx0VGV4dChpbWFnZURhdGEgPSBudWxsLCB1cGRhdGVBbHRUZXh0RGF0YSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5oYXNBbHRUZXh0RGF0YSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWxNYW5hZ2VyXG4gICAgfSA9IHRoaXMuX3VpTWFuYWdlcjtcbiAgICBpZiAoIW1sTWFuYWdlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gTUwuXCIpO1xuICAgIH1cbiAgICBpZiAoIShhd2FpdCBtbE1hbmFnZXIuaXNFbmFibGVkRm9yKFwiYWx0VGV4dFwiKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1MIGlzbid0IGVuYWJsZWQgZm9yIGFsdCB0ZXh0LlwiKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltYWdlRGF0YSB8fCB0aGlzLmNvcHlDYW52YXMobnVsbCwgbnVsbCwgdHJ1ZSkuaW1hZ2VEYXRhO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbWxNYW5hZ2VyLmd1ZXNzKHtcbiAgICAgIG5hbWU6IFwiYWx0VGV4dFwiLFxuICAgICAgcmVxdWVzdDoge1xuICAgICAgICBkYXRhLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBjaGFubmVsczogZGF0YS5sZW5ndGggLyAod2lkdGggKiBoZWlnaHQpXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVzcG9uc2UgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5jYW5jZWwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLm91dHB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gdmFsaWQgcmVzcG9uc2UgZnJvbSB0aGUgQUkgc2VydmljZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGFsdFRleHQgPSByZXNwb25zZS5vdXRwdXQ7XG4gICAgYXdhaXQgdGhpcy5zZXRHdWVzc2VkQWx0VGV4dChhbHRUZXh0KTtcbiAgICBpZiAodXBkYXRlQWx0VGV4dERhdGEgJiYgIXRoaXMuaGFzQWx0VGV4dERhdGEoKSkge1xuICAgICAgdGhpcy5hbHRUZXh0RGF0YSA9IHtcbiAgICAgICAgYWx0OiBhbHRUZXh0LFxuICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFsdFRleHQ7XG4gIH1cbiAgI2dldEJpdG1hcCgpIHtcbiAgICBpZiAodGhpcy4jYml0bWFwSWQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tSWQodGhpcy4jYml0bWFwSWQpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEsIHRydWUpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBVcmwpIHtcbiAgICAgIGNvbnN0IHVybCA9IHRoaXMuI2JpdG1hcFVybDtcbiAgICAgIHRoaXMuI2JpdG1hcFVybCA9IG51bGw7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21VcmwodXJsKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZSkge1xuICAgICAgY29uc3QgZmlsZSA9IHRoaXMuI2JpdG1hcEZpbGU7XG4gICAgICB0aGlzLiNiaXRtYXBGaWxlID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoZmlsZSkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgaW5wdXQudHlwZSA9IFwiZmlsZVwiO1xuICAgIGlucHV0LmFjY2VwdCA9IFN1cHBvcnRlZEltYWdlTWltZVR5cGVzLmpvaW4oXCIsXCIpO1xuICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuX3VpTWFuYWdlci5fc2lnbmFsO1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIWlucHV0LmZpbGVzIHx8IGlucHV0LmZpbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbUZpbGUoaW5wdXQuZmlsZXNbMF0pO1xuICAgICAgICAgIHRoaXMuX3JlcG9ydFRlbGVtZXRyeSh7XG4gICAgICAgICAgICBhY3Rpb246IFwicGRmanMuaW1hZ2UuaW1hZ2Vfc2VsZWN0ZWRcIixcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgYWx0X3RleHRfbW9kYWw6IHRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0Rmxvd1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSwge1xuICAgICAgICBzaWduYWxcbiAgICAgIH0pO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNiaXRtYXAgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5kZWxldGVJZCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICB0aGlzLiNjYW52YXM/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jY2FudmFzID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLiNyZXNpemVUaW1lb3V0SWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCAmJiB0aGlzLiNjYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG4gIG9uY2VBZGRlZChmb2N1cykge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICBpZiAoZm9jdXMpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUgfHwgdGhpcy4jYml0bWFwSWQgfHwgdGhpcy4jbWlzc2luZ0NhbnZhcyk7XG4gIH1cbiAgZ2V0IHRvb2xiYXJCdXR0b25zKCkge1xuICAgIHJldHVybiBbW1wiYWx0VGV4dFwiLCB0aGlzLmNyZWF0ZUFsdFRleHQoKV1dO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB0aGlzLmNyZWF0ZUFsdFRleHQoKTtcbiAgICBpZiAoIXRoaXMuI21pc3NpbmdDYW52YXMpIHtcbiAgICAgIGlmICh0aGlzLiNiaXRtYXApIHtcbiAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNnZXRCaXRtYXAoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2lzQ29weSkge1xuICAgICAgdGhpcy5fbW92ZUFmdGVyUGFzdGUoYmFzZVgsIGJhc2VZKTtcbiAgICB9XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmFkZFNob3VsZFJlc2NhbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHNldENhbnZhcyhhbm5vdGF0aW9uRWxlbWVudElkLCBjYW52YXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogYml0bWFwSWQsXG4gICAgICBiaXRtYXBcbiAgICB9ID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tQ2FudmFzKGFubm90YXRpb25FbGVtZW50SWQsIGNhbnZhcyk7XG4gICAgY2FudmFzLnJlbW92ZSgpO1xuICAgIGlmIChiaXRtYXBJZCAmJiB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmlzVmFsaWRJZChiaXRtYXBJZCkpIHtcbiAgICAgIHRoaXMuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgICBpZiAoYml0bWFwKSB7XG4gICAgICAgIHRoaXMuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICAgIHRoaXMuI21pc3NpbmdDYW52YXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgfVxuICBfb25SZXNpemVkKCkge1xuICAgIHRoaXMub25TY2FsZUNoYW5naW5nKCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKCk7XG4gICAgfSwgVElNRV9UT19XQUlUKTtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLiNjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiaW1nXCIpO1xuICAgIHRoaXMuYWRkQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFnZVdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB0aGlzLnNldERpbXMoKTtcbiAgICBpZiAodGhpcy5faW5pdGlhbE9wdGlvbnM/LmlzQ2VudGVyZWQpIHtcbiAgICAgIHRoaXMuY2VudGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICAgIGlmICghdGhpcy5fdWlNYW5hZ2VyLnVzZU5ld0FsdFRleHRXaGVuQWRkaW5nSW1hZ2UgfHwgIXRoaXMuX3VpTWFuYWdlci51c2VOZXdBbHRUZXh0RmxvdyB8fCB0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jZHJhd0JpdG1hcCgpO1xuICAgIGlmICghdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2spIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZFVuZG9hYmxlRWRpdG9yKHRoaXMpO1xuICAgICAgdGhpcy4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9yZXBvcnRUZWxlbWV0cnkoe1xuICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jYml0bWFwRmlsZU5hbWUpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpcHRpb25cIiwgdGhpcy4jYml0bWFwRmlsZU5hbWUpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmExMXlBbGVydChcInBkZmpzLWVkaXRvci1zdGFtcC1hZGRlZC1hbGVydFwiKTtcbiAgICB9XG4gIH1cbiAgY29weUNhbnZhcyhtYXhEYXRhRGltZW5zaW9uLCBtYXhQcmV2aWV3RGltZW5zaW9uLCBjcmVhdGVJbWFnZURhdGEgPSBmYWxzZSkge1xuICAgIGlmICghbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgbWF4RGF0YURpbWVuc2lvbiA9IDIyNDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGNvbnN0IG91dHB1dFNjYWxlID0gbmV3IE91dHB1dFNjYWxlKCk7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICBsZXQgd2lkdGggPSBiaXRtYXBXaWR0aCxcbiAgICAgIGhlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBpZiAobWF4UHJldmlld0RpbWVuc2lvbikge1xuICAgICAgaWYgKGJpdG1hcFdpZHRoID4gbWF4UHJldmlld0RpbWVuc2lvbiB8fCBiaXRtYXBIZWlnaHQgPiBtYXhQcmV2aWV3RGltZW5zaW9uKSB7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4UHJldmlld0RpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhQcmV2aWV3RGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgd2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgIH1cbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICBjb25zdCBzY2FsZWRXaWR0aCA9IGNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0ICogb3V0cHV0U2NhbGUuc3kpO1xuICAgICAgaWYgKCF0aGlzLiNpc1N2Zykge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICAgIGxldCB3aGl0ZSA9IFwid2hpdGVcIixcbiAgICAgICAgYmxhY2sgPSBcIiNjZmNmZDhcIjtcbiAgICAgIGlmICh0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyICE9PSBcIm5vbmVcIikge1xuICAgICAgICBibGFjayA9IFwiYmxhY2tcIjtcbiAgICAgIH0gZWxzZSBpZiAoQ29sb3JTY2hlbWUuaXNEYXJrTW9kZSkge1xuICAgICAgICB3aGl0ZSA9IFwiIzhmOGY5ZFwiO1xuICAgICAgICBibGFjayA9IFwiIzQyNDE0ZFwiO1xuICAgICAgfVxuICAgICAgY29uc3QgYm94RGltID0gMTU7XG4gICAgICBjb25zdCBib3hEaW1XaWR0aCA9IGJveERpbSAqIG91dHB1dFNjYWxlLnN4O1xuICAgICAgY29uc3QgYm94RGltSGVpZ2h0ID0gYm94RGltICogb3V0cHV0U2NhbGUuc3k7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhib3hEaW1XaWR0aCAqIDIsIGJveERpbUhlaWdodCAqIDIpO1xuICAgICAgY29uc3QgcGF0dGVybkN0eCA9IHBhdHRlcm4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSB3aGl0ZTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFJlY3QoMCwgMCwgYm94RGltV2lkdGggKiAyLCBib3hEaW1IZWlnaHQgKiAyKTtcbiAgICAgIHBhdHRlcm5DdHguZmlsbFN0eWxlID0gYmxhY2s7XG4gICAgICBwYXR0ZXJuQ3R4LmZpbGxSZWN0KDAsIDAsIGJveERpbVdpZHRoLCBib3hEaW1IZWlnaHQpO1xuICAgICAgcGF0dGVybkN0eC5maWxsUmVjdChib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0LCBib3hEaW1XaWR0aCwgYm94RGltSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuLCBcInJlcGVhdFwiKTtcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICAgIH1cbiAgICBsZXQgaW1hZ2VEYXRhID0gbnVsbDtcbiAgICBpZiAoY3JlYXRlSW1hZ2VEYXRhKSB7XG4gICAgICBsZXQgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0O1xuICAgICAgaWYgKG91dHB1dFNjYWxlLnN5bW1ldHJpYyAmJiBiaXRtYXAud2lkdGggPCBtYXhEYXRhRGltZW5zaW9uICYmIGJpdG1hcC5oZWlnaHQgPCBtYXhEYXRhRGltZW5zaW9uKSB7XG4gICAgICAgIGRhdGFXaWR0aCA9IGJpdG1hcC53aWR0aDtcbiAgICAgICAgZGF0YUhlaWdodCA9IGJpdG1hcC5oZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaXRtYXAgPSB0aGlzLiNiaXRtYXA7XG4gICAgICAgIGlmIChiaXRtYXBXaWR0aCA+IG1heERhdGFEaW1lbnNpb24gfHwgYml0bWFwSGVpZ2h0ID4gbWF4RGF0YURpbWVuc2lvbikge1xuICAgICAgICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4obWF4RGF0YURpbWVuc2lvbiAvIGJpdG1hcFdpZHRoLCBtYXhEYXRhRGltZW5zaW9uIC8gYml0bWFwSGVpZ2h0KTtcbiAgICAgICAgICBkYXRhV2lkdGggPSBNYXRoLmZsb29yKGJpdG1hcFdpZHRoICogcmF0aW8pO1xuICAgICAgICAgIGRhdGFIZWlnaHQgPSBNYXRoLmZsb29yKGJpdG1hcEhlaWdodCAqIHJhdGlvKTtcbiAgICAgICAgICBpZiAoIXRoaXMuI2lzU3ZnKSB7XG4gICAgICAgICAgICBiaXRtYXAgPSB0aGlzLiNzY2FsZUJpdG1hcChkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgY29uc3Qgb2Zmc2NyZWVuQ3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBvZmZzY3JlZW5DdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCBkYXRhV2lkdGgsIGRhdGFIZWlnaHQpO1xuICAgICAgaW1hZ2VEYXRhID0ge1xuICAgICAgICB3aWR0aDogZGF0YVdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRhdGFIZWlnaHQsXG4gICAgICAgIGRhdGE6IG9mZnNjcmVlbkN0eC5nZXRJbWFnZURhdGEoMCwgMCwgZGF0YVdpZHRoLCBkYXRhSGVpZ2h0KS5kYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBpbWFnZURhdGFcbiAgICB9O1xuICB9XG4gICNzY2FsZUJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGg6IGJpdG1hcFdpZHRoLFxuICAgICAgaGVpZ2h0OiBiaXRtYXBIZWlnaHRcbiAgICB9ID0gdGhpcy4jYml0bWFwO1xuICAgIGxldCBuZXdXaWR0aCA9IGJpdG1hcFdpZHRoO1xuICAgIGxldCBuZXdIZWlnaHQgPSBiaXRtYXBIZWlnaHQ7XG4gICAgbGV0IGJpdG1hcCA9IHRoaXMuI2JpdG1hcDtcbiAgICB3aGlsZSAobmV3V2lkdGggPiAyICogd2lkdGggfHwgbmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgY29uc3QgcHJldldpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjb25zdCBwcmV2SGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgaWYgKG5ld1dpZHRoID4gMiAqIHdpZHRoKSB7XG4gICAgICAgIG5ld1dpZHRoID0gbmV3V2lkdGggPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld1dpZHRoIC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld1dpZHRoIC8gMik7XG4gICAgICB9XG4gICAgICBpZiAobmV3SGVpZ2h0ID4gMiAqIGhlaWdodCkge1xuICAgICAgICBuZXdIZWlnaHQgPSBuZXdIZWlnaHQgPj0gMTYzODQgPyBNYXRoLmZsb29yKG5ld0hlaWdodCAvIDIpIC0gMSA6IE1hdGguY2VpbChuZXdIZWlnaHQgLyAyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMobmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDAsIHByZXZXaWR0aCwgcHJldkhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBiaXRtYXAgPSBvZmZzY3JlZW4udHJhbnNmZXJUb0ltYWdlQml0bWFwKCk7XG4gICAgfVxuICAgIHJldHVybiBiaXRtYXA7XG4gIH1cbiAgI2RyYXdCaXRtYXAoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb3V0cHV0U2NhbGUgPSBuZXcgT3V0cHV0U2NhbGUoKTtcbiAgICBjb25zdCBzY2FsZWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAqIHBhcmVudFdpZHRoICogb3V0cHV0U2NhbGUuc3gpO1xuICAgIGNvbnN0IHNjYWxlZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgKiBwYXJlbnRIZWlnaHQgKiBvdXRwdXRTY2FsZS5zeSk7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy4jY2FudmFzO1xuICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gc2NhbGVkV2lkdGggJiYgY2FudmFzLmhlaWdodCA9PT0gc2NhbGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbnZhcy53aWR0aCA9IHNjYWxlZFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBzY2FsZWRIZWlnaHQ7XG4gICAgY29uc3QgYml0bWFwID0gdGhpcy4jaXNTdmcgPyB0aGlzLiNiaXRtYXAgOiB0aGlzLiNzY2FsZUJpdG1hcChzY2FsZWRXaWR0aCwgc2NhbGVkSGVpZ2h0KTtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGN0eC5maWx0ZXIgPSB0aGlzLl91aU1hbmFnZXIuaGNtRmlsdGVyO1xuICAgIGN0eC5kcmF3SW1hZ2UoYml0bWFwLCAwLCAwLCBiaXRtYXAud2lkdGgsIGJpdG1hcC5oZWlnaHQsIDAsIDAsIHNjYWxlZFdpZHRoLCBzY2FsZWRIZWlnaHQpO1xuICB9XG4gICNzZXJpYWxpemVCaXRtYXAodG9VcmwpIHtcbiAgICBpZiAodG9VcmwpIHtcbiAgICAgIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldFN2Z1VybCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgKHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9ID0gdGhpcy4jYml0bWFwKTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuI2JpdG1hcCwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogcGFnZVdpZHRoICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgucm91bmQodGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0ICogUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTKTtcbiAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDAsIHRoaXMuI2JpdG1hcC53aWR0aCwgdGhpcy4jYml0bWFwLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gb2Zmc2NyZWVuLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHRoaXMuI2JpdG1hcCk7XG4gIH1cbiAgc3RhdGljIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBsZXQgbWlzc2luZ0NhbnZhcyA9IGZhbHNlO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVjdCxcbiAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBzdHJ1Y3RQYXJlbnQsXG4gICAgICAgICAgcG9wdXBSZWYsXG4gICAgICAgICAgcmljaFRleHQsXG4gICAgICAgICAgY29udGVudHNPYmosXG4gICAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICAgIG1vZGlmaWNhdGlvbkRhdGVcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyLFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICBwYWdlTnVtYmVyXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW52YXNcbiAgICAgIH0gPSBkYXRhO1xuICAgICAgbGV0IGJpdG1hcElkLCBiaXRtYXA7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmNhbnZhcztcbiAgICAgICAgKHtcbiAgICAgICAgICBpZDogYml0bWFwSWQsXG4gICAgICAgICAgYml0bWFwXG4gICAgICAgIH0gPSB1aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21DYW52YXMoY29udGFpbmVyLmlkLCBjYW52YXMpKTtcbiAgICAgICAgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZ0NhbnZhcyA9IHRydWU7XG4gICAgICAgIGRhdGEuX2hhc05vQ2FudmFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFsdFRleHQgPSAoYXdhaXQgcGFyZW50Ll9zdHJ1Y3RUcmVlLmdldEFyaWFBdHRyaWJ1dGVzKGAke0Fubm90YXRpb25QcmVmaXh9JHtpZH1gKSk/LmdldChcImFyaWEtbGFiZWxcIikgfHwgXCJcIjtcbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgICBiaXRtYXBJZCxcbiAgICAgICAgYml0bWFwLFxuICAgICAgICBwYWdlSW5kZXg6IHBhZ2VOdW1iZXIgLSAxLFxuICAgICAgICByZWN0OiByZWN0LnNsaWNlKDApLFxuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnRJZDogaWQsXG4gICAgICAgIGlkLFxuICAgICAgICBkZWxldGVkOiBmYWxzZSxcbiAgICAgICAgYWNjZXNzaWJpbGl0eURhdGE6IHtcbiAgICAgICAgICBkZWNvcmF0aXZlOiBmYWxzZSxcbiAgICAgICAgICBhbHRUZXh0XG4gICAgICAgIH0sXG4gICAgICAgIGlzU3ZnOiBmYWxzZSxcbiAgICAgICAgc3RydWN0UGFyZW50LFxuICAgICAgICBwb3B1cFJlZixcbiAgICAgICAgcmljaFRleHQsXG4gICAgICAgIGNvbW1lbnQ6IGNvbnRlbnRzT2JqPy5zdHIgfHwgbnVsbCxcbiAgICAgICAgY3JlYXRpb25EYXRlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQsIHVpTWFuYWdlcik7XG4gICAgY29uc3Qge1xuICAgICAgcmVjdCxcbiAgICAgIGJpdG1hcCxcbiAgICAgIGJpdG1hcFVybCxcbiAgICAgIGJpdG1hcElkLFxuICAgICAgaXNTdmcsXG4gICAgICBhY2Nlc3NpYmlsaXR5RGF0YVxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChtaXNzaW5nQ2FudmFzKSB7XG4gICAgICB1aU1hbmFnZXIuYWRkTWlzc2luZ0NhbnZhcyhkYXRhLmlkLCBlZGl0b3IpO1xuICAgICAgZWRpdG9yLiNtaXNzaW5nQ2FudmFzID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJpdG1hcElkICYmIHVpTWFuYWdlci5pbWFnZU1hbmFnZXIuaXNWYWxpZElkKGJpdG1hcElkKSkge1xuICAgICAgZWRpdG9yLiNiaXRtYXBJZCA9IGJpdG1hcElkO1xuICAgICAgaWYgKGJpdG1hcCkge1xuICAgICAgICBlZGl0b3IuI2JpdG1hcCA9IGJpdG1hcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLiNiaXRtYXBVcmwgPSBiaXRtYXBVcmw7XG4gICAgfVxuICAgIGVkaXRvci4jaXNTdmcgPSBpc1N2ZztcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgZWRpdG9yLndpZHRoID0gKHJlY3RbMl0gLSByZWN0WzBdKSAvIHBhcmVudFdpZHRoO1xuICAgIGVkaXRvci5oZWlnaHQgPSAocmVjdFszXSAtIHJlY3RbMV0pIC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5RGF0YSkge1xuICAgICAgZWRpdG9yLmFsdFRleHREYXRhID0gYWNjZXNzaWJpbGl0eURhdGE7XG4gICAgfVxuICAgIGVkaXRvci5faW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICBpZiAoZGF0YS5jb21tZW50KSB7XG4gICAgICBlZGl0b3Iuc2V0Q29tbWVudERhdGEoZGF0YSk7XG4gICAgfVxuICAgIGVkaXRvci4jaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSAhIWluaXRpYWxEYXRhO1xuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgc2VyaWFsaXplKGlzRm9yQ29weWluZyA9IGZhbHNlLCBjb250ZXh0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURlbGV0ZWQoKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IE9iamVjdC5hc3NpZ24oc3VwZXIuc2VyaWFsaXplKGlzRm9yQ29weWluZyksIHtcbiAgICAgIGJpdG1hcElkOiB0aGlzLiNiaXRtYXBJZCxcbiAgICAgIGlzU3ZnOiB0aGlzLiNpc1N2Z1xuICAgIH0pO1xuICAgIHRoaXMuYWRkQ29tbWVudChzZXJpYWxpemVkKTtcbiAgICBpZiAoaXNGb3JDb3B5aW5nKSB7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcFVybCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcCh0cnVlKTtcbiAgICAgIHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGEgPSB0aGlzLnNlcmlhbGl6ZUFsdFRleHQodHJ1ZSk7XG4gICAgICBzZXJpYWxpemVkLmlzQ29weSA9IHRydWU7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5zZXJpYWxpemVBbHRUZXh0KGZhbHNlKTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy4jaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCk7XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlcy5pc1NhbWVBbHRUZXh0KSB7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkLmFjY2Vzc2liaWxpdHlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YS5zdHJ1Y3RQYXJlbnQgPSB0aGlzLl9pbml0aWFsRGF0YS5zdHJ1Y3RQYXJlbnQgPz8gLTE7XG4gICAgICB9XG4gICAgICBzZXJpYWxpemVkLmlkID0gdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgICAgZGVsZXRlIHNlcmlhbGl6ZWQuYml0bWFwSWQ7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBjb250ZXh0LnN0YW1wcyB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLiNpc1N2ZyA/IChzZXJpYWxpemVkLnJlY3RbMl0gLSBzZXJpYWxpemVkLnJlY3RbMF0pICogKHNlcmlhbGl6ZWQucmVjdFszXSAtIHNlcmlhbGl6ZWQucmVjdFsxXSkgOiBudWxsO1xuICAgIGlmICghY29udGV4dC5zdGFtcHMuaGFzKHRoaXMuI2JpdG1hcElkKSkge1xuICAgICAgY29udGV4dC5zdGFtcHMuc2V0KHRoaXMuI2JpdG1hcElkLCB7XG4gICAgICAgIGFyZWEsXG4gICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgIH0pO1xuICAgICAgc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgIGNvbnN0IHByZXZEYXRhID0gY29udGV4dC5zdGFtcHMuZ2V0KHRoaXMuI2JpdG1hcElkKTtcbiAgICAgIGlmIChhcmVhID4gcHJldkRhdGEuYXJlYSkge1xuICAgICAgICBwcmV2RGF0YS5hcmVhID0gYXJlYTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAuY2xvc2UoKTtcbiAgICAgICAgcHJldkRhdGEuc2VyaWFsaXplZC5iaXRtYXAgPSB0aGlzLiNzZXJpYWxpemVCaXRtYXAoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgfVxuICAjaGFzRWxlbWVudENoYW5nZWQoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VJbmRleCxcbiAgICAgIGFjY2Vzc2liaWxpdHlEYXRhOiB7XG4gICAgICAgIGFsdFRleHRcbiAgICAgIH1cbiAgICB9ID0gdGhpcy5faW5pdGlhbERhdGE7XG4gICAgY29uc3QgaXNTYW1lUGFnZUluZGV4ID0gc2VyaWFsaXplZC5wYWdlSW5kZXggPT09IHBhZ2VJbmRleDtcbiAgICBjb25zdCBpc1NhbWVBbHRUZXh0ID0gKHNlcmlhbGl6ZWQuYWNjZXNzaWJpbGl0eURhdGE/LmFsdCB8fCBcIlwiKSA9PT0gYWx0VGV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgaXNTYW1lOiAhdGhpcy5oYXNFZGl0ZWRDb21tZW50ICYmICF0aGlzLl9oYXNCZWVuTW92ZWQgJiYgIXRoaXMuX2hhc0JlZW5SZXNpemVkICYmIGlzU2FtZVBhZ2VJbmRleCAmJiBpc1NhbWVBbHRUZXh0LFxuICAgICAgaXNTYW1lQWx0VGV4dFxuICAgIH07XG4gIH1cbiAgcmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbikge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGFubm90YXRpb24uaGlkZSgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGFubm90YXRpb24udXBkYXRlRWRpdGVkKHtcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UERGUmVjdCgpLFxuICAgICAgcG9wdXA6IHRoaXMuY29tbWVudFxuICAgIH0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2VkaXRvci9hbm5vdGF0aW9uX2VkaXRvcl9sYXllci5qc1xuXG5cblxuXG5cblxuXG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNjbGlja0FDID0gbnVsbDtcbiAgI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgI2VkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAjaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgI2lzRW5hYmxpbmcgPSBmYWxzZTtcbiAgI2RyYXdpbmdBQyA9IG51bGw7XG4gICNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICN0ZXh0TGF5ZXIgPSBudWxsO1xuICAjdGV4dFNlbGVjdGlvbkFDID0gbnVsbDtcbiAgI3RleHRMYXllckRibENsaWNrQUMgPSBudWxsO1xuICAjbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gLTE7XG4gICN1aU1hbmFnZXI7XG4gIHN0YXRpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgc3RhdGljICNlZGl0b3JUeXBlcyA9IG5ldyBNYXAoW0ZyZWVUZXh0RWRpdG9yLCBJbmtFZGl0b3IsIFN0YW1wRWRpdG9yLCBIaWdobGlnaHRFZGl0b3IsIFNpZ25hdHVyZUVkaXRvcl0ubWFwKHR5cGUgPT4gW3R5cGUuX2VkaXRvclR5cGUsIHR5cGVdKSk7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB1aU1hbmFnZXIsXG4gICAgcGFnZUluZGV4LFxuICAgIGRpdixcbiAgICBzdHJ1Y3RUcmVlTGF5ZXIsXG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgYW5ub3RhdGlvbkxheWVyLFxuICAgIGRyYXdMYXllcixcbiAgICB0ZXh0TGF5ZXIsXG4gICAgdmlld3BvcnQsXG4gICAgbDEwblxuICB9KSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZXMgPSBbLi4uQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKV07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbiwgdWlNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdWlNYW5hZ2VyLnJlZ2lzdGVyRWRpdG9yVHlwZXMoZWRpdG9yVHlwZXMpO1xuICAgIHRoaXMuI3VpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB0aGlzLnBhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllciA9IGFubm90YXRpb25MYXllcjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy4jdGV4dExheWVyID0gdGV4dExheWVyO1xuICAgIHRoaXMuZHJhd0xheWVyID0gZHJhd0xheWVyO1xuICAgIHRoaXMuX3N0cnVjdFRyZWUgPSBzdHJ1Y3RUcmVlTGF5ZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLiNlZGl0b3JzLnNpemUgPT09IDA7XG4gIH1cbiAgZ2V0IGlzSW52aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORTtcbiAgfVxuICB1cGRhdGVUb29sYmFyKG9wdGlvbnMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudXBkYXRlVG9vbGJhcihvcHRpb25zKTtcbiAgfVxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBBbm5vdGF0aW9uRWRpdG9yVHlwZS5OT05FOlxuICAgICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgICAgICB0aGlzLnRvZ2dsZVBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgICAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHModHJ1ZSk7XG4gICAgICAgIHRoaXMuZGlzYWJsZUNsaWNrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUOlxuICAgICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b2dnbGVQb2ludGVyRXZlbnRzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmRpc2FibGVUZXh0U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICB0aGlzLnRvZ2dsZUFubm90YXRpb25MYXllclBvaW50ZXJFdmVudHMoZmFsc2UpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgaWYgKG1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlBPUFVQKSB7XG4gICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiY29tbWVudEVkaXRpbmdcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJjb21tZW50RWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKGAke2VkaXRvclR5cGUuX3R5cGV9RWRpdGluZ2AsIG1vZGUgPT09IGVkaXRvclR5cGUuX2VkaXRvclR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxuICBoYXNUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgcmV0dXJuIHRleHRMYXllciA9PT0gdGhpcy4jdGV4dExheWVyPy5kaXY7XG4gIH1cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKTtcbiAgfVxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ29tbWFuZHMocGFyYW1zKTtcbiAgfVxuICBjbGVhblVuZG9TdGFjayh0eXBlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmNsZWFuVW5kb1N0YWNrKHR5cGUpO1xuICB9XG4gIHRvZ2dsZURyYXdpbmcoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRyYXdpbmdcIiwgIWVuYWJsZWQpO1xuICB9XG4gIHRvZ2dsZVBvaW50ZXJFdmVudHMoZW5hYmxlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImRpc2FibGVkXCIsICFlbmFibGVkKTtcbiAgfVxuICB0b2dnbGVBbm5vdGF0aW9uTGF5ZXJQb2ludGVyRXZlbnRzKGVuYWJsZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuI2Fubm90YXRpb25MYXllcj8udG9nZ2xlUG9pbnRlckV2ZW50cyhlbmFibGVkKTtcbiAgfVxuICBnZXQgI2FsbEVkaXRvcnNJdGVyYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplICE9PSAwID8gdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSA6IHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KTtcbiAgfVxuICBhc3luYyBlbmFibGUoKSB7XG4gICAgdGhpcy4jaXNFbmFibGluZyA9IHRydWU7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAwO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwibm9uRWRpdGluZ1wiLCBmYWxzZSk7XG4gICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDID0gbnVsbDtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzSXRlcmF0b3IpIHtcbiAgICAgIGVkaXRvci5lbmFibGVFZGl0aW5nKCk7XG4gICAgICBlZGl0b3Iuc2hvdyh0cnVlKTtcbiAgICAgIGlmIChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICBhbm5vdGF0aW9uRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXIgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI7XG4gICAgaWYgKGFubm90YXRpb25MYXllcikge1xuICAgICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBhbm5vdGF0aW9uTGF5ZXIuZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpKSB7XG4gICAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgICAgaWYgKHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0YWJsZS5kYXRhLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkcy5oYXMoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGl0b3IgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplKGVkaXRhYmxlKTtcbiAgICAgICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNpc0VuYWJsaW5nID0gZmFsc2U7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLl9ldmVudEJ1cy5kaXNwYXRjaChcImVkaXRvcnNyZW5kZXJlZFwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBwYWdlTnVtYmVyOiB0aGlzLnBhZ2VJbmRleCArIDFcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi50YWJJbmRleCA9IC0xO1xuICAgIHRoaXMudG9nZ2xlUG9pbnRlckV2ZW50cyhmYWxzZSk7XG4gICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcIm5vbkVkaXRpbmdcIiwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMuI3RleHRMYXllciAmJiAhdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQykge1xuICAgICAgdGhpcy4jdGV4dExheWVyRGJsQ2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHNpZ25hbCA9IHRoaXMuI3VpTWFuYWdlci5jb21iaW5lZFNpZ25hbCh0aGlzLiN0ZXh0TGF5ZXJEYmxDbGlja0FDKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGUgPT4ge1xuICAgICAgICBjb25zdCBEQkxfQ0xJQ0tfVEhSRVNIT0xEID0gNTAwO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2xpZW50WCxcbiAgICAgICAgICBjbGllbnRZLFxuICAgICAgICAgIHRpbWVTdGFtcFxuICAgICAgICB9ID0gZTtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wO1xuICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID4gREJMX0NMSUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgIHRoaXMuI2xhc3RQb2ludGVyRG93blRpbWVzdGFtcCA9IHRpbWVTdGFtcDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbGFzdFBvaW50ZXJEb3duVGltZXN0YW1wID0gLTE7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjbGFzc0xpc3RcbiAgICAgICAgfSA9IHRoaXMuZGl2O1xuICAgICAgICBjbGFzc0xpc3QudG9nZ2xlKFwiZ2V0RWxlbWVudHNcIiwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQoY2xpZW50WCwgY2xpZW50WSk7XG4gICAgICAgIGNsYXNzTGlzdC50b2dnbGUoXCJnZXRFbGVtZW50c1wiLCBmYWxzZSk7XG4gICAgICAgIGlmICghdGhpcy5kaXYuY29udGFpbnMoZWxlbWVudHNbMF0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKGBeJHtBbm5vdGF0aW9uRWRpdG9yUHJlZml4fVswLTldKyRgKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgaWYgKHJlZ2V4LnRlc3QoZWxlbWVudC5pZCkpIHtcbiAgICAgICAgICAgIGlkID0gZWxlbWVudC5pZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI2VkaXRvcnMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKGVkaXRvcj8uYW5ub3RhdGlvbkVsZW1lbnRJZCA9PT0gbnVsbCkge1xuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGVkaXRvci5kYmxjbGljayhlKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBzaWduYWwsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhbm5vdGF0aW9uTGF5ZXIgPSB0aGlzLiNhbm5vdGF0aW9uTGF5ZXI7XG4gICAgY29uc3QgbmVlZEZha2VBbm5vdGF0aW9uID0gW107XG4gICAgaWYgKGFubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgY2hhbmdlZEFubm90YXRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgcmVzZXRBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2FsbEVkaXRvcnNJdGVyYXRvcikge1xuICAgICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgICAgaWYgKCFlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgICAgIG5lZWRGYWtlQW5ub3RhdGlvbi5wdXNoKGVkaXRvcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkaXRvci5zZXJpYWxpemUoKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoYW5nZWRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzZXRBbm5vdGF0aW9ucy5zZXQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQsIGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRFZGl0YWJsZUFubm90YXRpb24oZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpPy5zaG93KCk7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkaXRhYmxlcyA9IGFubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRhYmxlIG9mIGVkaXRhYmxlcykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWRcbiAgICAgICAgfSA9IGVkaXRhYmxlLmRhdGE7XG4gICAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgZWRpdGFibGUudXBkYXRlRWRpdGVkKHtcbiAgICAgICAgICAgIGRlbGV0ZWQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWRpdG9yID0gcmVzZXRBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgZWRpdG9yLnJlc2V0QW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpO1xuICAgICAgICAgIGVkaXRvci5zaG93KGZhbHNlKTtcbiAgICAgICAgICBlZGl0YWJsZS5zaG93KCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdG9yID0gY2hhbmdlZEFubm90YXRpb25zLmdldChpZCk7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkQ2hhbmdlZEV4aXN0aW5nQW5ub3RhdGlvbihlZGl0b3IpO1xuICAgICAgICAgIGlmIChlZGl0b3IucmVuZGVyQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUpKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2hvdyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkaXRhYmxlLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdFxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgQW5ub3RhdGlvbkVkaXRvckxheWVyLiNlZGl0b3JUeXBlcy52YWx1ZXMoKSkge1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZShgJHtlZGl0b3JUeXBlLl90eXBlfUVkaXRpbmdgKTtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xuICAgIHRoaXMudG9nZ2xlQW5ub3RhdGlvbkxheWVyUG9pbnRlckV2ZW50cyh0cnVlKTtcbiAgICBhbm5vdGF0aW9uTGF5ZXI/LnVwZGF0ZUZha2VBbm5vdGF0aW9ucyhuZWVkRmFrZUFubm90YXRpb24pO1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Fubm90YXRpb25MYXllcj8uZ2V0RWRpdGFibGVBbm5vdGF0aW9uKGlkKSB8fCBudWxsO1xuICB9XG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIGlmIChjdXJyZW50QWN0aXZlID09PSBlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEFjdGl2ZUVkaXRvcihlZGl0b3IpO1xuICB9XG4gIGVuYWJsZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5kaXYudGFiSW5kZXggPSAtMTtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgIXRoaXMuI3RleHRTZWxlY3Rpb25BQykge1xuICAgICAgdGhpcy4jdGV4dFNlbGVjdGlvbkFDID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3Qgc2lnbmFsID0gdGhpcy4jdWlNYW5hZ2VyLmNvbWJpbmVkU2lnbmFsKHRoaXMuI3RleHRTZWxlY3Rpb25BQyk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiN0ZXh0TGF5ZXJQb2ludGVyRG93bi5iaW5kKHRoaXMpLCB7XG4gICAgICAgIHNpZ25hbFxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gIGRpc2FibGVUZXh0U2VsZWN0aW9uKCkge1xuICAgIHRoaXMuZGl2LnRhYkluZGV4ID0gMDtcbiAgICBpZiAodGhpcy4jdGV4dExheWVyPy5kaXYgJiYgdGhpcy4jdGV4dFNlbGVjdGlvbkFDKSB7XG4gICAgICB0aGlzLiN0ZXh0U2VsZWN0aW9uQUMuYWJvcnQoKTtcbiAgICAgIHRoaXMuI3RleHRTZWxlY3Rpb25BQyA9IG51bGw7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWdobGlnaHRpbmdcIik7XG4gICAgfVxuICB9XG4gICN0ZXh0TGF5ZXJQb2ludGVyRG93bihldmVudCkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdEFsbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzLiN0ZXh0TGF5ZXIuZGl2IHx8ICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwicm9sZVwiKSA9PT0gXCJpbWdcIiB8fCB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZW5kT2ZDb250ZW50XCIpKSAmJiB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaXNNYWNcbiAgICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3VpTWFuYWdlci5zaG93QWxsRWRpdG9ycyhcImhpZ2hsaWdodFwiLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRoaXMuI3RleHRMYXllci5kaXYuY2xhc3NMaXN0LmFkZChcImZyZWVcIik7XG4gICAgICB0aGlzLnRvZ2dsZURyYXdpbmcoKTtcbiAgICAgIEhpZ2hsaWdodEVkaXRvci5zdGFydEhpZ2hsaWdodGluZyh0aGlzLCB0aGlzLiN1aU1hbmFnZXIuZGlyZWN0aW9uID09PSBcImx0clwiLCB7XG4gICAgICAgIHRhcmdldDogdGhpcy4jdGV4dExheWVyLmRpdixcbiAgICAgICAgeDogZXZlbnQueCxcbiAgICAgICAgeTogZXZlbnQueVxuICAgICAgfSk7XG4gICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLiN0ZXh0TGF5ZXIuZGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJmcmVlXCIpO1xuICAgICAgICB0aGlzLnRvZ2dsZURyYXdpbmcodHJ1ZSk7XG4gICAgICB9LCB7XG4gICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgIH0pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgaWYgKHRoaXMuI2NsaWNrQUMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY2xpY2tBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jY2xpY2tBQyk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMucG9pbnRlcmRvd24uYmluZCh0aGlzKSwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJ1cCwge1xuICAgICAgc2lnbmFsXG4gICAgfSk7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgcG9pbnRlcnVwLCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgfVxuICBkaXNhYmxlQ2xpY2soKSB7XG4gICAgdGhpcy4jY2xpY2tBQz8uYWJvcnQoKTtcbiAgICB0aGlzLiNjbGlja0FDID0gbnVsbDtcbiAgfVxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25FbGVtZW50SWRcbiAgICB9ID0gZWRpdG9yO1xuICAgIGlmIChhbm5vdGF0aW9uRWxlbWVudElkICYmIHRoaXMuI3VpTWFuYWdlci5pc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5kZWxldGUoZWRpdG9yLmlkKTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICBpZiAoIXRoaXMuI2lzRGlzYWJsaW5nICYmIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvcik7XG4gICAgfVxuICB9XG4gIHJlbW92ZShlZGl0b3IpIHtcbiAgICB0aGlzLmRldGFjaChlZGl0b3IpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVFZGl0b3IoZWRpdG9yKTtcbiAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgJiYgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5hZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIEFubm90YXRpb25FZGl0b3IuZGVsZXRlQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5hdHRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3IucGFyZW50Py5kZXRhY2goZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2V0UGFyZW50KHRoaXMpO1xuICAgIGlmIChlZGl0b3IuZGl2ICYmIGVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZWRpdG9yLmRpdik7XG4gICAgfVxuICB9XG4gIGFkZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcyAmJiBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCF0aGlzLiNpc0VuYWJsaW5nKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShlZGl0b3IpO1xuICAgIGVkaXRvci5fcmVwb3J0VGVsZW1ldHJ5KGVkaXRvci50ZWxlbWV0cnlJbml0aWFsRGF0YSk7XG4gIH1cbiAgbW92ZUVkaXRvckluRE9NKGVkaXRvcikge1xuICAgIGlmICghZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGlmIChlZGl0b3IuZGl2LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpICYmICF0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCkge1xuICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2VkaXRvckZvY3VzVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgICAgIHNpZ25hbDogdGhpcy4jdWlNYW5hZ2VyLl9zaWduYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLl9zdHJ1Y3RUcmVlUGFyZW50SWQgPSB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWRpdG9yLmRpdiwgZWRpdG9yLmNvbnRlbnREaXYsIHRydWUpO1xuICB9XG4gIGFkZE9yUmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLm5lZWRzVG9CZVJlYnVpbHQoKSkge1xuICAgICAgZWRpdG9yLnBhcmVudCB8fD0gdGhpcztcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgICBlZGl0b3Iuc2hvdygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldEVkaXRvckJ5VUlEKHVpZCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IudWlkID09PSB1aWQpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgI2N1cnJlbnRFZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuI2VkaXRvclR5cGVzLmdldCh0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKTtcbiAgfVxuICBjb21iaW5lZFNpZ25hbChhYykge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwoYWMpO1xuICB9XG4gICNjcmVhdGVOZXdFZGl0b3IocGFyYW1zKSB7XG4gICAgY29uc3QgZWRpdG9yVHlwZSA9IHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlO1xuICAgIHJldHVybiBlZGl0b3JUeXBlID8gbmV3IGVkaXRvclR5cGUucHJvdG90eXBlLmNvbnN0cnVjdG9yKHBhcmFtcykgOiBudWxsO1xuICB9XG4gIGNhbkNyZWF0ZU5ld0VtcHR5RWRpdG9yKCkge1xuICAgIHJldHVybiB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uY2FuQ3JlYXRlTmV3RW1wdHlFZGl0b3IoKTtcbiAgfVxuICBhc3luYyBwYXN0ZUVkaXRvcihvcHRpb25zLCBwYXJhbXMpIHtcbiAgICB0aGlzLnVwZGF0ZVRvb2xiYXIob3B0aW9ucyk7XG4gICAgYXdhaXQgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUob3B0aW9ucy5tb2RlKTtcbiAgICBjb25zdCB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH0gPSB0aGlzLiNnZXRDZW50ZXJQb2ludCgpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBvZmZzZXRYLFxuICAgICAgeTogb2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZDogdHJ1ZSxcbiAgICAgIC4uLnBhcmFtc1xuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICByZXR1cm4gKGF3YWl0IEFubm90YXRpb25FZGl0b3JMYXllci4jZWRpdG9yVHlwZXMuZ2V0KGRhdGEuYW5ub3RhdGlvblR5cGUgPz8gZGF0YS5hbm5vdGF0aW9uRWRpdG9yVHlwZSk/LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMsIHRoaXMuI3VpTWFuYWdlcikpIHx8IG51bGw7XG4gIH1cbiAgY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBpc0NlbnRlcmVkLCBkYXRhID0ge30pIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogZXZlbnQub2Zmc2V0WCxcbiAgICAgIHk6IGV2ZW50Lm9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQsXG4gICAgICAuLi5kYXRhXG4gICAgfSk7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBnZXQgYm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICAjZ2V0Q2VudGVyUG9pbnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgICBjb25zdCB0bFggPSBNYXRoLm1heCgwLCB4KTtcbiAgICBjb25zdCB0bFkgPSBNYXRoLm1heCgwLCB5KTtcbiAgICBjb25zdCBiclggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCwgeCArIHdpZHRoKTtcbiAgICBjb25zdCBiclkgPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJIZWlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGNvbnN0IGNlbnRlclggPSAodGxYICsgYnJYKSAvIDIgLSB4O1xuICAgIGNvbnN0IGNlbnRlclkgPSAodGxZICsgYnJZKSAvIDIgLSB5O1xuICAgIGNvbnN0IFtvZmZzZXRYLCBvZmZzZXRZXSA9IHRoaXMudmlld3BvcnQucm90YXRpb24gJSAxODAgPT09IDAgPyBbY2VudGVyWCwgY2VudGVyWV0gOiBbY2VudGVyWSwgY2VudGVyWF07XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfTtcbiAgfVxuICBhZGROZXdFZGl0b3IoZGF0YSA9IHt9KSB7XG4gICAgdGhpcy5jcmVhdGVBbmRBZGROZXdFZGl0b3IodGhpcy4jZ2V0Q2VudGVyUG9pbnQoKSwgdHJ1ZSwgZGF0YSk7XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnRvZ2dsZVNlbGVjdGVkKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0KGVkaXRvcik7XG4gIH1cbiAgcG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gdXRpbF9GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8IGV2ZW50LmN0cmxLZXkgJiYgaXNNYWMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kaXYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgIGlmICh0aGlzLiNjdXJyZW50RWRpdG9yVHlwZT8uaXNEcmF3ZXIgJiYgdGhpcy4jY3VycmVudEVkaXRvclR5cGUuc3VwcG9ydE11bHRpcGxlRHJhd2luZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudE1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpO1xuICAgIGlmIChjdXJyZW50TW9kZSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVAgfHwgY3VycmVudE1vZGUgPT09IEFubm90YXRpb25FZGl0b3JUeXBlLlNJR05BVFVSRSkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSA9PT0gQW5ub3RhdGlvbkVkaXRvclR5cGUuSElHSExJR0hUKSB7XG4gICAgICB0aGlzLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSB1dGlsX0ZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgaWYgKHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlPy5pc0RyYXdlcikge1xuICAgICAgdGhpcy5zdGFydERyYXdpbmdTZXNzaW9uKGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgc3RhcnREcmF3aW5nU2Vzc2lvbihldmVudCkge1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICBpZiAodGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0Q3VycmVudERyYXdpbmdTZXNzaW9uKHRoaXMpO1xuICAgIHRoaXMuI2RyYXdpbmdBQyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBzaWduYWwgPSB0aGlzLiN1aU1hbmFnZXIuY29tYmluZWRTaWduYWwodGhpcy4jZHJhd2luZ0FDKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoe1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pID0+IHtcbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICYmICF0aGlzLmRpdi5jb250YWlucyhyZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICB0aGlzLiNjdXJyZW50RWRpdG9yVHlwZS5zdGFydERyYXdpbmcodGhpcywgdGhpcy4jdWlNYW5hZ2VyLCBmYWxzZSwgZXZlbnQpO1xuICB9XG4gIHBhdXNlKG9uKSB7XG4gICAgaWYgKG9uKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBkb2N1bWVudDtcbiAgICAgIGlmICh0aGlzLmRpdi5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNmb2N1c2VkRWxlbWVudCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2ZvY3VzZWRFbGVtZW50Py5mb2N1cygpO1xuICAgICAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZ1Nlc3Npb24oaXNBYm9ydGVkID0gZmFsc2UpIHtcbiAgICBpZiAoIXRoaXMuI2RyYXdpbmdBQykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRDdXJyZW50RHJhd2luZ1Nlc3Npb24obnVsbCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDLmFib3J0KCk7XG4gICAgdGhpcy4jZHJhd2luZ0FDID0gbnVsbDtcbiAgICB0aGlzLiNmb2N1c2VkRWxlbWVudCA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLmVuZERyYXdpbmcoaXNBYm9ydGVkKTtcbiAgfVxuICBmaW5kTmV3UGFyZW50KGVkaXRvciwgeCwgeSkge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy4jdWlNYW5hZ2VyLmZpbmRQYXJlbnQoeCwgeSk7XG4gICAgaWYgKGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxheWVyLmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLiNkcmF3aW5nQUMpIHtcbiAgICAgIHRoaXMuZW5kRHJhd2luZ1Nlc3Npb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGlmICghdGhpcy4jZHJhd2luZ0FDKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2N1cnJlbnRFZGl0b3JUeXBlLm9uU2NhbGVDaGFuZ2luZ1doZW5EcmF3aW5nKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGhpcy4jZWRpdG9yRm9jdXNUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCk7XG4gICAgICB0aGlzLiNlZGl0b3JGb2N1c1RpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLnNldFBhcmVudChudWxsKTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgICAgIGVkaXRvci5kaXYucmVtb3ZlKCk7XG4gICAgfVxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG4gICNjbGVhbnVwKCkge1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVuZGVyKHtcbiAgICB2aWV3cG9ydFxuICB9KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHNldExheWVyRGltZW5zaW9ucyh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlTW9kZSgpO1xuICB9XG4gIHVwZGF0ZSh7XG4gICAgdmlld3BvcnRcbiAgfSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMuI2NsZWFudXAoKTtcbiAgICBjb25zdCBvbGRSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb247XG4gICAgY29uc3Qgcm90YXRpb24gPSB2aWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgc2V0TGF5ZXJEaW1lbnNpb25zKHRoaXMuZGl2LCB7XG4gICAgICByb3RhdGlvblxuICAgIH0pO1xuICAgIGlmIChvbGRSb3RhdGlvbiAhPT0gcm90YXRpb24pIHtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgICAgZWRpdG9yLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwYWdlRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0XG4gICAgfSA9IHRoaXMudmlld3BvcnQucmF3RGltcztcbiAgICByZXR1cm4gW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF07XG4gIH1cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIudmlld1BhcmFtZXRlcnMucmVhbFNjYWxlO1xuICB9XG59XG5cbjsvLyAuL3NyYy9kaXNwbGF5L2RyYXdfbGF5ZXIuanNcblxuXG5jbGFzcyBEcmF3TGF5ZXIge1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI21hcHBpbmcgPSBuZXcgTWFwKCk7XG4gICN0b1VwZGF0ZSA9IG5ldyBNYXAoKTtcbiAgc3RhdGljICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBwYWdlSW5kZXhcbiAgfSkge1xuICAgIHRoaXMucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICB9XG4gIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICBpZiAoIXRoaXMuI3BhcmVudCkge1xuICAgICAgdGhpcy4jcGFyZW50ID0gcGFyZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy4jcGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgIGlmICh0aGlzLiNtYXBwaW5nLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICAgICAgcm9vdC5yZW1vdmUoKTtcbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHJvb3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLiNwYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXQgX3N2Z0ZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcIl9zdmdGYWN0b3J5XCIsIG5ldyBET01TVkdGYWN0b3J5KCkpO1xuICB9XG4gIHN0YXRpYyAjc2V0Qm94KGVsZW1lbnQsIFt4LCB5LCB3aWR0aCwgaGVpZ2h0XSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGVsZW1lbnQ7XG4gICAgc3R5bGUudG9wID0gYCR7MTAwICogeX0lYDtcbiAgICBzdHlsZS5sZWZ0ID0gYCR7MTAwICogeH0lYDtcbiAgICBzdHlsZS53aWR0aCA9IGAkezEwMCAqIHdpZHRofSVgO1xuICAgIHN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodH0lYDtcbiAgfVxuICAjY3JlYXRlU1ZHKCkge1xuICAgIGNvbnN0IHN2ZyA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGUoMSwgMSwgdHJ1ZSk7XG4gICAgdGhpcy4jcGFyZW50LmFwcGVuZChzdmcpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCB0cnVlKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gICNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIHtcbiAgICBjb25zdCBjbGlwUGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQoY2xpcFBhdGgpO1xuICAgIGNvbnN0IGNsaXBQYXRoSWQgPSBgY2xpcF8ke3BhdGhJZH1gO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIGNsaXBQYXRoSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBjb25zdCBjbGlwUGF0aFVzZSA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwidXNlXCIpO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwUGF0aFVzZSk7XG4gICAgY2xpcFBhdGhVc2Uuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBgIyR7cGF0aElkfWApO1xuICAgIGNsaXBQYXRoVXNlLmNsYXNzTGlzdC5hZGQoXCJjbGlwXCIpO1xuICAgIHJldHVybiBjbGlwUGF0aElkO1xuICB9XG4gICN1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhdyhwcm9wZXJ0aWVzLCBpc1BhdGhVcGRhdGFibGUgPSBmYWxzZSwgaGFzQ2xpcCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaWQgPSBEcmF3TGF5ZXIuI2lkKys7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI2NyZWF0ZVNWRygpO1xuICAgIGNvbnN0IGRlZnMgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgcm9vdC5hcHBlbmQoZGVmcyk7XG4gICAgY29uc3QgcGF0aCA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicGF0aFwiKTtcbiAgICBkZWZzLmFwcGVuZChwYXRoKTtcbiAgICBjb25zdCBwYXRoSWQgPSBgcGF0aF9wJHt0aGlzLnBhZ2VJbmRleH1fJHtpZH1gO1xuICAgIHBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgcGF0aElkKTtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcInZlY3Rvci1lZmZlY3RcIiwgXCJub24tc2NhbGluZy1zdHJva2VcIik7XG4gICAgaWYgKGlzUGF0aFVwZGF0YWJsZSkge1xuICAgICAgdGhpcy4jdG9VcGRhdGUuc2V0KGlkLCBwYXRoKTtcbiAgICB9XG4gICAgY29uc3QgY2xpcFBhdGhJZCA9IGhhc0NsaXAgPyB0aGlzLiNjcmVhdGVDbGlwUGF0aChkZWZzLCBwYXRoSWQpIDogbnVsbDtcbiAgICBjb25zdCB1c2UgPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInVzZVwiKTtcbiAgICByb290LmFwcGVuZCh1c2UpO1xuICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgdGhpcy51cGRhdGVQcm9wZXJ0aWVzKHJvb3QsIHByb3BlcnRpZXMpO1xuICAgIHRoaXMuI21hcHBpbmcuc2V0KGlkLCByb290KTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBjbGlwUGF0aElkOiBgdXJsKCMke2NsaXBQYXRoSWR9KWBcbiAgICB9O1xuICB9XG4gIGRyYXdPdXRsaW5lKHByb3BlcnRpZXMsIG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgIGNvbnN0IGlkID0gRHJhd0xheWVyLiNpZCsrO1xuICAgIGNvbnN0IHJvb3QgPSB0aGlzLiNjcmVhdGVTVkcoKTtcbiAgICBjb25zdCBkZWZzID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJkZWZzXCIpO1xuICAgIHJvb3QuYXBwZW5kKGRlZnMpO1xuICAgIGNvbnN0IHBhdGggPSBEcmF3TGF5ZXIuX3N2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInBhdGhcIik7XG4gICAgZGVmcy5hcHBlbmQocGF0aCk7XG4gICAgY29uc3QgcGF0aElkID0gYHBhdGhfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICBwYXRoLnNldEF0dHJpYnV0ZShcImlkXCIsIHBhdGhJZCk7XG4gICAgcGF0aC5zZXRBdHRyaWJ1dGUoXCJ2ZWN0b3ItZWZmZWN0XCIsIFwibm9uLXNjYWxpbmctc3Ryb2tlXCIpO1xuICAgIGxldCBtYXNrSWQ7XG4gICAgaWYgKG11c3RSZW1vdmVTZWxmSW50ZXJzZWN0aW9ucykge1xuICAgICAgY29uc3QgbWFzayA9IERyYXdMYXllci5fc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwibWFza1wiKTtcbiAgICAgIGRlZnMuYXBwZW5kKG1hc2spO1xuICAgICAgbWFza0lkID0gYG1hc2tfcCR7dGhpcy5wYWdlSW5kZXh9XyR7aWR9YDtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKFwiaWRcIiwgbWFza0lkKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKFwibWFza1VuaXRzXCIsIFwib2JqZWN0Qm91bmRpbmdCb3hcIik7XG4gICAgICBjb25zdCByZWN0ID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJyZWN0XCIpO1xuICAgICAgbWFzay5hcHBlbmQocmVjdCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMVwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMVwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIndoaXRlXCIpO1xuICAgICAgY29uc3QgdXNlID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgICBtYXNrLmFwcGVuZCh1c2UpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke3BhdGhJZH1gKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJub25lXCIpO1xuICAgICAgdXNlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJibGFja1wiKTtcbiAgICAgIHVzZS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgICAgdXNlLmNsYXNzTGlzdC5hZGQoXCJtYXNrXCIpO1xuICAgIH1cbiAgICBjb25zdCB1c2UxID0gRHJhd0xheWVyLl9zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIik7XG4gICAgcm9vdC5hcHBlbmQodXNlMSk7XG4gICAgdXNlMS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGAjJHtwYXRoSWR9YCk7XG4gICAgaWYgKG1hc2tJZCkge1xuICAgICAgdXNlMS5zZXRBdHRyaWJ1dGUoXCJtYXNrXCIsIGB1cmwoIyR7bWFza0lkfSlgKTtcbiAgICB9XG4gICAgY29uc3QgdXNlMiA9IHVzZTEuY2xvbmVOb2RlKCk7XG4gICAgcm9vdC5hcHBlbmQodXNlMik7XG4gICAgdXNlMS5jbGFzc0xpc3QuYWRkKFwibWFpbk91dGxpbmVcIik7XG4gICAgdXNlMi5jbGFzc0xpc3QuYWRkKFwic2Vjb25kYXJ5T3V0bGluZVwiKTtcbiAgICB0aGlzLnVwZGF0ZVByb3BlcnRpZXMocm9vdCwgcHJvcGVydGllcyk7XG4gICAgdGhpcy4jbWFwcGluZy5zZXQoaWQsIHJvb3QpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmaW5hbGl6ZURyYXcoaWQsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLiN0b1VwZGF0ZS5kZWxldGUoaWQpO1xuICAgIHRoaXMudXBkYXRlUHJvcGVydGllcyhpZCwgcHJvcGVydGllcyk7XG4gIH1cbiAgdXBkYXRlUHJvcGVydGllcyhlbGVtZW50T3JJZCwgcHJvcGVydGllcykge1xuICAgIGlmICghcHJvcGVydGllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAgYmJveCxcbiAgICAgIHJvb3RDbGFzcyxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcGVydGllcztcbiAgICBjb25zdCBlbGVtZW50ID0gdHlwZW9mIGVsZW1lbnRPcklkID09PSBcIm51bWJlclwiID8gdGhpcy4jbWFwcGluZy5nZXQoZWxlbWVudE9ySWQpIDogZWxlbWVudE9ySWQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyb290KSB7XG4gICAgICB0aGlzLiN1cGRhdGVQcm9wZXJ0aWVzKGVsZW1lbnQsIHJvb3QpO1xuICAgIH1cbiAgICBpZiAoYmJveCkge1xuICAgICAgRHJhd0xheWVyLiNzZXRCb3goZWxlbWVudCwgYmJveCk7XG4gICAgfVxuICAgIGlmIChyb290Q2xhc3MpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2xhc3NMaXN0XG4gICAgICB9ID0gZWxlbWVudDtcbiAgICAgIGZvciAoY29uc3QgW2NsYXNzTmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJvb3RDbGFzcykpIHtcbiAgICAgICAgY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGNvbnN0IGRlZnMgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgY29uc3QgcGF0aEVsZW1lbnQgPSBkZWZzLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgdGhpcy4jdXBkYXRlUHJvcGVydGllcyhwYXRoRWxlbWVudCwgcGF0aCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmVudChpZCwgbGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuI21hcHBpbmcuZ2V0KGlkKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5ZXIuI3BhcmVudC5hcHBlbmQocm9vdCk7XG4gICAgdGhpcy4jbWFwcGluZy5kZWxldGUoaWQpO1xuICAgIGxheWVyLiNtYXBwaW5nLnNldChpZCwgcm9vdCk7XG4gIH1cbiAgcmVtb3ZlKGlkKSB7XG4gICAgdGhpcy4jdG9VcGRhdGUuZGVsZXRlKGlkKTtcbiAgICBpZiAodGhpcy4jcGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI21hcHBpbmcuZ2V0KGlkKS5yZW1vdmUoKTtcbiAgICB0aGlzLiNtYXBwaW5nLmRlbGV0ZShpZCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNwYXJlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgcm9vdCBvZiB0aGlzLiNtYXBwaW5nLnZhbHVlcygpKSB7XG4gICAgICByb290LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLiNtYXBwaW5nLmNsZWFyKCk7XG4gICAgdGhpcy4jdG9VcGRhdGUuY2xlYXIoKTtcbiAgfVxufVxuXG47Ly8gLi9zcmMvcGRmLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbntcbiAgZ2xvYmFsVGhpcy5fcGRmanNUZXN0aW5nVXRpbHMgPSB7XG4gICAgSGlnaGxpZ2h0T3V0bGluZXI6IEhpZ2hsaWdodE91dGxpbmVyXG4gIH07XG59XG5nbG9iYWxUaGlzLnBkZmpzTGliID0ge1xuICBBYm9ydEV4Y2VwdGlvbjogQWJvcnRFeGNlcHRpb24sXG4gIEFubm90YXRpb25FZGl0b3JMYXllcjogQW5ub3RhdGlvbkVkaXRvckxheWVyLFxuICBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZTogQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsXG4gIEFubm90YXRpb25FZGl0b3JUeXBlOiBBbm5vdGF0aW9uRWRpdG9yVHlwZSxcbiAgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjogQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcixcbiAgQW5ub3RhdGlvbkxheWVyOiBBbm5vdGF0aW9uTGF5ZXIsXG4gIEFubm90YXRpb25Nb2RlOiBBbm5vdGF0aW9uTW9kZSxcbiAgQW5ub3RhdGlvblR5cGU6IEFubm90YXRpb25UeXBlLFxuICBhcHBseU9wYWNpdHk6IGFwcGx5T3BhY2l0eSxcbiAgYnVpbGQ6IGJ1aWxkLFxuICBDb2xvclBpY2tlcjogQ29sb3JQaWNrZXIsXG4gIGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw6IGNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwsXG4gIENTU0NvbnN0YW50czogQ1NTQ29uc3RhbnRzLFxuICBET01TVkdGYWN0b3J5OiBET01TVkdGYWN0b3J5LFxuICBEcmF3TGF5ZXI6IERyYXdMYXllcixcbiAgRmVhdHVyZVRlc3Q6IHV0aWxfRmVhdHVyZVRlc3QsXG4gIGZldGNoRGF0YTogZmV0Y2hEYXRhLFxuICBmaW5kQ29udHJhc3RDb2xvcjogZmluZENvbnRyYXN0Q29sb3IsXG4gIGdldERvY3VtZW50OiBnZXREb2N1bWVudCxcbiAgZ2V0RmlsZW5hbWVGcm9tVXJsOiBnZXRGaWxlbmFtZUZyb21VcmwsXG4gIGdldFBkZkZpbGVuYW1lRnJvbVVybDogZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLFxuICBnZXRSR0I6IGdldFJHQixcbiAgZ2V0VXVpZDogZ2V0VXVpZCxcbiAgZ2V0WGZhUGFnZVZpZXdwb3J0OiBnZXRYZmFQYWdlVmlld3BvcnQsXG4gIEdsb2JhbFdvcmtlck9wdGlvbnM6IEdsb2JhbFdvcmtlck9wdGlvbnMsXG4gIEltYWdlS2luZDogdXRpbF9JbWFnZUtpbmQsXG4gIEludmFsaWRQREZFeGNlcHRpb246IEludmFsaWRQREZFeGNlcHRpb24sXG4gIGlzRGF0YVNjaGVtZTogaXNEYXRhU2NoZW1lLFxuICBpc1BkZkZpbGU6IGlzUGRmRmlsZSxcbiAgaXNWYWxpZEV4cGxpY2l0RGVzdDogaXNWYWxpZEV4cGxpY2l0RGVzdCxcbiAgTWF0aENsYW1wOiBNYXRoQ2xhbXAsXG4gIG5vQ29udGV4dE1lbnU6IG5vQ29udGV4dE1lbnUsXG4gIG5vcm1hbGl6ZVVuaWNvZGU6IG5vcm1hbGl6ZVVuaWNvZGUsXG4gIE9QUzogT1BTLFxuICBPdXRwdXRTY2FsZTogT3V0cHV0U2NhbGUsXG4gIFBhc3N3b3JkUmVzcG9uc2VzOiBQYXNzd29yZFJlc3BvbnNlcyxcbiAgUERGRGF0YVJhbmdlVHJhbnNwb3J0OiBQREZEYXRhUmFuZ2VUcmFuc3BvcnQsXG4gIFBERkRhdGVTdHJpbmc6IFBERkRhdGVTdHJpbmcsXG4gIFBERldvcmtlcjogUERGV29ya2VyLFxuICBQZXJtaXNzaW9uRmxhZzogUGVybWlzc2lvbkZsYWcsXG4gIFBpeGVsc1BlckluY2g6IFBpeGVsc1BlckluY2gsXG4gIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjogUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLFxuICByZW5kZXJSaWNoVGV4dDogcmVuZGVyUmljaFRleHQsXG4gIFJlc3BvbnNlRXhjZXB0aW9uOiBSZXNwb25zZUV4Y2VwdGlvbixcbiAgc2V0TGF5ZXJEaW1lbnNpb25zOiBzZXRMYXllckRpbWVuc2lvbnMsXG4gIHNoYWRvdzogc2hhZG93LFxuICBTaWduYXR1cmVFeHRyYWN0b3I6IFNpZ25hdHVyZUV4dHJhY3RvcixcbiAgc3RvcEV2ZW50OiBzdG9wRXZlbnQsXG4gIFN1cHBvcnRlZEltYWdlTWltZVR5cGVzOiBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcyxcbiAgVGV4dExheWVyOiBUZXh0TGF5ZXIsXG4gIFRvdWNoTWFuYWdlcjogVG91Y2hNYW5hZ2VyLFxuICB1cGRhdGVVcmxIYXNoOiB1cGRhdGVVcmxIYXNoLFxuICBVdGlsOiBVdGlsLFxuICBWZXJib3NpdHlMZXZlbDogVmVyYm9zaXR5TGV2ZWwsXG4gIHZlcnNpb246IHZlcnNpb24sXG4gIFhmYUxheWVyOiBYZmFMYXllclxufTtcblxuZXhwb3J0IHsgQWJvcnRFeGNlcHRpb24sIEFubm90YXRpb25FZGl0b3JMYXllciwgQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUsIEFubm90YXRpb25FZGl0b3JUeXBlLCBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyLCBBbm5vdGF0aW9uTGF5ZXIsIEFubm90YXRpb25Nb2RlLCBBbm5vdGF0aW9uVHlwZSwgQ1NTQ29uc3RhbnRzLCBDb2xvclBpY2tlciwgRE9NU1ZHRmFjdG9yeSwgRHJhd0xheWVyLCB1dGlsX0ZlYXR1cmVUZXN0IGFzIEZlYXR1cmVUZXN0LCBHbG9iYWxXb3JrZXJPcHRpb25zLCB1dGlsX0ltYWdlS2luZCBhcyBJbWFnZUtpbmQsIEludmFsaWRQREZFeGNlcHRpb24sIE1hdGhDbGFtcCwgT1BTLCBPdXRwdXRTY2FsZSwgUERGRGF0YVJhbmdlVHJhbnNwb3J0LCBQREZEYXRlU3RyaW5nLCBQREZXb3JrZXIsIFBhc3N3b3JkUmVzcG9uc2VzLCBQZXJtaXNzaW9uRmxhZywgUGl4ZWxzUGVySW5jaCwgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uLCBSZXNwb25zZUV4Y2VwdGlvbiwgU2lnbmF0dXJlRXh0cmFjdG9yLCBTdXBwb3J0ZWRJbWFnZU1pbWVUeXBlcywgVGV4dExheWVyLCBUb3VjaE1hbmFnZXIsIFV0aWwsIFZlcmJvc2l0eUxldmVsLCBYZmFMYXllciwgYXBwbHlPcGFjaXR5LCBidWlsZCwgY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCwgZmV0Y2hEYXRhLCBmaW5kQ29udHJhc3RDb2xvciwgZ2V0RG9jdW1lbnQsIGdldEZpbGVuYW1lRnJvbVVybCwgZ2V0UGRmRmlsZW5hbWVGcm9tVXJsLCBnZXRSR0IsIGdldFV1aWQsIGdldFhmYVBhZ2VWaWV3cG9ydCwgaXNEYXRhU2NoZW1lLCBpc1BkZkZpbGUsIGlzVmFsaWRFeHBsaWNpdERlc3QsIG5vQ29udGV4dE1lbnUsIG5vcm1hbGl6ZVVuaWNvZGUsIHJlbmRlclJpY2hUZXh0LCBzZXRMYXllckRpbWVuc2lvbnMsIHNoYWRvdywgc3RvcEV2ZW50LCB1cGRhdGVVcmxIYXNoLCB2ZXJzaW9uIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pdfjs-dist/build/pdf.mjs\n");

/***/ })

};
;