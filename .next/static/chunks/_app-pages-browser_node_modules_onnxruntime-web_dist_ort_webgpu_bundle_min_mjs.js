"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_onnxruntime-web_dist_ort_webgpu_bundle_min_mjs"],{

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.2e583633.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?164a":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Of),\n/* harmony export */   TRACE: () => (/* binding */ vr),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ne),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ Be),\n/* harmony export */   Tensor: () => (/* binding */ qe),\n/* harmony export */   \"default\": () => (/* binding */ lT),\n/* harmony export */   env: () => (/* binding */ we),\n/* harmony export */   registerBackend: () => (/* binding */ Ct)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\nvar Un=Object.defineProperty;var Af=Object.getOwnPropertyDescriptor;var kf=Object.getOwnPropertyNames;var Ef=Object.prototype.hasOwnProperty;var Nn=(e=>typeof require<\"u\"?require:typeof Proxy<\"u\"?new Proxy(e,{get:(t,n)=>(typeof require<\"u\"?require:t)[n]}):e)(function(e){if(typeof require<\"u\")return require.apply(this,arguments);throw Error('Dynamic require of \"'+e+'\" is not supported')});var G=(e,t)=>()=>(e&&(t=e(e=0)),t);var Zt=(e,t)=>{for(var n in t)Un(e,n,{get:t[n],enumerable:!0})},Pf=(e,t,n,r)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of kf(t))!Ef.call(e,o)&&o!==n&&Un(e,o,{get:()=>t[o],enumerable:!(r=Af(t,o))||r.enumerable});return e};var br=e=>Pf(Un({},\"__esModule\",{value:!0}),e);var _r,Tt,Ct,zf,Wa,Vn=G(()=>{\"use strict\";_r=new Map,Tt=[],Ct=(e,t,n)=>{if(t&&typeof t.init==\"function\"&&typeof t.createInferenceSessionHandler==\"function\"){let r=_r.get(e);if(r===void 0)_r.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend \"${e}\" using priority ${n}`)}if(n>=0){let o=Tt.indexOf(e);o!==-1&&Tt.splice(o,1);for(let a=0;a<Tt.length;a++)if(_r.get(Tt[a]).priority<=n){Tt.splice(a,0,e);return}Tt.push(e)}return}throw new TypeError(\"not a valid backend\")},zf=async e=>{let t=_r.get(e);if(!t)return\"backend not found.\";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(r){return n||(t.error=`${r}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Wa=async e=>{let t=e.executionProviders||[],n=t.map(l=>typeof l==\"string\"?l:l.name),r=n.length===0?Tt:n,o,a=[],s=new Set;for(let l of r){let p=await zf(l);typeof p==\"string\"?a.push({name:l,err:p}):(o||(o=p),o===p&&s.add(l))}if(!o)throw new Error(`no available backend found. ERR: ${a.map(l=>`[${l.name}] ${l.err}`).join(\", \")}`);for(let{name:l,err:p}of a)n.includes(l)&&console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);let d=t.filter(l=>s.has(typeof l==\"string\"?l:l.name));return[o,new Proxy(e,{get:(l,p)=>p===\"executionProviders\"?d:Reflect.get(l,p)})]}});var La=G(()=>{\"use strict\";Vn()});var Ga,Ha=G(()=>{\"use strict\";Ga=\"1.21.0\"});var Fa,Ue,Wn=G(()=>{\"use strict\";Ha();Fa=\"warning\",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:Ga},set logLevel(e){if(e!==void 0){if(typeof e!=\"string\"||[\"verbose\",\"info\",\"warning\",\"error\",\"fatal\"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);Fa=e}},get logLevel(){return Fa}};Object.defineProperty(Ue,\"logLevel\",{enumerable:!0})});var we,qa=G(()=>{\"use strict\";Wn();we=Ue});var Ka,ja,Za=G(()=>{\"use strict\";Ka=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext(\"2d\");if(r!=null){let o,a;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[3]):(o=e.dims[3],a=e.dims[2]);let s=t?.format!==void 0?t.format:\"RGB\",d=t?.norm,l,p;d===void 0||d.mean===void 0?l=[255,255,255,255]:typeof d.mean==\"number\"?l=[d.mean,d.mean,d.mean,d.mean]:(l=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(l[3]=d.mean[3])),d===void 0||d.bias===void 0?p=[0,0,0,0]:typeof d.bias==\"number\"?p=[d.bias,d.bias,d.bias,d.bias]:(p=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(p[3]=d.bias[3]));let f=a*o,h=0,y=f,_=f*2,b=-1;s===\"RGBA\"?(h=0,y=f,_=f*2,b=f*3):s===\"RGB\"?(h=0,y=f,_=f*2):s===\"RBG\"&&(h=0,_=f,y=f*2);for(let w=0;w<a;w++)for(let S=0;S<o;S++){let $=(e.data[h++]-p[0])*l[0],v=(e.data[y++]-p[1])*l[1],T=(e.data[_++]-p[2])*l[2],C=b===-1?255:(e.data[b++]-p[3])*l[3];r.fillStyle=\"rgba(\"+$+\",\"+v+\",\"+T+\",\"+C+\")\",r.fillRect(S,w,1,1)}if(\"toDataURL\"in n)return n.toDataURL();throw new Error(\"toDataURL is not supported\")}else throw new Error(\"Can not access image data\")},ja=(e,t)=>{let n=typeof document<\"u\"?document.createElement(\"canvas\").getContext(\"2d\"):new OffscreenCanvas(1,1).getContext(\"2d\"),r;if(n!=null){let o,a,s;t?.tensorLayout!==void 0&&t.tensorLayout===\"NHWC\"?(o=e.dims[2],a=e.dims[1],s=e.dims[3]):(o=e.dims[3],a=e.dims[2],s=e.dims[1]);let d=t!==void 0&&t.format!==void 0?t.format:\"RGB\",l=t?.norm,p,f;l===void 0||l.mean===void 0?p=[255,255,255,255]:typeof l.mean==\"number\"?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],l.mean[3]!==void 0&&(p[3]=l.mean[3])),l===void 0||l.bias===void 0?f=[0,0,0,0]:typeof l.bias==\"number\"?f=[l.bias,l.bias,l.bias,l.bias]:(f=[l.bias[0],l.bias[1],l.bias[2],0],l.bias[3]!==void 0&&(f[3]=l.bias[3]));let h=a*o;if(t!==void 0&&(t.format!==void 0&&s===4&&t.format!==\"RGBA\"||s===3&&t.format!==\"RGB\"&&t.format!==\"BGR\"))throw new Error(\"Tensor format doesn't match input tensor dims\");let y=4,_=0,b=1,w=2,S=3,$=0,v=h,T=h*2,C=-1;d===\"RGBA\"?($=0,v=h,T=h*2,C=h*3):d===\"RGB\"?($=0,v=h,T=h*2):d===\"RBG\"&&($=0,T=h,v=h*2),r=n.createImageData(o,a);for(let A=0;A<a*o;_+=y,b+=y,w+=y,S+=y,A++)r.data[_]=(e.data[$++]-f[0])*p[0],r.data[b]=(e.data[v++]-f[1])*p[1],r.data[w]=(e.data[T++]-f[2])*p[2],r.data[S]=C===-1?255:(e.data[C++]-f[3])*p[3]}else throw new Error(\"Can not access image data\");return r}});var Ln,Qa,Ya,Xa,Ja,es,ts=G(()=>{\"use strict\";wr();Ln=(e,t)=>{if(e===void 0)throw new Error(\"Image buffer must be defined\");if(t.height===void 0||t.width===void 0)throw new Error(\"Image height and width must be defined\");if(t.tensorLayout===\"NHWC\")throw new Error(\"NHWC Tensor layout is not supported yet\");let{height:n,width:r}=t,o=t.norm??{mean:255,bias:0},a,s;typeof o.mean==\"number\"?a=[o.mean,o.mean,o.mean,o.mean]:a=[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],typeof o.bias==\"number\"?s=[o.bias,o.bias,o.bias,o.bias]:s=[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let d=t.format!==void 0?t.format:\"RGBA\",l=t.tensorFormat!==void 0&&t.tensorFormat!==void 0?t.tensorFormat:\"RGB\",p=n*r,f=l===\"RGBA\"?new Float32Array(p*4):new Float32Array(p*3),h=4,y=0,_=1,b=2,w=3,S=0,$=p,v=p*2,T=-1;d===\"RGB\"&&(h=3,y=0,_=1,b=2,w=-1),l===\"RGBA\"?T=p*3:l===\"RBG\"?(S=0,v=p,$=p*2):l===\"BGR\"&&(v=0,$=p,S=p*2);for(let A=0;A<p;A++,y+=h,b+=h,_+=h,w+=h)f[S++]=(e[y]+s[0])/a[0],f[$++]=(e[_]+s[1])/a[1],f[v++]=(e[b]+s[2])/a[2],T!==-1&&w!==-1&&(f[T++]=(e[w]+s[3])/a[3]);return l===\"RGBA\"?new De(\"float32\",f,[1,4,n,r]):new De(\"float32\",f,[1,3,n,r])},Qa=async(e,t)=>{let n=typeof HTMLImageElement<\"u\"&&e instanceof HTMLImageElement,r=typeof ImageData<\"u\"&&e instanceof ImageData,o=typeof ImageBitmap<\"u\"&&e instanceof ImageBitmap,a=typeof e==\"string\",s,d=t??{},l=()=>{if(typeof document<\"u\")return document.createElement(\"canvas\");if(typeof OffscreenCanvas<\"u\")return new OffscreenCanvas(1,1);throw new Error(\"Canvas is not supported\")},p=f=>typeof HTMLCanvasElement<\"u\"&&f instanceof HTMLCanvasElement||f instanceof OffscreenCanvas?f.getContext(\"2d\"):null;if(n){let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;if(t!==void 0&&t.resizedHeight!==void 0&&t.resizedWidth!==void 0&&(y=t.resizedHeight,_=t.resizedWidth),t!==void 0){if(d=t,t.tensorFormat!==void 0)throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");d.tensorFormat=\"RGBA\",d.height=y,d.width=_}else d.tensorFormat=\"RGBA\",d.height=y,d.width=_;h.drawImage(e,0,0),s=h.getImageData(0,0,_,y).data}else throw new Error(\"Can not access image data\")}else if(r){let f,h;if(t!==void 0&&t.resizedWidth!==void 0&&t.resizedHeight!==void 0?(f=t.resizedHeight,h=t.resizedWidth):(f=e.height,h=e.width),t!==void 0&&(d=t),d.format=\"RGBA\",d.height=f,d.width=h,t!==void 0){let y=l();y.width=h,y.height=f;let _=p(y);if(_!=null)_.putImageData(e,0,0),s=_.getImageData(0,0,h,f).data;else throw new Error(\"Can not access image data\")}else s=e.data}else if(o){if(t===void 0)throw new Error(\"Please provide image config with format for Imagebitmap\");let f=l();f.width=e.width,f.height=e.height;let h=p(f);if(h!=null){let y=e.height,_=e.width;return h.drawImage(e,0,0,_,y),s=h.getImageData(0,0,_,y).data,d.height=y,d.width=_,Ln(s,d)}else throw new Error(\"Can not access image data\")}else{if(a)return new Promise((f,h)=>{let y=l(),_=p(y);if(!e||!_)return h();let b=new Image;b.crossOrigin=\"Anonymous\",b.src=e,b.onload=()=>{y.width=b.width,y.height=b.height,_.drawImage(b,0,0,y.width,y.height);let w=_.getImageData(0,0,y.width,y.height);d.height=y.height,d.width=y.width,f(Ln(w.data,d))}});throw new Error(\"Input data provided is not supported - aborted tensor creation\")}if(s!==void 0)return Ln(s,d);throw new Error(\"Input data provided is not supported - aborted tensor creation\")},Ya=(e,t)=>{let{width:n,height:r,download:o,dispose:a}=t,s=[1,r,n,4];return new De({location:\"texture\",type:\"float32\",texture:e,dims:s,download:o,dispose:a})},Xa=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"gpu-buffer\",type:n??\"float32\",gpuBuffer:e,dims:r,download:o,dispose:a})},Ja=(e,t)=>{let{dataType:n,dims:r,download:o,dispose:a}=t;return new De({location:\"ml-tensor\",type:n??\"float32\",mlTensor:e,dims:r,download:o,dispose:a})},es=(e,t,n)=>new De({location:\"cpu-pinned\",type:e,data:t,dims:n??[t.length]})});var It,Qt,rs,ns,os=G(()=>{\"use strict\";It=new Map([[\"float32\",Float32Array],[\"uint8\",Uint8Array],[\"int8\",Int8Array],[\"uint16\",Uint16Array],[\"int16\",Int16Array],[\"int32\",Int32Array],[\"bool\",Uint8Array],[\"float64\",Float64Array],[\"uint32\",Uint32Array],[\"int4\",Uint8Array],[\"uint4\",Uint8Array]]),Qt=new Map([[Float32Array,\"float32\"],[Uint8Array,\"uint8\"],[Int8Array,\"int8\"],[Uint16Array,\"uint16\"],[Int16Array,\"int16\"],[Int32Array,\"int32\"],[Float64Array,\"float64\"],[Uint32Array,\"uint32\"]]),rs=!1,ns=()=>{if(!rs){rs=!0;let e=typeof BigInt64Array<\"u\"&&BigInt64Array.from,t=typeof BigUint64Array<\"u\"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<\"u\"&&n.from;e&&(It.set(\"int64\",BigInt64Array),Qt.set(BigInt64Array,\"int64\")),t&&(It.set(\"uint64\",BigUint64Array),Qt.set(BigUint64Array,\"uint64\")),r?(It.set(\"float16\",n),Qt.set(n,\"float16\")):It.set(\"float16\",Uint16Array)}}});var is,as,ss=G(()=>{\"use strict\";wr();is=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!=\"number\"||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},as=(e,t)=>{switch(e.location){case\"cpu\":return new De(e.type,e.data,t);case\"cpu-pinned\":return new De({location:\"cpu-pinned\",data:e.data,type:e.type,dims:t});case\"texture\":return new De({location:\"texture\",texture:e.texture,type:e.type,dims:t});case\"gpu-buffer\":return new De({location:\"gpu-buffer\",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case\"ml-tensor\":return new De({location:\"ml-tensor\",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}});var De,wr=G(()=>{\"use strict\";Za();ts();os();ss();De=class{constructor(t,n,r){ns();let o,a;if(typeof t==\"object\"&&\"location\"in t)switch(this.dataLocation=t.location,o=t.type,a=t.dims,t.location){case\"cpu-pinned\":{let d=It.get(o);if(!d)throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);if(!(t.data instanceof d))throw new TypeError(`buffer should be of type ${d.name}`);this.cpuData=t.data;break}case\"texture\":{if(o!==\"float32\")throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case\"gpu-buffer\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case\"ml-tensor\":{if(o!==\"float32\"&&o!==\"float16\"&&o!==\"int32\"&&o!==\"int64\"&&o!==\"uint32\"&&o!==\"uint64\"&&o!==\"int8\"&&o!==\"uint8\"&&o!==\"bool\"&&o!==\"uint4\"&&o!==\"int4\")throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let d,l;if(typeof t==\"string\")if(o=t,l=r,t===\"string\"){if(!Array.isArray(n))throw new TypeError(\"A string tensor's data must be a string array.\");d=n}else{let p=It.get(t);if(p===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(n)){if(t===\"float16\"&&p===Uint16Array||t===\"uint4\"||t===\"int4\")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);t===\"uint64\"||t===\"int64\"?d=p.from(n,BigInt):d=p.from(n)}else if(n instanceof p)d=n;else if(n instanceof Uint8ClampedArray)if(t===\"uint8\")d=Uint8Array.from(n);else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");else if(t===\"float16\"&&n instanceof Uint16Array&&p!==Uint16Array)d=new globalThis.Float16Array(n.buffer,n.byteOffset,n.length);else throw new TypeError(`A ${o} tensor's data must be type of ${p}`)}else if(l=n,Array.isArray(t)){if(t.length===0)throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");let p=typeof t[0];if(p===\"string\")o=\"string\",d=t;else if(p===\"boolean\")o=\"bool\",d=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${p}.`)}else if(t instanceof Uint8ClampedArray)o=\"uint8\",d=Uint8Array.from(t);else{let p=Qt.get(t.constructor);if(p===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);o=p,d=t}if(l===void 0)l=[d.length];else if(!Array.isArray(l))throw new TypeError(\"A tensor's dims must be a number array\");a=l,this.cpuData=d,this.dataLocation=\"cpu\"}let s=is(a);if(this.cpuData&&s!==this.cpuData.length&&!((o===\"uint4\"||o===\"int4\")&&Math.ceil(s/2)===this.cpuData.length))throw new Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=a,this.size=s}static async fromImage(t,n){return Qa(t,n)}static fromTexture(t,n){return Ya(t,n)}static fromGpuBuffer(t,n){return Xa(t,n)}static fromMLTensor(t,n){return Ja(t,n)}static fromPinnedBuffer(t,n,r){return es(t,n,r)}toDataURL(t){return Ka(this,t)}toImageData(t){return ja(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error(\"The data is not stored as a WebGL texture.\");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error(\"The data is not stored as a WebGPU buffer.\");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error(\"The data is not stored as a WebNN MLTensor.\");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case\"cpu\":case\"cpu-pinned\":return this.data;case\"texture\":case\"gpu-buffer\":case\"ml-tensor\":{if(!this.downloader)throw new Error(\"The current tensor is not created with a specified data downloader.\");if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation=\"cpu\",this.cpuData=n,t&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error(\"The current tensor is being downloaded.\");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation=\"none\"}ensureValid(){if(this.dataLocation===\"none\")throw new Error(\"The tensor is disposed.\")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");return as(this,t)}}});var qe,Gn=G(()=>{\"use strict\";wr();qe=De});var vr,us,Ne,Be,Hn=G(()=>{\"use strict\";Wn();vr=(e,t)=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},us=(e,t)=>{let n=new Error().stack?.split(/\\r\\n|\\r|\\n/g)||[],r=!1;for(let o=0;o<n.length;o++){if(r&&!n[o].includes(\"TRACE_FUNC\")){let a=`FUNC_${e}::${n[o].trim().split(\" \")[1]}`;t&&(a+=`::${t}`),vr(\"CPU\",a);return}n[o].includes(\"TRACE_FUNC\")&&(r=!0)}},Ne=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"BEGIN\",e)},Be=e=>{(typeof Ue.trace>\"u\"?!Ue.wasm.trace:!Ue.trace)||us(\"END\",e)}});var $r,ds=G(()=>{\"use strict\";Vn();Gn();Hn();$r=class e{constructor(t){this.handler=t}async run(t,n,r){Ne();let o={},a={};if(typeof t!=\"object\"||t===null||t instanceof qe||Array.isArray(t))throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");let s=!0;if(typeof n==\"object\"){if(n===null)throw new TypeError(\"Unexpected argument[1]: cannot be null.\");if(n instanceof qe)throw new TypeError(\"'fetches' cannot be a Tensor\");if(Array.isArray(n)){if(n.length===0)throw new TypeError(\"'fetches' cannot be an empty array.\");s=!1;for(let p of n){if(typeof p!=\"string\")throw new TypeError(\"'fetches' must be a string array or an object.\");if(this.outputNames.indexOf(p)===-1)throw new RangeError(`'fetches' contains invalid output name: ${p}.`);o[p]=null}if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else{let p=!1,f=Object.getOwnPropertyNames(n);for(let h of this.outputNames)if(f.indexOf(h)!==-1){let y=n[h];(y===null||y instanceof qe)&&(p=!0,s=!1,o[h]=y)}if(p){if(typeof r==\"object\"&&r!==null)a=r;else if(typeof r<\"u\")throw new TypeError(\"'options' must be an object.\")}else a=n}}else if(typeof n<\"u\")throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");for(let p of this.inputNames)if(typeof t[p]>\"u\")throw new Error(`input '${p}' is missing in 'feeds'.`);if(s)for(let p of this.outputNames)o[p]=null;let d=await this.handler.run(t,o,a),l={};for(let p in d)if(Object.hasOwnProperty.call(d,p)){let f=d[p];f instanceof qe?l[p]=f:l[p]=new qe(f.type,f.data,f.dims)}return Be(),l}async release(){return this.handler.dispose()}static async create(t,n,r,o){Ne();let a,s={};if(typeof t==\"string\"){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof Uint8Array){if(a=t,typeof n==\"object\"&&n!==null)s=n;else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<\"u\"&&t instanceof SharedArrayBuffer){let f=t,h=0,y=t.byteLength;if(typeof n==\"object\"&&n!==null)s=n;else if(typeof n==\"number\"){if(h=n,!Number.isSafeInteger(h))throw new RangeError(\"'byteOffset' must be an integer.\");if(h<0||h>=f.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${f.byteLength}).`);if(y=t.byteLength-h,typeof r==\"number\"){if(y=r,!Number.isSafeInteger(y))throw new RangeError(\"'byteLength' must be an integer.\");if(y<=0||h+y>f.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${f.byteLength-h}].`);if(typeof o==\"object\"&&o!==null)s=o;else if(typeof o<\"u\")throw new TypeError(\"'options' must be an object.\")}else if(typeof r<\"u\")throw new TypeError(\"'byteLength' must be a number.\")}else if(typeof n<\"u\")throw new TypeError(\"'options' must be an object.\");a=new Uint8Array(f,h,y)}else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");let[d,l]=await Wa(s),p=await d.createInferenceSessionHandler(a,l);return Be(),new e(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}});var Of,ls=G(()=>{\"use strict\";ds();Of=$r});var cs=G(()=>{\"use strict\"});var ps=G(()=>{\"use strict\"});var ms=G(()=>{\"use strict\"});var fs=G(()=>{\"use strict\"});var Fn={};Zt(Fn,{InferenceSession:()=>Of,TRACE:()=>vr,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>Be,Tensor:()=>qe,env:()=>we,registerBackend:()=>Ct});var Ge=G(()=>{\"use strict\";La();qa();ls();Gn();cs();ps();Hn();ms();fs()});var xr=G(()=>{\"use strict\"});var bs={};Zt(bs,{default:()=>Df});var gs,ys,Df,_s=G(()=>{\"use strict\";qn();bt();Sr();gs=\"ort-wasm-proxy-worker\",ys=globalThis.self?.name===gs;ys&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case\"init-wasm\":Tr(n.wasm).then(()=>{Cr(n).then(()=>{postMessage({type:t})},r=>{postMessage({type:t,err:r})})},r=>{postMessage({type:t,err:r})});break;case\"init-ep\":{let{epName:r,env:o}=n;Ir(o,r).then(()=>{postMessage({type:t})},a=>{postMessage({type:t,err:a})});break}case\"copy-from\":{let{buffer:r}=n,o=Yt(r);postMessage({type:t,out:o});break}case\"create\":{let{model:r,options:o}=n;Ar(r,o).then(a=>{postMessage({type:t,out:a})},a=>{postMessage({type:t,err:a})});break}case\"release\":kr(n),postMessage({type:t});break;case\"run\":{let{sessionId:r,inputIndices:o,inputs:a,outputIndices:s,options:d}=n;Er(r,o,a,s,new Array(s.length).fill(null),d).then(l=>{l.some(p=>p[3]!==\"cpu\")?postMessage({type:t,err:\"Proxy does not support non-cpu tensor location.\"}):postMessage({type:t,out:l},zr([...a,...l]))},l=>{postMessage({type:t,err:l})});break}case\"end-profiling\":Pr(n),postMessage({type:t});break;default:}}catch(r){postMessage({type:t,err:r})}});Df=ys?null:e=>new Worker(e??Ve,{type:\"module\",name:gs})});var vs={};Zt(vs,{default:()=>Bf});var Kn,ws,Bf,Mf,$s=G(()=>{\"use strict\";ws=(Kn=\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\",async function(e={}){var t,n,r=e,o=new Promise((i,u)=>{t=i,n=u}),a=typeof window==\"object\",s=typeof WorkerGlobalScope<\"u\",d=s&&self.name?.startsWith(\"em-pthread\");r.mountExternalData=(i,u)=>{i.startsWith(\"./\")&&(i=i.substring(2)),(r.Bd||(r.Bd=new Map)).set(i,u)},r.unmountExternalData=()=>{delete r.Bd};var l=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let p=()=>{let i=(c,m,g)=>(...x)=>{let I=Je,z=m?.();x=c(...x);let B=m?.();return z!==B&&(c=B,g(z),m=g=null),Je!=I?new Promise((L,q)=>{En={resolve:L,reject:q}}):x},u=c=>async(...m)=>{try{if(r.Cd)throw Error(\"Session already started\");let g=r.Cd={be:m[0],errors:[]},x=await c(...m);if(r.Cd!==g)throw Error(\"Session mismatch\");r.Dd?.flush();let I=g.errors;if(0<I.length){let z=await Promise.all(I);if(z=z.filter(B=>B),0<z.length)throw Error(z.join(`\n`))}return x}finally{r.Cd=null}};r._OrtCreateSession=i(r._OrtCreateSession,()=>r._OrtCreateSession,c=>r._OrtCreateSession=c),r._OrtRun=u(i(r._OrtRun,()=>r._OrtRun,c=>r._OrtRun=c)),r._OrtRunWithBinding=u(i(r._OrtRunWithBinding,()=>r._OrtRunWithBinding,c=>r._OrtRunWithBinding=c)),r._OrtBindInput=i(r._OrtBindInput,()=>r._OrtBindInput,c=>r._OrtBindInput=c),p=void 0};r.jsepInit=(i,u)=>{if(p?.(),i===\"webgpu\"){[r.Dd,r.Rd,r.Vd,r.Hd,r.Ud,r.hc,r.Wd,r.Zd,r.Sd,r.Td,r.Xd]=u;let c=r.Dd;r.jsepRegisterBuffer=(m,g,x,I)=>c.registerBuffer(m,g,x,I),r.jsepGetBuffer=m=>c.getBuffer(m),r.jsepCreateDownloader=(m,g,x)=>c.createDownloader(m,g,x),r.jsepOnCreateSession=m=>{c.onCreateSession(m)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepOnRunStart=m=>c.onRunStart(m),r.$d=(m,g)=>{c.upload(m,g)}}else if(i===\"webnn\"){[r.Dd,r.Yd,r.Id,r.jsepEnsureTensor,r.Jd,r.jsepDownloadTensor]=u,r.jsepReleaseTensorId=r.Id,r.jsepUploadTensor=r.Jd;let c=r.Dd;r.jsepOnRunStart=m=>c.onRunStart(m),r.jsepOnRunEnd=c.onRunEnd.bind(c),r.jsepRegisterMLContext=(m,g)=>{c.registerMLContext(m,g)},r.jsepOnReleaseSession=m=>{c.onReleaseSession(m)},r.jsepCreateMLTensorDownloader=(m,g)=>c.createMLTensorDownloader(m,g),r.jsepRegisterMLTensor=(m,g,x,I)=>c.registerMLTensor(m,g,x,I),r.jsepCreateMLContext=m=>c.createMLContext(m),r.jsepRegisterMLConstant=(m,g,x,I,z)=>c.registerMLConstant(m,g,x,I,z,r.Bd),r.jsepRegisterGraphInput=c.registerGraphInput.bind(c),r.jsepIsGraphInput=c.isGraphInput.bind(c),r.jsepCreateTemporaryTensor=c.createTemporaryTensor.bind(c)}};var f,h,y=Object.assign({},r),_=(i,u)=>{throw u},b=\"\";(a||s)&&(s?b=self.location.href:typeof document<\"u\"&&document.currentScript&&(b=document.currentScript.src),Kn&&(b=Kn),b=b.startsWith(\"blob:\")?\"\":b.slice(0,b.replace(/[?#].*/,\"\").lastIndexOf(\"/\")+1),s&&(h=i=>{var u=new XMLHttpRequest;return u.open(\"GET\",i,!1),u.responseType=\"arraybuffer\",u.send(null),new Uint8Array(u.response)}),f=async i=>{if(le(i))return new Promise((c,m)=>{var g=new XMLHttpRequest;g.open(\"GET\",i,!0),g.responseType=\"arraybuffer\",g.onload=()=>{g.status==200||g.status==0&&g.response?c(g.response):m(g.status)},g.onerror=m,g.send(null)});var u=await fetch(i,{credentials:\"same-origin\"});if(u.ok)return u.arrayBuffer();throw Error(u.status+\" : \"+u.url)});var w=console.log.bind(console),S=console.error.bind(console),$=w,v=S;Object.assign(r,y),y=null;var T,C,A,k,O,M,V,F,j,ne,W,J,ve,Q=r.wasmBinary,ee=!1,le=i=>i.startsWith(\"file://\");function Z(){return T.buffer!=k.buffer&&be(),k}function pe(){return T.buffer!=k.buffer&&be(),O}function ke(){return T.buffer!=k.buffer&&be(),M}function Se(){return T.buffer!=k.buffer&&be(),V}function D(){return T.buffer!=k.buffer&&be(),F}function R(){return T.buffer!=k.buffer&&be(),j}function Y(){return T.buffer!=k.buffer&&be(),ne}function fe(){return T.buffer!=k.buffer&&be(),ve}if(d){let i=function(u){try{var c=u.data,m=c.yd;if(m===\"load\"){let g=[];self.onmessage=x=>g.push(x),self.startWorker=()=>{postMessage({yd:\"loaded\"});for(let x of g)i(x);self.onmessage=i};for(let x of c.Od)r[x]&&!r[x].proxy||(r[x]=(...I)=>{postMessage({yd:\"callHandler\",Nd:x,args:I})},x==\"print\"&&($=r[x]),x==\"printErr\"&&(v=r[x]));T=c.he,be(),Fe(c.ie)}else if(m===\"run\"){cp(c.xd),Dn(c.xd,0,0,1,0,0),Lo(),An(c.xd),xe||(Mi(),xe=!0);try{pp(c.de,c.Fd)}catch(g){if(g!=\"unwind\")throw g}}else c.target!==\"setimmediate\"&&(m===\"checkMailbox\"?xe&&ur():m&&(v(`worker: received unknown command ${m}`),v(c)))}catch(g){throw Ri(),g}};var ub=i,Fe,xe=!1;v=function(...u){u=u.join(\" \"),console.error(u)},self.alert=function(...u){postMessage({yd:\"alert\",text:u.join(\" \"),fe:gr()})},self.onunhandledrejection=u=>{throw u.reason||u},self.onmessage=i}function be(){var i=T.buffer;r.HEAP8=k=new Int8Array(i),r.HEAP16=M=new Int16Array(i),r.HEAPU8=O=new Uint8Array(i),r.HEAPU16=V=new Uint16Array(i),r.HEAP32=F=new Int32Array(i),r.HEAPU32=j=new Uint32Array(i),r.HEAPF32=ne=new Float32Array(i),r.HEAPF64=ve=new Float64Array(i),r.HEAP64=W=new BigInt64Array(i),r.HEAPU64=J=new BigUint64Array(i)}function Ye(){d?startWorker(r):U.Bb()}d||(T=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),be());var Gt,xt=0,Ht=null;function Bo(){if(--xt==0&&Ht){var i=Ht;Ht=null,i()}}function ut(i){throw v(i=\"Aborted(\"+i+\")\"),ee=!0,i=new WebAssembly.RuntimeError(i+\". Build with -sASSERTIONS for more info.\"),n(i),i}function Mo(){return{a:{Ta:lp,Va:dp,W:mp,la:fp,b:gp,u:yp,R:bp,Za:_p,d:wp,pb:qo,g:hp,T:Zo,Ga:Qo,lb:Xo,nb:Jo,Ha:ei,Ea:ti,wb:ri,Da:ni,pa:oi,mb:ii,jb:ai,Fa:si,kb:ui,Ma:vp,za:xp,eb:Sp,cb:Cp,ya:Ap,V:kp,N:Ep,db:Pp,ma:Up,fb:Np,zb:Vp,hb:Wp,qb:Lp,ab:Gp,Aa:Hp,yb:An,Ja:Fp,S:qp,Wa:Kp,$:Qp,G:Yp,E:Jp,m:Tn,H:em,B:nm,X:om,J:im,v:am,O:sm,D:um,t:dm,A:lm,z:cm,w:pm,r:mm,tb:fm,ub:hm,vb:gm,rb:$i,sb:xi,bb:Si,Oa:bm,La:vm,y:$m,ja:xm,Ba:Sm,Ka:_m,qa:Tm,Ia:Cm,ib:Im,U:ym,fa:Am,Sa:km,gb:Em,Qa:Pm,Pa:zm,Ab:Ai,Ca:ki,ob:_n,aa:Ei,oa:Pi,xb:zi,na:Oi,$a:af,ia:_f,sa:Sf,ga:nf,da:pf,ua:$f,p:tf,e:Nm,c:Rm,ea:lf,f:Vm,n:Lm,k:Ym,Y:Hm,ka:Xm,j:rf,wa:df,Ra:If,ca:yf,Ua:Cf,P:cf,K:qm,_:gf,Q:of,Z:wf,x:Fm,l:Um,va:hf,i:Mm,h:Gm,ra:Tf,ta:xf,o:Wm,q:Km,s:Zm,I:Qm,C:ef,L:Jm,xa:uf,_a:sf,F:bf,Ya:mf,ba:vf,M:jm,Xa:ff,ha:Dm,a:T,Na:bn}}}var hn={1319426:()=>typeof wasmOffsetConverter<\"u\",1319483:(i,u,c,m,g)=>{if(r===void 0||!r.Bd)return 1;if((i=Ae(Number(i>>>0))).startsWith(\"./\")&&(i=i.substring(2)),!(i=r.Bd.get(i)))return 2;if(u=Number(u>>>0),c=Number(c>>>0),m=Number(m>>>0),u+c>i.byteLength)return 3;try{let x=i.subarray(u,u+c);switch(g){case 0:pe().set(x,m>>>0);break;case 1:r.$d(m,x);break;default:return 4}return 0}catch{return 4}},1320198:(i,u,c)=>{r.Jd(i,pe().subarray(u>>>0,u+c>>>0))},1320261:()=>r.Yd(),1320302:i=>{r.Id(i)},1320338:()=>{r.Sd()},1320369:()=>{r.Td()},1320398:()=>{r.Xd()},1320423:i=>r.Rd(i),1320456:i=>r.Vd(i),1320488:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c),!0)},1320551:(i,u,c)=>{r.Hd(Number(i),Number(u),Number(c))},1320608:i=>{r.hc(\"Abs\",i,void 0)},1320659:i=>{r.hc(\"Neg\",i,void 0)},1320710:i=>{r.hc(\"Floor\",i,void 0)},1320763:i=>{r.hc(\"Ceil\",i,void 0)},1320815:i=>{r.hc(\"Reciprocal\",i,void 0)},1320873:i=>{r.hc(\"Sqrt\",i,void 0)},1320925:i=>{r.hc(\"Exp\",i,void 0)},1320976:i=>{r.hc(\"Erf\",i,void 0)},1321027:i=>{r.hc(\"Sigmoid\",i,void 0)},1321082:(i,u,c)=>{r.hc(\"HardSigmoid\",i,{alpha:u,beta:c})},1321161:i=>{r.hc(\"Log\",i,void 0)},1321212:i=>{r.hc(\"Sin\",i,void 0)},1321263:i=>{r.hc(\"Cos\",i,void 0)},1321314:i=>{r.hc(\"Tan\",i,void 0)},1321365:i=>{r.hc(\"Asin\",i,void 0)},1321417:i=>{r.hc(\"Acos\",i,void 0)},1321469:i=>{r.hc(\"Atan\",i,void 0)},1321521:i=>{r.hc(\"Sinh\",i,void 0)},1321573:i=>{r.hc(\"Cosh\",i,void 0)},1321625:i=>{r.hc(\"Asinh\",i,void 0)},1321678:i=>{r.hc(\"Acosh\",i,void 0)},1321731:i=>{r.hc(\"Atanh\",i,void 0)},1321784:i=>{r.hc(\"Tanh\",i,void 0)},1321836:i=>{r.hc(\"Not\",i,void 0)},1321887:(i,u,c)=>{r.hc(\"Clip\",i,{min:u,max:c})},1321956:i=>{r.hc(\"Clip\",i,void 0)},1322008:(i,u)=>{r.hc(\"Elu\",i,{alpha:u})},1322066:i=>{r.hc(\"Gelu\",i,void 0)},1322118:i=>{r.hc(\"Relu\",i,void 0)},1322170:(i,u)=>{r.hc(\"LeakyRelu\",i,{alpha:u})},1322234:(i,u)=>{r.hc(\"ThresholdedRelu\",i,{alpha:u})},1322304:(i,u)=>{r.hc(\"Cast\",i,{to:u})},1322362:i=>{r.hc(\"Add\",i,void 0)},1322413:i=>{r.hc(\"Sub\",i,void 0)},1322464:i=>{r.hc(\"Mul\",i,void 0)},1322515:i=>{r.hc(\"Div\",i,void 0)},1322566:i=>{r.hc(\"Pow\",i,void 0)},1322617:i=>{r.hc(\"Equal\",i,void 0)},1322670:i=>{r.hc(\"Greater\",i,void 0)},1322725:i=>{r.hc(\"GreaterOrEqual\",i,void 0)},1322787:i=>{r.hc(\"Less\",i,void 0)},1322839:i=>{r.hc(\"LessOrEqual\",i,void 0)},1322898:(i,u,c,m,g)=>{r.hc(\"ReduceMean\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323073:(i,u,c,m,g)=>{r.hc(\"ReduceMax\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323247:(i,u,c,m,g)=>{r.hc(\"ReduceMin\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323421:(i,u,c,m,g)=>{r.hc(\"ReduceProd\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323596:(i,u,c,m,g)=>{r.hc(\"ReduceSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323770:(i,u,c,m,g)=>{r.hc(\"ReduceL1\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1323943:(i,u,c,m,g)=>{r.hc(\"ReduceL2\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324116:(i,u,c,m,g)=>{r.hc(\"ReduceLogSum\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324293:(i,u,c,m,g)=>{r.hc(\"ReduceSumSquare\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324473:(i,u,c,m,g)=>{r.hc(\"ReduceLogSumExp\",i,{keepDims:!!u,noopWithEmptyAxes:!!c,axes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1324653:i=>{r.hc(\"Where\",i,void 0)},1324706:(i,u,c)=>{r.hc(\"Transpose\",i,{perm:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[]})},1324830:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1324963:(i,u,c,m)=>{r.hc(\"DepthToSpace\",i,{blocksize:u,mode:Ae(c),format:m?\"NHWC\":\"NCHW\"})},1325096:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1325529:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1326190:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le)=>{r.hc(\"ConvTranspose\",i,{format:B?\"NHWC\":\"NCHW\",autoPad:u,dilations:[c],group:m,kernelShape:[g],pads:[x,I],strides:[z],wIsConst:()=>!!Z()[L>>>0],outputPadding:q?Array.from(D().subarray(Number(q)>>>0,Number(X)>>>0)):[],outputShape:ue?Array.from(D().subarray(Number(ue)>>>0,Number($e)>>>0)):[],activation:Ae(Le)})},1326623:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"ConvTranspose\",i,{format:z?\"NHWC\":\"NCHW\",autoPad:u,dilations:Array.from(D().subarray(Number(c)>>>0,2+(Number(c)>>>0)>>>0)),group:m,kernelShape:Array.from(D().subarray(Number(g)>>>0,2+(Number(g)>>>0)>>>0)),pads:Array.from(D().subarray(Number(x)>>>0,4+(Number(x)>>>0)>>>0)),strides:Array.from(D().subarray(Number(I)>>>0,2+(Number(I)>>>0)>>>0)),wIsConst:()=>!!Z()[B>>>0],outputPadding:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],outputShape:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[],activation:Ae($e)})},1327284:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327375:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1327854:(i,u)=>{r.hc(\"GlobalAveragePool\",i,{format:u?\"NHWC\":\"NCHW\"})},1327945:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"AveragePool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328424:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1328511:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1328986:(i,u)=>{r.hc(\"GlobalMaxPool\",i,{format:u?\"NHWC\":\"NCHW\"})},1329073:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>{r.hc(\"MaxPool\",i,{format:$e?\"NHWC\":\"NCHW\",auto_pad:u,ceil_mode:c,count_include_pad:m,storage_order:g,dilations:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],kernel_shape:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],pads:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],strides:X?Array.from(D().subarray(Number(X)>>>0,Number(ue)>>>0)):[]})},1329548:(i,u,c,m,g)=>{r.hc(\"Gemm\",i,{alpha:u,beta:c,transA:m,transB:g})},1329652:i=>{r.hc(\"MatMul\",i,void 0)},1329706:(i,u,c,m)=>{r.hc(\"ArgMax\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329814:(i,u,c,m)=>{r.hc(\"ArgMin\",i,{keepDims:!!u,selectLastIndex:!!c,axis:m})},1329922:(i,u)=>{r.hc(\"Softmax\",i,{axis:u})},1329985:(i,u)=>{r.hc(\"Concat\",i,{axis:u})},1330045:(i,u,c,m,g)=>{r.hc(\"Split\",i,{axis:u,numOutputs:c,splitSizes:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1330201:i=>{r.hc(\"Expand\",i,void 0)},1330255:(i,u)=>{r.hc(\"Gather\",i,{axis:Number(u)})},1330326:(i,u)=>{r.hc(\"GatherElements\",i,{axis:Number(u)})},1330405:(i,u)=>{r.hc(\"GatherND\",i,{batch_dims:Number(u)})},1330484:(i,u,c,m,g,x,I,z,B,L,q)=>{r.hc(\"Resize\",i,{antialias:u,axes:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],coordinateTransformMode:Ae(g),cubicCoeffA:x,excludeOutside:I,extrapolationValue:z,keepAspectRatioPolicy:Ae(B),mode:Ae(L),nearestMode:Ae(q)})},1330846:(i,u,c,m,g,x,I)=>{r.hc(\"Slice\",i,{starts:u?Array.from(D().subarray(Number(u)>>>0,Number(c)>>>0)):[],ends:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[],axes:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[]})},1331110:i=>{r.hc(\"Tile\",i,void 0)},1331162:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331276:(i,u,c)=>{r.hc(\"InstanceNormalization\",i,{epsilon:u,format:c?\"NHWC\":\"NCHW\"})},1331390:i=>{r.hc(\"Range\",i,void 0)},1331443:(i,u)=>{r.hc(\"Einsum\",i,{equation:Ae(u)})},1331524:(i,u,c,m,g)=>{r.hc(\"Pad\",i,{mode:u,value:c,pads:m?Array.from(D().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},1331667:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1331836:(i,u,c,m,g,x)=>{r.hc(\"BatchNormalization\",i,{epsilon:u,momentum:c,spatial:!!g,trainingMode:!!m,format:x?\"NHWC\":\"NCHW\"})},1332005:(i,u,c)=>{r.hc(\"CumSum\",i,{exclusive:Number(u),reverse:Number(c)})},1332102:(i,u,c)=>{r.hc(\"DequantizeLinear\",i,{axis:u,blockSize:c})},1332192:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332362:(i,u,c,m,g)=>{r.hc(\"GridSample\",i,{align_corners:u,mode:Ae(c),padding_mode:Ae(m),format:g?\"NHWC\":\"NCHW\"})},1332532:(i,u)=>{r.hc(\"ScatterND\",i,{reduction:Ae(u)})},1332617:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"Attention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x,qkvHiddenSizes:I?Array.from(D().subarray(Number(z)>>>0,Number(z)+I>>>0)):[],pastPresentShareBuffer:!!B})},1332889:i=>{r.hc(\"BiasAdd\",i,void 0)},1332944:i=>{r.hc(\"BiasSplitGelu\",i,void 0)},1333005:i=>{r.hc(\"FastGelu\",i,void 0)},1333061:(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e,Le,jt)=>{r.hc(\"Conv\",i,{format:X?\"NHWC\":\"NCHW\",auto_pad:u,dilations:c?Array.from(D().subarray(Number(c)>>>0,Number(m)>>>0)):[],group:g,kernel_shape:x?Array.from(D().subarray(Number(x)>>>0,Number(I)>>>0)):[],pads:z?Array.from(D().subarray(Number(z)>>>0,Number(B)>>>0)):[],strides:L?Array.from(D().subarray(Number(L)>>>0,Number(q)>>>0)):[],w_is_const:()=>!!Z()[Number(ue)>>>0],activation:Ae($e),activation_params:Le?Array.from(Y().subarray(Number(Le)>>>0,Number(jt)>>>0)):[]})},1333645:i=>{r.hc(\"Gelu\",i,void 0)},1333697:(i,u,c,m,g,x,I,z,B)=>{r.hc(\"GroupQueryAttention\",i,{numHeads:u,kvNumHeads:c,scale:m,softcap:g,doRotary:x,rotaryInterleaved:I,smoothSoftmax:z,localWindowSize:B})},1333914:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334025:(i,u,c,m)=>{r.hc(\"LayerNormalization\",i,{axis:u,epsilon:c,simplified:!!m})},1334136:(i,u,c,m,g,x)=>{r.hc(\"MatMulNBits\",i,{k:u,n:c,accuracyLevel:m,bits:g,blockSize:x})},1334263:(i,u,c,m,g,x)=>{r.hc(\"MultiHeadAttention\",i,{numHeads:u,isUnidirectional:c,maskFilterValue:m,scale:g,doRotary:x})},1334422:(i,u)=>{r.hc(\"QuickGelu\",i,{alpha:u})},1334486:(i,u,c,m,g)=>{r.hc(\"RotaryEmbedding\",i,{interleaved:!!u,numHeads:c,rotaryEmbeddingDim:m,scale:g})},1334625:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334727:(i,u,c)=>{r.hc(\"SkipLayerNormalization\",i,{epsilon:u,simplified:!!c})},1334829:(i,u,c,m)=>{r.hc(\"GatherBlockQuantized\",i,{gatherAxis:u,quantizeAxis:c,blockSize:m})},1334950:i=>{r.Wd(i)},1334984:(i,u)=>r.Zd(Number(i),Number(u),r.Cd.be,r.Cd.errors)};function dp(i,u,c){return gi(async()=>{await r.Ud(Number(i),Number(u),Number(c))})}function lp(){return typeof wasmOffsetConverter<\"u\"}class gn{name=\"ExitStatus\";constructor(u){this.message=`Program terminated with exit(${u})`,this.status=u}}var Ro=i=>{i.terminate(),i.onmessage=()=>{}},yn=[],Uo=i=>{ft.length==0&&(Ho(),Go(ft[0]));var u=ft.pop();if(!u)return 6;Ft.push(u),St[i.xd]=u,u.xd=i.xd;var c={yd:\"run\",de:i.ce,Fd:i.Fd,xd:i.xd};return u.postMessage(c,i.Ld),0},mt=0,Te=(i,u,...c)=>{for(var m=2*c.length,g=ie(),x=Mn(8*m),I=x>>>3,z=0;z<c.length;z++){var B=c[z];typeof B==\"bigint\"?(W[I+2*z]=1n,W[I+2*z+1]=B):(W[I+2*z]=0n,fe()[I+2*z+1>>>0]=B)}return i=Ui(i,0,m,x,u),oe(g),i};function bn(i){if(d)return Te(0,1,i);if(A=i,!(0<mt)){for(var u of Ft)Ro(u);for(u of ft)Ro(u);ft=[],Ft=[],St={},ee=!0}_(0,new gn(i))}function No(i){if(d)return Te(1,0,i);_n(i)}var _n=i=>{if(A=i,d)throw No(i),\"unwind\";bn(i)},ft=[],Ft=[],Vo=[],St={},Wo=i=>{var u=i.xd;delete St[u],ft.push(i),Ft.splice(Ft.indexOf(i),1),i.xd=0,Ni(u)};function Lo(){Vo.forEach(i=>i())}var Go=i=>new Promise(u=>{i.onmessage=g=>{var x=(g=g.data).yd;if(g.Ed&&g.Ed!=gr()){var I=St[g.Ed];I?I.postMessage(g,g.Ld):v(`Internal error! Worker sent a message \"${x}\" to target pthread ${g.Ed}, but that thread no longer exists!`)}else x===\"checkMailbox\"?ur():x===\"spawnThread\"?Uo(g):x===\"cleanupThread\"?Wo(St[g.ee]):x===\"loaded\"?(i.loaded=!0,u(i)):x===\"alert\"?alert(`Thread ${g.fe}: ${g.text}`):g.target===\"setimmediate\"?i.postMessage(g):x===\"callHandler\"?r[g.Nd](...g.args):x&&v(`worker sent an unknown command ${x}`)},i.onerror=g=>{throw v(`worker sent an error! ${g.filename}:${g.lineno}: ${g.message}`),g};var c,m=[];for(c of[])r.propertyIsEnumerable(c)&&m.push(c);i.postMessage({yd:\"load\",Od:m,he:T,ie:C})});function Ho(){var i=new Worker(\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\")?/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?9165\")):new URL(\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"),{type:\"module\",workerData:\"em-pthread\",name:\"em-pthread\"});ft.push(i)}var cp=i=>{be();var u=R()[i+52>>>2>>>0];i=R()[i+56>>>2>>>0],Li(u,u-i),oe(u)},pp=(i,u)=>{mt=0,i=Rn(i,u),0<mt?A=i:Bn(i)},sr=[];function mp(i){var u=new wn(i>>>=0);if(Z()[u.wd+12>>>0]==0){var c=1;Z()[u.wd+12>>>0]=c}return c=0,Z()[u.wd+13>>>0]=c,sr.push(u),Hi(i),qi(i)}var Dt=0,fp=()=>{se(0,0);var i=sr.pop();Gi(i.Gd),Dt=0};class wn{constructor(u){this.Gd=u,this.wd=u-24}}function hp(i){throw Dt||=i>>>0,Dt}var vn=i=>{var u=Dt;if(!u)return Kt(0),0;var c=new wn(u);R()[c.wd+16>>>2>>>0]=u;var m=R()[c.wd+4>>>2>>>0];if(!m)return Kt(0),u;for(var g of i){if(g===0||g===m)break;if(Fi(g,m,c.wd+16))return Kt(g),u}return Kt(m),u};function gp(){return vn([])}function yp(i){return vn([i>>>0])}function bp(i,u){return vn([i>>>0,u>>>0])}var _p=()=>{var i=sr.pop();i||ut(\"no exception to throw\");var u=i.Gd;if(Z()[i.wd+13>>>0]==0){sr.push(i);var c=1;Z()[i.wd+13>>>0]=c,c=0,Z()[i.wd+12>>>0]=c}throw Dt=u};function wp(i,u,c){var m=new wn(i>>>=0);throw u>>>=0,c>>>=0,R()[m.wd+16>>>2>>>0]=0,R()[m.wd+4>>>2>>>0]=u,R()[m.wd+8>>>2>>>0]=c,Dt=i}function Fo(i,u,c,m){return d?Te(2,1,i,u,c,m):qo(i,u,c,m)}function qo(i,u,c,m){if(i>>>=0,c>>>=0,m>>>=0,l===void 0)return 6;var g=[];return d&&g.length===0?Fo(i,u>>>=0,c,m):(i={ce:c,xd:i,Fd:m,Ld:g},d?(i.yd=\"spawnThread\",postMessage(i,g),0):Uo(i))}var Ko=typeof TextDecoder<\"u\"?new TextDecoder:void 0,jo=(i,u=0,c=NaN)=>{var m=(u>>>=0)+c;for(c=u;i[c]&&!(c>=m);)++c;if(16<c-u&&i.buffer&&Ko)return Ko.decode(i.buffer instanceof ArrayBuffer?i.subarray(u,c):i.slice(u,c));for(m=\"\";u<c;){var g=i[u++];if(128&g){var x=63&i[u++];if((224&g)==192)m+=String.fromCharCode((31&g)<<6|x);else{var I=63&i[u++];65536>(g=(240&g)==224?(15&g)<<12|x<<6|I:(7&g)<<18|x<<12|I<<6|63&i[u++])?m+=String.fromCharCode(g):(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g))}}else m+=String.fromCharCode(g)}return m},Ae=(i,u)=>(i>>>=0)?jo(pe(),i,u):\"\";function Zo(i,u,c){return d?Te(3,1,i,u,c):0}function Qo(i,u){if(d)return Te(4,1,i,u)}var Yo=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);127>=m?u++:2047>=m?u+=2:55296<=m&&57343>=m?(u+=4,++c):u+=3}return u},Bt=(i,u,c)=>{var m=pe();if(u>>>=0,0<c){var g=u;c=u+c-1;for(var x=0;x<i.length;++x){var I=i.charCodeAt(x);if(55296<=I&&57343>=I&&(I=65536+((1023&I)<<10)|1023&i.charCodeAt(++x)),127>=I){if(u>=c)break;m[u++>>>0]=I}else{if(2047>=I){if(u+1>=c)break;m[u++>>>0]=192|I>>6}else{if(65535>=I){if(u+2>=c)break;m[u++>>>0]=224|I>>12}else{if(u+3>=c)break;m[u++>>>0]=240|I>>18,m[u++>>>0]=128|I>>12&63}m[u++>>>0]=128|I>>6&63}m[u++>>>0]=128|63&I}}m[u>>>0]=0,i=u-g}else i=0;return i};function Xo(i,u){if(d)return Te(5,1,i,u)}function Jo(i,u,c){if(d)return Te(6,1,i,u,c)}function ei(i,u,c){return d?Te(7,1,i,u,c):0}function ti(i,u){if(d)return Te(8,1,i,u)}function ri(i,u,c){if(d)return Te(9,1,i,u,c)}function ni(i,u,c,m){if(d)return Te(10,1,i,u,c,m)}function oi(i,u,c,m){if(d)return Te(11,1,i,u,c,m)}function ii(i,u,c,m){if(d)return Te(12,1,i,u,c,m)}function ai(i){if(d)return Te(13,1,i)}function si(i,u){if(d)return Te(14,1,i,u)}function ui(i,u,c){if(d)return Te(15,1,i,u,c)}var di,ht,vp=()=>ut(\"\"),Xe=i=>{for(var u=\"\";pe()[i>>>0];)u+=di[pe()[i++>>>0]];return u},$n={},xn={},$p={};function dt(i,u,c={}){return function(m,g,x={}){var I=g.name;if(!m)throw new ht(`type \"${I}\" must have a positive integer typeid pointer`);if(xn.hasOwnProperty(m)){if(x.Pd)return;throw new ht(`Cannot register type '${I}' twice`)}xn[m]=g,delete $p[m],$n.hasOwnProperty(m)&&(g=$n[m],delete $n[m],g.forEach(z=>z()))}(i,u,c)}var li=(i,u,c)=>{switch(u){case 1:return c?m=>Z()[m>>>0]:m=>pe()[m>>>0];case 2:return c?m=>ke()[m>>>1>>>0]:m=>Se()[m>>>1>>>0];case 4:return c?m=>D()[m>>>2>>>0]:m=>R()[m>>>2>>>0];case 8:return c?m=>W[m>>>3]:m=>J[m>>>3];default:throw new TypeError(`invalid integer width (${u}): ${i}`)}};function xp(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:function(m,g){if(typeof g!=\"bigint\"&&typeof g!=\"number\")throw g=g===null?\"null\":(m=typeof g)==\"object\"||m===\"array\"||m===\"function\"?g.toString():\"\"+g,new TypeError(`Cannot convert \"${g}\" to ${this.name}`);return typeof g==\"number\"&&(g=BigInt(g)),g},zd:gt,readValueFromPointer:li(u,c,u.indexOf(\"u\")==-1),Ad:null})}var gt=8;function Sp(i,u,c,m){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(g){return!!g},toWireType:function(g,x){return x?c:m},zd:gt,readValueFromPointer:function(g){return this.fromWireType(pe()[g>>>0])},Ad:null})}var Sn=[],lt=[];function Tn(i){9<(i>>>=0)&&--lt[i+1]==0&&(lt[i]=void 0,Sn.push(i))}var Re=i=>{if(!i)throw new ht(\"Cannot use deleted val. handle = \"+i);return lt[i]},We=i=>{switch(i){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let u=Sn.pop()||lt.length;return lt[u]=i,lt[u+1]=1,u}};function Cn(i){return this.fromWireType(R()[i>>>2>>>0])}var Tp={name:\"emscripten::val\",fromWireType:i=>{var u=Re(i);return Tn(i),u},toWireType:(i,u)=>We(u),zd:gt,readValueFromPointer:Cn,Ad:null};function Cp(i){return dt(i>>>0,Tp)}var Ip=(i,u)=>{switch(u){case 4:return function(c){return this.fromWireType(Y()[c>>>2>>>0])};case 8:return function(c){return this.fromWireType(fe()[c>>>3>>>0])};default:throw new TypeError(`invalid float width (${u}): ${i}`)}};function Ap(i,u,c){c>>>=0,dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:m=>m,toWireType:(m,g)=>g,zd:gt,readValueFromPointer:Ip(u,c),Ad:null})}function kp(i,u,c,m,g){if(i>>>=0,c>>>=0,u=Xe(u>>>0),g===-1&&(g=4294967295),g=z=>z,m===0){var x=32-8*c;g=z=>z<<x>>>x}var I=u.includes(\"unsigned\")?function(z,B){return B>>>0}:function(z,B){return B};dt(i,{name:u,fromWireType:g,toWireType:I,zd:gt,readValueFromPointer:li(u,c,m!==0),Ad:null})}function Ep(i,u,c){function m(x){var I=R()[x>>>2>>>0];return x=R()[x+4>>>2>>>0],new g(Z().buffer,x,I)}var g=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][u];dt(i>>>=0,{name:c=Xe(c>>>0),fromWireType:m,zd:gt,readValueFromPointer:m},{Pd:!0})}function Pp(i,u){dt(i>>>=0,{name:u=Xe(u>>>0),fromWireType:function(c){for(var m,g=R()[c>>>2>>>0],x=c+4,I=x,z=0;z<=g;++z){var B=x+z;z!=g&&pe()[B>>>0]!=0||(I=Ae(I,B-I),m===void 0?m=I:(m+=\"\\0\",m+=I),I=B+1)}return et(c),m},toWireType:function(c,m){m instanceof ArrayBuffer&&(m=new Uint8Array(m));var g=typeof m==\"string\";if(!(g||m instanceof Uint8Array||m instanceof Uint8ClampedArray||m instanceof Int8Array))throw new ht(\"Cannot pass non-string to std::string\");var x=g?Yo(m):m.length,I=yr(4+x+1),z=I+4;if(R()[I>>>2>>>0]=x,g)Bt(m,z,x+1);else if(g)for(g=0;g<x;++g){var B=m.charCodeAt(g);if(255<B)throw et(I),new ht(\"String has UTF-16 code units that do not fit in 8 bits\");pe()[z+g>>>0]=B}else for(g=0;g<x;++g)pe()[z+g>>>0]=m[g];return c!==null&&c.push(et,I),I},zd:gt,readValueFromPointer:Cn,Ad(c){et(c)}})}var ci=typeof TextDecoder<\"u\"?new TextDecoder(\"utf-16le\"):void 0,zp=(i,u)=>{for(var c=i>>1,m=c+u/2;!(c>=m)&&Se()[c>>>0];)++c;if(32<(c<<=1)-i&&ci)return ci.decode(pe().slice(i,c));for(c=\"\",m=0;!(m>=u/2);++m){var g=ke()[i+2*m>>>1>>>0];if(g==0)break;c+=String.fromCharCode(g)}return c},Op=(i,u,c)=>{if(c??=2147483647,2>c)return 0;var m=u;c=(c-=2)<2*i.length?c/2:i.length;for(var g=0;g<c;++g){var x=i.charCodeAt(g);ke()[u>>>1>>>0]=x,u+=2}return ke()[u>>>1>>>0]=0,u-m},Dp=i=>2*i.length,Bp=(i,u)=>{for(var c=0,m=\"\";!(c>=u/4);){var g=D()[i+4*c>>>2>>>0];if(g==0)break;++c,65536<=g?(g-=65536,m+=String.fromCharCode(55296|g>>10,56320|1023&g)):m+=String.fromCharCode(g)}return m},Mp=(i,u,c)=>{if(u>>>=0,c??=2147483647,4>c)return 0;var m=u;c=m+c-4;for(var g=0;g<i.length;++g){var x=i.charCodeAt(g);if(55296<=x&&57343>=x&&(x=65536+((1023&x)<<10)|1023&i.charCodeAt(++g)),D()[u>>>2>>>0]=x,(u+=4)+4>c)break}return D()[u>>>2>>>0]=0,u-m},Rp=i=>{for(var u=0,c=0;c<i.length;++c){var m=i.charCodeAt(c);55296<=m&&57343>=m&&++c,u+=4}return u};function Up(i,u,c){if(i>>>=0,u>>>=0,c=Xe(c>>>=0),u===2)var m=zp,g=Op,x=Dp,I=z=>Se()[z>>>1>>>0];else u===4&&(m=Bp,g=Mp,x=Rp,I=z=>R()[z>>>2>>>0]);dt(i,{name:c,fromWireType:z=>{for(var B,L=R()[z>>>2>>>0],q=z+4,X=0;X<=L;++X){var ue=z+4+X*u;X!=L&&I(ue)!=0||(q=m(q,ue-q),B===void 0?B=q:(B+=\"\\0\",B+=q),q=ue+u)}return et(z),B},toWireType:(z,B)=>{if(typeof B!=\"string\")throw new ht(`Cannot pass non-string to C++ string type ${c}`);var L=x(B),q=yr(4+L+u);return R()[q>>>2>>>0]=L/u,g(B,q+4,L+u),z!==null&&z.push(et,q),q},zd:gt,readValueFromPointer:Cn,Ad(z){et(z)}})}function Np(i,u){dt(i>>>=0,{Qd:!0,name:u=Xe(u>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function Vp(i){Dn(i>>>0,!s,1,!a,131072,!1),Lo()}var In=i=>{if(!ee)try{if(i(),!(0<mt))try{d?Bn(A):_n(A)}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}}catch(u){u instanceof gn||u==\"unwind\"||_(0,u)}};function An(i){i>>>=0,typeof Atomics.ge==\"function\"&&(Atomics.ge(D(),i>>>2,i).value.then(ur),i+=128,Atomics.store(D(),i>>>2,1))}var ur=()=>{var i=gr();i&&(An(i),In(Wi))};function Wp(i,u){(i>>>=0)==u>>>0?setTimeout(ur):d?postMessage({Ed:i,yd:\"checkMailbox\"}):(i=St[i])&&i.postMessage({yd:\"checkMailbox\"})}var kn=[];function Lp(i,u,c,m,g){for(u>>>=0,m/=2,kn.length=m,c=g>>>0>>>3,g=0;g<m;g++)kn[g]=W[c+2*g]?W[c+2*g+1]:fe()[c+2*g+1>>>0];return(u?hn[u]:Bm[i])(...kn)}var Gp=()=>{mt=0};function Hp(i){i>>>=0,d?postMessage({yd:\"cleanupThread\",ee:i}):Wo(St[i])}function Fp(i){}var dr=(i,u)=>{var c=xn[i];if(c===void 0)throw i=Bi(i),c=Xe(i),et(i),new ht(`${u} has unknown type ${c}`);return c},pi=(i,u,c)=>{var m=[];return i=i.toWireType(m,c),m.length&&(R()[u>>>2>>>0]=We(m)),i};function qp(i,u,c){return u>>>=0,c>>>=0,i=Re(i>>>0),u=dr(u,\"emval::as\"),pi(u,c,i)}function Kp(i,u){return u>>>=0,i=Re(i>>>0),(u=dr(u,\"emval::as\")).toWireType(null,i)}var lr=i=>{try{i()}catch(u){ut(u)}},yt=0,Je=null,mi=0,cr=[],fi={},hi={},jp=0,En=null,Zp=[];function gi(i){return function(u){if(!ee){if(yt===0){var c=!1,m=!1;u((g=0)=>{if(!ee&&(mi=g,c=!0,m)){yt=2,lr(()=>Na(Je)),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.resume(),g=!1;try{var x=function(){var B=D()[Je+8>>>2>>>0];return B=U[hi[B]],--mt,B()}()}catch(B){x=B,g=!0}var I=!1;if(!Je){var z=En;z&&(En=null,(g?z.reject:z.resolve)(x),I=!0)}if(g&&!I)throw x}}),m=!0,c||(yt=1,Je=function(){var g=yr(65548),x=g+12;R()[g>>>2>>>0]=x,R()[g+4>>>2>>>0]=x+65536,x=cr[0];var I=fi[x];return I===void 0&&(I=jp++,fi[x]=I,hi[I]=x),x=I,D()[g+8>>>2>>>0]=x,g}(),typeof MainLoop<\"u\"&&MainLoop.Md&&MainLoop.pause(),lr(()=>Ra(Je)))}else yt===2?(yt=0,lr(Va),et(Je),Je=null,Zp.forEach(In)):ut(`invalid state: ${yt}`);return mi}}(u=>{i().then(u)})}function Qp(i){return i>>>=0,gi(async()=>{var u=await Re(i);return We(u)})}var pr=[];function Yp(i,u,c,m){return c>>>=0,m>>>=0,(i=pr[i>>>0])(null,u=Re(u>>>0),c,m)}var Xp={},mr=i=>{var u=Xp[i];return u===void 0?Xe(i):u};function Jp(i,u,c,m,g){return c>>>=0,m>>>=0,g>>>=0,(i=pr[i>>>0])(u=Re(u>>>0),u[c=mr(c)],m,g)}var yi=()=>typeof globalThis==\"object\"?globalThis:Function(\"return this\")();function em(i){return(i>>>=0)==0?We(yi()):(i=mr(i),We(yi()[i]))}var tm=i=>{var u=pr.length;return pr.push(i),u},rm=(i,u)=>{for(var c=Array(i),m=0;m<i;++m)c[m]=dr(R()[u+4*m>>>2>>>0],\"parameter \"+m);return c},bi=(i,u)=>Object.defineProperty(u,\"name\",{value:i});function nm(i,u,c){var m=(u=rm(i,u>>>0)).shift();i--;var g=`return function (obj, func, destructorsRef, args) {\n`,x=0,I=[];c===0&&I.push(\"obj\");for(var z=[\"retType\"],B=[m],L=0;L<i;++L)I.push(\"arg\"+L),z.push(\"argType\"+L),B.push(u[L]),g+=`  var arg${L} = argType${L}.readValueFromPointer(args${x?\"+\"+x:\"\"});\n`,x+=u[L].zd;return g+=`  var rv = ${c===1?\"new func\":\"func.call\"}(${I.join(\", \")});\n`,m.Qd||(z.push(\"emval_returnValue\"),B.push(pi),g+=`  return emval_returnValue(retType, destructorsRef, rv);\n`),z.push(g+`};\n`),i=function(q){var X=Function;if(!(X instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof X} which is not a function`);var ue=bi(X.name||\"unknownFunctionName\",function(){});return ue.prototype=X.prototype,ue=new ue,(q=X.apply(ue,q))instanceof Object?q:ue}(z)(...B),c=`methodCaller<(${u.map(q=>q.name).join(\", \")}) => ${m.name}>`,tm(bi(c,i))}function om(i){return i=mr(i>>>0),We(r[i])}function im(i,u){return u>>>=0,i=Re(i>>>0),u=Re(u),We(i[u])}function am(i){9<(i>>>=0)&&(lt[i+1]+=1)}function sm(){return We([])}function um(i){i=Re(i>>>0);for(var u=Array(i.length),c=0;c<i.length;c++)u[c]=i[c];return We(u)}function dm(i){return We(mr(i>>>0))}function lm(){return We({})}function cm(i){for(var u=Re(i>>>=0);u.length;){var c=u.pop();u.pop()(c)}Tn(i)}function pm(i,u,c){u>>>=0,c>>>=0,i=Re(i>>>0),u=Re(u),c=Re(c),i[u]=c}function mm(i,u){return u>>>=0,i=(i=dr(i>>>0,\"_emval_take_value\")).readValueFromPointer(u),We(i)}function fm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getUTCSeconds(),D()[u+4>>>2>>>0]=i.getUTCMinutes(),D()[u+8>>>2>>>0]=i.getUTCHours(),D()[u+12>>>2>>>0]=i.getUTCDate(),D()[u+16>>>2>>>0]=i.getUTCMonth(),D()[u+20>>>2>>>0]=i.getUTCFullYear()-1900,D()[u+24>>>2>>>0]=i.getUTCDay(),i=(i.getTime()-Date.UTC(i.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,D()[u+28>>>2>>>0]=i}var _i=i=>i%4==0&&(i%100!=0||i%400==0),wi=[0,31,60,91,121,152,182,213,244,274,305,335],vi=[0,31,59,90,120,151,181,212,243,273,304,334];function hm(i,u){i=-9007199254740992>i||9007199254740992<i?NaN:Number(i),u>>>=0,i=new Date(1e3*i),D()[u>>>2>>>0]=i.getSeconds(),D()[u+4>>>2>>>0]=i.getMinutes(),D()[u+8>>>2>>>0]=i.getHours(),D()[u+12>>>2>>>0]=i.getDate(),D()[u+16>>>2>>>0]=i.getMonth(),D()[u+20>>>2>>>0]=i.getFullYear()-1900,D()[u+24>>>2>>>0]=i.getDay();var c=(_i(i.getFullYear())?wi:vi)[i.getMonth()]+i.getDate()-1|0;D()[u+28>>>2>>>0]=c,D()[u+36>>>2>>>0]=-60*i.getTimezoneOffset(),c=new Date(i.getFullYear(),6,1).getTimezoneOffset();var m=new Date(i.getFullYear(),0,1).getTimezoneOffset();i=0|(c!=m&&i.getTimezoneOffset()==Math.min(m,c)),D()[u+32>>>2>>>0]=i}function gm(i){i>>>=0;var u=new Date(D()[i+20>>>2>>>0]+1900,D()[i+16>>>2>>>0],D()[i+12>>>2>>>0],D()[i+8>>>2>>>0],D()[i+4>>>2>>>0],D()[i>>>2>>>0],0),c=D()[i+32>>>2>>>0],m=u.getTimezoneOffset(),g=new Date(u.getFullYear(),6,1).getTimezoneOffset(),x=new Date(u.getFullYear(),0,1).getTimezoneOffset(),I=Math.min(x,g);return 0>c?D()[i+32>>>2>>>0]=+(g!=x&&I==m):0<c!=(I==m)&&(g=Math.max(x,g),u.setTime(u.getTime()+6e4*((0<c?I:g)-m))),D()[i+24>>>2>>>0]=u.getDay(),c=(_i(u.getFullYear())?wi:vi)[u.getMonth()]+u.getDate()-1|0,D()[i+28>>>2>>>0]=c,D()[i>>>2>>>0]=u.getSeconds(),D()[i+4>>>2>>>0]=u.getMinutes(),D()[i+8>>>2>>>0]=u.getHours(),D()[i+12>>>2>>>0]=u.getDate(),D()[i+16>>>2>>>0]=u.getMonth(),D()[i+20>>>2>>>0]=u.getYear(),i=u.getTime(),BigInt(isNaN(i)?-1:i/1e3)}function $i(i,u,c,m,g,x,I){return d?Te(16,1,i,u,c,m,g,x,I):-52}function xi(i,u,c,m,g,x){if(d)return Te(17,1,i,u,c,m,g,x)}var qt={},ym=()=>performance.timeOrigin+performance.now();function Si(i,u){if(d)return Te(18,1,i,u);if(qt[i]&&(clearTimeout(qt[i].id),delete qt[i]),!u)return 0;var c=setTimeout(()=>{delete qt[i],In(()=>Vi(i,performance.timeOrigin+performance.now()))},u);return qt[i]={id:c,ke:u},0}function bm(i,u,c,m){i>>>=0,u>>>=0,c>>>=0,m>>>=0;var g=new Date().getFullYear(),x=new Date(g,0,1).getTimezoneOffset();g=new Date(g,6,1).getTimezoneOffset();var I=Math.max(x,g);R()[i>>>2>>>0]=60*I,D()[u>>>2>>>0]=+(x!=g),i=(u=z=>{var B=Math.abs(z);return`UTC${0<=z?\"-\":\"+\"}${String(Math.floor(B/60)).padStart(2,\"0\")}${String(B%60).padStart(2,\"0\")}`})(x),u=u(g),g<x?(Bt(i,c,17),Bt(u,m,17)):(Bt(i,m,17),Bt(u,c,17))}var _m=()=>Date.now(),wm=1;function vm(i,u,c){if(!(0<=i&&3>=i))return 28;if(i===0)i=Date.now();else{if(!wm)return 52;i=performance.timeOrigin+performance.now()}return W[c>>>0>>>3]=BigInt(Math.round(1e6*i)),0}var Pn=[],Ti=(i,u)=>{Pn.length=0;for(var c;c=pe()[i++>>>0];){var m=c!=105;u+=(m&=c!=112)&&u%8?4:0,Pn.push(c==112?R()[u>>>2>>>0]:c==106?W[u>>>3]:c==105?D()[u>>>2>>>0]:fe()[u>>>3>>>0]),u+=m?8:4}return Pn};function $m(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}function xm(i,u,c){return i>>>=0,u=Ti(u>>>0,c>>>0),hn[i](...u)}var Sm=()=>{};function Tm(i,u){return v(Ae(i>>>0,u>>>0))}var Cm=()=>{throw mt+=1,\"unwind\"};function Im(){return 4294901760}var Am=()=>navigator.hardwareConcurrency;function km(){return ut(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"),0}function Em(i){i>>>=0;var u=pe().length;if(i<=u||4294901760<i)return!1;for(var c=1;4>=c;c*=2){var m=u*(1+.2/c);m=Math.min(m,i+100663296);e:{m=(Math.min(4294901760,65536*Math.ceil(Math.max(i,m)/65536))-T.buffer.byteLength+65535)/65536|0;try{T.grow(m),be();var g=1;break e}catch{}g=void 0}if(g)return!0}return!1}var fr=()=>(ut(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"),0),Mt={},Ci=i=>{i.forEach(u=>{var c=fr();c&&(Mt[c]=u)})};function Pm(){var i=Error().stack.toString().split(`\n`);return i[0]==\"Error\"&&i.shift(),Ci(i),Mt.Kd=fr(),Mt.ae=i,Mt.Kd}function zm(i,u,c){if(i>>>=0,u>>>=0,Mt.Kd==i)var m=Mt.ae;else(m=Error().stack.toString().split(`\n`))[0]==\"Error\"&&m.shift(),Ci(m);for(var g=3;m[g]&&fr()!=i;)++g;for(i=0;i<c&&m[i+g];++i)D()[u+4*i>>>2>>>0]=fr();return i}var zn,On={},Ii=()=>{if(!zn){var i,u={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(typeof navigator==\"object\"&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:\"./this.program\"};for(i in On)On[i]===void 0?delete u[i]:u[i]=On[i];var c=[];for(i in u)c.push(`${i}=${u[i]}`);zn=c}return zn};function Ai(i,u){if(d)return Te(19,1,i,u);i>>>=0,u>>>=0;var c=0;return Ii().forEach((m,g)=>{var x=u+c;for(g=R()[i+4*g>>>2>>>0]=x,x=0;x<m.length;++x)Z()[g++>>>0]=m.charCodeAt(x);Z()[g>>>0]=0,c+=m.length+1}),0}function ki(i,u){if(d)return Te(20,1,i,u);i>>>=0,u>>>=0;var c=Ii();R()[i>>>2>>>0]=c.length;var m=0;return c.forEach(g=>m+=g.length+1),R()[u>>>2>>>0]=m,0}function Ei(i){return d?Te(21,1,i):52}function Pi(i,u,c,m){return d?Te(22,1,i,u,c,m):52}function zi(i,u,c,m){return d?Te(23,1,i,u,c,m):70}var Om=[null,[],[]];function Oi(i,u,c,m){if(d)return Te(24,1,i,u,c,m);u>>>=0,c>>>=0,m>>>=0;for(var g=0,x=0;x<c;x++){var I=R()[u>>>2>>>0],z=R()[u+4>>>2>>>0];u+=8;for(var B=0;B<z;B++){var L=pe()[I+B>>>0],q=Om[i];L===0||L===10?((i===1?$:v)(jo(q)),q.length=0):q.push(L)}g+=z}return R()[m>>>2>>>0]=g,0}function Dm(i){return i>>>0}d||function(){for(var i=r.numThreads-1;i--;)Ho();yn.unshift(()=>{xt++,function(u){d?u():Promise.all(ft.map(Go)).then(u)}(()=>Bo())})}();for(var Di=Array(256),hr=0;256>hr;++hr)Di[hr]=String.fromCharCode(hr);di=Di,ht=r.BindingError=class extends Error{constructor(i){super(i),this.name=\"BindingError\"}},r.InternalError=class extends Error{constructor(i){super(i),this.name=\"InternalError\"}},lt.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>lt.length/2-5-Sn.length;var U,Bm=[bn,No,Fo,Zo,Qo,Xo,Jo,ei,ti,ri,ni,oi,ii,ai,si,ui,$i,xi,Si,Ai,ki,Ei,Pi,zi,Oi];(async function(){function i(m,g){return U=m.exports,U=function(){var x=U,I={};for(let[z,B]of Object.entries(x))I[z]=typeof B==\"function\"?(...L)=>{cr.push(z);try{return B(...L)}finally{ee||(cr.pop(),Je&&yt===1&&cr.length===0&&(yt=0,mt+=1,lr(Ua),typeof Fibers<\"u\"&&Fibers.le()))}}:B;return I}(),U=function(){var x=U,I=B=>L=>B(L)>>>0,z=B=>()=>B()>>>0;return(x=Object.assign({},x)).Cb=I(x.Cb),x.fc=z(x.fc),x.ic=I(x.ic),x.vc=I(x.vc),x.wc=z(x.wc),x.Ac=I(x.Ac),x}(),Vo.push(U.jc),C=g,Bo(),U}xt++;var u=Mo();if(r.instantiateWasm)return new Promise(m=>{r.instantiateWasm(u,(g,x)=>{i(g,x),m(g.exports)})});if(d)return new Promise(m=>{Fe=g=>{var x=new WebAssembly.Instance(g,Mo());m(i(x,g))}});Gt??=r.locateFile?r.locateFile?r.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\",b):b+\"ort-wasm-simd-threaded.jsep.wasm\":/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href;try{var c=await async function(m){var g=Gt;if(!Q&&typeof WebAssembly.instantiateStreaming==\"function\"&&!le(g))try{var x=fetch(g,{credentials:\"same-origin\"});return await WebAssembly.instantiateStreaming(x,m)}catch(I){v(`wasm streaming compile failed: ${I}`),v(\"falling back to ArrayBuffer instantiation\")}return async function(I,z){try{var B=await async function(L){if(!Q)try{var q=await f(L);return new Uint8Array(q)}catch{}if(L==Gt&&Q)L=new Uint8Array(Q);else{if(!h)throw\"both async and sync fetching of the wasm failed\";L=h(L)}return L}(I);return await WebAssembly.instantiate(B,z)}catch(L){v(`failed to asynchronously prepare wasm: ${L}`),ut(L)}}(g,m)}(u);return i(c.instance,c.module)}catch(m){return n(m),Promise.reject(m)}})();var Bi=i=>(Bi=U.Cb)(i),Mi=()=>(Mi=U.Db)();r._OrtInit=(i,u)=>(r._OrtInit=U.Eb)(i,u),r._OrtGetLastError=(i,u)=>(r._OrtGetLastError=U.Fb)(i,u),r._OrtCreateSessionOptions=(i,u,c,m,g,x,I,z,B,L)=>(r._OrtCreateSessionOptions=U.Gb)(i,u,c,m,g,x,I,z,B,L),r._OrtAppendExecutionProvider=(i,u)=>(r._OrtAppendExecutionProvider=U.Hb)(i,u),r._OrtAddFreeDimensionOverride=(i,u,c)=>(r._OrtAddFreeDimensionOverride=U.Ib)(i,u,c),r._OrtAddSessionConfigEntry=(i,u,c)=>(r._OrtAddSessionConfigEntry=U.Jb)(i,u,c),r._OrtReleaseSessionOptions=i=>(r._OrtReleaseSessionOptions=U.Kb)(i),r._OrtCreateSession=(i,u,c)=>(r._OrtCreateSession=U.Lb)(i,u,c),r._OrtReleaseSession=i=>(r._OrtReleaseSession=U.Mb)(i),r._OrtGetInputOutputCount=(i,u,c)=>(r._OrtGetInputOutputCount=U.Nb)(i,u,c),r._OrtGetInputName=(i,u)=>(r._OrtGetInputName=U.Ob)(i,u),r._OrtGetOutputName=(i,u)=>(r._OrtGetOutputName=U.Pb)(i,u),r._OrtFree=i=>(r._OrtFree=U.Qb)(i),r._OrtCreateTensor=(i,u,c,m,g,x)=>(r._OrtCreateTensor=U.Rb)(i,u,c,m,g,x),r._OrtGetTensorData=(i,u,c,m,g)=>(r._OrtGetTensorData=U.Sb)(i,u,c,m,g),r._OrtReleaseTensor=i=>(r._OrtReleaseTensor=U.Tb)(i),r._OrtCreateRunOptions=(i,u,c,m)=>(r._OrtCreateRunOptions=U.Ub)(i,u,c,m),r._OrtAddRunConfigEntry=(i,u,c)=>(r._OrtAddRunConfigEntry=U.Vb)(i,u,c),r._OrtReleaseRunOptions=i=>(r._OrtReleaseRunOptions=U.Wb)(i),r._OrtCreateBinding=i=>(r._OrtCreateBinding=U.Xb)(i),r._OrtBindInput=(i,u,c)=>(r._OrtBindInput=U.Yb)(i,u,c),r._OrtBindOutput=(i,u,c,m)=>(r._OrtBindOutput=U.Zb)(i,u,c,m),r._OrtClearBoundOutputs=i=>(r._OrtClearBoundOutputs=U._b)(i),r._OrtReleaseBinding=i=>(r._OrtReleaseBinding=U.$b)(i),r._OrtRunWithBinding=(i,u,c,m,g)=>(r._OrtRunWithBinding=U.ac)(i,u,c,m,g),r._OrtRun=(i,u,c,m,g,x,I,z)=>(r._OrtRun=U.bc)(i,u,c,m,g,x,I,z),r._OrtEndProfiling=i=>(r._OrtEndProfiling=U.cc)(i),r._JsepOutput=(i,u,c)=>(r._JsepOutput=U.dc)(i,u,c),r._JsepGetNodeName=i=>(r._JsepGetNodeName=U.ec)(i);var gr=()=>(gr=U.fc)(),et=r._free=i=>(et=r._free=U.gc)(i),yr=r._malloc=i=>(yr=r._malloc=U.ic)(i),Dn=(i,u,c,m,g,x)=>(Dn=U.kc)(i,u,c,m,g,x),Ri=()=>(Ri=U.lc)(),Ui=(i,u,c,m,g)=>(Ui=U.mc)(i,u,c,m,g),Ni=i=>(Ni=U.nc)(i),Bn=i=>(Bn=U.oc)(i),Vi=(i,u)=>(Vi=U.pc)(i,u),Wi=()=>(Wi=U.qc)(),se=(i,u)=>(se=U.rc)(i,u),Kt=i=>(Kt=U.sc)(i),Li=(i,u)=>(Li=U.tc)(i,u),oe=i=>(oe=U.uc)(i),Mn=i=>(Mn=U.vc)(i),ie=()=>(ie=U.wc)(),Gi=i=>(Gi=U.xc)(i),Hi=i=>(Hi=U.yc)(i),Fi=(i,u,c)=>(Fi=U.zc)(i,u,c),qi=i=>(qi=U.Ac)(i),Ki=r.dynCall_iii=(i,u,c)=>(Ki=r.dynCall_iii=U.Bc)(i,u,c),ji=r.dynCall_vi=(i,u)=>(ji=r.dynCall_vi=U.Cc)(i,u),Rn=r.dynCall_ii=(i,u)=>(Rn=r.dynCall_ii=U.Dc)(i,u),Zi=r.dynCall_vii=(i,u,c)=>(Zi=r.dynCall_vii=U.Ec)(i,u,c),Qi=r.dynCall_iiii=(i,u,c,m)=>(Qi=r.dynCall_iiii=U.Fc)(i,u,c,m),Yi=r.dynCall_viii=(i,u,c,m)=>(Yi=r.dynCall_viii=U.Gc)(i,u,c,m),Xi=r.dynCall_iiiii=(i,u,c,m,g)=>(Xi=r.dynCall_iiiii=U.Hc)(i,u,c,m,g),Ji=r.dynCall_viiii=(i,u,c,m,g)=>(Ji=r.dynCall_viiii=U.Ic)(i,u,c,m,g),ea=r.dynCall_viiiiii=(i,u,c,m,g,x,I)=>(ea=r.dynCall_viiiiii=U.Jc)(i,u,c,m,g,x,I),ta=r.dynCall_viiiiiii=(i,u,c,m,g,x,I,z)=>(ta=r.dynCall_viiiiiii=U.Kc)(i,u,c,m,g,x,I,z),ra=r.dynCall_ji=(i,u)=>(ra=r.dynCall_ji=U.Lc)(i,u),na=r.dynCall_v=i=>(na=r.dynCall_v=U.Mc)(i),oa=r.dynCall_viiiii=(i,u,c,m,g,x)=>(oa=r.dynCall_viiiii=U.Nc)(i,u,c,m,g,x),ia=r.dynCall_i=i=>(ia=r.dynCall_i=U.Oc)(i),aa=r.dynCall_fii=(i,u,c)=>(aa=r.dynCall_fii=U.Pc)(i,u,c),sa=r.dynCall_viiiiiiii=(i,u,c,m,g,x,I,z,B)=>(sa=r.dynCall_viiiiiiii=U.Qc)(i,u,c,m,g,x,I,z,B),ua=r.dynCall_viiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ua=r.dynCall_viiiiiiiiii=U.Rc)(i,u,c,m,g,x,I,z,B,L,q),da=r.dynCall_jiii=(i,u,c,m)=>(da=r.dynCall_jiii=U.Sc)(i,u,c,m),la=r.dynCall_dii=(i,u,c)=>(la=r.dynCall_dii=U.Tc)(i,u,c),ca=r.dynCall_viiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ca=r.dynCall_viiiiiiiii=U.Uc)(i,u,c,m,g,x,I,z,B,L),pa=r.dynCall_viiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X)=>(pa=r.dynCall_viiiiiiiiiii=U.Vc)(i,u,c,m,g,x,I,z,B,L,q,X),ma=r.dynCall_iiiiii=(i,u,c,m,g,x)=>(ma=r.dynCall_iiiiii=U.Wc)(i,u,c,m,g,x),fa=r.dynCall_iij=(i,u,c)=>(fa=r.dynCall_iij=U.Xc)(i,u,c),ha=r.dynCall_iiiiiiiiii=(i,u,c,m,g,x,I,z,B,L)=>(ha=r.dynCall_iiiiiiiiii=U.Yc)(i,u,c,m,g,x,I,z,B,L),ga=r.dynCall_iiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q)=>(ga=r.dynCall_iiiiiiiiiii=U.Zc)(i,u,c,m,g,x,I,z,B,L,q),ya=r.dynCall_vij=(i,u,c)=>(ya=r.dynCall_vij=U._c)(i,u,c),ba=r.dynCall_iiif=(i,u,c,m)=>(ba=r.dynCall_iiif=U.$c)(i,u,c,m),_a=r.dynCall_iiij=(i,u,c,m)=>(_a=r.dynCall_iiij=U.ad)(i,u,c,m),wa=r.dynCall_fiii=(i,u,c,m)=>(wa=r.dynCall_fiii=U.bd)(i,u,c,m),va=r.dynCall_viiiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)=>(va=r.dynCall_viiiiiiiiiiiii=U.cd)(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e),$a=r.dynCall_vjiii=(i,u,c,m,g)=>($a=r.dynCall_vjiii=U.dd)(i,u,c,m,g),xa=r.dynCall_vif=(i,u,c)=>(xa=r.dynCall_vif=U.ed)(i,u,c),Sa=r.dynCall_iiiiiii=(i,u,c,m,g,x,I)=>(Sa=r.dynCall_iiiiiii=U.fd)(i,u,c,m,g,x,I),Ta=r.dynCall_iiiij=(i,u,c,m,g)=>(Ta=r.dynCall_iiiij=U.gd)(i,u,c,m,g),Ca=r.dynCall_iiiiiiii=(i,u,c,m,g,x,I,z)=>(Ca=r.dynCall_iiiiiiii=U.hd)(i,u,c,m,g,x,I,z),Ia=r.dynCall_viiiiiiiiiiii=(i,u,c,m,g,x,I,z,B,L,q,X,ue)=>(Ia=r.dynCall_viiiiiiiiiiii=U.id)(i,u,c,m,g,x,I,z,B,L,q,X,ue),Aa=r.dynCall_diii=(i,u,c,m)=>(Aa=r.dynCall_diii=U.jd)(i,u,c,m),ka=r.dynCall_jiiii=(i,u,c,m,g)=>(ka=r.dynCall_jiiii=U.kd)(i,u,c,m,g),Ea=r.dynCall_viiij=(i,u,c,m,g)=>(Ea=r.dynCall_viiij=U.ld)(i,u,c,m,g),Pa=r.dynCall_fiiii=(i,u,c,m,g)=>(Pa=r.dynCall_fiiii=U.md)(i,u,c,m,g),za=r.dynCall_viiif=(i,u,c,m,g)=>(za=r.dynCall_viiif=U.nd)(i,u,c,m,g),Oa=r.dynCall_diiii=(i,u,c,m,g)=>(Oa=r.dynCall_diiii=U.od)(i,u,c,m,g),Da=r.dynCall_viiid=(i,u,c,m,g)=>(Da=r.dynCall_viiid=U.pd)(i,u,c,m,g),Ba=r.dynCall_iiiijii=(i,u,c,m,g,x,I)=>(Ba=r.dynCall_iiiijii=U.qd)(i,u,c,m,g,x,I),Ma=r.dynCall_iiiiiij=(i,u,c,m,g,x,I)=>(Ma=r.dynCall_iiiiiij=U.rd)(i,u,c,m,g,x,I),Ra=i=>(Ra=U.sd)(i),Ua=()=>(Ua=U.td)(),Na=i=>(Na=U.ud)(i),Va=()=>(Va=U.vd)();function Mm(i,u,c){var m=ie();try{Zi(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Rm(i,u,c){var m=ie();try{return Ki(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Um(i,u){var c=ie();try{ji(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Nm(i,u){var c=ie();try{return Rn(i,u)}catch(m){if(oe(c),m!==m+0)throw m;se(1,0)}}function Vm(i,u,c,m){var g=ie();try{return Qi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Wm(i,u,c,m,g){var x=ie();try{Ji(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Lm(i,u,c,m,g){var x=ie();try{return Xi(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Gm(i,u,c,m){var g=ie();try{Yi(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function Hm(i,u,c,m,g,x,I){var z=ie();try{return Sa(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Fm(i){var u=ie();try{na(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function qm(i,u,c){var m=ie();try{return fa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Km(i,u,c,m,g,x){var I=ie();try{oa(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function jm(i,u,c){var m=ie();try{ya(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function Zm(i,u,c,m,g,x,I){var z=ie();try{ea(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function Qm(i,u,c,m,g,x,I,z){var B=ie();try{ta(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Ym(i,u,c,m,g,x){var I=ie();try{return ma(i,u,c,m,g,x)}catch(z){if(oe(I),z!==z+0)throw z;se(1,0)}}function Xm(i,u,c,m,g,x,I,z){var B=ie();try{return Ca(i,u,c,m,g,x,I,z)}catch(L){if(oe(B),L!==L+0)throw L;se(1,0)}}function Jm(i,u,c,m,g,x,I,z,B,L){var q=ie();try{ca(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function ef(i,u,c,m,g,x,I,z,B){var L=ie();try{sa(i,u,c,m,g,x,I,z,B)}catch(q){if(oe(L),q!==q+0)throw q;se(1,0)}}function tf(i){var u=ie();try{return ia(i)}catch(c){if(oe(u),c!==c+0)throw c;se(1,0)}}function rf(i,u,c,m,g,x,I,z,B,L){var q=ie();try{return ha(i,u,c,m,g,x,I,z,B,L)}catch(X){if(oe(q),X!==X+0)throw X;se(1,0)}}function nf(i,u,c){var m=ie();try{return aa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function of(i,u,c,m){var g=ie();try{return da(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;return se(1,0),0n}}function af(i,u,c){var m=ie();try{return la(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function sf(i,u,c,m,g,x,I,z,B,L,q,X){var ue=ie();try{pa(i,u,c,m,g,x,I,z,B,L,q,X)}catch($e){if(oe(ue),$e!==$e+0)throw $e;se(1,0)}}function uf(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{ua(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function df(i,u,c,m,g,x,I,z,B,L,q){var X=ie();try{return ga(i,u,c,m,g,x,I,z,B,L,q)}catch(ue){if(oe(X),ue!==ue+0)throw ue;se(1,0)}}function lf(i,u,c,m){var g=ie();try{return ba(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function cf(i,u,c,m){var g=ie();try{return _a(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function pf(i,u,c,m){var g=ie();try{return wa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function mf(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e){var Le=ie();try{va(i,u,c,m,g,x,I,z,B,L,q,X,ue,$e)}catch(jt){if(oe(Le),jt!==jt+0)throw jt;se(1,0)}}function ff(i,u,c,m,g){var x=ie();try{$a(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function hf(i,u,c){var m=ie();try{xa(i,u,c)}catch(g){if(oe(m),g!==g+0)throw g;se(1,0)}}function gf(i,u){var c=ie();try{return ra(i,u)}catch(m){if(oe(c),m!==m+0)throw m;return se(1,0),0n}}function yf(i,u,c,m,g){var x=ie();try{return Ta(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function bf(i,u,c,m,g,x,I,z,B,L,q,X,ue){var $e=ie();try{Ia(i,u,c,m,g,x,I,z,B,L,q,X,ue)}catch(Le){if(oe($e),Le!==Le+0)throw Le;se(1,0)}}function _f(i,u,c,m){var g=ie();try{return Aa(i,u,c,m)}catch(x){if(oe(g),x!==x+0)throw x;se(1,0)}}function wf(i,u,c,m,g){var x=ie();try{return ka(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;return se(1,0),0n}}function vf(i,u,c,m,g){var x=ie();try{Ea(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function $f(i,u,c,m,g){var x=ie();try{return Pa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function xf(i,u,c,m,g){var x=ie();try{za(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Sf(i,u,c,m,g){var x=ie();try{return Oa(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Tf(i,u,c,m,g){var x=ie();try{Da(i,u,c,m,g)}catch(I){if(oe(x),I!==I+0)throw I;se(1,0)}}function Cf(i,u,c,m,g,x,I){var z=ie();try{return Ba(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}function If(i,u,c,m,g,x,I){var z=ie();try{return Ma(i,u,c,m,g,x,I)}catch(B){if(oe(z),B!==B+0)throw B;se(1,0)}}return r.stackSave=()=>ie(),r.stackRestore=i=>oe(i),r.stackAlloc=i=>Mn(i),r.setValue=function(i,u,c=\"i8\"){switch(c.endsWith(\"*\")&&(c=\"*\"),c){case\"i1\":case\"i8\":Z()[i>>>0]=u;break;case\"i16\":ke()[i>>>1>>>0]=u;break;case\"i32\":D()[i>>>2>>>0]=u;break;case\"i64\":W[i>>>3]=BigInt(u);break;case\"float\":Y()[i>>>2>>>0]=u;break;case\"double\":fe()[i>>>3>>>0]=u;break;case\"*\":R()[i>>>2>>>0]=u;break;default:ut(`invalid type for setValue: ${c}`)}},r.getValue=function(i,u=\"i8\"){switch(u.endsWith(\"*\")&&(u=\"*\"),u){case\"i1\":case\"i8\":return Z()[i>>>0];case\"i16\":return ke()[i>>>1>>>0];case\"i32\":return D()[i>>>2>>>0];case\"i64\":return W[i>>>3];case\"float\":return Y()[i>>>2>>>0];case\"double\":return fe()[i>>>3>>>0];case\"*\":return R()[i>>>2>>>0];default:ut(`invalid type for getValue: ${u}`)}},r.UTF8ToString=Ae,r.stringToUTF8=Bt,r.lengthBytesUTF8=Yo,function i(){if(0<xt)Ht=i;else if(d)t(r),Ye();else{for(;0<yn.length;)yn.shift()(r);0<xt?Ht=i:(r.calledRun=!0,ee||(Ye(),t(r)))}}(),r.PTR_SIZE=4,o}),Bf=ws,Mf=globalThis.self?.name?.startsWith(\"em-pthread\");Mf&&ws()});var Ts,Rf,Ve,Cs,jn,Uf,Nf,Is,Vf,xs,As,Ss,ks,Sr=G(()=>{\"use strict\";xr();Ts=typeof location>\"u\"?void 0:location.origin,Rf=()=>{if(true)return \"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")?new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?9165\")).href,Ts).href:\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"},Ve=Rf(),Cs=()=>{if(Ve&&!Ve.startsWith(\"blob:\"))return Ve.substring(0,Ve.lastIndexOf(\"/\")+1)},jn=(e,t)=>{try{let n=t??Ve;return(n?new URL(e,n):new URL(e)).origin===Ts}catch{return!1}},Uf=(e,t)=>{let n=t??Ve;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Nf=(e,t)=>`${t??\"./\"}${e}`,Is=async e=>{let n=await(await fetch(e,{credentials:\"same-origin\"})).blob();return URL.createObjectURL(n)},Vf=async e=>(await import(/*webpackIgnore:true*/e)).default,xs=(_s(),br(bs)).default,As=async()=>{if(!Ve)throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");if(jn(Ve))return[void 0,xs()];let e=await Is(Ve);return[e,xs(e)]},Ss=($s(),br(vs)).default,ks=async(e,t,n)=>{if(!e&&!t&&Ss&&Ve&&jn(Ve))return[void 0,Ss];{let r=\"ort-wasm-simd-threaded.jsep.mjs\",o=e??Uf(r,t),a= true&&n&&o&&!jn(o,t),s=a?await Is(o):o??Nf(r,t);return[a?s:void 0,await Vf(s)]}}});var Zn,Qn,Or,Es,Wf,Lf,Tr,Ie,bt=G(()=>{\"use strict\";Sr();Qn=!1,Or=!1,Es=!1,Wf=()=>{if(typeof SharedArrayBuffer>\"u\")return!1;try{return typeof MessageChannel<\"u\"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lf=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Tr=async e=>{if(Qn)return Promise.resolve();if(Or)throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");if(Es)throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");Or=!0;let t=e.initTimeout,n=e.numThreads;if(!Lf())throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");let r=Wf();n>1&&!r&&(typeof self<\"u\"&&!self.crossOriginIsolated&&console.warn(\"env.wasm.numThreads is set to \"+n+\", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"),console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"),e.numThreads=n=1);let o=e.wasmPaths,a=typeof o==\"string\"?o:void 0,s=o?.mjs,d=s?.href??s,l=o?.wasm,p=l?.href??l,f=e.wasmBinary,[h,y]=await ks(d,a,n>1),_=!1,b=[];if(t>0&&b.push(new Promise(w=>{setTimeout(()=>{_=!0,w()},t)})),b.push(new Promise((w,S)=>{let $={numThreads:n};if(f)$.wasmBinary=f;else if(p||a)$.locateFile=v=>p??a+v;else if(d&&d.indexOf(\"blob:\")!==0)$.locateFile=v=>new URL(v,d).href;else if(h){let v=Cs();v&&($.locateFile=T=>v+T)}y($).then(v=>{Or=!1,Qn=!0,Zn=v,w(),h&&URL.revokeObjectURL(h)},v=>{Or=!1,Es=!0,S(v)})})),await Promise.race(b),_)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ie=()=>{if(Qn&&Zn)return Zn;throw new Error(\"WebAssembly is not initialized yet.\")}});var Pe,Xt,he,Dr=G(()=>{\"use strict\";bt();Pe=(e,t)=>{let n=Ie(),r=n.lengthBytesUTF8(e)+1,o=n._malloc(r);return n.stringToUTF8(e,o,r),t.push(o),o},Xt=(e,t,n,r)=>{if(typeof e==\"object\"&&e!==null){if(n.has(e))throw new Error(\"Circular reference in options\");n.add(e)}Object.entries(e).forEach(([o,a])=>{let s=t?t+o:o;if(typeof a==\"object\")Xt(a,s+\".\",n,r);else if(typeof a==\"string\"||typeof a==\"number\")r(s,a.toString());else if(typeof a==\"boolean\")r(s,a?\"1\":\"0\");else throw new Error(`Can't handle extra config type: ${typeof a}`)})},he=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetLastError(o,o+r);let a=Number(t.getValue(o,r===4?\"i32\":\"i64\")),s=t.getValue(o+r,\"*\"),d=s?t.UTF8ToString(s):\"\";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${d}`)}finally{t.stackRestore(n)}}});var Ps,zs=G(()=>{\"use strict\";bt();Dr();Ps=e=>{let t=Ie(),n=0,r=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if(typeof e.logSeverityLevel!=\"number\"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!=\"number\"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let a=0;return e?.tag!==void 0&&(a=Pe(e.tag,r)),n=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),n===0&&he(\"Can't create run options.\"),e?.extra!==void 0&&Xt(e.extra,\"\",new WeakSet,(s,d)=>{let l=Pe(s,r),p=Pe(d,r);t._OrtAddRunConfigEntry(n,l,p)!==0&&he(`Can't set a run config entry: ${s} - ${d}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseRunOptions(n),r.forEach(s=>t._free(s)),a}}});var Gf,Hf,Ff,qf,Os,Ds=G(()=>{\"use strict\";bt();Dr();Gf=e=>{switch(e){case\"disabled\":return 0;case\"basic\":return 1;case\"extended\":return 2;case\"all\":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Hf=e=>{switch(e){case\"sequential\":return 0;case\"parallel\":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ff=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly=\"1\"),e.executionProviders&&e.executionProviders.some(n=>(typeof n==\"string\"?n:n.name)===\"webgpu\")&&(e.enableMemPattern=!1)},qf=(e,t,n)=>{for(let r of t){let o=typeof r==\"string\"?r:r.name;switch(o){case\"webnn\":if(o=\"WEBNN\",typeof r!=\"string\"){let d=r?.deviceType;if(d){let l=Pe(\"deviceType\",n),p=Pe(d,n);Ie()._OrtAddSessionConfigEntry(e,l,p)!==0&&he(`Can't set a session config entry: 'deviceType' - ${d}.`)}}break;case\"webgpu\":if(o=\"JS\",typeof r!=\"string\"){let s=r;if(s?.preferredLayout){if(s.preferredLayout!==\"NCHW\"&&s.preferredLayout!==\"NHWC\")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let d=Pe(\"preferredLayout\",n),l=Pe(s.preferredLayout,n);Ie()._OrtAddSessionConfigEntry(e,d,l)!==0&&he(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case\"wasm\":case\"cpu\":continue;default:throw new Error(`not supported execution provider: ${o}`)}let a=Pe(o,n);Ie()._OrtAppendExecutionProvider(e,a)!==0&&he(`Can't append execution provider: ${o}.`)}},Os=e=>{let t=Ie(),n=0,r=[],o=e||{};Ff(o);try{let a=Gf(o.graphOptimizationLevel??\"all\"),s=Hf(o.executionMode??\"sequential\"),d=typeof o.logId==\"string\"?Pe(o.logId,r):0,l=o.logSeverityLevel??2;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log serverity level is not valid: ${l}`);let p=o.logVerbosityLevel??0;if(!Number.isInteger(p)||p<0||p>4)throw new Error(`log verbosity level is not valid: ${p}`);let f=typeof o.optimizedModelFilePath==\"string\"?Pe(o.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(a,!!o.enableCpuMemArena,!!o.enableMemPattern,s,!!o.enableProfiling,0,d,l,p,f),n===0&&he(\"Can't create session options.\"),o.executionProviders&&qf(n,o.executionProviders,r),o.enableGraphCapture!==void 0){if(typeof o.enableGraphCapture!=\"boolean\")throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);let h=Pe(\"enableGraphCapture\",r),y=Pe(o.enableGraphCapture.toString(),r);t._OrtAddSessionConfigEntry(n,h,y)!==0&&he(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`)}if(o.freeDimensionOverrides)for(let[h,y]of Object.entries(o.freeDimensionOverrides)){if(typeof h!=\"string\")throw new Error(`free dimension override name must be a string: ${h}`);if(typeof y!=\"number\"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let _=Pe(h,r);t._OrtAddFreeDimensionOverride(n,_,y)!==0&&he(`Can't set a free dimension override: ${h} - ${y}.`)}return o.extra!==void 0&&Xt(o.extra,\"\",new WeakSet,(h,y)=>{let _=Pe(h,r),b=Pe(y,r);t._OrtAddSessionConfigEntry(n,_,b)!==0&&he(`Can't set a session config entry: ${h} - ${y}.`)}),[n,r]}catch(a){throw n!==0&&t._OrtReleaseSessionOptions(n)!==0&&he(\"Can't release session options.\"),r.forEach(s=>t._free(s)),a}}});var Rt,_t,wt,Br,Jt,Mr,Rr,Yn,te=G(()=>{\"use strict\";Rt=e=>{switch(e){case\"int8\":return 3;case\"uint8\":return 2;case\"bool\":return 9;case\"int16\":return 5;case\"uint16\":return 4;case\"int32\":return 6;case\"uint32\":return 12;case\"float16\":return 10;case\"float32\":return 1;case\"float64\":return 11;case\"string\":return 8;case\"int64\":return 7;case\"uint64\":return 13;case\"int4\":return 22;case\"uint4\":return 21;default:throw new Error(`unsupported data type: ${e}`)}},_t=e=>{switch(e){case 3:return\"int8\";case 2:return\"uint8\";case 9:return\"bool\";case 5:return\"int16\";case 4:return\"uint16\";case 6:return\"int32\";case 12:return\"uint32\";case 10:return\"float16\";case 1:return\"float32\";case 11:return\"float64\";case 8:return\"string\";case 7:return\"int64\";case 13:return\"uint64\";case 22:return\"int4\";case 21:return\"uint4\";default:throw new Error(`unsupported data type: ${e}`)}},wt=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r=typeof t==\"number\"?t:t.reduce((o,a)=>o*a,1);return n>0?Math.ceil(r*n):void 0},Br=e=>{switch(e){case\"float16\":return typeof Float16Array<\"u\"&&Float16Array.from?Float16Array:Uint16Array;case\"float32\":return Float32Array;case\"uint8\":return Uint8Array;case\"int8\":return Int8Array;case\"uint16\":return Uint16Array;case\"int16\":return Int16Array;case\"int32\":return Int32Array;case\"bool\":return Uint8Array;case\"float64\":return Float64Array;case\"uint32\":return Uint32Array;case\"int64\":return BigInt64Array;case\"uint64\":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Jt=e=>{switch(e){case\"verbose\":return 0;case\"info\":return 1;case\"warning\":return 2;case\"error\":return 3;case\"fatal\":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Mr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Rr=e=>e===\"float32\"||e===\"float16\"||e===\"int32\"||e===\"int64\"||e===\"uint32\"||e===\"uint64\"||e===\"int8\"||e===\"uint8\"||e===\"bool\"||e===\"uint4\"||e===\"int4\",Yn=e=>{switch(e){case\"none\":return 0;case\"cpu\":return 1;case\"cpu-pinned\":return 2;case\"texture\":return 3;case\"gpu-buffer\":return 4;case\"ml-tensor\":return 5;default:throw new Error(`unsupported data location: ${e}`)}}});var er,Xn=G(()=>{\"use strict\";xr();er=async e=>{if(typeof e==\"string\")if(false){}else{let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get(\"Content-Length\"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader(),a;try{a=new ArrayBuffer(r)}catch(d){if(d instanceof RangeError){let l=Math.ceil(r/65536);a=new WebAssembly.Memory({initial:l,maximum:l}).buffer}else throw d}let s=0;for(;;){let{done:d,value:l}=await o.read();if(d)break;let p=l.byteLength;new Uint8Array(a,s,p).set(l),s+=p}return new Uint8Array(a,0,r)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}});var Kf,jf,Bs,Ms,Ur,Zf,me,tt=G(()=>{\"use strict\";te();Kf=[\"V\",\"I\",\"W\",\"E\",\"F\"],jf=(e,t)=>{console.log(`[${Kf[e]},${new Date().toISOString()}]${t}`)},Ur=(e,t)=>{Bs=e,Ms=t},Zf=(e,t)=>{let n=Jt(e),r=Jt(Bs);n>=r&&jf(n,typeof t==\"function\"?t():t)},me=(...e)=>{Ms&&Zf(...e)}});var Nr,Jn=G(()=>{\"use strict\";te();Nr=(e,t)=>new(Br(t))(e)});var Vr=G(()=>{\"use strict\"});var Rs,eo,to,Qf,Yf,Us,no,ro,Vs,Ws=G(()=>{\"use strict\";tt();Vr();Rs=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),eo=[],to=e=>Math.ceil(Number(e)/16)*16,Qf=e=>{for(let t=0;t<eo.length;t++){let n=eo[t];if(e<=n)return n}return Math.ceil(e/16)*16},Yf=1,Us=()=>Yf++,no=async(e,t,n,r)=>{let o=to(n),a=e.device.createBuffer({size:o,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let s=e.getCommandEncoder();e.endComputePass(),s.copyBufferToBuffer(t,0,a,0,o),e.flush(),await a.mapAsync(GPUMapMode.READ);let d=a.getMappedRange();if(r){let l=r();return l.set(new Uint8Array(d,0,n)),l}else return new Uint8Array(d.slice(0,n))}finally{a.destroy()}},ro=class{constructor(t){this.backend=t;this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[n]of Rs)eo.push(n),this.freeBuffers.set(n,[]),this.freeUniformBuffers.set(n,[]);this.sessionCount=0}upload(t,n){let r=n.buffer,o=n.byteOffset,a=n.byteLength,s=to(a),d=this.storageCache.get(t);if(!d)throw new Error(\"gpu data for uploading does not exist\");if(Number(d.originalSize)!==a)throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${a}`);let l=this.backend.device.createBuffer({mappedAtCreation:!0,size:s,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),p=l.getMappedRange();new Uint8Array(p).set(new Uint8Array(r,o,a)),l.unmap();let f=this.backend.device.createCommandEncoder();f.copyBufferToBuffer(l,0,d.gpuData.buffer,0,s),this.backend.device.queue.submit([f.finish()]),l.destroy(),me(\"verbose\",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,n){let r=this.storageCache.get(t);if(!r)throw new Error(\"source gpu data for memcpy does not exist\");let o=this.storageCache.get(n);if(!o)throw new Error(\"destination gpu data for memcpy does not exist\");if(r.originalSize!==o.originalSize)throw new Error(\"inconsistent source and destination gpu data size\");let a=to(r.originalSize),s=this.backend.getCommandEncoder();this.backend.endComputePass(),s.copyBufferToBuffer(r.gpuData.buffer,0,o.gpuData.buffer,0,a)}registerExternalBuffer(t,n,r){let o;if(r){if(o=r[0],t===r[1])return me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, buffer is the same, skip.`),o;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`)}else o=Us();return this.storageCache.set(o,{gpuData:{id:o,type:0,buffer:t},originalSize:n}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${n}) => id=${o}, registered.`),o}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),me(\"verbose\",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,n=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r=Qf(t),o,a=(n&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,s=(n&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||s){let p=(a?this.freeBuffers:this.freeUniformBuffers).get(r);p?p.length>0?o=p.pop():o=this.backend.device.createBuffer({size:r,usage:n}):o=this.backend.device.createBuffer({size:r,usage:n})}else o=this.backend.device.createBuffer({size:r,usage:n});let d={id:Us(),type:0,buffer:o};return this.storageCache.set(d.id,{gpuData:d,originalSize:Number(t)}),me(\"verbose\",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`),d}get(t){return this.storageCache.get(t)?.gpuData}release(t){let n=typeof t==\"bigint\"?Number(t):t,r=this.storageCache.get(n);if(!r){if(this.storageCache.size===0)return 0;throw new Error(\"releasing data does not exist\")}return me(\"verbose\",()=>`[WebGPU] GpuDataManager.release(id=${n}), gpuDataId=${r.gpuData.id}`),this.storageCache.delete(n),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(t,n){let r=this.storageCache.get(Number(t));if(!r)throw new Error(\"data does not exist\");await no(this.backend,r.gpuData.buffer,r.originalSize,n)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus===\"default\"){for(let t of this.buffersPending){let n=Rs.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(t.size)||[];n===void 0||r.length>=n?t.destroy():r.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let n of this.buffersPending)t.push(n);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(n=>{n.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let n=this.capturedPendingBuffers.get(t);n&&(n.forEach(r=>{r.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(me(\"warning\",()=>\"[WebGPU] Clearing webgpu buffer cache\"),this.storageCache.forEach(r=>{r.gpuData.buffer.destroy()}),this.storageCache=new Map)}},Vs=(...e)=>new ro(...e)});var oo,re,Ce=G(()=>{\"use strict\";oo=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(\";\")),this.key}},re=e=>new oo(e)});var io,rt,E,kt,Wr,Ls,Gs,ae=G(()=>{\"use strict\";io=class{static calcMatMulShape(t,n){return t[1]!==n[0]?void 0:[t[0],n[1]]}},rt=class{static calcShape(t,n,r=!1){let o=t.length,a=n.length;if(o===0)return n;if(a===0)return t;let s=Math.max(t.length,n.length),d=new Array(s);if(r){if(o<2||a<2)return;let l=io.calcMatMulShape([t[o-2],t[o-1]],[n[a-2],n[a-1]]);if(l===void 0)return;[d[s-2],d[s-1]]=l}for(let l=r?3:1;l<=s;l++){let p=o-l<0?1:t[o-l],f=a-l<0?1:n[a-l];if(p!==f&&p>1&&f>1)return;let h=Math.max(p,f);if(p&&f)d[s-l]=Math.max(p,f);else{if(h>1)return;d[s-l]=0}}return d}static isValidBroadcast(t,n){let r=t.length,o=n.length;if(r>o)return!1;for(let a=1;a<=r;a++)if(t[r-a]!==1&&t[r-a]!==n[o-a])return!1;return!0}},E=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(t,n=4){let r=t.length;if(r===0)return[];let o=new Array(r),a=r-1;for(;a>=0;){if(t[a]%n===0){o[a]=t[a]/n;break}if(n%t[a]!==0)throw new Error(\"cannot convert shape\");o[a]=1,n/=t[a],a--}for(a--;a>=0;a--)o[a]=t[a];return o}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(t,n,r){let o=1;for(let a=n;a<r;a++){if(t[a]<0)throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");o*=Number(t[a])}return o}static computeStrides(t){let n=t.length;if(n===0)return[];if(n===1)return[1];let r=new Array(n);r[n-1]=1,r[n-2]=t[n-1];for(let o=n-3;o>=0;--o)r[o]=r[o+1]*t[o+1];return r}static normalizeAxis(t,n){if(t<-n&&t>=n)throw new Error(\"unsupported axis for this operation.\");return t<0?t+n:t}static normalizeAxes(t,n){return t.map(r=>this.normalizeAxis(r,n??t.length))}static sortBasedOnPerm(t,n){return n?n.map(r=>t[r]):t.slice().reverse()}static padShape(t,n){let r=t.length;return t.map((o,a)=>o+n[a]+n[a+r])}static areEqual(t,n){return t.length!==n.length?!1:t.every((r,o)=>r===n[o])}},kt=class e{static adjustPoolAttributes(t,n,r,o,a,s){if(!t&&r.length!==n.length-2)throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");if(t)for(let d=0;d<n.length-2;d++)d>=r.length?r.push(n[d+2]):r[d]=n[d+2];for(let d=0;d<r.length;d++)if(d<o.length){if(o[d]<0)throw new Error(\"strides should be greater than or equal to 1\")}else o.push(1);for(let d=0;d<r.length;d++)if(d<a.length){if(a[d]<0)throw new Error(\"dilations should be greater than or equal to 1\")}else a.push(1);for(let d=0;d<r.length*2;d++)if(d<s.length){if(s[d]<0)throw new Error(\"pad should be greater than or equal to 1\")}else s.push(0);for(let d=0;d<r.length;d++){if(r[d]<=0)throw new Error(\"kernel shapes need to be greater than 0\");if(s[d]>=r[d]||s[d+r.length]>=r[d])throw new Error(\"pads should be smaller than kernel\")}}static adjustPadsBasedOnAutoPad(t,n,r,o,a,s,d){if(d){if(a.length!==2*(t.length-2))throw new Error(\"length of pads should be twice the length of data dimensions\");if(n.length!==t.length-2)throw new Error(\"length of strides should be the length of data dimensions\");if(o.length!==t.length-2)throw new Error(\"length of kernel shapes should be the length of data dimensions\");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(s?1:2)],n[l],r[l],o[l],a,l,l+t.length-2,d)}}static computePoolOutputShape(t,n,r,o,a,s,d){if(n.length<=0)throw new Error(\"input shape must be of size greater than 0\");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,o,a,s,d),l}static computeConvOutputShape(t,n,r,o,a,s,d){if(t.length<=0||n.length<=0)throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,o,a,s,d),l}static computeShapeHelper(t,n,r,o,a,s,d,l){if(t)for(let p=0;p<n.length-2;p++)r.push(1);else for(let p=0;p<n.length-2;p++)r.push(e.adjustPadAndReturnShape(n[p+2],o[p],a[p],s[p],d,p,p+n.length-2,l))}static adjustPadAndReturnShape(t,n,r,o,a,s,d,l){let p=r*(o-1)+1;if(l&&l!==\"NOTSET\")switch(l){case\"VALID\":return a[s]=0,a[d]=0,Math.floor((t-p)/n+1);case\"SAME_LOWER\":case\"SAME_UPPER\":if(r!==1)throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");{let h=((t+n-1)/n-1)*n+o-t;return a[s]=Math.floor(l===\"SAME_LOWER\"?(h+1)/2:h/2),a[d]=h-a[s],Math.floor((t+h-o)/n+1)}default:throw new Error(\"Unsupported AutoPad type\")}else return Math.floor((t+a[s]+a[d]-p)/n+1)}},Wr=class{static getShapeOfGemmResult(t,n,r,o,a){if(t.length!==2||r.length!==2)throw new Error(\"shape need to be of size 2\");let s,d,l;n?(s=t[1],d=t[0]):(s=t[0],d=t[1]);let p=-1;if(o?(l=r[0],p=1):(l=r[1],p=0),r[p]!==d)throw new Error(\"dimension mismatch\");if(s<=0||l<=0||d<=0)throw new Error(\"invalid shape specified\");if(a&&!rt.isValidBroadcast(a,[s,l]))throw new Error(\"gemm: invalid bias shape for broadcast\");return[s,l,d]}},Ls=-34028234663852886e22,Gs=34028234663852886e22});var Et,so,_e,ze,H,ge,uo,Pt,Ke,K,Lr,P,N,Hs,Gr,ao,Fs,ce=G(()=>{\"use strict\";te();ae();Et=64,so=(e,t)=>{if(t===3)throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:\"f16\";case 1:return t>1?`vec${t}<f32>`:\"f32\";case 6:return t>1?`vec${t}<i32>`:\"i32\";case 12:return t>1?`vec${t}<u32>`:\"u32\";case 7:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"i32\"];case 13:if(t>1)throw new Error(\"currently not supported vecX of uint64 yet\");return[\"vec2<u32>\",\"u32\"];case 9:if(t!==4)throw new Error(\"bool must be vec4\");return[\"u32\",\"vec4<bool>\"];case 22:return\"i32\";case 21:return\"u32\";default:throw new Error(`Unknown data type: ${e}`)}},_e=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[0]},ze=(e,t=1)=>{let n=so(e,t);return typeof n==\"string\"?n:n[1]},H=(...e)=>{let t=[];return e.forEach(n=>{n.length!==0&&t.push({type:12,data:n},{type:12,data:E.computeStrides(n)})}),t},ge=e=>e%4===0?4:e%2===0?2:1,uo=(e=\"f32\",t,n=\"0\")=>!t||t===1?`${e}(${n})`:`vec${t}<${e}>(${n})`,Pt=(e,t,n)=>e===\"f32\"?n:t===1?`f32(${n})`:`vec${t}<f32>(${n})`,Ke=(e,t)=>t===4?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:t===2?`(${e}.x + ${e}.y)`:t===3?`(${e}.x + ${e}.y + ${e}.z)`:e,K=(e,t,n,r)=>e.startsWith(\"uniforms.\")&&n>4?typeof t==\"string\"?r===\"f16\"?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:r===\"f16\"?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,Lr=(e,t,n,r,o)=>{let a=typeof n==\"number\",s=a?n:n.length,d=[...new Array(s).keys()],l=s<2?\"u32\":s<=4?`vec${s}<u32>`:`array<u32, ${s}>`,p=so(t,o),f=typeof p==\"string\"?p:p[1],h=typeof p==\"string\"?p:p[0],y={indices:l,value:f,storage:h,tensor:t},_=R=>typeof R==\"string\"?R:`${R}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},w=a?\"uniforms.\":\"\",S=`${w}${e}_shape`,$=`${w}${e}_strides`,v=\"\";for(let R=0;R<s-1;R++)v+=`\n    let dim${R} = current / ${K($,R,s)};\n    let rest${R} = current % ${K($,R,s)};\n    indices[${R}] = dim${R};\n    current = rest${R};\n    `;v+=`indices[${s-1}] = current;`;let T=s<2?\"\":`\n  fn o2i_${e}(offset: u32) -> ${y.indices} {\n    var indices: ${y.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`,C=R=>(b.offsetToIndices=!0,s<2?R:`o2i_${e}(${R})`),A=[];if(s>=2)for(let R=s-1;R>=0;R--)A.push(`${K($,R,s)} * (indices[${R}])`);let k=s<2?\"\":`\n  fn i2o_${e}(indices: ${y.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`,O=R=>(b.indicesToOffset=!0,s<2?R:`i2o_${e}(${R})`),M=(...R)=>s===0?\"0u\":`${y.indices}(${R.map(_).join(\",\")})`,V=(R,Y)=>s<2?`${R}`:`${K(R,Y,s)}`,F=(R,Y,fe)=>s<2?`${R}=${fe};`:`${K(R,Y,s)}=${fe};`,j={},ne=(R,Y)=>{b.broadcastedIndicesToOffset=!0;let fe=`${Y.name}broadcastedIndicesTo${e}Offset`;if(fe in j)return`${fe}(${R})`;let Fe=[];for(let xe=s-1;xe>=0;xe--){let be=Y.indicesGet(\"outputIndices\",xe+Y.rank-s);Fe.push(`${V($,xe)} * (${be} % ${V(S,xe)})`)}return j[fe]=`fn ${fe}(outputIndices: ${Y.type.indices}) -> u32 {\n             return ${Fe.length>0?Fe.join(\"+\"):\"0u\"};\n           }`,`${fe}(${R})`},W=(R,Y)=>(()=>{if(y.storage===y.value)return`${e}[${R}]=${Y};`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), select(0u, 0xFFFFFFFFu, ${Y} < 0));`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`${e}[${R}]=vec2<u32>(u32(${Y}), 0u);`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`${e}[${R}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${Y}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),J=R=>(()=>{if(y.storage===y.value)return`${e}[${R}]`;if(y.storage===\"vec2<u32>\"&&y.value===\"i32\")return`i32(${e}[${R}].x)`;if(y.storage===\"vec2<u32>\"&&y.value===\"u32\")return`u32(${e}[${R}].x)`;if(y.storage===\"u32\"&&y.value===\"vec4<bool>\")return`vec4<bool>(bool(${e}[${R}] & 0xFFu), bool(${e}[${R}] & 0xFF00u), bool(${e}[${R}] & 0xFF0000u), bool(${e}[${R}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ve=s<2?\"\":`\n  fn get_${e}ByIndices(indices: ${y.indices}) -> ${f} {\n    return ${J(`i2o_${e}(indices)`)};\n  }`,Q=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn get_${e}(${R}) -> ${f} {\n    return get_${e}ByIndices(${M(Y)});\n  }`})(),ee=(...R)=>{if(R.length!==s)throw new Error(`indices length must be ${s}`);let Y=R.map(_).join(\",\");return s===0?J(\"0u\"):s===1?J(Y[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}(${Y})`)},le=R=>s<2?J(R):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${e}ByIndices(${R})`),Z=s<2?\"\":`\n  fn set_${e}ByIndices(indices: ${y.indices}, value: ${f}) {\n    ${W(`i2o_${e}(indices)`,\"value\")}\n  }`,pe=s<2?\"\":(()=>{let R=d.map(fe=>`d${fe}: u32`).join(\", \"),Y=d.map(fe=>`d${fe}`).join(\", \");return`\n  fn set_${e}(${R}, value: ${f}) {\n    set_${e}ByIndices(${M(Y)}, value);\n  }`})();return{impl:()=>{let R=[],Y=!1;return b.offsetToIndices&&(R.push(T),Y=!0),b.indicesToOffset&&(R.push(k),Y=!0),b.broadcastedIndicesToOffset&&(Object.values(j).forEach(fe=>R.push(fe)),Y=!0),b.set&&(R.push(pe),Y=!0),b.setByIndices&&(R.push(Z),Y=!0),b.get&&(R.push(Q),Y=!0),b.getByIndices&&(R.push(ve),Y=!0),!a&&Y&&R.unshift(`const ${S} = ${y.indices}(${n.join(\",\")});`,`const ${$} = ${y.indices}(${E.computeStrides(n).join(\",\")});`),R.join(`\n`)},type:y,offsetToIndices:C,indicesToOffset:O,broadcastedIndicesToOffset:ne,indices:M,indicesGet:V,indicesSet:F,set:(...R)=>{if(R.length!==s+1)throw new Error(`indices length must be ${s}`);let Y=R[s];if(typeof Y!=\"string\")throw new Error(\"value must be string\");let fe=R.slice(0,s).map(_).join(\",\");return s===0?W(\"0u\",Y):s===1?W(fe[0],Y):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}(${fe}, ${Y})`)},setByOffset:W,setByIndices:(R,Y)=>s<2?W(R,Y):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${e}ByIndices(${R}, ${Y});`),get:ee,getByOffset:J,getByIndices:le,usage:r,name:e,strides:$,shape:S,rank:s}},P=(e,t,n,r=1)=>Lr(e,t,n,\"input\",r),N=(e,t,n,r=1)=>Lr(e,t,n,\"output\",r),Hs=(e,t,n)=>Lr(e,t,n,\"atomicOutput\",1),Gr=(e,t,n,r=1)=>Lr(e,t,n,\"internal\",r),ao=class{constructor(t,n){this.normalizedDispatchGroup=t;this.limits=n;this.internalVariables=[];this.variables=[];this.uniforms=[];this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t==\"number\"?`${t}u`:t}) { return; }`}mainStart(t=Et){let n=typeof t==\"number\"?t:t[0],r=typeof t==\"number\"?1:t[1],o=typeof t==\"number\"?1:t[2];if(n>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||o>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(n*r*o>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${n}, ${r}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,s=a?`@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`,d=a?`let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${n*r*o}u + local_idx;`;return`@compute @workgroup_size(${n}, ${r}, ${o})\n  fn main(${s}) {\n    ${d}\n  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.shape.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}),t.strides.startsWith(\"uniforms.\")&&this.uniforms.push({name:t.strides.replace(\"uniforms.\",\"\"),type:\"u32\",length:t.rank}))}declareVariable(t,n){if(t.usage===\"internal\")throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");this.variables.push(t),this.appendVariableUniforms(t);let r=t.usage===\"input\"?\"read\":\"read_write\",o=t.usage===\"atomicOutput\"?\"atomic<i32>\":t.type.storage;return`@group(0) @binding(${n}) var<storage, ${r}> ${t.name}: array<${o}>;`}declareVariables(...t){return t.map(n=>this.declareVariable(n,this.variableIndex++)).join(`\n`)}registerInternalVariable(t){if(t.usage!==\"internal\")throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(n=>this.registerInternalVariable(n)),this}registerUniform(t,n,r=1){return this.uniforms.push({name:t,type:n,length:r}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return\"\";let t=[];for(let{name:n,type:r,length:o}of this.uniforms)if(o&&o>4)r===\"f16\"?t.push(`@align(16) ${n}:array<mat2x4<${r}>, ${Math.ceil(o/8)}>`):t.push(`${n}:array<vec4<${r}>, ${Math.ceil(o/4)}>`);else{let a=o==null||o===1?r:`vec${o}<${r}>`;t.push(`${n}:${a}`)}return`\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`\n`)+this.internalVariables.map(t=>t.impl()).join(`\n`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=n=>[12,10,1,6][[\"u32\",\"f16\",\"f32\",\"i32\"].indexOf(n)];return this.uniforms.map(n=>[t(n.type),n.length??1])}},Fs=(e,t)=>new ao(e,t)});var Xf,qs,Jf,eh,th,rh,Oe,Ks,js,ct=G(()=>{\"use strict\";te();ae();Ce();ce();Xf=(e,t)=>{if(!e||e.length!==1)throw new Error(\"Transpose requires 1 input.\");if(t.length!==0&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},qs=(e,t)=>t.length!==0?t:[...new Array(e).keys()].reverse(),Jf=(e,t)=>E.sortBasedOnPerm(e,qs(e.length,t)),eh=(e,t,n,r)=>{let o=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let a=0;a<t;++a)o+=`a[${e[a]}]=i[${a}];`;return o+=\"return a;}\"},th=(e,t)=>{let n=[],r=[];for(let o=0;o<e.length;++o)e[o]!==1&&n.push(e[o]),e[t[o]]!==1&&r.push(t[o]);return{newShape:n,newPerm:r}},rh=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(t[e[r]]!==1){if(e[r]<n)return!1;n=e[r]}return!0},Oe=(e,t)=>{let n=e.dataType,r=e.dims.length,o=qs(r,t),a=Jf(e.dims,o),s=e.dims,d=a,l=r<2||rh(o,e.dims),p;if(l)return p=w=>{let S=P(\"input\",n,s,4),$=N(\"output\",n,d,4);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`},{name:\"TransposeCopy\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64/4)},programUniforms:[{type:12,data:Math.ceil(w/4)}]}},getShaderSource:p};let{newShape:f,newPerm:h}=th(e.dims,o),y=E.areEqual(h,[2,3,1]),_=E.areEqual(h,[3,1,2]);if(f.length===2||y||_){s=y?[f[0],f[1]*f[2]]:_?[f[0]*f[1],f[2]]:f,d=[s[1],s[0]];let w=16;return p=S=>{let $=P(\"a\",n,s.length),v=N(\"output\",n,d.length);return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables($,v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${w+1}>, ${w}>;\n  ${S.mainStart([w,w,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${w} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${w}u + local_id.x;\n    let input_row = workgroup_id_x * ${w}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${w}u + local_id.x;\n    let output_row = workgroup_id_y * ${w}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`,\"tile[local_id.x][local_id.y]\")}\n    }\n  }`},{name:\"TransposeShared\",shaderCache:{inputDependencies:[\"type\"]},getRunData:()=>{let S=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(d[1]/w),y:Math.ceil(d[0]/w)},programUniforms:[{type:12,data:S},...H(s,d)]}},getShaderSource:p}}return p=w=>{let S=P(\"a\",n,s.length),$=N(\"output\",n,d.length);return`\n  ${w.registerUniform(\"output_size\",\"u32\").declareVariables(S,$)}\n\n  ${eh(o,r,S,$)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\",S.getByIndices(\"aIndices\"))}\n  }`},{name:\"Transpose\",shaderCache:{hint:`${t}`,inputDependencies:[\"rank\"]},getRunData:()=>{let w=E.size(a);return{outputs:[{dims:a,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(w/64)},programUniforms:[{type:12,data:w},...H(s,d)]}},getShaderSource:p}},Ks=(e,t)=>{Xf(e.inputs,t.perm),e.compute(Oe(e.inputs[0],t.perm))},js=e=>re({perm:e.perm})});var nh,oh,ih,ah,sh,uh,dh,lh,ch,ph,nt,Zs,Qs,Ys,Xs,Js,eu,tu,ru,nu,ou,iu=G(()=>{\"use strict\";te();ae();ce();Hr();ct();nh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate * candidate\",logSumExp:\"bestValue + exp(candidate)\",l1:\"bestValue + abs(candidate)\",l2:\"bestValue + candidate * candidate\",logSum:\"bestValue + candidate\"},oh={max:\"select(bestValue, candidate, candidate > bestValue)\",min:\"select(bestValue, candidate, candidate < bestValue)\",mean:\"bestValue + candidate\",sum:\"bestValue + candidate\",prod:\"bestValue * candidate\",sumSquare:\"bestValue + candidate\",logSumExp:\"bestValue + candidate\",l1:\"bestValue + candidate\",l2:\"bestValue + candidate\",logSum:\"bestValue + candidate\"},ih={max:\"_A[offset]\",min:\"_A[offset]\",mean:\"0\",sum:\"0\",prod:\"1\",sumSquare:\"0\",logSumExp:\"0\",l1:\"0\",l2:\"0\",logSum:\"0\"},ah={max:\"bestValue\",min:\"bestValue\",sum:\"bestValue\",prod:\"bestValue\",sumSquare:\"bestValue\",logSumExp:\"log(bestValue)\",l1:\"bestValue\",l2:\"sqrt(bestValue)\",logSum:\"log(bestValue)\"},sh=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},uh=(e,t)=>{let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let o=t.map(a=>e[a]);return[n,o]},dh=(e,t)=>{let n=e.length+t.length,r=[],o=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?r.push(e[o++]):r.push(1);return r},lh=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},ch=(e,t)=>{let n=[];if(!lh(e,t)){for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);e.forEach(r=>n.push(r))}return n},ph=(e,t,n,r,o,a,s)=>{let d=n[0].dims,l=E.size(a),p=E.size(s),f=P(\"_A\",n[0].dataType,d),h=N(\"output\",o,a),y=64;l===1&&(y=256);let _=`\n          var<workgroup> aBestValues : array<f32, ${y}>;\n       `,b=w=>`\n        ${w.registerUniform(\"reduceSize\",\"u32\").declareVariables(f,h)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${w.mainStart(y)}\n\n          let outputIndex = global_idx / ${y};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${ih[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${y}) {\n           let candidate = f32(${f.getByOffset(\"offset + k\")});\n           bestValue = ${nh[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${y}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${oh[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${h.setByOffset(\"outputIndex\",`${r===\"mean\"?`${h.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${h.type.storage}(${ah[r]})`}`)};\n         }\n        }`;return{name:e,shaderCache:{hint:`${t};${y}`,inputDependencies:[\"type\"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:a,dataType:o}],dispatchGroup:{x:l},programUniforms:[{type:12,data:p}]})}},nt=(e,t,n,r)=>{let o=e.inputs.length===1?n:lo(e.inputs,n),a=o.axes;a.length===0&&!o.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((_,b)=>b));let s=E.normalizeAxes(a,e.inputs[0].dims.length),d=s,l=e.inputs[0],p=ch(d,e.inputs[0].dims.length);p.length>0&&(l=e.compute(Oe(e.inputs[0],p),{inputs:[0],outputs:[-1]})[0],d=sh(d.length,l.dims.length));let[f,h]=uh(l.dims,d),y=f;o.keepDims&&(y=dh(f,s)),e.compute(ph(t,o.cacheKey,[l],r,e.inputs[0].dataType,y,h),{inputs:[l]})},Zs=(e,t)=>{nt(e,\"ReduceMeanShared\",t,\"mean\")},Qs=(e,t)=>{nt(e,\"ReduceL1Shared\",t,\"l1\")},Ys=(e,t)=>{nt(e,\"ReduceL2Shared\",t,\"l2\")},Xs=(e,t)=>{nt(e,\"ReduceLogSumExpShared\",t,\"logSumExp\")},Js=(e,t)=>{nt(e,\"ReduceMaxShared\",t,\"max\")},eu=(e,t)=>{nt(e,\"ReduceMinShared\",t,\"min\")},tu=(e,t)=>{nt(e,\"ReduceProdShared\",t,\"prod\")},ru=(e,t)=>{nt(e,\"ReduceSumShared\",t,\"sum\")},nu=(e,t)=>{nt(e,\"ReduceSumSquareShared\",t,\"sumSquare\")},ou=(e,t)=>{nt(e,\"ReduceLogSumShared\",t,\"logSum\")}});var ot,mh,Fr,lo,it,fh,hh,gh,yh,bh,_h,wh,vh,$h,xh,at,au,su,uu,du,lu,cu,pu,mu,fu,hu,Hr=G(()=>{\"use strict\";te();ae();Ce();ce();iu();ot=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"Reduce op requires 1 or 2 inputs.\");if(e.length===2&&e[1].dims.length!==1)throw new Error(\"Invalid axes input dims.\")},mh=e=>[\"\",\"\",`var value = ${e.getByIndices(\"input_indices\")};`,\"\"],Fr=(e,t,n,r,o,a,s=!1,d=!1)=>{let l=[],p=n[0].dims,f=p.length,h=E.normalizeAxes(o,f),y=!d&&h.length===0;p.forEach((S,$)=>{y||h.indexOf($)>=0?s&&l.push(1):l.push(S)});let _=l.length,b=E.size(l);return{name:e,shaderCache:t,getShaderSource:S=>{let $=[],v=P(\"_A\",n[0].dataType,f),T=N(\"output\",a,_),C=r(v,T,h),A=C[2];for(let k=0,O=0;k<f;k++)y||h.indexOf(k)>=0?(s&&O++,A=`for(var j${k}: u32 = 0; j${k} < ${p[k]}; j${k}++) {\n                  ${C[2].includes(\"last_index\")?`let last_index = j${k};`:\"\"}\n                  ${v.indicesSet(\"input_indices\",k,`j${k}`)}\n                  ${A}\n                }`):($.push(`${v.indicesSet(\"input_indices\",k,T.indicesGet(\"output_indices\",O))};`),O++);return`\n\n        ${S.registerUniform(\"output_size\",\"u32\").declareVariables(v,T)}\n\n        ${S.mainStart()}\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${T.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${C[0]}       // init ops for reduce max/min\n          ${C[1]}\n          ${A}\n          ${C[3]}\n          ${C.length===4?T.setByOffset(\"global_idx\",\"value\"):C.slice(4).join(`\n`)}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...H(p,l)]})}},lo=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(r=>n.push(Number(r))),re({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},it=(e,t,n,r)=>{let o=e.inputs,a=o.length===1?n:lo(o,n);e.compute(Fr(t,{hint:a.cacheKey,inputDependencies:[\"rank\"]},[o[0]],a.noopWithEmptyAxes&&a.axes.length===0?mh:r,a.axes,o[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},fh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"value = log(value);\"])},hh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL1\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += abs(${r.getByIndices(\"input_indices\")});`,\"\"])},gh=(e,t)=>{ot(e.inputs),it(e,\"ReduceL2\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += (t * t);`,\"value = sqrt(value);\"])},yh=(e,t)=>{ot(e.inputs),it(e,\"ReduceLogSumExp\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += exp(${r.getByIndices(\"input_indices\")});`,\"value = log(value);\"])},bh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMax\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(r.indicesSet(\"input_indices\",d,0));return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = max(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},_h=(e,t)=>{ot(e.inputs),it(e,\"ReduceMean\",t,(r,o,a)=>{let s=1;for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&(s*=e.inputs[0].dims[d]);return[\"var sum = f32(0);\",\"\",`sum += f32(${r.getByIndices(\"input_indices\")});`,`let value = ${o.type.value}(sum / ${s});`]})},wh=(e,t)=>{ot(e.inputs),it(e,\"ReduceMin\",t,(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};`,`value = min(value, ${r.getByIndices(\"input_indices\")});`,\"\"]})},vh=(e,t)=>{ot(e.inputs),it(e,\"ReduceProd\",t,(r,o)=>[`var value = ${o.type.storage}(1);`,\"\",`value *= ${r.getByIndices(\"input_indices\")};`,\"\"])},$h=(e,t)=>{ot(e.inputs),it(e,\"ReduceSum\",t,(r,o)=>[`var value = ${o.type.storage}(0);`,\"\",`value += ${r.getByIndices(\"input_indices\")};`,\"\"])},xh=(e,t)=>{ot(e.inputs),it(e,\"ReduceSumSquare\",t,(r,o)=>[`var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\"\",`t = ${r.getByIndices(\"input_indices\")}; value += t * t;`,\"\"])},at=(e,t,n)=>{if(t.length===0)return n;let r=1,o=1;for(let a=0;a<t.length;a++)t.indexOf(a)===-1?r*=e[a]:o*=e[a];return o<32&&r>1024},au=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_h(e,t):Zs(e,t)},su=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hh(e,t):Qs(e,t)},uu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gh(e,t):Ys(e,t)},du=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yh(e,t):Xs(e,t)},lu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bh(e,t):Js(e,t)},cu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wh(e,t):eu(e,t)},pu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vh(e,t):tu(e,t)},mu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$h(e,t):ru(e,t)},fu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xh(e,t):nu(e,t)},hu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fh(e,t):ou(e,t)}});var gu,yu,bu,co,_u=G(()=>{\"use strict\";te();Ce();Hr();gu=e=>{if(!e||e.length===0||e.length>2)throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");if(e[0].dataType!==1)throw new Error(\"Invalid input type.\")},yu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\"<=\":\"<\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"ArgMin\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},bu=(e,t)=>{gu(e.inputs);let n=(r,o,a)=>{let s=[];for(let d=0;d<r.rank;d++)(a.indexOf(d)>=0||a.length===0)&&s.push(`input_indices[${d}] = 0;`);return[`${s.join(`\n`)}`,`var value = ${r.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,`if (${r.getByIndices(\"input_indices\")} ${t.selectLastIndex>0?\">=\":\">\"} value) {\n         value = ${r.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\"\",o.setByOffset(\"global_idx\",\"best_index\")]};e.compute(Fr(\"argMax\",{hint:t.cacheKey,inputDependencies:[\"rank\"]},[e.inputs[0]],n,[t.axis],7,t.keepDims),{inputs:[0]})},co=e=>re(e)});var Sh,po,Th,Ch,Ih,Ut,Ah,wu,qr=G(()=>{\"use strict\";te();ae();Vr();ce();Sh=(e,t)=>{let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],d=e[5];if(s&&d)throw new Error(\"Attention cannot have both past and attention_bias\");if(n.dims.length!==3)throw new Error('Input \"input\" must have 3 dimensions');let l=n.dims[0],p=n.dims[1],f=n.dims[2];if(o.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimensions');if(r.dims.length!==2)throw new Error('Input \"weights\" is expected to have 2 dimensions');if(r.dims[0]!==f)throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");if(o.dims[0]!==r.dims[1])throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');let h=o.dims[0]/3,y=h,_=y;if(t.qkvHiddenSizes.length>0){if(t.qkvHiddenSizes.length!==3)throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");for(let T of t.qkvHiddenSizes)if(T%t.numHeads!==0)throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");h=t.qkvHiddenSizes[0],y=t.qkvHiddenSizes[1],_=t.qkvHiddenSizes[2]}let b=p;if(h!==y)throw new Error(\"qkv_hidden_sizes first element should be same as the second\");if(o.dims[0]!==h+y+_)throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');let w=0;if(s){if(y!==_)throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');if(s.dims.length!==5)throw new Error('Input \"past\" must have 5 dimensions');if(s.dims[0]!==2)throw new Error('Input \"past\" first dimension must be 2');if(s.dims[1]!==l)throw new Error('Input \"past\" second dimension must be batch_size');if(s.dims[2]!==t.numHeads)throw new Error('Input \"past\" third dimension must be num_heads');if(s.dims[4]!==y/t.numHeads)throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(w=s.dims[3])}let S=b+w,$=-1,v=0;if(a)throw new Error(\"Mask not supported\");if(s)throw new Error(\"past is not supported\");if(d){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" must have 4 dimensions');if(d.dims[0]!==l||d.dims[1]!==t.numHeads||d.dims[2]!==p||d.dims[3]!==S)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:p,pastSequenceLength:w,kvSequenceLength:b,totalSequenceLength:S,maxSequenceLength:$,inputHiddenSize:f,hiddenSize:h,vHiddenSize:_,headSize:Math.floor(h/t.numHeads),vHeadSize:Math.floor(_/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:v,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},po=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?\"let past_sequence_length = uniforms.past_sequence_length\":\"\"};\n    let present_sequence_length = total_sequence_length;\n    `,Th=(e,t,n,r,o,a,s,d)=>{let l=ge(s?1:a),p=64,f=a/l;f<p&&(p=32);let h=Math.ceil(a/l/p),y=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:o},{type:12,data:f},{type:12,data:h}],_=_e(e.dataType,l),b=ze(1,l),w=[\"type\"];s&&w.push(\"type\"),d&&w.push(\"type\");let S=$=>{let v=N(\"x\",e.dataType,e.dims,l),T=[v],C=s?P(\"seq_lens\",s.dataType,s.dims):void 0;C&&T.push(C);let A=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;A&&T.push(A);let k=ze(e.dataType),O=[{name:\"batch_size\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"sequence_length\",type:\"u32\"},{name:\"total_sequence_length\",type:\"u32\"},{name:\"elements_per_thread\",type:\"u32\"}];return`\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(O).declareVariables(...T)}\n  ${$.mainStart([p,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${po(C,A,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${s?\"u32(past_sequence_length + workgroup_id.y + 1)\":\"total_sequence_length\"};\n    var thread_max_vector = ${b}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${b}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return\"thread_max_vector\";case 2:return\"max(thread_max_vector.x, thread_max_vector.y)\";case 4:return\"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${b}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${b}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return\"sum_vector\";case 2:return\"sum_vector.x + sum_vector.y\";case 4:return\"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${k}(1.0) / ${k}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${b}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${s?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${k}(0));\n        }`:\"\"};\n  }`};return{name:\"AttentionProbsSoftmax\",shaderCache:{hint:`${p};${_};${l}`,inputDependencies:w},getShaderSource:S,getRunData:()=>({outputs:[],dispatchGroup:{x:Math.ceil(a/p),y:o,z:t*n},programUniforms:y})}},Ch=(e,t,n,r,o,a,s,d,l)=>{let p=s+a.kvSequenceLength,f=[a.batchSize,a.numHeads,a.sequenceLength,p],h=e>1&&r,y=a.kvNumHeads?a.kvNumHeads:a.numHeads,_=h?[a.batchSize,y,p,a.headSize]:void 0,b=a.nReps?a.nReps:1,w=a.scale===0?1/Math.sqrt(a.headSize):a.scale,S=ge(a.headSize),$=a.headSize/S,v=12,T={x:Math.ceil(p/v),y:Math.ceil(a.sequenceLength/v),z:a.batchSize*a.numHeads},C=[{type:12,data:a.sequenceLength},{type:12,data:$},{type:12,data:p},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:w},{type:12,data:s},{type:12,data:a.kvSequenceLength},{type:12,data:b}],A=h&&r&&E.size(r.dims)>0,k=[\"type\",\"type\"];A&&k.push(\"type\"),o&&k.push(\"type\"),d&&k.push(\"type\"),l&&k.push(\"type\");let O=[{dims:f,dataType:t.dataType,gpuDataType:0}];h&&O.push({dims:_,dataType:t.dataType,gpuDataType:0});let M=V=>{let F=P(\"q\",t.dataType,t.dims,S),j=P(\"key\",n.dataType,n.dims,S),ne=[F,j];if(A){let Z=P(\"past_key\",r.dataType,r.dims,S);ne.push(Z)}o&&ne.push(P(\"attention_bias\",o.dataType,o.dims));let W=d?P(\"seq_lens\",d.dataType,d.dims):void 0;W&&ne.push(W);let J=l?P(\"total_sequence_length_input\",l.dataType,l.dims):void 0;J&&ne.push(J);let ve=N(\"output\",t.dataType,f),Q=[ve];h&&Q.push(N(\"present_key\",t.dataType,_,S));let ee=ze(1,S),le=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${F.type.storage}, ${v*v}>;\n  var<workgroup> tileK: array<${F.type.storage}, ${v*v}>;\n  ${V.registerUniforms(le).declareVariables(...ne,...Q)}\n  ${V.mainStart([v,v,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${b===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${b===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${po(W,J,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A&&h?\"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\":\"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${h?\"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\":\"\"}\n    var value = ${ee}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${A&&h?`\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }`:`\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`}\n      ${h?`if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }`:\"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(S){case 1:return\"value\";case 2:return\"value.x + value.y\";case 4:return\"value.x + value.y + value.z + value.w\";default:throw new Error(`Unsupported components: ${S}`)}})()};\n        output[outputIdx] = ${ve.type.value} (sum * uniforms.alpha) + ${o?\"attention_bias[outputIdx]\":\"0.0\"};\n    }\n  }`};return{name:\"AttentionProbs\",shaderCache:{hint:`${S};${o!==void 0};${r!==void 0};${e}`,inputDependencies:k},getRunData:()=>({outputs:O,dispatchGroup:T,programUniforms:C}),getShaderSource:M}},Ih=(e,t,n,r,o,a,s=void 0,d=void 0)=>{let l=a+o.kvSequenceLength,p=o.nReps?o.nReps:1,f=o.vHiddenSize*p,h=e>1&&r,y=o.kvNumHeads?o.kvNumHeads:o.numHeads,_=h?[o.batchSize,y,l,o.headSize]:void 0,b=[o.batchSize,o.sequenceLength,f],w=12,S={x:Math.ceil(o.vHeadSize/w),y:Math.ceil(o.sequenceLength/w),z:o.batchSize*o.numHeads},$=[{type:12,data:o.sequenceLength},{type:12,data:l},{type:12,data:o.vHeadSize},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:12,data:f},{type:12,data:a},{type:12,data:o.kvSequenceLength},{type:12,data:p}],v=h&&r&&E.size(r.dims)>0,T=[\"type\",\"type\"];v&&T.push(\"type\"),s&&T.push(\"type\"),d&&T.push(\"type\");let C=[{dims:b,dataType:t.dataType,gpuDataType:0}];h&&C.push({dims:_,dataType:t.dataType,gpuDataType:0});let A=k=>{let O=P(\"probs\",t.dataType,t.dims),M=P(\"v\",n.dataType,n.dims),V=[O,M];v&&V.push(P(\"past_value\",r.dataType,r.dims));let F=s?P(\"seq_lens\",s.dataType,s.dims):void 0;s&&V.push(F);let j=d?P(\"total_sequence_length_input\",d.dataType,d.dims):void 0;d&&V.push(j);let W=[N(\"output\",t.dataType,b)];h&&W.push(N(\"present_value\",t.dataType,_));let J=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"v_hidden_size\",type:\"u32\"},{name:\"past_sequence_length\",type:\"u32\"},{name:\"kv_sequence_length\",type:\"u32\"},{name:\"n_reps\",type:\"u32\"}];return`\n  const TILE_SIZE = ${w}u;\n  var<workgroup> tileQ: array<${O.type.value}, ${w*w}>;\n  var<workgroup> tileV: array<${O.type.value}, ${w*w}>;\n  ${k.registerUniforms(J).declareVariables(...V,...W)}\n  ${k.mainStart([w,w,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p===1?\"headIdx\":\"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p===1?\"uniforms.num_heads\":\"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${po(F,j,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v&&h?\"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\":\"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${h?\"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\":\"\"}\n   var value = ${O.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${v&&h?`\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      `:`\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`}\n        ${h?`\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }`:\"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`};return{name:\"AttentionScore\",shaderCache:{hint:`${r!==void 0};${e}`,inputDependencies:T},getRunData:()=>({outputs:C,dispatchGroup:S,programUniforms:$}),getShaderSource:A}},Ut=(e,t,n,r,o,a,s,d,l,p,f=void 0,h=void 0)=>{let y=Math.min(e.outputCount,1+(s?1:0)+(d?1:0)),_=y>1?p.pastSequenceLength:0,b=_+p.kvSequenceLength,w=l&&E.size(l.dims)>0?l:void 0,S=[t,n];y>1&&s&&E.size(s.dims)>0&&S.push(s),w&&S.push(w),f&&S.push(f),h&&S.push(h);let $=e.compute(Ch(y,t,n,s,w,p,_,f,h),{inputs:S,outputs:y>1?[-1,1]:[-1]})[0];e.compute(Th($,p.batchSize,p.numHeads,_,p.sequenceLength,b,f,h),{inputs:f&&h?[$,f,h]:[$],outputs:[]});let v=[$,r];y>1&&d&&E.size(d.dims)>0&&v.push(d),f&&v.push(f),h&&v.push(h),e.compute(Ih(y,$,r,d,p,_,f,h),{inputs:v,outputs:y>1?[0,2]:[0]})},Ah=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,o=t.inputHiddenSize,a=t.headSize,s=12,d={x:Math.ceil(t.headSize/s),y:Math.ceil(t.sequenceLength/s),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],p=[{type:12,data:r},{type:12,data:o},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}],f=h=>{let y=N(\"output_q\",l[0].dataType,n),_=N(\"output_k\",l[0].dataType,n),b=N(\"output_v\",l[0].dataType,n),w=P(\"input\",l[0].dataType,l[0].dims),S=P(\"weight\",l[1].dataType,l[1].dims),$=P(\"bias\",l[2].dataType,l[2].dims),v=w.type.storage,T=[{name:\"M\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"num_heads\",type:\"u32\"},{name:\"head_size\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"ldb\",type:\"u32\"}];return`\n  const TILE_SIZE = ${s}u;\n  var<workgroup> tileInput: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightQ: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightK: array<${v}, ${s*s}>;\n  var<workgroup> tileWeightV: array<${v}, ${s*s}>;\n  ${h.registerUniforms(T).declareVariables(w,S,$,y,_,b)}\n  ${h.mainStart([s,s,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`};return e.compute({name:\"AttentionPrepare\",shaderCache:{inputDependencies:[\"type\",\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:d,programUniforms:p}),getShaderSource:f},{inputs:l,outputs:[-1,-1,-1]})},wu=(e,t)=>{let n=Sh(e.inputs,t),[r,o,a]=Ah(e,n);return Ut(e,r,o,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}});var kh,Eh,Ph,vu,$u=G(()=>{\"use strict\";Ge();te();ae();Ce();ce();kh=(e,t)=>{if(!e||e.length!==5)throw new Error(\"BatchNormalization requires 5 inputs\");let n=(r,o,a)=>{let s=o.length;if(s!==r.length)throw new Error(`${a}: num dimensions != ${s}`);o.forEach((d,l)=>{if(d!==r[l])throw new Error(`${a}: dim[${l}] do not match`)})};if(e[0].dims.length>1){let r=t.format===\"NHWC\"?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,\"Invalid input scale\"),n(e[2].dims,r,\"Invalid input B\"),n(e[3].dims,r,\"Invalid input mean\"),n(e[4].dims,r,\"Invalid input var\")}else n(e[1].dims,[1],\"Invalid input scale\"),n(e[2].dims,[1],\"Invalid input B\"),n(e[3].dims,[1],\"Invalid input mean\"),n(e[4].dims,[1],\"Invalid input var\")},Eh=(e,t)=>{let{epsilon:n,spatial:r,format:o}=t,a=e[0].dims,s=r?ge(a[a.length-1]):1,d=o===\"NHWC\"&&a.length>1?s:1,l=E.size(a)/s,p=r,f=p?a.length:a,h=P(\"x\",e[0].dataType,e[0].dims,s),y=P(\"scale\",e[1].dataType,e[1].dims,d),_=P(\"bias\",e[2].dataType,e[2].dims,d),b=P(\"inputMean\",e[3].dataType,e[3].dims,d),w=P(\"inputVar\",e[4].dataType,e[4].dims,d),S=N(\"y\",e[0].dataType,f,s),$=()=>{let T=\"\";if(r)T=`let cOffset = ${a.length===1?\"0u\":o===\"NHWC\"?`outputIndices[${a.length-1}] / ${s}`:\"outputIndices[1]\"};`;else if(o===\"NCHW\")T=`\n            ${S.indicesSet(\"outputIndices\",\"0\",\"0\")}\n            let cOffset = ${S.indicesToOffset(\"outputIndices\")};`;else{T=`var cIndices = ${y.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let C=1;C<y.rank;C++)T+=`cIndices[${C}] = outputIndices[${C}];`;T+=`let cOffset = ${y.indicesToOffset(\"cIndices\")};`}return T},v=T=>`\n  const epsilon = ${n};\n  ${T.registerUniform(\"outputSize\",\"u32\").declareVariables(h,y,_,b,w,S)}\n  ${T.mainStart()}\n  ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${S.offsetToIndices(`global_idx * ${s}`)};\n    ${$()}\n    let scale = ${y.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${b.getByOffset(\"cOffset\")};\n    let inputVar = ${w.getByOffset(\"cOffset\")};\n    let x = ${h.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${S.setByOffset(\"global_idx\",\"value\")}\n  }`;return{name:\"BatchNormalization\",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${s}`,inputDependencies:p?[\"rank\",\"type\",\"type\",\"type\",\"type\"]:void 0},getShaderSource:v,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p?[{type:12,data:l},...H(a)]:[{type:12,data:l}]})}},Ph=e=>re(e),vu=(e,t)=>{let{inputs:n,outputCount:r}=e,o=Ph({...t,outputCount:r});if(we.webgpu.validateInputContent&&kh(n,o),t.trainingMode)throw new Error(\"BatchNormalization trainingMode is not supported yet.\");e.compute(Eh(n,o))}});var zh,Oh,xu,Su=G(()=>{\"use strict\";ae();ce();zh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![320,640,1280].includes(e[0].dims[2]))throw new Error(\"number of channels should be 320, 640 or 1280\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Oh=e=>{let t=e[0].dims,n=e[0].dims[2],r=E.size(t)/4,o=e[0].dataType,a=P(\"input\",o,t,4),s=P(\"bias\",o,[n],4),d=P(\"residual\",o,t,4),l=N(\"output\",o,t,4);return{name:\"BiasAdd\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:f=>`\n  const channels = ${n}u / 4;\n  ${f.declareVariables(a,s,d,l)}\n\n  ${f.mainStart()}\n    ${f.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${a.getByOffset(\"global_idx\")}\n      + ${s.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\",\"value\")}\n  }`}},xu=e=>{zh(e.inputs),e.compute(Oh(e.inputs))}});var Dh,ye,Tu,Cu,Iu,Au,ku,Eu,Pu,zu,Ou,Bh,Du,Bu,Mu,Ru,tr,Uu,Kr,Nu,Vu,Wu,Lu,Gu,Hu,Fu,qu,Ku,ju,Zu,Qu,Yu,Xu,Ju,ed,td,rd,mo,fo,nd,od,id,Mh,Rh,ad,jr=G(()=>{\"use strict\";te();ae();Ce();ce();Dh=(e,t,n,r,o,a,s)=>{let d=Math.ceil(t/4),l=\"\";typeof o==\"string\"?l=`${o}(a)`:l=o(\"a\");let p=P(\"inputData\",n,[d],4),f=N(\"outputData\",r,[d],4),h=[{name:\"vec_size\",type:\"u32\"}];return s&&h.push(...s),`\n      ${e.registerUniforms(h).declareVariables(p,f)}\n\n  ${a??\"\"}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${f.setByOffset(\"global_idx\",l)}\n  }`},ye=(e,t,n,r,o,a=e.dataType,s,d)=>{let l=[{type:12,data:Math.ceil(E.size(e.dims)/4)}];return s&&l.push(...s),{name:t,shaderCache:{hint:o,inputDependencies:[\"type\"]},getShaderSource:p=>Dh(p,E.size(e.dims),e.dataType,a,n,r,d),getRunData:p=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(E.size(p[0].dims)/64/4)},programUniforms:l})}},Tu=e=>{e.compute(ye(e.inputs[0],\"Abs\",\"abs\"))},Cu=e=>{e.compute(ye(e.inputs[0],\"Acos\",\"acos\"))},Iu=e=>{e.compute(ye(e.inputs[0],\"Acosh\",\"acosh\"))},Au=e=>{e.compute(ye(e.inputs[0],\"Asin\",\"asin\"))},ku=e=>{e.compute(ye(e.inputs[0],\"Asinh\",\"asinh\"))},Eu=e=>{e.compute(ye(e.inputs[0],\"Atan\",\"atan\"))},Pu=e=>{e.compute(ye(e.inputs[0],\"Atanh\",\"atanh\"))},zu=e=>re(e),Ou=(e,t)=>{let n;switch(t.to){case 10:n=\"vec4<f16>\";break;case 1:n=\"vec4<f32>\";break;case 12:n=\"vec4<u32>\";break;case 6:n=\"vec4<i32>\";break;case 9:n=\"vec4<bool>\";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(ye(e.inputs[0],\"Cast\",n,void 0,t.cacheKey,t.to))},Bh=e=>{let t,n,r=e.length>=2&&e[1].data!==0,o=e.length>=3&&e[2].data!==0;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=o?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=o?e[2].getUint16Array()[0]:31743;break;default:throw new Error(\"Unsupport data type\")}return re({min:t,max:n})},Du=(e,t)=>{let n=t||Bh(e.inputs),r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Clip\",o=>`clamp(${o}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:\"min\",type:r},{name:\"max\",type:r}]),{inputs:[0]})},Bu=e=>{e.compute(ye(e.inputs[0],\"Ceil\",\"ceil\"))},Mu=e=>{e.compute(ye(e.inputs[0],\"Cos\",\"cos\"))},Ru=e=>{e.compute(ye(e.inputs[0],\"Cosh\",\"cosh\"))},tr=e=>re(e),Uu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Elu\",r=>`elu_vf32(${r})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Kr=(e=\"f32\")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Nu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Erf\",n=>`erf_vf32(${n})`,Kr(t)))},Vu=e=>{e.compute(ye(e.inputs[0],\"Exp\",\"exp\"))},Wu=e=>{e.compute(ye(e.inputs[0],\"Floor\",\"floor\"))},Lu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Gelu\",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Kr(t)))},Gu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"LeakyRelu\",r=>`select(leaky_relu_alpha_ * ${r}, ${r}, ${r} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},Hu=e=>{e.compute(ye(e.inputs[0],\"Not\",t=>`!${t}`))},Fu=e=>{e.compute(ye(e.inputs[0],\"Neg\",t=>`-${t}`))},qu=e=>{e.compute(ye(e.inputs[0],\"Reciprocal\",t=>`1.0/${t}`))},Ku=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"Relu\",n=>`select(vec4<${t}>(0.0), ${n}, ${n} > vec4<${t}>(0.0))`))},ju=e=>{e.compute(ye(e.inputs[0],\"Sigmoid\",t=>`(1.0 / (1.0 + exp(-${t})))`))},Zu=e=>re(e),Qu=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"HardSigmoid\",r=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${r} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},Yu=e=>{e.compute(ye(e.inputs[0],\"Sin\",\"sin\"))},Xu=e=>{e.compute(ye(e.inputs[0],\"Sinh\",\"sinh\"))},Ju=e=>{e.compute(ye(e.inputs[0],\"Sqrt\",\"sqrt\"))},ed=e=>{e.compute(ye(e.inputs[0],\"Tan\",\"tan\"))},td=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,rd=e=>{e.compute(ye(e.inputs[0],\"Tanh\",td))},mo=(e=\"f32\")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${td(\"v\")};\n}\n`,fo=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,nd=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"FastGelu\",fo,mo(t),void 0,e.inputs[0].dataType))},od=(e,t)=>{let n=ze(e.inputs[0].dataType);return e.compute(ye(e.inputs[0],\"ThresholdedRelu\",r=>`select(vec4<${n}>(0.0), ${r}, ${r} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},id=e=>{e.compute(ye(e.inputs[0],\"Log\",\"log\"))},Mh=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Rh=e=>`quick_gelu_impl(${e})`,ad=(e,t)=>{let n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],\"QuickGelu\",Rh,Mh(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}});var Uh,Nh,ud,dd=G(()=>{\"use strict\";ae();ce();jr();Uh=e=>{if(e[0].dims.length!==3)throw new Error(\"input should have 3 dimensions\");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error(\"hidden state should be 2560, 5120 or 10240\");if(e[1].dims.length!==1)throw new Error(\"bias is expected to have 1 dimensions\");if(e[0].dims[2]!==e[1].dims[0])throw new Error(\"last dimension of input and bias are not the same\")},Nh=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=P(\"input\",e[0].dataType,e[0].dims,4),r=P(\"bias\",e[0].dataType,[e[0].dims[2]],4),o=N(\"output\",e[0].dataType,t,4),a=E.size(t)/4,s=_e(e[0].dataType);return{name:\"BiasSplitGelu\",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:l=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${l.declareVariables(n,r,o)}\n\n  ${Kr(s)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\",\"valueLeft * geluRight\")}\n  }`}},ud=e=>{Uh(e.inputs),e.compute(Nh(e.inputs))}});var Vh,Wh,st,ld,cd,pd,md,fd,hd,gd,yd,bd,_d,wd=G(()=>{\"use strict\";te();ae();ce();Vh=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y,_;typeof d==\"string\"?y=_=(v,T)=>`${d}((${v}),(${T}))`:typeof d==\"function\"?y=_=d:(y=d.scalar,_=d.vector);let b=N(\"outputData\",f,r.length,4),w=P(\"aData\",l,t.length,4),S=P(\"bData\",p,n.length,4),$;if(o)if(a){let v=E.size(t)===1,T=E.size(n)===1,C=t.length>0&&t[t.length-1]%4===0,A=n.length>0&&n[n.length-1]%4===0;v||T?$=b.setByOffset(\"global_idx\",_(v?`${w.type.value}(${w.getByOffset(\"0\")}.x)`:w.getByOffset(\"global_idx\"),T?`${S.type.value}(${S.getByOffset(\"0\")}.x)`:S.getByOffset(\"global_idx\"))):$=`\n            let outputIndices = ${b.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${w.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            let offsetB = ${S.broadcastedIndicesToOffset(\"outputIndices\",b)};\n            ${b.setByOffset(\"global_idx\",_(s||C?w.getByOffset(\"offsetA / 4u\"):`${w.type.value}(${w.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`,s||A?S.getByOffset(\"offsetB / 4u\"):`${S.type.value}(${S.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `}else $=b.setByOffset(\"global_idx\",_(w.getByOffset(\"global_idx\"),S.getByOffset(\"global_idx\")));else{if(!a)throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");let v=(T,C,A=\"\")=>{let k=`aData[indexA${C}][componentA${C}]`,O=`bData[indexB${C}][componentB${C}]`;return`\n            let outputIndices${C} = ${b.offsetToIndices(`global_idx * 4u + ${C}u`)};\n            let offsetA${C} = ${w.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let offsetB${C} = ${S.broadcastedIndicesToOffset(`outputIndices${C}`,b)};\n            let indexA${C} = offsetA${C} / 4u;\n            let indexB${C} = offsetB${C} / 4u;\n            let componentA${C} = offsetA${C} % 4u;\n            let componentB${C} = offsetB${C} % 4u;\n            ${T}[${C}] = ${A}(${y(k,O)});\n          `};f===9?$=`\n            var data = vec4<u32>(0);\n            ${v(\"data\",0,\"u32\")}\n            ${v(\"data\",1,\"u32\")}\n            ${v(\"data\",2,\"u32\")}\n            ${v(\"data\",3,\"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:$=`\n            ${v(\"outputData[global_idx]\",0)}\n            ${v(\"outputData[global_idx]\",1)}\n            ${v(\"outputData[global_idx]\",2)}\n            ${v(\"outputData[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(w,S,b)}\n\n        ${h??\"\"}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`},Wh=(e,t,n,r,o,a,s=n.dataType)=>{let d=n.dims.map(w=>Number(w)??1),l=r.dims.map(w=>Number(w)??1),p=!E.areEqual(d,l),f=d,h=E.size(d),y=!1,_=!1,b=[p];if(p){let w=rt.calcShape(d,l,!1);if(!w)throw new Error(\"Can't perform binary op on the given tensors\");f=w.slice(),h=E.size(f);let S=E.size(d)===1,$=E.size(l)===1,v=d.length>0&&d[d.length-1]%4===0,T=l.length>0&&l[l.length-1]%4===0;b.push(S),b.push($),b.push(v),b.push(T);let C=1;for(let A=1;A<f.length;A++){let k=d[d.length-A],O=l[l.length-A];if(k===O)C*=k;else break}C%4===0?(_=!0,y=!0):(S||$||v||T)&&(y=!0)}else y=!0;return b.push(y),{name:e,shaderCache:{hint:t+b.map(w=>w.toString()).join(\"_\"),inputDependencies:[\"rank\",\"rank\"]},getShaderSource:w=>Vh(w,d,l,f,y,p,_,o,n.dataType,r.dataType,s,a),getRunData:()=>({outputs:[{dims:f,dataType:s}],dispatchGroup:{x:Math.ceil(h/64/4)},programUniforms:[{type:12,data:Math.ceil(E.size(f)/4)},...H(d,l,f)]})}},st=(e,t,n,r,o,a)=>{e.compute(Wh(t,o??\"\",e.inputs[0],e.inputs[1],n,r,a))},ld=e=>{st(e,\"Add\",(t,n)=>`${t}+${n}`)},cd=e=>{st(e,\"Div\",(t,n)=>`${t}/${n}`)},pd=e=>{st(e,\"Equal\",{scalar:(t,n)=>`u32(${t}==${n})`,vector:(t,n)=>`vec4<u32>(${t}==${n})`},void 0,void 0,9)},md=e=>{st(e,\"Mul\",(t,n)=>`${t}*${n}`)},fd=e=>{let t=P(\"input\",e.inputs[0].dataType,e.inputs[0].dims).type.value;st(e,\"Pow\",{scalar:(r,o)=>`pow_custom(${r},${o})`,vector:(r,o)=>`pow_vector_custom(${r},${o})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t===\"i32\"?\"round\":\"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},hd=e=>{st(e,\"Sub\",(t,n)=>`${t}-${n}`)},gd=e=>{st(e,\"Greater\",{scalar:(t,n)=>`u32(${t}>${n})`,vector:(t,n)=>`vec4<u32>(${t}>${n})`},void 0,void 0,9)},yd=e=>{st(e,\"Less\",{scalar:(t,n)=>`u32(${t}<${n})`,vector:(t,n)=>`vec4<u32>(${t}<${n})`},void 0,void 0,9)},bd=e=>{st(e,\"GreaterOrEqual\",{scalar:(t,n)=>`u32(${t}>=${n})`,vector:(t,n)=>`vec4<u32>(${t}>=${n})`},void 0,void 0,9)},_d=e=>{st(e,\"LessOrEqual\",{scalar:(t,n)=>`u32(${t}<=${n})`,vector:(t,n)=>`vec4<u32>(${t}<=${n})`},void 0,void 0,9)}});var Gh,Hh,Fh,qh,vd,$d,xd=G(()=>{\"use strict\";te();ae();Ce();ce();Gh=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");let n=0,r=e[n],o=r.dataType,a=r.dims.length;e.forEach((s,d)=>{if(d!==n){if(s.dataType!==o)throw new Error(\"input tensors should be one type\");if(s.dims.length!==a)throw new Error(\"input tensors should have the same shape\");s.dims.forEach((l,p)=>{if(p!==t&&l!==r.dims[p])throw new Error(\"non concat dimensions must match\")})}})},Hh=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Fh=(e,t)=>{let n=e.length,r=[];for(let o=0;o<n;++o){let a=t.setByOffset(\"global_idx\",e[o].getByIndices(\"indices\"));n===1?r.push(a):o===0?r.push(`if (inputIndex == ${o}u) { ${a} }`):o===n-1?r.push(`else { ${a} }`):r.push(`else if (inputIndex == ${o}) { ${a} }`)}return r.join(`\n`)},qh=(e,t,n,r)=>{let o=E.size(n),a=new Array(e.length),s=new Array(e.length),d=0,l=[],p=[],f=[{type:12,data:o}];for(let w=0;w<e.length;++w)d+=e[w].dims[t],a[w]=d,p.push(e[w].dims.length),s[w]=P(`input${w}`,r,p[w]),l.push(\"rank\"),f.push({type:12,data:a[w]});for(let w=0;w<e.length;++w)f.push(...H(e[w].dims));f.push(...H(n));let h=N(\"output\",r,n.length),y=h.indicesGet(\"indices\",t),_=Array.from(Array(a.length).keys()).map(w=>`uniforms.sizeInConcatAxis${w}`).join(\",\"),b=w=>`\n\n  ${(()=>{w.registerUniform(\"outputSize\",\"u32\");for(let S=0;S<e.length;S++)w.registerUniform(`sizeInConcatAxis${S}`,\"u32\");return w.declareVariables(...s,h)})()}\n\n  ${Hh(a.length,_)}\n\n  ${w.mainStart()}\n    ${w.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${h.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${y});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${_});\n      ${y} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Fh(s,h)}\n  }`;return{name:\"Concat\",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:b}},vd=(e,t)=>{let n=e.inputs,r=n[0].dims,o=E.normalizeAxis(t.axis,r.length);Gh(n,o);let a=r.slice();a[o]=n.reduce((d,l)=>d+(l.dims.length>o?l.dims[o]:0),0);let s=n.filter(d=>E.size(d.dims)>0);e.compute(qh(s,o,a,n[0].dataType),{inputs:s})},$d=e=>re({axis:e.axis})});var je,Ze,Qe,Zr,vt=G(()=>{\"use strict\";te();ae();je=(e,t,n=\"f32\")=>{switch(e.activation){case\"Relu\":return`value = max(value, ${t}(0.0));`;case\"Sigmoid\":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case\"Clip\":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case\"HardSigmoid\":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case\"LeakyRelu\":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case\"Tanh\":return`let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;case\"\":return\"\";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ze=(e,t)=>{e.activation===\"Clip\"?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):e.activation===\"HardSigmoid\"?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):e.activation===\"LeakyRelu\"&&t.push({type:1,data:e.alpha})},Qe=(e,t)=>{e.activation===\"Clip\"?t.push({name:\"clip_max\",type:\"f32\"},{name:\"clip_min\",type:\"f32\"}):e.activation===\"HardSigmoid\"?t.push({name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}):e.activation===\"LeakyRelu\"&&t.push({name:\"alpha\",type:\"f32\"})},Zr=e=>{let t=e?.activation||\"\";if(t===\"HardSigmoid\"){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}else if(t===\"Clip\"){let[n,r]=e?.activation_params||[Ls,Gs];return{activation:t,clipMax:r,clipMin:n}}else if(t===\"LeakyRelu\"){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}});var Ee,Sd,Qr=G(()=>{\"use strict\";Ee=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Sd=e=>`\n      ${e?\"value = value + getBiasByOutputCoords(coords);\":\"\"}\n      `});var Td,Cd=G(()=>{\"use strict\";Td=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`});var rr,Yr,Xr=G(()=>{\"use strict\";te();ae();ce();vt();rr=(e,t,n,r,o)=>{let a=r-n;return`\n      ${Array.from({length:n}).map((s,d)=>`\n      if (${K(t.shape,d,t.rank)} != 1) {\n        ${t.indicesSet(e,d,K(o,d+a,r))}\n      } else {\n        ${t.indicesSet(e,d,0)}\n      }`).join(\"\")}\n`},Yr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s[s.length-2],p=d[d.length-1],f=s[s.length-1],h=ge(p),y=ge(f),_=ge(l),b=E.size(n)/h/_,w=e.length>2,S=r?r.slice(0,-2):n.slice(0,-2),v=[E.size(S),l,p],T=[{type:12,data:b},{type:12,data:l},{type:12,data:p},{type:12,data:f}];Ze(t,T),T.push(...H(S,s,d)),w&&T.push(...H(e[2].dims)),T.push(...H(v));let C=A=>{let k=Gr(\"batch_dims\",e[0].dataType,S.length),O=P(\"a\",e[0].dataType,s.length,y),M=P(\"b\",e[1].dataType,d.length,h),V=N(\"output\",e[0].dataType,v.length,h),F=_e(V.type.tensor),j=je(t,V.type.value,F),ne=[O,M],W=\"\";if(w){let Q=o?h:1;ne.push(P(\"bias\",e[2].dataType,e[2].dims.length,Q)),W=`${o?`value += bias[col / ${Q}];`:`value += ${V.type.value}(bias[row + i]);`}`}let J=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"}];Qe(t,J);let ve=()=>{let Q=`var a_data: ${O.type.value};`;for(let ee=0;ee<y;ee++)Q+=`\n              let b_data${ee} = b[(b_offset + (k + ${ee}) * uniforms.N + col) / ${h}];`;for(let ee=0;ee<_;ee++){Q+=`a_data = a[(a_offset + (row + ${ee}) * uniforms.K + k) / ${y}];`;for(let le=0;le<y;le++)Q+=`\n            values[${ee}] = fma(${M.type.value}(a_data${y===1?\"\":`[${le}]`}), b_data${le}, values[${ee}]);\n`}return Q};return`\n  ${A.registerUniforms(J).registerInternalVariables(k).declareVariables(...ne,V)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${h})) * ${h};\n    var index1 = global_idx / (uniforms.N / ${h});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${n.length===2?\"\":`let batch_indices = ${k.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${O.type.indices};\n    ${rr(\"a_indices\",O,O.rank-2,k.rank,\"batch_indices\")}\n    ${O.indicesSet(\"a_indices\",O.rank-2,0)}\n    ${O.indicesSet(\"a_indices\",O.rank-1,0)}\n    let a_offset = ${O.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${M.type.indices};\n    ${rr(\"b_indices\",M,M.rank-2,k.rank,\"batch_indices\")}\n    ${M.indicesSet(\"b_indices\",M.rank-2,0)}\n    ${M.indicesSet(\"b_indices\",M.rank-1,0)}\n    let b_offset = ${M.indicesToOffset(\"b_indices\")};\n    var values: array<${V.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {\n      ${ve()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${W}\n      ${j}\n      let cur_indices = ${V.type.indices}(batch, row + i, col);\n      let offset = ${V.indicesToOffset(\"cur_indices\")};\n      ${V.setByOffset(`offset / ${h}`,\"value\")};\n    }\n  }\n  `};return{name:\"MatMulNaive\",shaderCache:{hint:`${t.activation};${h};${y};${_};${o}`,inputDependencies:w?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:T}),getShaderSource:C}}});var Kh,jh,ho,Id,Zh,go,Qh,nr,Jr=G(()=>{\"use strict\";te();ae();ce();vt();Xr();Qr();Kh=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?\", batchIndices\":\"\"});\n        `,jh=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t===3?\"\":\"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t===3?\"\":\"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`,ho=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32)=>{let l=t[1]*e[1],p=t[0]*e[0],f=o?l:a,h=o?a:l,y=f/t[0],_=a/t[1];if(!((o&&y===4&&e[1]===4||!o&&(y===3||y===4))&&f%t[0]===0&&a%t[1]===0&&e[0]===4))throw new Error(`If transposeA ${o} is true, innerElementSize ${y} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${y} must be 3 or 4.\n  tileAWidth ${f} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${y}<${n}>, ${f/y}>, ${h}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${p/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${y};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${s?\"0\":\"i32(globalId.z)\"};\n  ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Kh(o,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?\", batchIndices\":\"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${y===3?\"\":\"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${jh(o,y)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Id=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?\", batchIndices\":\"\"});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?\", batchIndices\":\"\"});\n            `,Zh=e=>e?\"let ACached = mm_Asub[k][tileRow + innerRow];\":\"let ACached = mm_Asub[tileRow + innerRow][k];\",go=(e,t,n=\"f32\",r,o=!1,a=32,s=!1,d=32,l=!1)=>{let p=e[1]*t[1],f=e[0]*t[0],h=o?p:a,y=o?a:p;if(!(y%t[1]===0&&h%t[0]===0&&a%t[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let _=y/t[1],b=h/t[0],w=a/t[1],S=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${f};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n          ${Id(o,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${f}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?\", batchIndices\":\"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${b};\nlet tileRowB = i32(localId.y) * ${w};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Id(o,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${w}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?\", batchIndices\":\"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Zh(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${h}>, ${y}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${f}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${s?\"0\":\"i32(globalId.z)\"};\n    ${r?`let batchIndices = ${r.offsetToIndices(\"u32(batch)\")};`:\"\"}\n    let num_tiles = ${s?`${Math.ceil(d/a)}`:\"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${s?`i32(globalId.z) * ${d}`:\"0\"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${S}\n  }\n`},Qh=(e,t,n,r,o=!1)=>{let[a,s,d,l]=r,p=_e(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${s.type.indices};\n        ${rr(\"aIndices\",s,s.rank-2,a.rank,\"batchIndices\")}\n        ${s.indicesSet(\"aIndices\",s.rank-2,\"u32(row)\")}\n        ${s.indicesSet(\"aIndices\",s.rank-1,\"u32(colIn)\")}\n        value = ${s.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${Ee(e,p)} {\n      var value = ${Ee(e,p)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${rr(\"bIndices\",d,d.rank-2,a.rank,\"batchIndices\")}\n        ${d.indicesSet(\"bIndices\",d.rank-2,\"u32(row)\")}\n        ${d.indicesSet(\"bIndices\",d.rank-1,\"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ee(e,p)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${o?\"bias[colIn]\":`${Ee(e,p)}(bias[row])`};`:\"\"}\n        ${n}\n        ${l.setByIndices(\"vec3<u32>(coords)\",\"value\")}\n      }\n    }\n    `},nr=(e,t,n,r,o=!1,a)=>{let s=e[0].dims,d=e[1].dims,l=s.slice(0,-2),p=d.slice(0,-2),f=r?r.slice(0,-2):n.slice(0,-2),h=E.size(f),y=s[s.length-2],_=s[s.length-1],b=d[d.length-1],w=_%4===0&&b%4===0,S=y<=8?[4,1,1]:[4,4,1],$=[8,8,1],v=[Math.ceil(b/$[0]/S[0]),Math.ceil(y/$[1]/S[1]),Math.ceil(h/$[2]/S[2])],T=w?4:1,C=[...l,y,_/T],A=C.length,k=[...p,_,b/T],O=k.length,M=[h,y,b/T],V=[{type:6,data:y},{type:6,data:b},{type:6,data:_}];Ze(t,V),V.push(...H(f,C,k));let F=[\"rank\",\"rank\"],j=e.length>2;j&&(V.push(...H(e[2].dims)),F.push(\"rank\")),V.push(...H(M));let ne=W=>{let J=f.length,ve=Gr(\"batchDims\",e[0].dataType,J,1),Q=_e(e[0].dataType),ee=P(\"a\",e[0].dataType,A,T),le=P(\"b\",e[1].dataType,O,T),Z=N(\"result\",e[0].dataType,M.length,T),pe=[ee,le];if(j){let Y=o?T:1;pe.push(P(\"bias\",e[2].dataType,e[2].dims.length,Y))}let ke=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"}];Qe(t,ke);let Se=_e(Z.type.tensor),D=je(t,Z.type.value,Se),R=Qh(T,j,D,[ve,ee,le,Z],o);return`\n  ${W.registerUniforms(ke).registerInternalVariables(ve).declareVariables(...pe,Z)}\n  ${R}\n  ${w?ho(S,$,Q,ve):go(S,$,Q,ve)}\n                   `};return{name:\"MatMul\",shaderCache:{hint:`${S};${t.activation};${w};${o}`,inputDependencies:F},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:v[0],y:v[1],z:v[2]},programUniforms:V}),getShaderSource:ne}}});var Yh,Ad,kd=G(()=>{\"use strict\";te();tt();ce();vt();Qr();Cd();Jr();Yh=(e,t,n,r,o=!1,a,s=4,d=4,l=4,p=\"f32\")=>{let f=F=>{switch(F){case 1:return\"resData = x[xIndex];\";case 3:return`resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return\"resData = x[xIndex / 4];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},h=F=>{switch(F){case 1:return\"return w[row * i32(uniforms.w_shape[3]) + colIn];\";case 4:return\"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";default:throw new Error(`innerElementSize ${F} is not supported.`)}},y=e?`\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    `:`\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `,_=e?`\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    `:`\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `,b=e?\"i32(uniforms.x_shape[1])\":\"i32(uniforms.x_shape[2])\",w=e?\"i32(uniforms.x_shape[2])\":\"i32(uniforms.x_shape[3])\",S=e?\"row\":\"col\",$=e?\"col\":\"row\",v=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n    let outRow = ${S} / outWidth;\n    let outCol = ${S} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ee(s,p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${w}) {\n      ${y}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${f(s)}\n    }\n    return resData;`,T=e?t&&r?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`:r&&n?`\n    let col = colIn * ${s};\n    ${v}`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ee(s,p)}(0.0);`,C=e?r&&n?h(d):`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`:`\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${h(d)}\n    }\n    return ${Ee(d,p)}(0.0);`,A=Ee(l,p),k=e?Ee(s,p):Ee(d,p),O=e?Ee(d,p):Ee(s,p),M=je(a,A,p);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e?T:C}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${O} {\n      ${e?C:T}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?\"i32(uniforms.result_shape[2])\":\"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Sd(o)}\n      ${M}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ad=(e,t,n,r,o,a,s,d,l)=>{let p=t.format===\"NHWC\",f=p?e[0].dims[3]:e[0].dims[1],h=n[0],y=p?n[2]:n[3],_=p?n[1]:n[2],b=p?n[3]:n[1],w=p&&(f%4===0||f%3===0)&&b%4===0,S=p?b:y*_,$=p?y*_:b,v=[8,8,1],T=r<=8?[4,1,1]:[4,4,1],C=[Math.ceil(S/v[0]/T[0]),Math.ceil($/v[1]/T[1]),Math.ceil(h/v[2]/T[2])];me(\"verbose\",()=>`[conv2d_mm_webgpu] dispatch = ${C}`);let A=w?p&&f%4!==0?3:4:1,k=v[1]*T[1],O=v[0]*T[0],M=Math.max(v[0]*A,v[1]),V=r%k===0,F=o%O===0,j=a%M===0,ne=w?[A,4,4]:[1,1,1],W=[{type:6,data:r},{type:6,data:o},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ze(t,W),W.push(...H(e[0].dims,e[1].dims));let J=[\"rank\",\"rank\"];s&&(W.push(...H(e[2].dims)),J.push(\"rank\")),W.push(...H(n));let ve=Q=>{let ee=[{name:\"dim_a_outer\",type:\"i32\"},{name:\"dim_b_outer\",type:\"i32\"},{name:\"dim_inner\",type:\"i32\"},{name:\"pad\",type:\"i32\",length:2},{name:\"stride\",type:\"i32\",length:2},{name:\"dilation\",type:\"i32\",length:2}];Qe(t,ee);let le=w?4:1,Z=_e(e[0].dataType),pe=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        result[flatIndex] = ${w?`vec4<${Z}>`:Z}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${w?`vec4<${Z}>`:Z}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${w?\"/ 4\":\"\"}, value);\n      }`,ke=P(\"x\",e[0].dataType,e[0].dims.length,A===3?1:A),Se=P(\"w\",e[1].dataType,e[1].dims.length,le),D=[ke,Se],R=N(\"result\",e[0].dataType,n.length,le);if(s){let Y=P(\"bias\",e[2].dataType,e[2].dims.length,le);D.push(Y),pe+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${w?`vec4<${Z}>`:Z} {\n          return bias[coords.${p?\"w\":\"y\"}${w?\"/ 4\":\"\"}];\n        }`}return`\n        ${Td(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Q.registerUniforms(ee).declareVariables(...D,R)}\n        ${pe}\n        ${Yh(p,V,F,j,s,t,ne[0],ne[1],ne[2],Z)}\n        ${w?ho(T,v,Z,void 0,!p,M):go(T,v,Z,void 0,!p,M,!1,void 0,d)}`};return{name:\"Conv2DMatMul\",shaderCache:{hint:`${t.cacheKey};${A};${w};${V};${F};${j};${k};${O};${M}`,inputDependencies:J},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:W}),getShaderSource:ve}}});var Xh,Ed,en,Jh,Pd,eg,zd,Od,Dd=G(()=>{\"use strict\";te();tt();ae();ce();vt();Qr();Xh=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},Ed=e=>typeof e==\"number\"?[e,e,e]:e,en=(e,t)=>t<=1?e:e+(e-1)*(t-1),Jh=(e,t,n,r=1)=>{let o=en(t,r);return Math.floor((e[0]*(n-1)-n+o)/2)},Pd=(e,t,n,r,o)=>{o==null&&(o=Jh(e,t[0],r[0]));let a=[0,0,0,n];for(let s=0;s<3;s++)e[s]+2*o>=t[s]&&(a[s]=Math.trunc((e[s]-t[s]+2*o)/r[s]+1));return a},eg=(e,t,n,r,o,a,s,d,l,p)=>{let f,h,y,_;if(e===\"VALID\"&&(e=0),typeof e==\"number\"){f={top:e,bottom:e,left:e,right:e,front:e,back:e};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e);h=b[0],y=b[1],_=b[2]}else if(Array.isArray(e)){if(!e.every((w,S,$)=>w===$[0]))throw Error(`Unsupported padding parameter: ${e}`);f={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let b=Pd([t,n,r,1],[d,l,p],1,[o,a,s],e[0]);h=b[0],y=b[1],_=b[2]}else if(e===\"SAME_UPPER\"){h=Math.ceil(t/o),y=Math.ceil(n/a),_=Math.ceil(r/s);let b=(h-1)*o+d-t,w=(y-1)*a+l-n,S=(_-1)*s+p-r,$=Math.floor(b/2),v=b-$,T=Math.floor(w/2),C=w-T,A=Math.floor(S/2),k=S-A;f={top:T,bottom:C,left:A,right:k,front:$,back:v}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:f,outDepth:h,outHeight:y,outWidth:_}},zd=(e,t,n,r,o,a=!1,s=\"channelsLast\")=>{let d,l,p,f,h;if(s===\"channelsLast\")[d,l,p,f,h]=e;else if(s===\"channelsFirst\")[d,h,l,p,f]=e;else throw new Error(`Unknown dataFormat ${s}`);let[y,,_,b,w]=t,[S,$,v]=Ed(n),[T,C,A]=Ed(r),k=en(_,T),O=en(b,C),M=en(w,A),{padInfo:V,outDepth:F,outHeight:j,outWidth:ne}=eg(o,l,p,f,S,$,v,k,O,M),W=a?y*h:y,J=[0,0,0,0,0];return s===\"channelsFirst\"?J=[d,W,F,j,ne]:s===\"channelsLast\"&&(J=[d,F,j,ne,W]),{batchSize:d,dataFormat:s,inDepth:l,inHeight:p,inWidth:f,inChannels:h,outDepth:F,outHeight:j,outWidth:ne,outChannels:W,padInfo:V,strideDepth:S,strideHeight:$,strideWidth:v,filterDepth:_,filterHeight:b,filterWidth:w,effectiveFilterDepth:k,effectiveFilterHeight:O,effectiveFilterWidth:M,dilationDepth:T,dilationHeight:C,dilationWidth:A,inShape:e,outShape:J,filterShape:t}},Od=(e,t,n,r,o,a)=>{let s=a===\"channelsLast\",d=s?e[0].dims[3]:e[0].dims[1],l=!1,p=[64,1,1],f={x:n.map((v,T)=>T)},h=[Math.ceil(Xh(f.x.map(v=>n[v]))/p[0]),1,1];me(\"verbose\",()=>`[conv3d_naive_webgpu] dispatch = ${h}`);let y=l?s&&d%4!==0?3:4:1,_=E.size(n),b=[{type:12,data:_},{type:12,data:r},{type:12,data:o},{type:12,data:t.strides},{type:12,data:t.dilations}];Ze(t,b),b.push(...H(e[0].dims,e[1].dims));let w=[\"rank\",\"rank\"],S=e.length===3;S&&(b.push(...H(e[2].dims)),w.push(\"rank\")),b.push(...H(n));let $=v=>{let T=[{name:\"output_size\",type:\"u32\"},{name:\"filter_dims\",type:\"u32\",length:r.length},{name:\"pads\",type:\"u32\",length:o.length},{name:\"strides\",type:\"u32\",length:t.strides.length},{name:\"dilations\",type:\"u32\",length:t.dilations.length}];Qe(t,T);let C=l?4:1,A=_e(e[0].dataType),k=P(\"x\",e[0].dataType,e[0].dims.length,y===3?1:y),O=P(\"W\",e[1].dataType,e[1].dims.length,C),M=[k,O],V=N(\"result\",e[0].dataType,n.length,C),F=\"\";if(S){let W=P(\"bias\",e[2].dataType,e[2].dims.length,C);M.push(W),F+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l?`vec4<${A}>`:A} {\n          return bias[${s?K(\"coords\",4,5):K(\"coords\",1,5)}${l?\"/ 4\":\"\"}];\n        }`}let j=Ee(y,A),ne=je(t,j,A);return`\n            ${F}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${k.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${O.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(T).declareVariables(...M,V)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${V.offsetToIndices(\"global_idx\")};\n              let batch = ${K(\"coords\",0,k.rank)};\n              let d2 = ${s?K(\"coords\",k.rank-1,k.rank):K(\"coords\",1,k.rank)};\n              let xFRCCorner = vec3<u32>(${s?K(\"coords\",1,k.rank):K(\"coords\",2,k.rank)},\n              ${s?K(\"coords\",2,k.rank):K(\"coords\",3,k.rank)},\n              ${s?K(\"coords\",3,k.rank):K(\"coords\",4,k.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${s?K(\"uniforms.x_shape\",1,k.rank):K(\"uniforms.x_shape\",2,k.rank)};\n              let xShapeZ = ${s?K(\"uniforms.x_shape\",2,k.rank):K(\"uniforms.x_shape\",3,k.rank)};\n              let xShapeW = ${s?K(\"uniforms.x_shape\",3,k.rank):K(\"uniforms.x_shape\",4,k.rank)};\n              let xShapeU = ${s?K(\"uniforms.x_shape\",4,k.rank):K(\"uniforms.x_shape\",1,k.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${s?`let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            `:`let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${s?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${s?`let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      `:`let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${s?`let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      `:`let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${S?\"value = value + getBiasByOutputCoords(coords)\":\"\"};\n              ${ne}\n              result[global_idx] = f32(value);\n          }`};return{name:\"Conv3DNaive\",shaderCache:{hint:`${t.cacheKey};${s};${y};${S}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:h[0],y:h[1],z:h[2]},programUniforms:b}),getShaderSource:$}}});var Bd,Md,Rd=G(()=>{\"use strict\";te();ae();ce();vt();Bd=(e,t,n,r)=>{let o=e.length>2,a=o?\"value += b[output_channel];\":\"\",s=e[0].dims,d=e[1].dims,l=t.format===\"NHWC\",p=l?n[3]:n[1],f=p/t.group,h=l&&f>=4?ge(p):1,y=E.size(n)/h,_=[{type:12,data:y},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:f}];Ze(t,_),_.push(...H(s,[d[0],d[1],d[2],d[3]/h]));let b=o?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"];_.push(...H([n[0],n[1],n[2],n[3]/h]));let w=S=>{let $=N(\"output\",e[0].dataType,n.length,h),v=_e($.type.tensor),T=je(t,$.type.value,v),C=P(\"x\",e[0].dataType,s.length),A=P(\"w\",e[1].dataType,d.length,h),k=[C,A];o&&k.push(P(\"b\",e[2].dataType,e[2].dims,h));let O=[{name:\"output_size\",type:\"u32\"},{name:\"dilations\",type:\"u32\",length:t.dilations.length},{name:\"strides\",type:\"u32\",length:2},{name:\"pads\",type:\"u32\",length:2},{name:\"output_channels_per_group\",type:\"u32\"}];Qe(t,O);let M=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${C.get(\"batch\",\"xHeight\",\"xWidth\",\"input_channel\")};\n            let wVal = ${A.get(\"wHeight\",\"wWidth\",\"wInChannel\",\"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${C.get(\"batch\",\"input_channel\",\"xHeight\",\"xWidth\")};\n            let wVal = ${A.get(\"output_channel\",\"wInChannel\",\"wHeight\",\"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${S.registerUniforms(O).declareVariables(...k,$)}\n\n  ${S.mainStart()}\n    ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${h} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${M}\n    ${a}\n    ${T}\n    ${$.setByOffset(\"global_idx\",\"value\")}\n  }`};return{name:\"GroupedConv\",shaderCache:{hint:`${t.cacheKey}_${h}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},Md=(e,t,n,r)=>{let o=e.length>2,a=ge(n[3]),s=ge(n[2]),d=E.size(n)/a/s,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],p=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],f=[n[0],n[1],n[2],n[3]/a],h=[{type:12,data:d},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ze(t,h),h.push(...H(l,p,f));let y=(s-1)*t.strides[1]+p[1],_=b=>{let w=N(\"output\",e[0].dataType,f.length,a),S=_e(w.type.tensor),$=je(t,w.type.value,S),v=P(\"x\",e[0].dataType,l.length,a),T=P(\"w\",e[1].dataType,p.length,a),C=[v,T];o&&C.push(P(\"b\",e[2].dataType,e[2].dims,a));let A=o?\"value += b[output_channel];\":\"\",k=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"i32\",length:2},{name:\"pads\",type:\"i32\",length:2}];return Qe(t,k),`\n  ${b.registerUniforms(k).declareVariables(...C,w)}\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${s}u;\n    let col = (index1 % width1) * ${s}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${y}>;\n    var values: array<${w.type.value}, ${s}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${y}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\",\"u32(x_height)\",\"u32(x_width)\",\"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${T.get(\"w_height\",\"w_width\",\"0\",\"output_channel\")};\n          for (var i = 0u; i < ${s}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${s}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${w.set(\"batch\",\"row\",\"col + i\",\"output_channel\",\"value\")};\n    }\n  }`};return{name:\"GroupedConv-Vectorize\",shaderCache:{hint:`${t.cacheKey};${a};${s};${y};${p[0]};${p[1]}`,inputDependencies:o?[\"rank\",\"rank\",\"type\"]:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:h}),getShaderSource:_}}});var tg,yo,rg,bo,_o,Ud,ng,og,wo,Nd=G(()=>{\"use strict\";ae();kd();Dd();Jr();Rd();vt();Xr();ct();tg=(e,t,n,r,o,a)=>{let s=e[0],d=e.slice(a?1:2,a?3:4),l=d.length,p=t[0],h=t.slice(2).map((b,w)=>b+(b-1)*(n[w]-1)),_=d.map((b,w)=>b+r[w]+r[w+l]).map((b,w)=>Math.floor((b-h[w]+o[w])/o[w]));return _.splice(0,0,s),_.splice(a?3:1,0,p),_},yo=[2,3,1,0],rg=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length>5)throw new Error(\"greater than 5D is not supported\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[1]*t.group;if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error(\"invalid bias\");let o=e[0].dims.length-2;if(t.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(t.strides.length!==o)throw new Error(`strides should be ${o}D`);if(t.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\")},bo=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let a=2;a<t[1].dims.length;++a)n[a-2]===0&&(n[a-2]=t[1].dims[a]);let r=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,e.format===\"NHWC\",e.autoPad);let o=Object.assign({},e);return Object.assign(o,{kernelShape:n,pads:r}),o},_o=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],o=e.dilations,a=e.group,s=e.kernel_shape,d=e.pads,l=e.strides,p=e.w_is_const();return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},Ud=(e,t,n,r)=>{let o=n.format===\"NHWC\",a=tg(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,o);if(n.group!==1){let k=[t[0]];if(o){let M=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=M),k.push(M)}else k.push(t[1]);t.length===3&&k.push(t[2]),!e.adapterInfo.isArchitecture(\"ampere\")&&o&&t[1].dims[0]===n.group&&t[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?e.compute(Md(k,n,a,r),{inputs:k}):e.compute(Bd(k,n,a,r),{inputs:k});return}let s=t.length===3,d=t[0].dims[o?1:2],l=t[0].dims[o?2:3],p=t[0].dims[o?3:1],f=t[1].dims[2],h=t[1].dims[3],y=a[o?1:2],_=a[o?2:3],b=a[o?3:1],w=o&&f===d&&h===l&&n.pads[0]===0&&n.pads[1]===0;if(w||f===1&&h===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let k=a[0],O,M,V,F=[];if(o){let W=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=W),w){let J=d*l*p;O=t[0].reshape([1,k,J]),M=W.reshape([1,J,b]),V=[1,k,b]}else O=t[0].reshape([k,d*l,p]),M=W.reshape([1,p,b]),V=[k,y*_,b];F.push(O),F.push(M)}else O=t[0].reshape([k,p,d*l]),M=t[1].reshape([1,b,p]),V=[k,b,y*_],F.push(M),F.push(O);s&&F.push(t[2]);let j=V[2],ne=F[0].dims[F[0].dims.length-1];j<8&&ne<8?e.compute(Yr(F,n,a,V,o,r),{inputs:F}):e.compute(nr(F,n,a,V,o,r),{inputs:F});return}let S=!0,$=e.kernelCustomData.wT??e.compute(Oe(t[1],yo),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=$);let v=[t[0],$];s&&v.push(t[2]);let T=o?y*_:b,C=o?b:y*_,A=f*h*p;e.compute(Ad(v,n,a,T,C,A,s,S,r),{inputs:v})},ng=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),s=[1].concat(t.dilations),d=[1].concat(t.kernelShape),l=bo({...t,pads:o,strides:a,dilations:s,kernelShape:d},r);Ud(e,r,l,p=>n?[p[0],p[2],p[3]]:[p[0],p[1],p[3]])},og=(e,t,n)=>{let r=n.format===\"NHWC\"?\"channelsLast\":\"channelsFirst\",o=bo(n,t),a=n.autoPad===\"NOTSET\"?n.pads:n.autoPad,s=zd(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,r);e.compute(Od(t,o,s.outShape,[s.filterDepth,s.filterHeight,s.filterWidth],[s.padInfo.front,s.padInfo.top,s.padInfo.left],r))},wo=(e,t)=>{if(rg(e.inputs,t),e.inputs[0].dims.length===3)ng(e,t);else if(e.inputs[0].dims.length===5)og(e,e.inputs,t);else{let n=bo(t,e.inputs);Ud(e,e.inputs,n)}}});var Vd,Wd=G(()=>{\"use strict\";te();tt();ae();ce();Vd=(e,t,n)=>{let r=e.length>2,o=t.outputShape,a=t.format===\"NHWC\",s=t.group,d=e[1].dims,l=d[2]/s,p=d[3],f=a?ge(l):1,h=a?ge(p):1,y=a?p===1?f:h:1,_=E.size(o)/h,b=[Math.ceil(_/64),1,1];me(\"verbose\",()=>`[conv2d_backprop_webgpu] dispatch = ${b}`);let w=[\"rank\",\"rank\"],S=[t.strides[0],t.strides[1]],$=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],v=[t.dilations[0],t.dilations[1]],T=[$[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),$[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],C=[T[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),T[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],A=[{type:12,data:_},{type:12,data:S},{type:12,data:$},{type:12,data:v},{type:12,data:T},{type:6,data:C},{type:12,data:l},{type:12,data:p},...H(e[0].dims,e[1].dims)];r&&(A.push(...H(e[2].dims)),w.push(\"rank\")),A.push(...H(o));let k=O=>{let M=[{name:\"output_size\",type:\"u32\"},{name:\"strides\",type:\"u32\",length:S.length},{name:\"filter_dims\",type:\"u32\",length:$.length},{name:\"dilations\",type:\"u32\",length:$.length},{name:\"effective_filter_dims\",type:\"u32\",length:T.length},{name:\"pads\",type:\"i32\",length:C.length},{name:\"input_channels_per_group\",type:\"u32\"},{name:\"output_channels_per_group\",type:\"u32\"}],V=_e(e[0].dataType),F=a?1:2,j=a?2:3,ne=a?3:1,W=P(\"W\",e[1].dataType,e[1].dims.length,y),J=P(\"Dy\",e[0].dataType,e[0].dims.length,f),ve=[J,W];r&&ve.push(P(\"bias\",e[2].dataType,[o[ne]].length,h));let Q=N(\"result\",e[0].dataType,o.length,h),ee=()=>{let Z=\"\";if(f===1)Z+=`\n        let w_offset = ${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${W.getByOffset(`w_offset / ${y}`)};\n        dotProd = dotProd + xValue * wValue;`;else if(p===1)Z+=`\n          let wValue = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${y}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;else for(let pe=0;pe<f;pe++)Z+=`\n            let wValue${pe} = ${W.getByOffset(`${W.indicesToOffset(`${W.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${pe}, wOutChannel)`)} / ${y}`)};\n            dotProd = dotProd + xValue[${pe}] * wValue${pe};`;return Z},le=`\n            let outputIndices = ${Q.offsetToIndices(`global_idx * ${h}`)};\n            let batch = ${Q.indicesGet(\"outputIndices\",0)};\n            let d1 = ${Q.indicesGet(\"outputIndices\",ne)};\n            let r = ${Q.indicesGet(\"outputIndices\",F)};\n            let c = ${Q.indicesGet(\"outputIndices\",j)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${Q.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${V}(dyRCorner) + ${V}(wR)) / ${V}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${V}(uniforms.Dy_shape[${F}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${V}(dyCCorner) + ${V}(wC)) / ${V}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${V}(uniforms.Dy_shape[${j}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${f}) {\n                  let xValue = ${a?J.getByOffset(`${J.indicesToOffset(`${J.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${f}`):J.get(\"batch\",\"inputChannel\",\"idyR\",\"idyC\")};\n                  ${ee()}\n                  inputChannel = inputChannel + ${f};\n                }\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${r?` + bias[d1 / ${h}]`:\"\"};\n            ${Q.setByOffset(\"global_idx\",\"value\")};\n          `;return`\n    ${O.registerUniforms(M).declareVariables(...ve,Q)}\n      ${O.mainStart()}\n      ${O.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${le}}`};return{name:\"ConvTranspose2D\",shaderCache:{hint:`${t.cacheKey};${f}${y}${h}${p===1}`,inputDependencies:w},getRunData:()=>({dispatchGroup:{x:b[0],y:b[1],z:b[2]},outputs:[{dims:n?n(o):o,dataType:e[0].dataType}],programUniforms:A}),getShaderSource:k}}});var ig,ag,sg,Ld,Gd,ug,Hd,dg,Fd,qd=G(()=>{\"use strict\";Wd();vt();ct();ig=(e,t,n,r,o,a)=>(e-1)*t+n+(r-1)*o+1-a,ag=(e,t,n,r,o)=>{let a=Math.floor(e/2);t===\"SAME_UPPER\"?(n[r]=a,n[o]=e-a):t===\"SAME_LOWER\"&&(n[r]=e-a,n[o]=a)},sg=(e,t,n,r,o,a,s,d,l,p)=>{let f=e.length-2,h=p.length===0;l.length<f&&l.push(...Array(f-l.length).fill(0));let y=e[0],_=t[d?3:1]*o;for(let b=0,w=e.length-f-(d?1:0);b<f;++b,++w){let S=e[w],$=h?S*s[b]:p[b],v=ig(S,s[b],a[b],t[w],n[b],$);ag(v,r,a,b,b+f),h&&p.push(s[b]*(S-1)+l[b]+(t[w]-1)*n[b]+1-a[b]-a[b+f])}p.splice(0,0,y),p.splice(d?3:1,0,_)},Ld=(e,t)=>{let n=e.kernelShape.slice();if(e.kernelShape.length===0||e.kernelShape.reduce((h,y)=>h*y,1)===0){n.length=0;for(let h=2;h<t[1].dims.length;++h)n.push(t[1].dims[h])}let r=e.format===\"NHWC\";n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let o=e.pads.slice(),a=e.outputShape.slice(),s=e.outputPadding.slice(),d=t[0].dims,l=e.dilations.slice();if(l.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;l=new Array(h).fill(1)}let p=e.strides.slice();if(p.reduce((h,y)=>h+y,0)===0){let h=t[0].dims.length-2;p=new Array(h).fill(1)}sg(d,n,l,e.autoPad,e.group,o,p,r,s,a);let f=Object.assign({},e);return Object.assign(f,{kernelShape:n,pads:o,outputPadding:s,outputShape:a,dilations:l,strides:p}),f},Gd=e=>{let t=Zr(e),n=e.format,r=[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][typeof e.autoPad>\"u\"?0:e.autoPad],o=e.dilations,a=e.group,s=e.kernelShape,d=e.pads,l=e.strides,p=e.wIsConst(),f=e.outputPadding,h=e.outputShape;return{autoPad:r,format:n,dilations:o,group:a,kernelShape:s,outputPadding:f,outputShape:h,pads:d,strides:l,wIsConst:p,...t,cacheKey:`${e.format};${t.activation};`}},ug=(e,t)=>{if(!e||e.length!==2&&e.length!==3)throw new Error(\"Conv requires 2 or 3 inputs\");if(e[0].dims.length!==4&&e[0].dims.length!==3)throw new Error(\"currently only support 2-dimensional conv\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"filter does not have same dimension as input\");let n=e[0].dims[t.format===\"NHWC\"?e[0].dims.length-1:1],r=e[1].dims[0];if(n!==r)throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");let o=e[1].dims[1]*t.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==o))throw new Error(\"invalid bias\");let a=e[0].dims.length-2;if(t.dilations.reduce((f,h)=>f+h,0)>0&&t.dilations.length!==a)throw new Error(`dilations should be ${a}D`);if(t.strides.reduce((f,h)=>f+h,0)>0&&t.strides.length!==a)throw new Error(`strides should be ${a}D`);if(t.pads.reduce((f,h)=>f+h,0)>0&&t.pads.length!==a*2)throw new Error(`pads should be ${a*2}D`);if(t.outputPadding.length!==a&&t.outputPadding.length!==0)throw new Error(`output_padding should be ${a}D`);if(t.kernelShape.reduce((f,h)=>f+h,0)>0&&t.kernelShape.length!==0&&t.kernelShape.length!==e[1].dims.length-2)throw new Error(\"invalid kernel shape\");if(t.outputShape.length!==0&&t.outputShape.length!==e[0].dims.length-2)throw new Error(\"invalid output shape\")},Hd=(e,t,n,r)=>{let o=e.kernelCustomData.wT??e.compute(Oe(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=o);let a=[t[0],o];t.length===3&&a.push(t[2]),e.compute(Vd(a,n,r),{inputs:a})},dg=(e,t)=>{let n=t.format===\"NHWC\",r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];e.inputs.length===3&&r.push(e.inputs[2]);let o=t.kernelShape;(o.length===0||o[0]===0)&&(o=[e.inputs[1].dims[2]]);let a=t.dilations;(a.length===0||a[0]===0)&&(a=[1]);let s=t.strides;(s.length===0||s[0]===0)&&(s=[1]);let d=t.pads;d.length===0&&(d=[0,0]),d=[0,d[0],0,d[1]],s=[1].concat(s),a=[1].concat(a),o=[1].concat(o);let l=t.outputPadding;l=[0].concat(l);let p=Ld({...t,pads:d,strides:s,dilations:a,kernelShape:o,outputPadding:l},r);Hd(e,r,p,f=>n?[f[0],f[2],f[3]]:[f[0],f[1],f[3]])},Fd=(e,t)=>{if(ug(e.inputs,t),e.inputs[0].dims.length===3)dg(e,t);else{let n=Ld(t,e.inputs);Hd(e,e.inputs,n)}}});var lg,Kd,jd,Zd=G(()=>{\"use strict\";te();ae();Ce();ce();lg=(e,t,n,r)=>{let o=E.size(t),a=t.length,s=P(\"input\",e,a),d=N(\"output\",e,a),l=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),p=E.normalizeAxis(l,a),f=h=>{let y=` i32(${s.indicesGet(\"inputIndices\",\"uniforms.axis\")}) `,_=K(\"uniforms.input_shape\",\"uniforms.axis\",a),b=r.reverse?y+(r.exclusive?\" + 1\":\"\"):\"0\",w=r.reverse?_:y+(r.exclusive?\"\":\" + 1\");return`\n                ${h.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axis\",\"u32\").declareVariables(s,d)}\n                ${h.mainStart()}\n                  ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${b};\n                  let last : i32 = ${w};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${s.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(i)\")};\n                    sum = sum + ${s.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\",\"sum\")};\n                }`};return{name:\"CumSum\",shaderCache:{hint:r.cacheKey,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},{type:12,data:p},...H(t,t)]}),getShaderSource:f}},Kd=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,o=e.inputs[1];e.compute(lg(r,n,o,t),{inputs:[0]})},jd=e=>{let t=e.exclusive===1,n=e.reverse===1;return re({exclusive:t,reverse:n})}});var cg,pg,mg,Qd,Yd,Xd=G(()=>{\"use strict\";te();ae();Ce();ce();cg=e=>{if(!e||e.length!==1)throw new Error(\"DepthToSpace requires 1 input.\");if(e[0].dims.length!==4)throw new Error(\"DepthToSpace requires 4D input.\")},pg=(e,t,n,r)=>{let o=[];o.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let a=0;a<t;++a)o.push(n.indicesSet(\"a\",e[a],`i[${a}]`));return o.push(\"return a;}\"),o.join(`\n`)},mg=(e,t)=>{let n,r,o,a,s,d,l=t.format===\"NHWC\",p=t.blocksize,f=t.mode===\"DCR\";l?([n,r,o,a]=e.dims,s=f?[n,r,o,p,p,a/p**2]:[n,r,o,a/p**2,p,p],d=f?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,o,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],s=f?[n,p,p,a/p**2,r,o]:[n,a/p**2,p,p,r,o],d=f?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let h=e.reshape(s),y=h.dims.length,_=e.dataType,b=P(\"a\",_,y),w=N(\"output\",_,y),S=$=>`\n  ${$.registerUniform(\"output_size\",\"u32\").declareVariables(b,w)}\n\n  ${pg(d,y,b,w)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${w.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${w.setByOffset(\"global_idx\",b.getByIndices(\"aIndices\"))}\n  }`;return{name:\"DepthToSpace\",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:[\"rank\"]},getRunData:$=>{let v=l?[n,r*p,o*p,a/p**2]:[n,a/p**2,r*p,o*p],T=E.size(v),C=h.dims,A=E.sortBasedOnPerm(C,d);return{outputs:[{dims:v,dataType:$[0].dataType}],dispatchGroup:{x:Math.ceil(T/64)},programUniforms:[{type:12,data:T},...H(C,A)]}},getShaderSource:S}},Qd=(e,t)=>{cg(e.inputs),e.compute(mg(e.inputs[0],t))},Yd=e=>re({blocksize:e.blocksize,mode:e.mode,format:e.format})});var vo,tn,Jd,fg,hg,$o,xo,el,gg,tl,rl,nl=G(()=>{\"use strict\";te();ae();Ce();ce();vo=\"[a-zA-Z]|\\\\.\\\\.\\\\.\",tn=\"(\"+vo+\")+\",Jd=\"^\"+tn+\"$\",fg=\"(\"+tn+\",)*\"+tn,hg=\"^\"+fg+\"$\",$o=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,n){let r=this.symbolToIndices.get(t);r===void 0?r=[n]:r.push(n),this.symbolToIndices.set(t,r)}},xo=class{constructor(t,n){this.equation=n;this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[r,o]=n.includes(\"->\")?n.split(\"->\",2):[n,\"\"];if(!r.match(RegExp(hg)))throw new Error(\"Invalid LHS term\");if(r.split(\",\").forEach((d,l)=>{let p=t[l].dims.slice();if(!d.match(RegExp(Jd)))throw new Error(\"Invalid LHS term\");let f=this.processTerm(d,!0,p,l);this.lhs.push(f)}),o===\"\")o+=[...this.symbolToInfo.entries()].filter(([d,l])=>l.count===1||d===\"...\").map(([d])=>d).join(\"\");else if(!o.match(RegExp(tn)))throw new Error(\"Invalid RHS\");o.match(RegExp(vo,\"g\"))?.forEach(d=>{if(d===\"...\")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let l=this.symbolToInfo.get(d);if(l===void 0)throw new Error(\"Invalid RHS symbol\");this.outputDims.push(l.dimValue)}}),this.rhs=this.processTerm(o,!1,this.outputDims)}addSymbol(t,n,r){let o=this.symbolToInfo.get(t);if(o!==void 0){if(o.dimValue!==n&&o.count!==1)throw new Error(\"Dimension mismatch\");o.count++,o.inputIndices.push(r)}else o={count:1,dimValue:n,inputIndices:[r]};this.symbolToInfo.set(t,o)}processTerm(t,n,r,o=-1){let a=r.length,s=!1,d=[],l=0;if(!t.match(RegExp(Jd))&&!n&&t!==\"\")throw new Error(\"Invalid LHS term\");let p=t.match(RegExp(vo,\"g\")),f=new $o(o);return p?.forEach((h,y)=>{if(h===\"...\"){if(s)throw new Error(\"Only one ellipsis is allowed per input term\");s=!0;let _=a-p.length+1;if(_<0)throw new Error(\"Ellipsis out of bounds\");if(d=r.slice(l,l+_),this.hasEllipsis){if(this.ellipsisDims.length!==d.length||this.ellipsisDims.toString()!==d.toString())throw new Error(\"Ellipsis dimensions mismatch\")}else if(n)this.hasEllipsis=!0,this.ellipsisDims=d;else throw new Error(\"Ellipsis must be specified in the LHS\");for(let b=0;b<d.length;b++){let w=String.fromCharCode(48+b);f.addSymbol(w,y+b),this.addSymbol(w,r[l++],o)}}else f.addSymbol(h,y+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(h,r[l++],o)}),f}},el=e=>e+\"_max\",gg=(e,t,n,r)=>{let a=e.map(f=>f.length).map((f,h)=>P(`input${h}`,t,f)),s=E.size(r),d=N(\"output\",t,r.length),l=[...n.symbolToInfo.keys()].filter(f=>!n.rhs.symbolToIndices.has(f)),p=f=>{let h=[],y=\"var prod = 1.0;\",_=\"var sum = 0.0;\",b=\"sum += prod;\",w=[],S=[],$=[],v=[],T=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((A,k)=>{if(n.rhs.symbolToIndices.has(k)){let O=n.rhs.symbolToIndices.get(k)?.[0];O!==void 0&&n.lhs.forEach((M,V)=>{if(A.inputIndices.includes(V)){let F=M.symbolToIndices.get(k);if(F===void 0)throw new Error(\"Invalid symbol error\");F.forEach(j=>{h.push(`${a[V].indicesSet(`input${V}Indices`,j,d.indicesGet(\"outputIndices\",O))}`)})}})}else n.lhs.forEach((O,M)=>{if(A.inputIndices.includes(M)){let V=O.symbolToIndices.get(k);if(V===void 0)throw new Error(\"Invalid symbol error\");V.forEach(F=>{w.push(`${a[M].indicesSet(`input${M}Indices`,F,`${k}`)}`)}),v.push(`prod *= ${a[M].getByIndices(`input${M}Indices`)};`)}}),S.push(`for(var ${k}: u32 = 0; ${k} < uniforms.${el(k)}; ${k}++) {`),$.push(\"}\")});let C=T?[...h,`let sum = ${a.map((A,k)=>A.getByIndices(`input${k}Indices`)).join(\" * \")};`]:[...h,_,...S,...w,y,...v,b,...$];return`\n            ${f.registerUniforms(l.map(A=>({name:`${el(A)}`,type:\"u32\"}))).registerUniform(\"outputSize\",\"u32\").declareVariables(...a,d)}\n\n            ${f.mainStart()}\n            ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${a.map((A,k)=>`var input${k}Indices: ${a[k].type.indices};`).join(`\n`)}\n            ${C.join(`\n`)};\n            ${d.setByOffset(\"global_idx\",\"sum\")};\n          }`};return{name:\"Einsum\",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>\"rank\")},getRunData:()=>{let f=l.filter(y=>n.symbolToInfo.has(y)).map(y=>({type:12,data:n.symbolToInfo.get(y)?.dimValue||0}));f.push({type:12,data:s});let h=e.map((y,_)=>[...H(y)]).reduce((y,_)=>y.concat(_),f);return h.push(...H(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:h}},getShaderSource:p}},tl=(e,t)=>{let n=new xo(e.inputs,t.equation),r=n.outputDims,o=e.inputs.map((a,s)=>a.dims);e.compute(gg(o,e.inputs[0].dataType,n,r))},rl=e=>{let t=e.equation.replace(/\\s+/g,\"\");return re({equation:t})}});var yg,ol,bg,_g,il,al=G(()=>{\"use strict\";te();ae();ce();yg=e=>{if(!e||e.length!==2)throw new Error(\"Expand requires 2 input.\");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,o=t.length<n.length?0:t.length-n.length;for(;r<n.length&&o<t.length;++r,++o)if(n[r]!==t[o]&&n[r]!==1&&t[o]!==1)throw new Error(\"Expand requires shape to be broadcastable to input\")},ol=(e,t)=>{let n=e.length-t.length,r=[];for(let o=0;o<n;++o)r.push(e[o]);for(let o=0;o<t.length;++o)r.push(t[o]===1?e[o+n]:t[o]);return r},bg=(e,t)=>e.length>t.length?ol(e,t):ol(t,e),_g=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=bg(t,n),o=e[0].dataType,a=o===9||E.size(t)===1,s=o===9||t.length>0&&t[t.length-1]%4===0?4:1,d=a||r.length>0&&r[r.length-1]%4===0?4:1,l=Math.ceil(E.size(r)/d),p=h=>{let y=P(\"input\",o,t.length,s),_=N(\"output\",o,r.length,d),b;if(o===9){let w=(S,$,v=\"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${y.broadcastedIndicesToOffset(`outputIndices${$}`,_)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${S}[${$}] = ${v}(${y.getByOffset(`index${$}`)}[component${$}]);\n        `;b=`\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${w(\"data\",0,\"u32\")}\n        ${w(\"data\",1,\"u32\")}\n        ${w(\"data\",2,\"u32\")}\n        ${w(\"data\",3,\"u32\")}\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`}else b=`\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${y.broadcastedIndicesToOffset(\"outputIndices\",_)};\n        let data = ${_.type.value}(${y.getByOffset(`inputOffset / ${s}`)});\n        ${_.setByOffset(\"global_idx\",\"data\")}\n      }`;return`\n    ${h.registerUniform(\"vec_size\",\"u32\").declareVariables(y,_)}\n    ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${b}`},f=[{type:12,data:l},...H(t,r)];return{name:\"Expand\",shaderCache:{hint:`${r.length};${s}${d}`,inputDependencies:[\"rank\"]},getShaderSource:p,getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:f})}},il=e=>{yg(e.inputs),e.compute(_g(e.inputs),{inputs:[0]})}});var wg,sl,ul=G(()=>{\"use strict\";te();ae();ce();jr();wg=e=>{let t=e[0].dataType,n=E.size(e[0].dims),r=E.size(e[1].dims),o=r%4===0,a=s=>{let d=P(\"x\",t,[1],4),l=P(\"bias\",t,[1],4),p=N(\"y\",t,[1],4),f=[{name:\"output_vec_size\",type:\"u32\"},{name:\"bias_size\",type:\"u32\"}],h=_=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`,y=o?`\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};`:`${h(0)}${h(1)}${h(2)}${h(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;return`${s.registerUniforms(f).declareVariables(d,l,p)}\n\n    ${mo(ze(t))}\n\n    ${s.mainStart(Et)}\n      ${s.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${y}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\",fo(\"x_in\"))}\n    }`};return{name:\"FastGeluWithBias\",shaderCache:{hint:`${o}`,inputDependencies:[\"type\",\"type\"]},getShaderSource:a,getRunData:s=>({outputs:[{dims:s[0].dims,dataType:s[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/Et/4)}})}},sl=e=>{e.inputs.length<2||E.size(e.inputs[1].dims)===0?nd(e):e.compute(wg(e.inputs))}});var vg,$g,dl,ll,cl=G(()=>{\"use strict\";te();ae();Ce();ce();vg=e=>{if(!e||e.length!==2)throw new Error(\"Gather requires 2 inputs.\")},$g=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.axis,o),s=n.slice(0);s.splice(a,1,...r);let d=n[a],l=e[0].dataType===9?4:1,p=Math.ceil(E.size(s)/l),f=[{type:12,data:p},{type:6,data:d},{type:12,data:a},...H(e[0].dims,e[1].dims,s)],h=y=>{let _=P(\"data\",e[0].dataType,e[0].dims.length,l),b=P(\"inputIndices\",e[1].dataType,e[1].dims.length),w=N(\"output\",e[0].dataType,s.length,l),S=v=>{let T=r.length,C=`var indicesIndices${v}  = ${b.type.indices}(0);`;for(let A=0;A<T;A++)C+=`${T>1?`indicesIndices${v}[${A}]`:`indicesIndices${v}`} = ${s.length>1?`outputIndices${v}[uniforms.axis + ${A}]`:`outputIndices${v}`};`;C+=`\n          var idx${v} = ${b.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;for(let A=0,k=0;A<o;A++)A===a?(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = u32(idx${v});`,k+=T):(C+=`${o>1?`dataIndices${v}[${A}]`:`dataIndices${v}`} = ${s.length>1?`outputIndices${v}[${k}]`:`outputIndices${v}`};`,k++);return C},$;if(e[0].dataType===9){let v=(T,C,A=\"\")=>`\n          let outputIndices${C} = ${w.offsetToIndices(`outputOffset + ${C}u`)};\n          ${S(C)};\n          let offset${C} = ${_.indicesToOffset(`dataIndices${C}`)};\n          let index${C} = offset${C} / 4u;\n          let component${C} = offset${C} % 4u;\n          ${T}[${C}] = ${A}(${_.getByOffset(`index${C}`)}[component${C}]);\n        `;$=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\",0,\"u32\")}\n        ${v(\"value\",1,\"u32\")}\n        ${v(\"value\",2,\"u32\")}\n        ${v(\"value\",3,\"u32\")}\n        ${w.setByOffset(\"global_idx\",\"value\")}\n      `}else $=`\n      let outputIndices = ${w.offsetToIndices(\"global_idx\")};\n      ${S(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${w.setByOffset(\"global_idx\",\"value\")};\n      `;return`\n      ${y.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(_,b,w)}\n      ${y.mainStart()}\n        ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`};return{name:\"Gather\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:h}},dl=e=>re({axis:e.axis}),ll=(e,t)=>{let n=e.inputs;vg(n),e.compute($g(e.inputs,t))}});var xg,pl,ml,fl=G(()=>{\"use strict\";te();ae();ce();xg=(e,t,n,r,o,a,s,d,l)=>{let p=[{type:12,data:a},{type:12,data:r},{type:12,data:o},{type:12,data:n},{type:12,data:s},{type:12,data:d},{type:12,data:l}],f=[a];p.push(...H(t.dims,f));let h=y=>{let _=P(\"indices_data\",t.dataType,t.dims.length),b=N(\"input_slice_offsets_data\",12,1,1),w=[_,b],S=[{name:\"output_size\",type:\"u32\"},{name:\"batch_dims\",type:\"u32\"},{name:\"input_dims\",type:\"u32\",length:o.length},{name:\"sizes_from_slice_dims_data\",type:\"u32\",length:n.length},{name:\"num_slices_per_batch\",type:\"u32\"},{name:\"input_batch_stride\",type:\"u32\"},{name:\"num_slice_dims\",type:\"u32\"}];return`\n  ${y.registerUniforms(S).declareVariables(...w)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length===1?\"index += i32(uniforms.input_dims);\":\"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${n.length===1?\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\":\"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`};return e.compute({name:\"computeSliceOffsets\",shaderCache:{hint:`${o.length}_${n.length}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:f,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:p}),getShaderSource:h},{inputs:[t],outputs:[-1]})[0]},pl=(e,t)=>{let n=e.inputs,r=n[0].dims,o=n[0].dataType,a=n[1].dims,s=a[a.length-1],d=E.sizeToDimension(a,a.length-1),l=E.sizeFromDimension(r,t.batchDims+s),p=E.sizeToDimension(r,t.batchDims),f=E.sizeFromDimension(r,t.batchDims),h=d/p,y=new Array(s),_=l;for(let C=0;C<s;++C)y[s-1-C]=_,_*=r[t.batchDims+s-1-C];let b=xg(e,n[1],y,t.batchDims,r,d,h,f,s),w=t.batchDims+s;if(w>r.length)throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");let S=a.slice(0,-1).concat(r.slice(w)),$=E.size(S),v=[{type:12,data:$},{type:12,data:l},...H(n[0].dims,b.dims,S)],T=C=>{let A=P(\"data\",n[0].dataType,n[0].dims.length),k=P(\"slice_offsets\",12,b.dims.length),O=N(\"output\",n[0].dataType,S.length);return`\n          ${C.registerUniform(\"output_size\",\"u32\").registerUniform(\"slice_size\",\"u32\").declareVariables(A,k,O)}\n            ${C.mainStart()}\n            ${C.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`};e.compute({name:\"GatherND\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:S,dataType:o}],dispatchGroup:{x:Math.ceil($/64)},programUniforms:v}),getShaderSource:T},{inputs:[n[0],b]})},ml=e=>({batchDims:e.batch_dims,cacheKey:\"\"})});var Sg,Tg,hl,gl,yl=G(()=>{\"use strict\";te();ae();Ce();ce();Sg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");let n=E.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,o=e[0],a=e[2],s=e.length===4?e[3]:void 0;if(a.dims.length!==o.dims.length||!o.dims.map((d,l)=>l===n?Math.ceil(d/r)===a.dims[l]:d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");if(s){if(s.dataType!==o.dataType)throw new Error(\"Zero point must have the same data type as the input tensor.\");if(s.dims.length!==a.dims.length||!s.dims.map((d,l)=>d===a.dims[l]).reduce((d,l)=>d&&l,!0))throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\")}},Tg=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n.length,a=E.normalizeAxis(t.gatherAxis,o),s=E.normalizeAxis(t.quantizeAxis,o),d=n.slice(0);d.splice(a,1,...r);let l=E.size(d),p=e[2].dataType,h=e[0].dataType===22,y=[{type:12,data:l},{type:12,data:s},{type:12,data:a},{type:12,data:t.blockSize},...H(...e.map((b,w)=>b.dims),d)],_=b=>{let w=P(\"data\",e[0].dataType,e[0].dims.length),S=P(\"inputIndices\",e[1].dataType,e[1].dims.length),$=P(\"scales\",e[2].dataType,e[2].dims.length),v=e.length>3?P(\"zeroPoint\",e[3].dataType,e[3].dims.length):void 0,T=N(\"output\",p,d.length),C=[w,S,$];v&&C.push(v);let A=[{name:\"output_size\",type:\"u32\"},{name:\"quantize_axis\",type:\"u32\"},{name:\"gather_axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n        ${b.registerUniforms(A).declareVariables(...C,T)}\n        ${b.mainStart()}\n        let output_indices = ${T.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${S.type.indices}(0);\n        ${r.length>1?`\n          for (var i: u32 = 0; i < ${r.length}; i++) {\n            let index = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis + i\")};\n            ${S.indicesSet(\"indices_indices\",\"i\",\"index\")};\n          }`:`indices_indices = ${T.indicesGet(\"output_indices\",\"uniforms.gather_axis\")};`};\n        var data_indices = ${w.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${T.indicesGet(\"output_indices\",\"i\")};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        var index_from_indices = ${S.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${w.indicesSet(\"data_indices\",\"uniforms.gather_axis\",\"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${T.indicesGet(\"output_indices\",`i + ${r.length} - 1`)};\n          ${w.indicesSet(\"data_indices\",\"i\",\"index\")};\n        }\n        let data_offset = ${w.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${w.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\",\"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\",\"uniforms.quantize_axis\",\"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${v?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${h?\"unpack4xI8\":\"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:\"var zero_point = 0\"};\n        let dequantized_data = ${ze(p)}(quantized_data - zero_point) * scale;\n        ${T.setByOffset(\"global_idx\",\"dequantized_data\")};\n    }`};return{name:\"GatherBlockQuantized\",shaderCache:{hint:`${t.cacheKey};${e.filter((b,w)=>w!==1).map(b=>b.dims.join(\"_\")).join(\";\")}`,inputDependencies:Array.from({length:e.length},(b,w)=>\"rank\")},getRunData:()=>({outputs:[{dims:d,dataType:p}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:y}),getShaderSource:_}},hl=(e,t)=>{let n=e.inputs;Sg(n,t),e.compute(Tg(e.inputs,t))},gl=e=>re({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})});var Cg,Ig,bl,_l,wl=G(()=>{\"use strict\";te();ae();Ce();ce();Cg=e=>{if(!e||e.length!==2)throw new Error(\"GatherElements requires 2 inputs.\");if(e[0].dims.length<1)throw new Error(\"GatherElements requires that the data input be rank >= 1.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`)},Ig=(e,t)=>{let n=e[0].dims,r=e[0].dataType,o=n.length,a=e[1].dims,s=e[1].dataType,d=E.normalizeAxis(t.axis,o),l=n[d],p=a.slice(0),f=E.size(p),h=P(\"input\",r,o),y=P(\"indicesInput\",s,a.length),_=N(\"output\",r,p.length),b=[{type:12,data:f},{type:6,data:l},{type:12,data:d}];return b.push(...H(n,a,p)),{name:\"GatherElements\",shaderCache:{inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:p,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:$=>`\n      ${$.registerUniform(\"outputSize\",\"u32\").registerUniform(\"axisDimLimit\",\"i32\").registerUniform(\"axis\",\"u32\").declareVariables(h,y,_)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${y.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${h.type.indices}(outputIndices);\n      ${h.indicesSet(\"inputIndices\",\"uniforms.axis\",\"u32(idx)\")};\n      let value = ${h.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\",\"value\")};\n  }`}},bl=e=>re({axis:e.axis}),_l=(e,t)=>{let n=e.inputs;Cg(n),e.compute(Ig(e.inputs,t))}});var Ag,kg,vl,$l,xl=G(()=>{\"use strict\";te();ae();ce();Ag=e=>{if(!e)throw new Error(\"Input is missing\");if(e.length<2||e.length>3)throw new Error(\"Invaid input number.\");if(e.length===3&&e[2].dims.length>2)throw new Error(\"Invalid input shape of C\");if(e[0].dataType!==e[1].dataType||e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"Input types are mismatched\")},kg=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[o,a,s]=Wr.getShapeOfGemmResult(n,t.transA,r,t.transB,e.length===3?e[2].dims:void 0),d=[o,a];if(!d)throw new Error(\"Can't use gemm on the given tensors\");let l=16,p=Math.ceil(a/l),f=Math.ceil(o/l),h=!0,y=E.size(d),_=[{type:12,data:h?p:y},{type:12,data:o},{type:12,data:a},{type:12,data:s},{type:1,data:t.alpha},{type:1,data:t.beta}],b=[\"type\",\"type\"];e.length===3&&(_.push(...H(e[2].dims)),b.push(\"rank\")),_.push(...H(d));let w=$=>{let v=\"\";t.transA&&t.transB?v=\"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\":t.transA&&!t.transB?v=\"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\":!t.transA&&t.transB?v=\"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\":!t.transA&&!t.transB&&(v=\"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");let T=t.alpha===1?\"\":\"value *= uniforms.alpha;\",C=P(\"a\",e[0].dataType,e[0].dims),A=P(\"b\",e[1].dataType,e[1].dims),k=C.type.value,O=null,M=[C,A];e.length===3&&(O=P(\"c\",e[2].dataType,e[2].dims.length),M.push(O));let V=N(\"output\",e[0].dataType,d.length);M.push(V);let F=[{name:\"output_size\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}];return`\n  ${$.registerUniforms(F).declareVariables(...M)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${k}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${T}\n    ${O!=null?`let cOffset = ${O.broadcastedIndicesToOffset(\"vec2(m, n)\",V)}; value += ${k}(uniforms.beta) * ${O.getByOffset(\"cOffset\")};`:\"\"}\n    output[global_idx] = value;\n  }`},S=$=>{let v=P(\"a\",e[0].dataType,e[0].dims),T=P(\"b\",e[1].dataType,e[1].dims),C=null,A=[v,T];e.length===3&&(C=P(\"c\",e[2].dataType,e[2].dims.length),A.push(C));let k=N(\"output\",e[0].dataType,d.length);A.push(k);let O=[{name:\"num_tile_n\",type:\"u32\"},{name:\"M\",type:\"u32\"},{name:\"N\",type:\"u32\"},{name:\"K\",type:\"u32\"},{name:\"alpha\",type:\"f32\"},{name:\"beta\",type:\"f32\"}],M=\"\",V=\"\";t.transA&&t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\"):t.transA&&!t.transB?(V=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\"):!t.transA&&t.transB?(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\"):!t.transA&&!t.transB&&(V=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${T.type.value}(0);\n      }\n      `,M=\"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");let F=t.alpha===1?\"\":\"value *= uniforms.alpha;\";return`\n  ${$.registerUniforms(O).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${T.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${k.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${V}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${M}\n      }\n      workgroupBarrier();\n    }\n\n    ${F}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${C!=null?`let cOffset = ${C.broadcastedIndicesToOffset(\"vec2(m, n)\",k)}; value += ${k.type.value}(uniforms.beta) * ${C.getByOffset(\"cOffset\")};`:\"\"}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`};return h?{name:\"GemmShared\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:p*f},programUniforms:_}),getShaderSource:S}:{name:\"Gemm\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:_}),getShaderSource:w}},vl=e=>{let t=e.transA,n=e.transB,r=e.alpha,o=e.beta;return{transA:t,transB:n,alpha:r,beta:o,cacheKey:`${e.transA};${e.transB};${e.alpha===1}`}},$l=(e,t)=>{Ag(e.inputs),e.compute(kg(e.inputs,t))}});var pt,$t,Nt,Vt,Eg,Pg,zg,Og,Dg,Bg,Mg,Rg,Sl,Tl,Cl=G(()=>{\"use strict\";te();ae();Ce();ce();[pt,$t,Nt,Vt]=[0,1,2,3],Eg=e=>{if(e[0].dims.length!==4)throw new Error(\"only 4-D tensor is supported.\");if(e[0].dims.length!==e[1].dims.length)throw new Error(\"input dimensions must be equal to grid dimensions\");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${e[0].dims.length-2}`);if(e[0].dims[0]!==e[1].dims[0])throw new Error(\"grid batch size must match input batch size\")},Pg=`\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`,zg=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Og=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e.alignCorners===0?`\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    `:`\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`,Dg=e=>`\n  ${e.paddingMode===\"reflection\"?`\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }`:\"\"}\n`,Bg=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${pt}] = batch;\n     indices[${$t}] = channel;`+(()=>{switch(n.paddingMode){case\"zeros\":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case\"border\":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case\"reflection\":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices(\"indices\")};\n  }\n`,Mg=(e,t,n)=>(()=>{switch(n.mode){case\"nearest\":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${pt}], indices[${$t}], border);\n        `;case\"bilinear\":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case\"bicubic\":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${pt}], indices[${$t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset(\"global_idx\",\"result\")}`,Rg=(e,t)=>{let n=P(\"x\",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],o=P(\"grid\",e[1].dataType,r.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];t.format===\"NHWC\"&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[pt,$t,Nt,Vt]=[0,3,1,2]);let s=N(\"output\",e[0].dataType,a.length),d=n.type.value,l=E.size(a),p=[{type:12,data:l},...H(e[0].dims,r,a)],f=h=>`\n  ${h.registerUniform(\"output_size\",\"u32\").declareVariables(n,o,s)}\n  ${Pg}\n  ${zg(d)}\n  ${Og(t)}\n  ${Dg(t)}\n  ${Bg(n,d,t)}\n\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${t.alignCorners===0?`\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      `:`\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${s.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${pt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Mg(s,d,t)}\n  }`;return{name:\"GridSample\",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:[\"type\",\"type\"]},getRunData:h=>{let y=E.size(a);return{outputs:[{dims:a,dataType:h[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:p}},getShaderSource:f}},Sl=(e,t)=>{Eg(e.inputs),e.compute(Rg(e.inputs,t))},Tl=e=>re({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})});var Me,Vg,Al,Il,Wg,or,kl,So=G(()=>{\"use strict\";te();ae();Ce();Vr();qr();ce();ct();Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Vg=(e,t)=>{let n=e[0],r=Me(e,1),o=Me(e,2),a=Me(e,3),s=Me(e,4),d=Me(e,5),l=Me(e,6),p=Me(e,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let f=n.dims[0],h=n.dims[1],y=n.dims.length===3?n.dims[2]:t.numHeads*n.dims[4],_=h,b=0,w=0,S=Math.floor(y/t.numHeads);if(l&&p&&E.size(l.dims)&&E.size(p.dims)){if(l.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(l.dims[0]!==f||l.dims[1]!==t.numHeads||l.dims[3]!==S)throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(p.dims[0]!==f||p.dims[1]!==t.numHeads||p.dims[3]!==S)throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==p.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');if(p.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');b=l.dims[2],w=l.dims[2]}else if(l&&E.size(l.dims)||p&&E.size(p.dims))throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let $;if(r&&E.size(r.dims)>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(r.dims[2]!==n.dims[2])throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');$=2,_=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==S)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');$=5,_=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==S)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');$=0,_=r.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||n.dims[3]!==3)throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');$=3}if(a&&E.size(a.dims)>0){if(a.dims.length!==1)throw new Error('Input \"bias\" is expected to have 1 dimension');if(r&&r.dims.length===5&&r.dims[3]===2)throw new Error(\"bias is not allowed for packed kv.\")}let v=b+_,T=0;if(s&&E.size(s.dims)>0){T=8;let O=s.dims;throw O.length===1?O[0]===f?T=1:O[0]===3*f+2&&(T=3):O.length===2&&O[0]===f&&O[1]===v&&(T=5),T===8?new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error(\"Mask not supported\")}let C=!1,A=y;if(o&&E.size(o.dims)>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(_!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(_!==o.dims[2])throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=!1;if(s&&E.size(s.dims)>0)throw new Error(\"Key padding mask is not supported\");if(d&&E.size(d.dims)>0){if(d.dims.length!==4)throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');if(d.dims[0]!==f||d.dims[1]!==t.numHeads||d.dims[2]!==h||d.dims[3]!==v)throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:f,sequenceLength:h,pastSequenceLength:b,kvSequenceLength:_,totalSequenceLength:v,maxSequenceLength:w,inputHiddenSize:0,hiddenSize:y,vHiddenSize:A,headSize:S,vHeadSize:Math.floor(A/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:T,scale:t.scale,broadcastResPosBias:k,passPastInKv:C,qkvFormat:$}},Al=e=>re({...e}),Il=re({perm:[0,2,1,3]}),Wg=(e,t,n,r,o,a,s)=>{let d=[r,o,a],l=E.size(d),p=[{type:12,data:l},{type:12,data:s},{type:12,data:a}],f=h=>{let y=N(\"qkv_with_bias\",t.dataType,d),_=P(\"qkv\",t.dataType,d),b=P(\"bias\",n.dataType,d),w=[{name:\"output_size\",type:\"u32\"},{name:\"bias_offset\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"}];return`\n  ${h.registerUniforms(w).declareVariables(_,b,y)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`};return e.compute({name:\"MultiHeadAttentionAddBias\",shaderCache:{inputDependencies:[\"type\",\"type\"]},getRunData:()=>({outputs:[{dims:d,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:p}),getShaderSource:f},{inputs:[t,n],outputs:[-1]})[0]},or=(e,t,n,r,o,a,s,d)=>{let l=a;if(s&&E.size(s.dims)>0){if(r===1)throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");return l=Wg(e,a,s,t,r,n*o,d),l=l.reshape([t,r,n,o]),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]}else return a.dims.length===3&&(l=a.reshape([t,r,n,o])),n===1||r===1?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]},kl=(e,t)=>{let n=Vg(e.inputs,t),r=e.inputs[0],o=Me(e.inputs,1),a=Me(e.inputs,2),s=Me(e.inputs,3),d=Me(e.inputs,4),l=Me(e.inputs,5),p=Me(e.inputs,6),f=Me(e.inputs,7);if(r.dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(o?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let h=o&&a&&o.dims.length===4&&a.dims.length===4,y=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,s,0);if(h)return Ut(e,y,o,a,d,void 0,p,f,l,n);if(!o||!a)throw new Error(\"key and value must be provided\");let _=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,o,s,n.hiddenSize),b=or(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,s,2*n.hiddenSize);Ut(e,y,_,b,d,void 0,p,f,l,n)}});var Lg,Gg,Hg,Fg,To,El,Pl,Co=G(()=>{\"use strict\";te();ae();Ce();ce();Lg=e=>{if(!e||e.length<1)throw new Error(\"too few inputs\")},Gg=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(o=>n.push(Number(o))),r=n.length),re({numOutputs:r,axis:t.axis,splitSizes:n})},Hg=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${K(\"uniforms.size_in_split_axis\",\"i\",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Fg=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let o=e[r].setByIndices(\"indices\",\"input[global_idx]\");t===1?n.push(o):r===0?n.push(`if (output_number == ${r}u) { ${o} }`):r===t-1?n.push(`else { ${o} }`):n.push(`else if (output_number == ${r}) { ${o} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join(`\n`)}\n      }`},To=(e,t)=>{let n=e[0].dims,r=E.size(n),o=e[0].dataType,a=E.normalizeAxis(t.axis,n.length),s=new Array(t.numOutputs),d=P(\"input\",o,n.length),l=new Array(t.numOutputs),p=[],f=[],h=0,y=[{type:12,data:r}];for(let b=0;b<t.numOutputs;b++){h+=t.splitSizes[b],l[b]=h;let w=n.slice();w[a]=t.splitSizes[b],f.push(w),s[b]=N(`output${b}`,o,w.length),p.push({dims:f[b],dataType:e[0].dataType})}y.push({type:12,data:l},...H(n,...f));let _=b=>`\n  ${b.registerUniform(\"input_size\",\"u32\").registerUniform(\"size_in_split_axis\",\"u32\",l.length).declareVariables(d,...s)}\n  ${Hg(l.length)}\n  ${Fg(s)}\n\n  ${b.mainStart()}\n    ${b.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${K(\"uniforms.size_in_split_axis\",\"output_number - 1u\",l.length)};\n      ${d.indicesSet(\"indices\",a,\"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;return{name:\"Split\",shaderCache:{hint:t.cacheKey,inputDependencies:[\"rank\"]},getShaderSource:_,getRunData:()=>({outputs:p,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:y})}},El=(e,t)=>{Lg(e.inputs);let n=e.inputs.length===1?t:Gg(e.inputs,t);e.compute(To(e.inputs,n),{inputs:[0]})},Pl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error(\"numOutputs and splitSizes lengh must be equal\");return re({axis:t,numOutputs:r,splitSizes:n})}});var qg,Kg,zl,Ol,Dl=G(()=>{\"use strict\";Ce();qr();So();Co();ct();qg=(e,t)=>{if(t.doRotary)throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");if(t.doRotary&&e.length<=7)throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");let n=e[0],r=e[1],o=e[2],a=e[3],s=e[4];if(t.localWindowSize!==-1)throw new Error(\"Local attention is not supported\");if(t.softcap!==0)throw new Error(\"Softcap is not supported\");if(t.rotaryInterleaved!==0)throw new Error(\"Rotary interleaved is not supported\");if(t.smoothSoftmax)throw new Error(\"Smooth softmax is not supported\");if(n.dims.length!==3&&n.dims.length!==5)throw new Error(\"Input query is expected to have 3 or 5 dimensions\");let d=!1,l=n.dims[0],p=n.dims[1],f=n.dims.length===3?d?n.dims[2]/3:n.dims[2]:t.numHeads*n.dims[4],h=p,y=0,_=!r||r.dims.length===0,b=Math.floor(_?f/(t.numHeads+2*t.kvNumHeads):f/t.numHeads);_&&(f=b*t.numHeads);let w=a&&a.dims.length!==0,S=s&&s.dims.length!==0;if(w&&a.dims.length===4&&a.dims[0]===l&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===b)throw new Error(\"BSNH pastKey/pastValue is not supported\");if(w&&S){if(a.dims.length!==4)throw new Error('Input \"past_key\" is expected to have 4 dimensions');if(s.dims.length!==4)throw new Error('Input \"past_value\" is expected to have 4 dimensions');y=a.dims[2]}else if(w||S)throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');let v=1;if(r&&r.dims.length>0){if(n.dims.length!==3)throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');if(r.dims.length===3){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');h=r.dims[1]}else if(r.dims.length===5){if(r.dims[2]!==t.numHeads||r.dims[3]!==2||r.dims[4]!==b)throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(o)throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');h=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==b)throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');h=r.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==t.numHeads||n.dims[3]!==3))throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');v=3}let T=0,C=!1,A=t.kvNumHeads?b*t.kvNumHeads:f;if(o&&o.dims.length>0){if(o.dims.length!==3&&o.dims.length!==4)throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');if(n.dims[0]!==o.dims[0])throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');if(o.dims.length===3){if(h!==o.dims[1])throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');A=o.dims[2]}else{if(h!==o.dims[2])throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');A=o.dims[1]*o.dims[3],C=!0}}let k=e.length>4?e[5]:void 0;if(k&&k.dims.length!==1&&k.dims[0]!==l)throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:l,sequenceLength:p,pastSequenceLength:y,kvSequenceLength:h,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:f,vHiddenSize:A,headSize:b,vHeadSize:Math.floor(A/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:T,scale:t.scale,broadcastResPosBias:!1,passPastInKv:C,qkvFormat:v}},Kg=re({perm:[0,2,1,3]}),zl=(e,t,n)=>{let r=t,o=n.kvNumHeads;return t.dims.length===3&&n.kvSequenceLength!==0&&(r=t.reshape([n.batchSize,n.kvSequenceLength,o,n.headSize]),r=e.compute(Oe(r,Kg.perm),{inputs:[r],outputs:[-1]})[0]),r},Ol=(e,t)=>{let n=qg(e.inputs,t);if(e.inputs[0].dims.length===5)throw new Error(\"Packed QKV is not implemented\");if(e.inputs[1]?.dims.length===5)throw new Error(\"Packed KV is not implemented\");let r=e.inputs[0],o=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,a=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,s=e.inputs[3]&&e.inputs[3].dims.length!==0?e.inputs[3]:void 0,d=e.inputs[4]&&e.inputs[4].dims.length!==0?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,p=e.inputs.length>5?e.inputs[6]:void 0,f=n.kvNumHeads?n.kvNumHeads:n.numHeads,h=re({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,f*n.headSize,f*n.headSize]}),[y,_,b]=!o&&!a?e.compute(To([r],h),{inputs:[r],outputs:[-1,-1,-1]}):[r,o,a],w=or(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,y,void 0,0);Ut(e,w,zl(e,_,n),zl(e,b,n),void 0,void 0,s,d,void 0,n,l,p)}});var Bl,jg,Zg,Ml,Rl=G(()=>{\"use strict\";te();ae();ct();ce();Bl=(e,t,n,r,o,a,s,d)=>{let l=ge(a),p=l===1?\"f32\":`vec${l}f`,f=l===1?\"vec2f\":`mat2x${l}f`,h=o*s,y=64;h===1&&(y=256);let _=[o,s,a/l],b=[o,s,2],w=[\"rank\",\"type\",\"type\"],S=[];S.push(...H(_,b));let $=v=>{let T=P(\"x\",t.dataType,3,l),C=P(\"scale\",n.dataType,n.dims),A=P(\"bias\",r.dataType,r.dims),k=N(\"output\",1,3,2),O=[T,C,A,k];return`\n  var<workgroup> workgroup_shared : array<${f}, ${y}>;\n  const workgroup_size = ${y}u;\n  ${v.declareVariables(...O)}\n  ${v.mainStart(y)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${T.get(\"batch\",\"channel\",\"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${f}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Ke(\"workgroup_shared[0][0]\",l)} / f32(hight * ${l});\n      let squared_sum_final = ${Ke(\"workgroup_shared[0][1]\",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`};return e.compute({name:\"InstanceNormComputeChannelScaleShift\",shaderCache:{hint:`${l};${d};${y}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:b,dataType:1}],dispatchGroup:{x:h},programUniforms:S}),getShaderSource:$},{inputs:[t,n,r],outputs:[-1]})[0]},jg=(e,t,n)=>{let r=t[0].dims,o=r,a=2,s=r[0],d=r[1],l=E.sizeFromDimension(r,a),p=ge(l),f=E.size(o)/p,h=Bl(e,t[0],t[1],t[2],s,l,d,n.epsilon),y=[s,d,l/p],_=[s,d],b=[\"type\",\"none\"],w=S=>{let $=P(\"x\",t[0].dataType,y.length,p),v=P(\"scale_shift\",1,_.length,2),T=N(\"output\",t[0].dataType,y.length,p),C=[$,v,T];return`\n  ${S.registerUniform(\"output_size\",\"u32\").declareVariables(...C)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${T.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${T.type.value}(scale_shift.x) + ${T.type.value}(scale_shift.y);\n      ${T.setByOffset(\"global_idx\",\"value\")};\n  }`};e.compute({name:\"InstanceNormalization\",shaderCache:{hint:`${p}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...H(y,_,y)]}),getShaderSource:w},{inputs:[t[0],h]})},Zg=(e,t,n)=>{let r=t[0].dims,o=r,a=r[0],s=r[r.length-1],d=E.sizeFromDimension(r,1)/s,l=ge(s),p=E.size(o)/l,f=[{type:12,data:d},{type:12,data:Math.floor(s/l)}],h=[\"type\",\"type\"],y=!1,_=[0,r.length-1];for(let $=0;$<r.length-2;$++)y=y||r[$+1]!==1,_.push($+1);y=y&&r[r.length-1]!==1;let b=y?e.compute(Oe(e.inputs[0],_),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},($,v)=>r[_[v]])),w=Bl(e,b,t[1],t[2],a,d,s,n.epsilon),S=$=>{let v=_e(t[0].dataType),T=l===1?\"vec2f\":`mat${l}x2f`,C=O=>{let M=O===0?\"x\":\"y\",V=l===1?\"f32\":`vec${l}f`;switch(l){case 1:return`${v}(${V}(scale.${M}))`;case 2:return`vec2<${v}>(${V}(scale[0].${M}, scale[1].${M}))`;case 4:return`vec4<${v}>(${V}(scale[0].${M}, scale[1].${M}, scale[2].${M}, scale[3].${M}))`;default:throw new Error(`Not supported compoents ${l}`)}},A=P(\"input\",t[0].dataType,t[0].dims,l),k=N(\"output\",t[0].dataType,o,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${T}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${C(0)}, ${C(1)});\n  }`};e.compute({name:\"InstanceNormalizationNHWC\",shaderCache:{hint:`${l}`,inputDependencies:h},getRunData:()=>({outputs:[{dims:o,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:f}),getShaderSource:S},{inputs:[t[0],w]})},Ml=(e,t)=>{t.format===\"NHWC\"?Zg(e,e.inputs,t):jg(e,e.inputs,t)}});var Qg,Yg,Ul,Nl=G(()=>{\"use strict\";te();ae();ce();Qg=e=>{if(!e||e.length<2)throw new Error(\"layerNorm requires at least 2 inputs.\")},Yg=(e,t,n)=>{let r=t.simplified,o=e[0].dims,a=e[1],s=!r&&e[2],d=o,l=E.normalizeAxis(t.axis,o.length),p=E.sizeToDimension(o,l),f=E.sizeFromDimension(o,l),h=E.size(a.dims),y=s?E.size(s.dims):0;if(h!==f||s&&y!==f)throw new Error(`Size of X.shape()[axis:] == ${f}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${h} and bias size of ${y}`);let _=[];for(let A=0;A<o.length;++A)A<l?_.push(o[A]):_.push(1);let b=ge(f),w=[\"type\",\"type\"],S=[{type:12,data:p},{type:1,data:f},{type:12,data:Math.floor(f/b)},{type:1,data:t.epsilon}];s&&w.push(\"type\");let $=n>1,v=n>2,T=A=>{let k=_e(e[0].dataType),O=[P(\"x\",e[0].dataType,e[0].dims,b),P(\"scale\",a.dataType,a.dims,b)];s&&O.push(P(\"bias\",s.dataType,s.dims,b)),O.push(N(\"output\",e[0].dataType,d,b)),$&&O.push(N(\"mean_data_output\",1,_)),v&&O.push(N(\"inv_std_output\",1,_));let M=[{name:\"norm_count\",type:\"u32\"},{name:\"norm_size\",type:\"f32\"},{name:\"norm_size_vectorized\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}];return`\n  ${A.registerUniforms(M).declareVariables(...O)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${uo(\"f32\",b)};\n    var mean_square_vector = ${uo(\"f32\",b)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(k,b,\"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Ke(\"mean_vector\",b)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Ke(\"mean_square_vector\",b)} / uniforms.norm_size ${r?\"\":\"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(k,b,\"x[j + offset]\")};\n      let f32scale = ${Pt(k,b,\"scale[j]\")};\n      output[j + offset] = ${O[0].type.value}((f32input ${r?\"\":\"- mean\"}) * inv_std_dev * f32scale\n        ${s?`+ ${Pt(k,b,\"bias[j]\")}`:\"\"}\n      );\n    }\n\n    ${$?\"mean_data_output[global_idx] = mean\":\"\"};\n    ${v?\"inv_std_output[global_idx] = inv_std_dev\":\"\"};\n  }`},C=[{dims:d,dataType:e[0].dataType}];return $&&C.push({dims:_,dataType:1}),v&&C.push({dims:_,dataType:1}),{name:\"LayerNormalization\",shaderCache:{hint:`${b};${n};${r}`,inputDependencies:w},getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(p/64)},programUniforms:S}),getShaderSource:T}},Ul=(e,t)=>{Qg(e.inputs),e.compute(Yg(e.inputs,t,e.outputCount))}});var Xg,Vl,Wl=G(()=>{\"use strict\";ae();Xr();Jr();Xg=e=>{if(!e||e.length!==2)throw new Error(\"MatMul requires 2 inputs.\");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error(\"shared dimension does not match.\")},Vl=e=>{Xg(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error(\"Can't use matmul on the given tensors\");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(Yr(e.inputs,{activation:\"\"},t));else{let o=t[t.length-2],a=E.size(e.inputs[0].dims.slice(0,-2)),s=E.size(e.inputs[1].dims.slice(0,-2));if(a!==1&&o===1&&s===1){let d=e.inputs[0].reshape([1,a,r]),l=e.inputs[1].reshape([1,r,n]),p=[1,a,n],f=[d,l];e.compute(nr(f,{activation:\"\"},t,p),{inputs:f})}else e.compute(nr(e.inputs,{activation:\"\"},t))}}});var Jg,ey,ty,Ll,Gl,Hl=G(()=>{\"use strict\";te();ae();Ce();ce();Jg=(e,t)=>{if(e.length<3||e.length>4)throw new Error(\"MatMulNBits requires 3 or 4 inputs\");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error(\"The last dim of input shape does not match the k value\");let o=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,s=e[1];if(!E.areEqual(s.dims,[t.n,o,a]))throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");let l=e[2].dims;if(E.size(l)!==t.n*o)throw new Error(\"scales input size error.\");if(e.length===4){let f=e[3].dims,h=t.bits>4?t.n*o:t.n*Math.floor((o+1)/2);if(E.size(f)!==h)throw new Error(\"zeroPoints input size error.\")}},ey=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=ge(s),w=d.concat([o,s]),S=o>1&&s/b%2===0?2:1,$=E.size(w)/b/S,v=64,T=[],C=[l,o,a/y],A=E.convertShape(e[1].dims).slice();A.splice(-1,1,f/_),T.push(...H(C)),T.push(...H(A)),T.push(...H(e[2].dims)),e.length===4&&T.push(...H(E.convertShape(e[3].dims)));let k=[l,o,s/b];T.push(...H(k));let O=M=>{let V=C.length,F=P(\"a\",e[0].dataType,V,y),j=P(\"b\",12,A.length,_),ne=P(\"scales\",e[2].dataType,e[2].dims.length),W=[F,j,ne],J=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;J&&W.push(J);let ve=k.length,Q=N(\"output\",e[0].dataType,ve,b),ee=_e(e[0].dataType),le=(()=>{switch(y){case 1:return`array<${ee}, 8>`;case 2:return`mat4x2<${ee}>`;case 4:return`mat2x4<${ee}>`;default:throw new Error(`${y}-component is not supported.`)}})(),Z=()=>{let Se=`\n          // reuse a data\n            var input_offset = ${F.indicesToOffset(`${F.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${le};\n            for (var j: u32 = 0; j < ${8/y}; j++) {\n              a_data[j] = ${F.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;for(let D=0;D<b*S;D++)Se+=`\n            b_value = ${_===1?`b${D}_data`:`b${D}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${le}(${Array.from({length:4},(R,Y)=>`${ee}(b_value_lower[${Y}]), ${ee}(b_value_upper[${Y}])`).join(\", \")});\n            b_dequantized_values = ${y===1?`${le}(${Array.from({length:8},(R,Y)=>`(b_quantized_values[${Y}] - ${J?`zero_point${D}`:\"zero_point\"}) * scale${D}`).join(\", \")});`:`(b_quantized_values - ${le}(${Array(8).fill(`${J?`zero_point${D}`:\"zero_point\"}`).join(\",\")})) * scale${D};`};\n            workgroup_shared[local_id.x * ${S} + ${Math.floor(D/b)}]${b>1?`[${D%b}]`:\"\"} += ${Array.from({length:8/y},(R,Y)=>`${y===1?`a_data[${Y}] * b_dequantized_values[${Y}]`:`dot(a_data[${Y}], b_dequantized_values[${Y}])`}`).join(\" + \")};\n          `;return Se},pe=()=>{let Se=`\n            var col_index = col * ${b};\n            ${J?`\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${ee}(8);`}\n            `;for(let D=0;D<b*S;D++)Se+=`\n            let scale${D} = ${ne.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${J?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${J.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${D} = ${ee}((zero_point_word) & 0xFu);`:\"\"}\n            col_index += 1;`;return Se},ke=()=>{let Se=`col_index = col * ${b};`;for(let D=0;D<b*S;D++)Se+=`\n            let b${D}_data = ${j.getByIndices(`${j.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return Se+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${le};\n            var b_dequantized_values: ${le};`,Se};return`\n        var<workgroup> workgroup_shared: array<${Q.type.value}, ${S*v}>;\n        ${M.declareVariables(...W,Q)}\n        ${M.mainStart([v,1,1])}\n          let output_indices = ${Q.offsetToIndices(`(global_idx / ${v}) * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/y};\n            ${pe()}\n            for (var word: u32 = 0; word < ${f}; word += ${_}) {\n              ${ke()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${Z()}\n                word_offset += ${8/y};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${S}) {\n            var output_value: ${Q.type.value} = ${Q.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${S};\n            }\n            ${Q.setByIndices(`${Q.type.indices}(batch, row, col + local_id.x)`,\"output_value\")};\n          }\n        }`};return{name:\"MatMulNBits\",shaderCache:{hint:`${t.blockSize};${t.bits};${y};${_};${b};${S};${v}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:w,dataType:h}],dispatchGroup:{x:$},programUniforms:T}),getShaderSource:O}},ty=(e,t)=>{let n=e[0].dims,r=n.length,o=n[r-2],a=t.k,s=t.n,d=n.slice(0,r-2),l=E.size(d),f=e[1].dims[2]/4,h=e[0].dataType,y=ge(t.k),_=ge(f),b=d.concat([o,s]),w=128,S=s%8===0?8:s%4===0?4:1,$=w/S,v=$*_*8,T=v/y,C=v/t.blockSize,A=E.size(b)/S,k=[],O=[l,o,a/y],M=E.convertShape(e[1].dims).slice();M.splice(-1,1,f/_),k.push(...H(O)),k.push(...H(M)),k.push(...H(e[2].dims)),e.length===4&&k.push(...H(E.convertShape(e[3].dims)));let V=[l,o,s];k.push(...H(V));let F=j=>{let ne=O.length,W=P(\"a\",e[0].dataType,ne,y),J=P(\"b\",12,M.length,_),ve=P(\"scales\",e[2].dataType,e[2].dims.length),Q=[W,J,ve],ee=e.length===4?P(\"zero_points\",12,e[3].dims.length):void 0;ee&&Q.push(ee);let le=V.length,Z=N(\"output\",e[0].dataType,le),pe=_e(e[0].dataType),ke=()=>{switch(y){case 1:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${pe}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${pe}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${y}-component is not supported.`)}};return`\n        var<workgroup> sub_a: array<${W.type.value}, ${T}>;\n        var<workgroup> inter_results: array<array<${Z.type.value}, ${$}>, ${S}>;\n        ${j.declareVariables(...Q,Z)}\n        ${j.mainStart([$,S,1])}\n          let output_indices = ${Z.offsetToIndices(`workgroup_index * ${S}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${C} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${T};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${T}; a_offset += ${w})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${W.getByIndices(`${W.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${W.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${C} + local_id.x;\n            ${ee?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${ee.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${pe}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${pe}(8);`}\n            let scale = ${ve.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${J.getByIndices(`${J.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/y};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${ke()}\n              let b_value = ${_===1?\"b_data\":\"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${pe}>(${Array.from({length:4},(Se,D)=>`${pe}(b_value_lower[${D}]), ${pe}(b_value_upper[${D}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${pe}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(Se,D)=>`${`dot(a_data${D}, b_dequantized_values[${D}])`}`).join(\" + \")};\n              word_offset += ${8/y};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${S}) {\n            var output_value: ${Z.type.value} = ${Z.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${Z.setByIndices(`${Z.type.indices}(batch, row, col + local_idx)`,\"output_value\")}\n            }\n          }\n        }`};return{name:\"BlockwiseMatMulNBits32\",shaderCache:{hint:`${t.blockSize};${y};${_};${$};${S}`,inputDependencies:Array(e.length).fill(\"rank\")},getRunData:()=>({outputs:[{dims:b,dataType:h}],dispatchGroup:{x:A},programUniforms:k}),getShaderSource:F}},Ll=(e,t)=>{Jg(e.inputs,t),t.blockSize===32&&e.adapterInfo.isVendor(\"intel\")&&e.adapterInfo.isArchitecture(\"gen-12lp\")?e.compute(ty(e.inputs,t)):e.compute(ey(e.inputs,t))},Gl=e=>re(e)});var ry,ny,oy,iy,ay,sy,uy,dy,Fl,ql=G(()=>{\"use strict\";te();ae();ce();ry=e=>{if(!e||e.length<1)throw new Error(\"Too few inputs\");if(e[0].dataType!==1&&e[0].dataType!==10)throw new Error(\"Input type must be float or float16.\");if(e.length>=2){let t=e[0].dims.length*2===e[1].dims[0];if(e.length===4&&(t=e[3].dims[0]*2===e[1].dims[0]),!t)throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\")}},ny=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n            k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n              break;\n            }\n            offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},oy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${K(\"uniforms.x_shape\",o,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},iy=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k = i32(${K(\"uniforms.x_shape\",o,t)}) - 1;\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},ay=(e,t,n)=>{let r=\"\";for(let o=t-1;o>=0;--o)r+=`\n                k = i32(${e.indicesGet(\"indices\",o)}) - ${K(\"uniforms.pads\",o,n)};\n                if (k < 0)  {\n                  k += i32(${K(\"uniforms.x_shape\",o,t)}]);\n                }\n                if (k >= i32(${K(\"uniforms.x_shape\",o,t)})) {\n                  k -= i32(${K(\"uniforms.x_shape\",o,t)});\n                }\n                offset += k * i32(${K(\"uniforms.x_strides\",o,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},sy=(e,t,n)=>{switch(n.mode){case 0:return ny(e,t,n.pads.length);case 1:return oy(e,t,n.pads.length);case 2:return iy(e,t,n.pads.length);case 3:return ay(e,t,n.pads.length);default:throw new Error(\"Invalid mode\")}},uy=(e,t)=>{let n=E.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,o=E.size(n),a=[{type:12,data:o},{type:6,data:t.pads}],s=e.length>=3&&e[2].data;t.mode===0&&a.push({type:s?e[2].dataType:1,data:t.value}),a.push(...H(e[0].dims,n));let d=[\"rank\"],l=p=>{let f=N(\"output\",e[0].dataType,n.length),h=P(\"x\",e[0].dataType,r.length),y=h.type.value,_=sy(f,r.length,t),b=[{name:\"output_size\",type:\"u32\"},{name:\"pads\",type:\"i32\",length:t.pads.length}];return t.mode===0&&b.push({name:\"constant_value\",type:s?y:\"f32\"}),`\n            ${p.registerUniforms(b).declareVariables(h,f)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${f.offsetToIndices(\"global_idx\")};\n\n            var value = ${y}(0);\n            ${_}\n            output[global_idx] = value;\n        }`};return{name:\"Pad\",shaderCache:{hint:`${t.mode}${s}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(n)/64)},programUniforms:a}),getShaderSource:l}},dy=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?e[2].dataType===10?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,o=e[0].dims.length,a=new Int32Array(2*o).fill(0);if(e.length>=4){let d=e[3].getBigInt64Array();for(let l=0;l<d.length;l++)a[Number(d[l])]=Number(n[l]),a[Number(d[l])+o]=Number(n[l+d.length])}else n.forEach((d,l)=>a[Number(l)]=Number(d));let s=[];return a.forEach(d=>s.push(d)),{mode:t.mode,value:r,pads:s}}else return t},Fl=(e,t)=>{ry(e.inputs);let n=dy(e.inputs,t);e.compute(uy(e.inputs,n),{inputs:[0]})}});var rn,Kl,jl,Zl,Ql,ly,cy,Yl,Xl,Jl,ec,tc,rc,nc,oc,ic,ac,sc,uc,dc=G(()=>{\"use strict\";Ge();te();ae();ce();rn=e=>{if(we.webgpu.validateInputContent&&(!e||e.length!==1))throw new Error(\"Pool ops requires 1 input.\")},Kl=(e,t,n)=>{let r=t.format===\"NHWC\",o=e.dims.slice();r&&o.splice(1,0,o.pop());let a=Object.hasOwnProperty.call(t,\"dilations\"),s=t.kernelShape.slice(),d=t.strides.slice(),l=a?t.dilations.slice():[],p=t.pads.slice();kt.adjustPoolAttributes(n,o,s,d,l,p);let f=kt.computePoolOutputShape(n,o,d,l,s,p,t.autoPad),h=Object.assign({},t);a?Object.assign(h,{kernelShape:s,strides:d,pads:p,dilations:l,cacheKey:t.cacheKey}):Object.assign(h,{kernelShape:s,strides:d,pads:p,cacheKey:t.cacheKey});let y=f.slice();return y.push(y.splice(1,1)[0]),[h,r?y:f]},jl=(e,t)=>{let n=t.format===\"NHWC\",r=E.size(e),o=E.size(t.kernelShape),a=[{type:12,data:r},{type:12,data:o}],s=[{name:\"outputSize\",type:\"u32\"},{name:\"kernelSize\",type:\"u32\"}];if(t.kernelShape.length<=2){let d=t.kernelShape[t.kernelShape.length-1],l=t.strides[t.strides.length-1],p=t.pads[t.pads.length/2-1],f=t.pads[t.pads.length-1],h=!!(p+f);a.push({type:12,data:d},{type:12,data:l},{type:12,data:p},{type:12,data:f}),s.push({name:\"kw\",type:\"u32\"},{name:\"sw\",type:\"u32\"},{name:\"pwStart\",type:\"u32\"},{name:\"pwEnd\",type:\"u32\"});let y=!1;if(t.kernelShape.length===2){let _=t.kernelShape[t.kernelShape.length-2],b=t.strides[t.strides.length-2],w=t.pads[t.pads.length/2-2],S=t.pads[t.pads.length-2];y=!!(w+S),a.push({type:12,data:_},{type:12,data:b},{type:12,data:w},{type:12,data:S}),s.push({name:\"kh\",type:\"u32\"},{name:\"sh\",type:\"u32\"},{name:\"phStart\",type:\"u32\"},{name:\"phEnd\",type:\"u32\"})}return[a,s,!0,h,y]}else{if(n)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let d=E.computeStrides(t.kernelShape);a.push({type:12,data:d},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:\"kernelStrides\",type:\"u32\",length:d.length},{name:\"pads\",type:\"u32\",length:t.pads.length},{name:\"strides\",type:\"u32\",length:t.strides.length});let l=t.pads.reduce((p,f)=>p+f);return[a,s,!!l,!1,!1]}},Zl=(e,t,n,r,o,a,s,d,l,p,f,h)=>{let y=o.format===\"NHWC\",_=t.type.value,b=N(\"output\",t.type.tensor,r);if(o.kernelShape.length<=2){let w=\"\",S=\"\",$=\"\",v=n-(y?2:1);if(f?w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`:w=`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${a}\n                }`,o.kernelShape.length===2){let C=n-(y?3:2);h?S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${C}] < 0 || xIndices[${C}] >= uniforms.x_shape[${C}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:S=`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${C}] = indices[${C}] * uniforms.sh - uniforms.phStart + j;\n                `,$=`\n              }\n            `}return`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${S}\n              ${w}\n              ${$}\n              ${s}\n\n              output[global_idx] = value;\n            }`}else{if(y)throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");let w=o.kernelShape.length,S=o.pads.length,$=\"\";return p?$=`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${a}\n              }`:$=`\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,b)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${b.offsetToIndices(\"global_idx\")};\n              var xIndices = ${b.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${w}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${w-1}u; j++) {\n                  offsets[j] = offset / ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                  offset -= offsets[j] * ${K(\"uniforms.kernelStrides\",\"j\",w)};\n                }\n                offsets[${w-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-w}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${K(\"uniforms.strides\",`j - ${n-w}u`,w)}\n                    + offsets[j - ${n-w}u] - ${K(\"uniforms.pads\",\"j - 2u\",S)};\n                  ${$}\n              }\n              ${s}\n\n              output[global_idx] = value;\n            }`}},Ql=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,ly=e=>`${Ql(e)};${e.countIncludePad}`,cy=e=>`${Ql(e)};${e.storageOrder};${e.dilations}`,Yl=e=>({format:e.format,autoPad:[\"NOTSET\",\"VALID\",\"SAME_UPPER\",\"SAME_LOWER\"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xl=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=P(\"x\",t.dataType,t.dims.length),d=s.type.value,l=\"value += x_val;\",p=\"\";o.countIncludePad?p+=`value /= ${d}(uniforms.kernelSize);`:p+=`value /= ${d}(i32(uniforms.kernelSize) - pad);`;let[f,h,y,_,b]=jl(a,o);f.push(...H(t.dims,a));let w=[\"rank\"];return{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:w},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:S=>Zl(S,s,t.dims.length,a.length,o,l,p,0,h,y,_,b)}},Jl=e=>{let t=e.count_include_pad!==0,n=Yl(e);if(n.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");let r={countIncludePad:t,...n,cacheKey:\"\"};return{...r,cacheKey:ly(r)}},ec=(e,t)=>{rn(e.inputs),e.compute(Xl(\"AveragePool\",e.inputs[0],!1,t))},tc={autoPad:\"\",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},rc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},nc=(e,t)=>{rn(e.inputs),e.compute(Xl(\"GlobalAveragePool\",e.inputs[0],!0,t))},oc=(e,t,n,r)=>{let[o,a]=Kl(t,r,n),s=`\n      value = max(x_val, value);\n    `,d=\"\",l=P(\"x\",t.dataType,t.dims.length),p=[\"rank\"],[f,h,y,_,b]=jl(a,o);return f.push(...H(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${y};${_};${b}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(a)/64)},programUniforms:f}),getShaderSource:w=>Zl(w,l,t.dims.length,a.length,o,s,d,t.dataType===10?-65504:-1e5,h,y,_,b)}},ic=(e,t)=>{rn(e.inputs),e.compute(oc(\"MaxPool\",e.inputs[0],!1,t))},ac=e=>{let t=e.storage_order,n=e.dilations,r=Yl(e);if(t!==0)throw new Error(\"column major storage order is not yet supported for MaxPool\");if(r.ceilMode!==0)throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");let o={storageOrder:t,dilations:n,...r,cacheKey:\"\"};return{...o,cacheKey:cy(o)}},sc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},uc=(e,t)=>{rn(e.inputs),e.compute(oc(\"GlobalMaxPool\",e.inputs[0],!0,t))}});var my,fy,lc,cc,pc=G(()=>{\"use strict\";te();ae();Ce();ce();my=(e,t)=>{if(e.length<2||e.length>3)throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");if(e.length===3&&e[1].dims===e[2].dims)throw new Error(\"x-scale and x-zero-point must have the same shape.\");if(e.length===3&&e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[0].dataType===6&&e.length>2)throw new Error(\"In the case of dequantizing int32 there is no zero point.\");if(e[1].dims.length!==0&&e[1].dims.length!==1&&e[1].dims.length!==e[0].dims.length)throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error(\"x and x-zero-point must have the same data type.\");if(e[1].dims.length!==e[2].dims.length)throw new Error(\"scale and zero-point inputs must have the same rank.\");if(!e[1].dims.map((n,r)=>n===e[2].dims[r]).reduce((n,r)=>n&&r,!0))throw new Error(\"scale and zero-point inputs must have the same shape.\")}if(t.blockSize>0){if(e[1].dims.length===0||e[1].dims.length===1&&e[1].dims[0]===1)throw new Error(\"blockSize must be set only for block quantization.\");if(!e[1].dims.map((o,a)=>a===t.axis||o===e[0].dims[a]).reduce((o,a)=>o&&a,!0))throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");if(e[1].dims.length!==e[0].dims.length)throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\")}},fy=(e,t)=>{let n=E.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,o=r===3,a=e[0].dims,s=e[1].dataType,d=E.size(a),l=r===3||r===2,p=l?[Math.ceil(E.size(e[0].dims)/4)]:e[0].dims,f=e[1].dims,h=e.length>2?e[2]:void 0,y=h?l?[Math.ceil(E.size(h.dims)/4)]:h.dims:void 0,_=f.length===0||f.length===1&&f[0]===1,b=_===!1&&f.length===1,w=ge(d),S=_&&(!l||w===4),$=S?w:1,v=S&&!l?w:1,T=P(\"input\",l?12:r,p.length,v),C=P(\"scale\",s,f.length),A=h?P(\"zero_point\",l?12:r,y.length):void 0,k=N(\"output\",s,a.length,$),O=[T,C];A&&O.push(A);let M=[p,f];h&&M.push(y);let V=[{type:12,data:d/$},{type:12,data:n},{type:12,data:t.blockSize},...H(...M,a)],F=j=>{let ne=[{name:\"output_size\",type:\"u32\"},{name:\"axis\",type:\"u32\"},{name:\"block_size\",type:\"u32\"}];return`\n      ${j.registerUniforms(ne).declareVariables(...O,k)}\n      ${j.mainStart()}\n          ${j.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${k.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${l?`\n            let input = ${T.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o?\"unpack4xI8(input)\":\"unpack4xU8(input)\"};\n            let x_value = ${$===1?\"x_vec[global_idx % 4]\":\"x_vec\"};`:`let x_value = ${T.getByOffset(\"global_idx\")};`};\n\n          // Set scale input\n          ${_?`let scale_value= ${C.getByOffset(\"0\")}`:b?`\n            let scale_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n            let scale_value= ${C.getByOffset(\"scale_index\")};`:`\n            var scale_indices: ${C.type.indices} = output_indices;\n            let index = ${C.indicesGet(\"scale_indices\",\"uniforms.axis\")} / uniforms.block_size;\n            ${C.indicesSet(\"scale_indices\",\"uniforms.axis\",\"index\")};\n            let scale_value= ${C.getByIndices(\"scale_indices\")};`};\n\n          // Set zero-point input\n          ${A?_?l?`\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${A.getByOffset(\"0\")}`:b?l?`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${k.indicesGet(\"output_indices\",\"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};`:l?`\n                let zero_point_offset = ${C.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o?\"unpack4xI8(zero_point_input)\":\"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${A.getByIndices(\"scale_indices\")};`:`let zero_point_value = ${l?o?\"i32\":\"u32\":T.type.value}(0);`};\n      // Compute and write output\n      ${k.setByOffset(\"global_idx\",`${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`};return{name:\"DequantizeLinear\",shaderCache:{hint:t.cacheKey,inputDependencies:A?[\"rank\",\"rank\",\"rank\"]:[\"rank\",\"rank\"]},getShaderSource:F,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:Math.ceil(d/$/64),y:1,z:1},programUniforms:V})}},lc=(e,t)=>{my(e.inputs,t),e.compute(fy(e.inputs,t))},cc=e=>re({axis:e.axis,blockSize:e.blockSize})});var hy,gy,mc,fc=G(()=>{\"use strict\";Ge();te();ce();hy=(e,t,n)=>{let r=e===t,o=e<t&&n<0,a=e>t&&n>0;if(r||o||a)throw new Error(\"Range these inputs' contents are invalid.\")},gy=(e,t,n,r)=>{let o=Math.abs(Math.ceil((t-e)/n)),a=[o],s=o,d=[{type:12,data:s},{type:r,data:e},{type:r,data:n},...H(a)],l=p=>{let f=N(\"output\",r,a.length),h=f.type.value,y=[{name:\"outputSize\",type:\"u32\"},{name:\"start\",type:h},{name:\"delta\",type:h}];return`\n        ${p.registerUniforms(y).declareVariables(f)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${h}(global_idx) * uniforms.delta;\n      }`};return{name:\"Range\",shaderCache:{hint:`${r}`},getShaderSource:l,getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:d})}},mc=e=>{let t=0,n=0,r=0;e.inputs[0].dataType===6?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):e.inputs[0].dataType===1&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),we.webgpu.validateInputContent&&hy(t,n,r),e.compute(gy(t,n,r,e.inputs[0].dataType),{inputs:[]})}});var yy,by,hc,gc,yc=G(()=>{\"use strict\";te();ae();Ce();ce();yy=(e,t,n,r)=>{if(e!==\"none\"&&r!==\"i32\"&&r!==\"u32\"&&r!==\"f32\")throw new Error(`Input ${r} is not supported with reduction ${e}.`);let o=`{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`,a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case\"none\":return`${t}=${n};`;case\"add\":return r===\"i32\"||r===\"u32\"?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\n              ${o}bitcast<${r}>(oldValue) + (${n})${a}`;case\"max\":return r===\"i32\"||r===\"u32\"?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\n                ${o}max(bitcast<f32>(oldValue), (${n}))${a}`;case\"min\":return r===\"i32\"||r===\"u32\"?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${o}min(bitcast<${r}>(oldValue), (${n}))${a}`;case\"mul\":return`${o}(bitcast<${r}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},by=(e,t)=>{let n=e[0].dims,r=e[1].dims,o=n,a=1,s=Math.ceil(E.size(r)/a),d=r[r.length-1],l=E.sizeFromDimension(n,d),p=[{type:12,data:s},{type:12,data:d},{type:12,data:l},...H(e[1].dims,e[2].dims,o)],f=h=>{let y=P(\"indices\",e[1].dataType,e[1].dims.length),_=P(\"updates\",e[2].dataType,e[2].dims.length,a),b=t.reduction!==\"none\"&&t.reduction!==\"\"?Hs(\"output\",e[0].dataType,o.length):N(\"output\",e[0].dataType,o.length,a);return`\n      ${h.registerUniform(\"output_size\",\"u32\").registerUniform(\"last_index_dimension\",\"u32\").registerUniform(\"num_updates_elements\",\"u32\").declareVariables(y,_,b)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var hasDuplicates = false;\n  if (${t.reduction===\"none\"}) {\n    let n = ${E.size(r)};\n    for (var i = 0; i < n; i = i + 1) {\n      for (var j = i + 1; j < n; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  if (${t.reduction===\"none\"} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    indices_start = 0u;\n  }\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e[0].dims.length===1?`\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;`:`\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${yy(t.reduction,\"output[data_offset + i]\",\"value\",b.type.value)}\n  }\n\n      }`};return{name:\"ScatterND\",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:[\"rank\",\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:p}),getShaderSource:f}},hc=e=>re({reduction:e.reduction}),gc=(e,t)=>{e.compute(by(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}});var _y,wy,vy,bc,$y,xy,Sy,Ty,Cy,Iy,Ay,ky,_c,Ey,Py,zy,Oy,Dy,wc,vc,$c=G(()=>{\"use strict\";te();ae();Ce();ce();_y=(e,t)=>{if(e.every(n=>n>0||(()=>{throw new Error(\"Resize requires scales input values to be positive\")})),e.length>0){if(t.mode===\"linear\"){if(!(e.length===2||e.length===3||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1||e.length===5&&e[0]===1&&e[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(t.mode===\"cubic\"&&!(e.length===2||e.length===4&&e[0]===1&&e[1]===1||e.length===4&&e[0]===1&&e[3]===1))throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\")}},wy=(e,t,n)=>{t.every(o=>o>=0&&o<n||(()=>{throw new Error(\"Resize requires axes input values to be positive and less than rank\")}));let r=new Array(n).fill(1);return t.forEach((o,a)=>r[o]=e[a]),r},vy=(e,t,n,r,o,a)=>{let[s,d,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],p=e[0].dims.length;if(s>0&&e.length>s&&e[s].dims.length>0)e[s].getFloat32Array().forEach(f=>a.push(f));else if(t.coordinateTransformMode===\"tf_crop_and_resize\")throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");if(d>0&&e.length>d&&e[d].dims.length===1&&e[d].dims[0]>0){if(e[d].getFloat32Array().forEach(f=>r.push(f)),r.length!==0&&r.length!==p&&n>=18&&r.length!==t.axes.length)throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");_y(r,t),t.axes.length>0&&wy(r,t.axes,p).forEach((f,h)=>r[h]=f)}if(l>0&&e.length>l&&e[l].dims.length===1&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(f=>o.push(Number(f))),o.length!==0&&o.length!==p&&n>=18&&o.length!==t.axes.length))throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");if(t.axes.length>0){if(r.length!==0&&r.length!==t.axes.length)throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');if(o.length!==0&&o.length!==t.axes.length)throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<\"u\"&&typeof o<\"u\"&&r.length>0&&o.length>p)throw new Error(\"Resize requires only of scales or sizes to be specified\")},bc=(e,t,n,r)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${r}(big / (${n}));\n  let fract = ${r}(big % (${n})) / ${r}(${n});\n  return whole + fract;\n`,$y=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case\"asymmetric\":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${bc(\"xResized\",\"lengthOriginal\",\"lengthResized\",t)}\n          }\n        `;case\"pytorch_half_pixel\":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case\"tf_half_pixel_for_nn\":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case\"align_corners\":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${bc(\"xResized\",\"lengthOriginal - 1\",\"lengthResized - 1\",t)}\n                  }`;case\"tf_crop_and_resize\":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case\"half_pixel_symmetric\":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case\"half_pixel\":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+\"}\",xy=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case\"round_prefer_ceil\":return\"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";case\"floor\":return\"return floor(xOriginal);\";case\"ceil\":return\"return ceil(xOriginal);\";case\"round_prefer_floor\":return\"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";case\"simple\":default:if(t<11)return\"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";throw new Error(`Nearest mode ${e} is not supported`)}})()+\"}\",Sy=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),o=e.length===0?r:e.slice();return t.length>0?(t.forEach((a,s)=>{r[a]=o[s],r[s+n]=o[t.length+s]}),r):o},Ty=(e,t,n,r)=>{let o=[];if(n.length>0)if(r.length>0){if(e.forEach(a=>o.push(a)),Math.max(...r)>e.length)throw new Error(\"axes is out of bound\");r.forEach((a,s)=>o[a]=n[s])}else n.forEach(a=>o.push(a));else{if(t.length===0)throw new Error(\"Resize requires either scales or sizes.\");o=e.map((a,s)=>Math.round(a*t[s]))}return o},Cy=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case\"not_larger\":return n.axes.length>0?Math.min(...n.axes.map(a=>t[a]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case\"not_smaller\":return n.axes.length>0?Math.max(...n.axes.map(a=>t[a]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let o=e.slice();return n.axes.length>0?(n.axes.forEach(a=>t[a]=r),n.axes.forEach(a=>o[a]=Math.round(e[a]*t[a]))):(t.fill(r,0,t.length),o.forEach((a,s)=>o[s]=Math.round(a*t[s]))),o},Iy=(e,t,n,r,o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet(\"output_indices\",\"i\")};\n        var scale = ${K(\"uniforms.scales\",\"i\",r)};\n        var roi_low = ${K(\"uniforms.roi\",\"i\",o)};\n        var roi_hi = ${K(\"uniforms.roi\",`i + ${t.length}`,o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",t.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ay=(e,t,n,r,o,a,s)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n        var input_index: u32;\n        var scale = ${K(\"uniforms.scales\",\"i\",o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${K(\"uniforms.roi\",\"i\",a)};\n          var roi_hi = ${K(\"uniforms.roi\",`i + ${n.length}`,a)};\n          var input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n          var output_shape_i = ${K(\"uniforms.output_shape\",\"i\",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${s} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")}\n      }\n      return input_indices;\n    }`,ky=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet(\"input_indices\",\"i\")};\n        if (input_index < 0 || input_index >= ${K(\"uniforms.input_shape\",\"i\",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,_c=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet(\"input_indices\",t,\"channel\")};\n    ${e.indicesSet(\"input_indices\",n,\"batch\")};\n`:\"\",Ey=(e,t,n,r,o)=>{let[s,d,l,p]=n.length===2?[-1,0,1,-1]:[0,2,3,1],f=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${f} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(row, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(col, ${n[l]} - 1))`)};\n      ${_c(e,p,s,2)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${f} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${f} = originalIndices[${d}];\n      var col:${f} = originalIndices[${l}];\n      ${r?`if (row < 0 || row > (${n[d]} - 1) || col < 0 || col > (${n[l]} - 1)) {\n        return ${o};\n      }`:\"\"};\n      row = max(0, min(row, ${n[d]} - 1));\n      col = max(0, min(col, ${n[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${p}])`:\"0\"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${s}])`:\"0\"};\n      var x11: ${f} = getInputValue(batch, channel, row1, col1);\n      var x12: ${f} = getInputValue(batch, channel, row1, col2);\n      var x21: ${f} = getInputValue(batch, channel, row2, col1);\n      var x22: ${f} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${f} = abs(row - ${f}(row1));\n      var dx2: ${f} = abs(${f}(row2) - row);\n      var dy1: ${f} = abs(col - ${f}(col1));\n      var dy2: ${f} = abs(${f}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Py=(e,t,n,r,o,a,s,d,l,p)=>{let f=n.length===2,h=!0,[y,_]=f?[0,1]:h?[2,3]:[1,2],b=e.type.value,w=S=>{let $=S===y?\"row\":\"col\";return`\n      fn ${$}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${b} {\n        var output_index = ${t.indicesGet(\"output_indices\",S)};\n        var originalIdx: ${b} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[S]},\n        ${r[S]}, ${n[S]}, ${a[S]}, ${a[S]} + ${n.length});\n        var fractOriginalIdx: ${b} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${n[S]} - 1))) {\n          return ${l};\n        }\n        var data: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${b} = originalIdx + ${b}(i);\n          if (${$} < 0 || ${$} >= ${n[S]}) {\n            ${p?`coefs[i + 1] = 0.0;\n                        continue;`:d?`return ${l};`:`${$} = max(0, min(${$}, ${n[S]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet(\"input_indices_copy\",S,`u32(${$})`)};\n          data[i + 1] = ${S===y?e.getByIndices(\"input_indices_copy\"):\"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${w(y)};\n    ${w(_)};\n  fn getCubicInterpolationCoefs(s: ${b}) -> array<${b}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${b}, 4> = array<${b}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${b} = 1.0 - absS;\n    var twoMinusAbsS: ${b} = 2.0 - absS;\n    var onePlusAbsS: ${b} = 1.0 + absS;\n    coeffs[0] = ((${s} * onePlusAbsS - 5 * ${s}) * onePlusAbsS + 8 * ${s}) * onePlusAbsS - 4 * ${s};\n    coeffs[1] = ((${s} + 2) * absS - (${s} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${s} + 2) * oneMinusAbsS - (${s} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${s} * twoMinusAbsS - 5 * ${s}) * twoMinusAbsS + 8 * ${s}) * twoMinusAbsS - 4 * ${s};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${b}, 4>, coefs: array<${b}, 4>) -> ${b} {\n    var coefsSum: ${b} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${b} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},zy=(e,t,n,r,o)=>{let[s,d,l,p,f]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],h=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${h} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet(\"input_indices\",d,`max(0, min(depth, ${n[d]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",l,`max(0, min(height, ${n[l]} - 1))`)};\n      ${e.indicesSet(\"input_indices\",p,`max(0, min(width, ${n[p]} - 1))`)};\n      ${_c(e,f,s,3)}\n      return ${e.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${h} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${h} = originalIndices[${d}];\n      var height:${h} = originalIndices[${l}];\n      var width:${h} = originalIndices[${p}];\n      ${r?`if (depth < 0 || depth > (${n[d]} - 1) || height < 0 || height > (${n[l]} - 1) || width < 0 || (width > ${n[p]} - 1)) {\n      return ${o};\n        }`:\"\"};\n\n    depth = max(0, min(depth, ${n[d]} - 1));\n      height = max(0, min(height, ${n[l]} - 1));\n      width = max(0, min(width, ${n[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${f}])`:\"0\"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${s}])`:\"0\"};\n\n      var x111: ${h} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${h} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${h} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${h} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${h} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${h} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${h} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${h} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${h} = abs(depth - ${h}(depth1));\n      var dx2: ${h} = abs(${h}(depth2) - depth);\n      var dy1: ${h} = abs(height - ${h}(height1));\n      var dy2: ${h} = abs(${h}(height2) - height);\n      var dz1: ${h} = abs(width - ${h}(width1));\n      var dz2: ${h} = abs(${h}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Oy=(e,t,n,r,o,a)=>{let s=e.dims,d=Sy(a,t.axes,s.length),l=Ty(s,r,o,t.axes),p=r.slice();r.length===0&&(p=s.map((v,T)=>v===0?1:l[T]/v),t.keepAspectRatioPolicy!==\"stretch\"&&(l=Cy(s,p,t)));let f=N(\"output\",e.dataType,l.length),h=P(\"input\",e.dataType,s.length),y=E.size(l),_=s.length===l.length&&s.every((v,T)=>v===l[T]),b=t.coordinateTransformMode===\"tf_crop_and_resize\",w=t.extrapolationValue,S=h.type.value,$=v=>`\n      ${_?\"\":`\n      ${$y(t.coordinateTransformMode,S)};\n      ${(()=>{switch(t.mode){case\"nearest\":return`\n              ${ky(h,s)};\n              ${xy(t.nearestMode,n,S)};\n              ${Ay(h,f,s,l,p.length,d.length,b)};\n              `;case\"linear\":return`\n              ${Iy(f,s,l,p.length,d.length)};\n              ${(()=>{if(s.length===2||s.length===4)return`${Ey(h,f,s,b,w)}`;if(s.length===3||s.length===5)return`${zy(h,f,s,b,w)}`;throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\")})()};\n            `;case\"cubic\":return`\n            ${(()=>{if(s.length===2||s.length===4)return`${Py(h,f,s,l,p,d,t.cubicCoeffA,b,t.extrapolationValue,t.excludeOutside)}`;throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\")})()};\n            `;default:throw Error(\"Invalid resize mode\")}})()};\n      `}\n      ${v.registerUniform(\"output_size\",\"u32\").registerUniform(\"scales\",\"f32\",p.length).registerUniform(\"roi\",\"f32\",d.length).declareVariables(h,f)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_?\"output[global_idx] = input[global_idx];\":`\n        let output_indices = ${f.offsetToIndices(\"global_idx\")};\n        var input_indices: ${h.type.indices};\n        ${(()=>{switch(t.mode){case\"nearest\":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${h.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case\"linear\":return`output[global_idx] = ${s.length===2||s.length===4?\"bilinearInterpolation\":\"trilinearInterpolation\"}(output_indices);`;case\"cubic\":return\"output[global_idx] = bicubicInterpolation(output_indices);\";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`;return{name:\"Resize\",shaderCache:{hint:`${t.cacheKey}|${n}|${p.length>0?t.mode===\"cubic\"?p:p.length:\"\"}|${o.length>0?o:\"\"}|${d.length>0?d:\"\"}|${_}|${t.mode===\"nearest\"?s.length:s}`,inputDependencies:[\"rank\"]},getShaderSource:$,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},{type:1,data:p},{type:1,data:d},...H(s,l)]})}},Dy=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},wc=(e,t)=>{let n=[],r=[],o=[],a=Dy(e);if(t.antialias!==0)throw Error(\"Only default value (0) for Antialias attribute is supported\");vy(e.inputs,t,a,n,r,o),e.compute(Oy(e.inputs[0],t,a,n,r,o),{inputs:[0]})},vc=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,o=e.cubicCoeffA,a=e.excludeOutside!==0,s=e.extrapolationValue,d=e.keepAspectRatioPolicy,l=e.mode,p=e.nearestMode===\"\"?\"simple\":e.nearestMode;return re({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:o,excludeOutside:a,extrapolationValue:s,keepAspectRatioPolicy:d,mode:l,nearestMode:p})}});var By,My,xc,Sc=G(()=>{\"use strict\";te();ae();Ce();ce();By=(e,t)=>{let[n,r,o,a]=e,{numHeads:s,rotaryEmbeddingDim:d}=t;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!E.areEqual(r.dims,[])&&!E.areEqual(r.dims,[1])&&r.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(a.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!E.areEqual(o.dims,a.dims))throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");if(d>0&&s===0)throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");let l=n.dims[0],p=n.dims[n.dims.length-2],f=o.dims[0],h=E.sizeFromDimension(n.dims,1)/p,y=d===0?o.dims[1]*2:h/s;if(d>y)throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");if(r.dims.length===2){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(p!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(y/2!==o.dims[1]&&d/2!==o.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);if(p>f)throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\")},My=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:o,scale:a}=t,s=e[0].dims[0],d=E.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],p=d/l,f=e[2].dims[1],h=o===0?f*2:p/r,y=new Array(s,l,p/h,h-f),_=E.computeStrides(y),b=[{type:1,data:a},{type:12,data:y},{type:12,data:_},...e[0].dims.length===3?new Array({type:12,data:[d,p,h,1]}):[],...e[0].dims.length===4?new Array({type:12,data:[d,h,l*h,1]}):[],...H(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)],w=S=>{let $=P(\"input\",e[0].dataType,e[0].dims.length),v=P(\"position_ids\",e[1].dataType,e[1].dims.length),T=P(\"cos_cache\",e[2].dataType,e[2].dims.length),C=P(\"sin_cache\",e[3].dataType,e[3].dims.length),A=N(\"output\",e[0].dataType,e[0].dims.length);return S.registerUniforms([{name:\"scale\",type:\"f32\"},{name:\"global_shape\",type:\"u32\",length:y.length},{name:\"global_strides\",type:\"u32\",length:_.length},{name:\"input_output_strides\",type:\"u32\",length:_.length}]),`\n        ${S.declareVariables($,v,T,C,A)}\n\n        ${S.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${T.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\",N(\"\",v.type.tensor,2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\",\"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${C.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"i\",\"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${C.get(\"position_id\",\"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\",\"bsnh[3]\")};\n            ${A.setByOffset(\"j\",\"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\",$.getByOffset(\"k\"))}\n          }\n        }`};return{name:\"RotaryEmbedding\",shaderCache:{hint:re({interleaved:n}).cacheKey,inputDependencies:[\"rank\",\"rank\",\"rank\",\"rank\"]},getShaderSource:w,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(y)/Et)},programUniforms:b})}},xc=(e,t)=>{By(e.inputs,t),e.compute(My(e.inputs,t))}});var Ry,Uy,Tc,Cc=G(()=>{\"use strict\";te();ae();ce();Ry=e=>{if(!e||e.length<3)throw new Error(\"layerNorm requires at least 3 inputs.\");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error(\"All inputs must have the same data type\");if(t.dims.length!==3&&t.dims.length!==2)throw new Error(\"Input must be 2D or 3D\");if(n.dims.length!==3&&n.dims.length!==2)throw new Error(\"Skip must be 2D or 3D\");let o=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==o)throw new Error(\"Skip must have the same hidden size as input\");if(n.dims[n.dims.length-2]!==a)throw new Error(\"Skip must have the same sequence length as input\");if(r.dims.length!==1)throw new Error(\"Gamma must be 1D\");if(r.dims[r.dims.length-1]!==o)throw new Error(\"Gamma must have the same hidden size as input\");if(e.length>3){let s=e[3];if(s.dims.length!==1)throw new Error(\"Beta must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Beta must have the same hidden size as input\")}if(e.length>4){let s=e[4];if(s.dims.length!==1)throw new Error(\"Bias must be 1D\");if(s.dims[s.dims.length-1]!==o)throw new Error(\"Bias must have the same hidden size as input\")}},Uy=(e,t,n,r)=>{let o=t.simplified,a=e[0].dims,s=E.size(a),d=a,l=s,p=a.slice(-1)[0],f=r?a.slice(0,-1).concat(1):[],h=!o&&e.length>3,y=e.length>4,_=r&&n>1,b=r&&n>2,w=n>3,S=64,$=ge(p),v=[{type:12,data:l},{type:12,data:$},{type:12,data:p},{type:1,data:t.epsilon}],T=A=>{let k=[{name:\"output_size\",type:\"u32\"},{name:\"components\",type:\"u32\"},{name:\"hidden_size\",type:\"u32\"},{name:\"epsilon\",type:\"f32\"}],O=[P(\"x\",e[0].dataType,e[0].dims,$),P(\"skip\",e[1].dataType,e[1].dims,$),P(\"gamma\",e[2].dataType,e[2].dims,$)];h&&O.push(P(\"beta\",e[3].dataType,e[3].dims,$)),y&&O.push(P(\"bias\",e[4].dataType,e[4].dims,$)),O.push(N(\"output\",e[0].dataType,d,$)),_&&O.push(N(\"mean_output\",1,f)),b&&O.push(N(\"inv_std_output\",1,f)),w&&O.push(N(\"input_skip_bias_sum\",e[0].dataType,d,$));let M=_e(e[0].dataType),V=_e(1,$);return`\n\n      ${A.registerUniforms(k).declareVariables(...O)}\n      var<workgroup> sum_shared : array<${V}, ${S}>;\n      var<workgroup> sum_squared_shared : array<${V}, ${S}>;\n\n      ${A.mainStart([S,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${S};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${S};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${S-1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${y?\"bias[offset1d + i]\":M+\"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${w?\"input_skip_bias_sum[offset + i] = value;\":\"\"}\n          output[offset + i] = value;\n          let f32_value = ${Pt(M,$,\"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${S};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Ke(\"sum\",$)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Ke(\"square_sum\",$)} / f32(uniforms.hidden_size) ${o?\"\":\"- mean * mean\"} + uniforms.epsilon);\n        ${_?\"mean_output[global_idx] = mean;\":\"\"}\n        ${b?\"inv_std_output[global_idx] = inv_std_dev;\":\"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o?\"\":`- ${M}(mean)`}) *\n            ${M}(inv_std_dev) * gamma[offset1d + i]\n            ${h?\"+ beta[offset1d + i]\":\"\"};\n        }\n      }`},C=[{dims:d,dataType:e[0].dataType}];return n>1&&C.push({dims:f,dataType:1}),n>2&&C.push({dims:f,dataType:1}),n>3&&C.push({dims:a,dataType:e[0].dataType}),{name:\"SkipLayerNormalization\",shaderCache:{hint:`${$};${_};${b};${w}`,inputDependencies:e.map((A,k)=>\"type\")},getShaderSource:T,getRunData:()=>({outputs:C,dispatchGroup:{x:Math.ceil(l/p)},programUniforms:v})}},Tc=(e,t)=>{Ry(e.inputs);let r=[0];e.outputCount>1&&r.push(-3),e.outputCount>2&&r.push(-3),e.outputCount>3&&r.push(3),e.compute(Uy(e.inputs,t,e.outputCount,!1),{outputs:r})}});var Ny,nn,Vy,Ic,Wy,Ly,Ac,kc,Ec=G(()=>{\"use strict\";te();ae();Ce();ce();Ny=(e,t)=>{if(!e||e.length<1)throw new Error(\"too few inputs\");if(t.axes.length!==0){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error(\"axes, starts and ends must have the same length\")}else if(t.starts.length!==t.ends.length)throw new Error(\"starts and ends must have the same length\");e.slice(1).forEach((n,r)=>{if(e[r+1].dataType!==6&&e[r+1].dataType!==7)throw new Error(`Input ${r} must be an array of int32 or int64`)})},nn=(e,t)=>{let n=[];if(e.length>t)if(e[t].dataType===7)e[t].getBigInt64Array().forEach(r=>n.push(Number(r)));else if(e[t].dataType===6)e[t].getInt32Array().forEach(r=>n.push(Number(r)));else throw new Error(`Input ${t} must be an array of int32 or int64`);return n},Vy=(e,t)=>{if(e.length>1){let n=nn(e,1),r=nn(e,2),o=nn(e,3);return o.length===0&&(o=[...Array(e[0].dims.length).keys()]),re({starts:n,ends:r,axes:o})}else return t},Ic=(e,t,n,r,o)=>{let a=e;return e<0&&(a+=n[r[t]]),o[t]<0?Math.max(0,Math.min(a,n[r[t]]-1)):Math.max(0,Math.min(a,n[r[t]]))},Wy=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${K(\"uniforms.input_shape\",\"i\",n.length)};\n            let steps_i = ${K(\"uniforms.steps\",\"i\",n.length)};\n            let signs_i = ${K(\"uniforms.signs\",\"i\",n.length)};\n            let starts_i = ${K(\"uniforms.starts\",\"i\",n.length)};\n            var output_index = ${t.indicesGet(\"output_indices\",\"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet(\"input_indices\",\"i\",\"input_index\")};\n          }\n          return input_indices;\n      }`,Ly=(e,t)=>{let n=e[0].dims,r=E.size(n),o=t.axes.length>0?E.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=nn(e,4);a.forEach($=>$!==0||(()=>{throw new Error(\"step cannot be 0\")})),a.length===0&&(a=Array(o.length).fill(1));let s=t.starts.map(($,v)=>Ic($,v,n,o,a)),d=t.ends.map(($,v)=>Ic($,v,n,o,a));if(o.length!==s.length||o.length!==d.length)throw new Error(\"start, ends and axes should have the same number of elements\");if(o.length!==n.length)for(let $=0;$<n.length;++$)o.includes($)||(s.splice($,0,0),d.splice($,0,n[$]),a.splice($,0,1));let l=a.map($=>Math.sign($));a.forEach(($,v,T)=>{if($<0){let C=(d[v]-s[v])/$,A=s[v],k=A+C*a[v];s[v]=k,d[v]=A,T[v]=-$}});let p=n.slice(0);o.forEach(($,v)=>{p[$]=Math.ceil((d[$]-s[$])/a[$])});let f={dims:p,dataType:e[0].dataType},h=N(\"output\",e[0].dataType,p.length),y=P(\"input\",e[0].dataType,e[0].dims.length),_=E.size(p),b=[{name:\"outputSize\",type:\"u32\"},{name:\"starts\",type:\"u32\",length:s.length},{name:\"signs\",type:\"i32\",length:l.length},{name:\"steps\",type:\"u32\",length:a.length}],w=[{type:12,data:_},{type:12,data:s},{type:6,data:l},{type:12,data:a},...H(e[0].dims,p)],S=$=>`\n      ${$.registerUniforms(b).declareVariables(y,h)}\n        ${Wy(y,h,n)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${h.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${h.setByOffset(\"global_idx\",y.getByIndices(\"input_indices\"))}\n      }`;return{name:\"Slice\",shaderCache:{hint:`${l.length}_${s.length}_${a.length}`,inputDependencies:[\"rank\"]},getShaderSource:S,getRunData:()=>({outputs:[f],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:w})}},Ac=(e,t)=>{Ny(e.inputs,t);let n=Vy(e.inputs,t);e.compute(Ly(e.inputs,n),{inputs:[0]})},kc=e=>{let t=e.starts,n=e.ends,r=e.axes;return re({starts:t,ends:n,axes:r})}});var Gy,Hy,Pc,zc,Oc=G(()=>{\"use strict\";te();ae();Ce();ct();ce();Gy=e=>{if(!e||e.length!==1)throw new Error(\"Softmax op requires 1 input.\")},Hy=(e,t)=>{let n=e.inputs[0],r=n.dims,o=E.size(r),a=r.length,s=E.normalizeAxis(t.axis,a),d=s<r.length-1,l,p=[];d?(p=Array.from({length:a},(O,M)=>M),p[s]=a-1,p[a-1]=s,l=e.compute(Oe(n,p),{inputs:[n],outputs:[-1]})[0]):l=n;let f=l.dims,h=f[a-1],y=o/h,_=ge(h),b=h/_,w=64;y===1&&(w=256);let S=(O,M)=>M===4?`max(max(${O}.x, ${O}.y), max(${O}.z, ${O}.w))`:M===2?`max(${O}.x, ${O}.y)`:M===3?`max(max(${O}.x, ${O}.y), ${O}.z)`:O,$=P(\"x\",l.dataType,l.dims,_),v=N(\"result\",l.dataType,l.dims,_),T=$.type.value,C=_e(l.dataType)===\"f32\"?`var threadMax = ${T}(-3.402823e+38f);`:`var threadMax = ${T}(-65504.0h);`,A=O=>`\n      var<workgroup> rowMaxShared : ${T};\n      var<workgroup> rowSumShared : ${T};\n      var<workgroup> threadShared : array<${T}, ${w}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${T} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${T}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${O.registerUniform(\"packedCols\",\"i32\").declareVariables($,v)}\n      ${O.mainStart(w)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${w};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${C}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${T}(${S(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${T}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${T}(${Ke(\"threadShared[0]\",_)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`,k=e.compute({name:\"Softmax\",shaderCache:{hint:`${_};${w}`,inputDependencies:[\"type\"]},getRunData:()=>({outputs:[{dims:f,dataType:l.dataType}],dispatchGroup:{x:y},programUniforms:[{type:6,data:b}]}),getShaderSource:A},{inputs:[l],outputs:[d?-1:0]})[0];d&&e.compute(Oe(k,p),{inputs:[k]})},Pc=(e,t)=>{Gy(e.inputs),Hy(e,t)},zc=e=>re({axis:e.axis})});var Dc,Fy,qy,Ky,Bc,Mc=G(()=>{\"use strict\";te();ae();ce();Dc=e=>Array.from(e.getBigInt64Array(),Number),Fy=e=>{if(!e||e.length!==2)throw new Error(\"Tile requires 2 inputs.\");if(e[0].dataType!==1&&e[0].dataType!==10&&e[0].dataType!==6&&e[0].dataType!==12)throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");if(e[1].dataType!==7)throw new Error(\"Tile `repeats` input should be of int64 data type\");if(e[1].dims.length!==1)throw new Error(\"Tile `repeats` input should be 1-D\");if(Dc(e[1]).length!==e[0].dims.length)throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\")},qy=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},Ky=(e,t)=>{let n=e[0].dims,r=t??Dc(e[1]),o=qy(n,r),a=E.size(o),s=e[0].dataType,d=P(\"input\",s,n.length),l=N(\"output\",s,o.length),p=f=>`\n      const inputShape = ${d.indices(...n)};\n      ${f.registerUniform(\"output_size\",\"u32\").declareVariables(d,l)}\n      ${f.mainStart()}\n      ${f.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\",\"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\",\"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\",\"i\",\"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\",d.getByIndices(\"input_indices\"))}\n    }`;return{name:\"Tile\",shaderCache:{hint:`${r}`,inputDependencies:[\"rank\"]},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...H(e[0].dims,o)]}),getShaderSource:p}},Bc=e=>{Fy(e.inputs),e.compute(Ky(e.inputs),{inputs:[0]})}});var jy,Zy,Rc,Uc=G(()=>{\"use strict\";te();ae();ce();jy=(e,t,n,r,o)=>{let a=N(\"output_data\",o,n.length,4),s=P(\"a_data\",t[1].dataType,t[1].dims.length,4),d=P(\"b_data\",t[2].dataType,t[2].dims.length,4),l=P(\"c_data\",t[0].dataType,t[0].dims.length,4),p,f=(h,y,_)=>`select(${y}, ${h}, ${_})`;if(!r)p=a.setByOffset(\"global_idx\",f(s.getByOffset(\"global_idx\"),d.getByOffset(\"global_idx\"),l.getByOffset(\"global_idx\")));else{let h=(y,_,b=\"\")=>{let w=`a_data[index_a${_}][component_a${_}]`,S=`b_data[index_b${_}][component_b${_}]`,$=`bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;return`\n            let output_indices${_} = ${a.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${s.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`,a)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${y}[${_}] = ${b}(${f(w,S,$)});\n          `};o===9?p=`\n            var data = vec4<u32>(0);\n            ${h(\"data\",0,\"u32\")}\n            ${h(\"data\",1,\"u32\")}\n            ${h(\"data\",2,\"u32\")}\n            ${h(\"data\",3,\"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:p=`\n            ${h(\"output_data[global_idx]\",0)}\n            ${h(\"output_data[global_idx]\",1)}\n            ${h(\"output_data[global_idx]\",2)}\n            ${h(\"output_data[global_idx]\",3)}\n          `}return`\n        ${e.registerUniform(\"vec_size\",\"u32\").declareVariables(l,s,d,a)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`},Zy=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,o=e[1].dataType,a=!(E.areEqual(t,n)&&E.areEqual(n,r)),s=t,d=E.size(t);if(a){let p=rt.calcShape(rt.calcShape(t,n,!1),r,!1);if(!p)throw new Error(\"Can't perform where op on the given tensors\");s=p,d=E.size(s)}let l=Math.ceil(d/4);return{name:\"Where\",shaderCache:{inputDependencies:[\"rank\",\"rank\",\"rank\"]},getShaderSource:p=>jy(p,e,s,a,o),getRunData:()=>({outputs:[{dims:s,dataType:o}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:l},...H(r,t,n,s)]})}},Rc=e=>{e.compute(Zy(e.inputs))}});var Nc,Vc=G(()=>{\"use strict\";_u();qr();$u();Su();dd();wd();xd();Nd();qd();Zd();Xd();nl();al();ul();cl();fl();yl();wl();xl();Cl();Dl();Rl();Nl();Wl();Hl();So();ql();dc();pc();fc();yc();Hr();$c();Sc();Cc();Ec();Oc();Co();Mc();ct();jr();Uc();Nc=new Map([[\"Abs\",[Tu]],[\"Acos\",[Cu]],[\"Acosh\",[Iu]],[\"Add\",[ld]],[\"ArgMax\",[bu,co]],[\"ArgMin\",[yu,co]],[\"Asin\",[Au]],[\"Asinh\",[ku]],[\"Atan\",[Eu]],[\"Atanh\",[Pu]],[\"Attention\",[wu]],[\"AveragePool\",[ec,Jl]],[\"BatchNormalization\",[vu]],[\"BiasAdd\",[xu]],[\"BiasSplitGelu\",[ud]],[\"Cast\",[Ou,zu]],[\"Ceil\",[Bu]],[\"Clip\",[Du]],[\"Concat\",[vd,$d]],[\"Conv\",[wo,_o]],[\"ConvTranspose\",[Fd,Gd]],[\"Cos\",[Mu]],[\"Cosh\",[Ru]],[\"CumSum\",[Kd,jd]],[\"DepthToSpace\",[Qd,Yd]],[\"DequantizeLinear\",[lc,cc]],[\"Div\",[cd]],[\"Einsum\",[tl,rl]],[\"Elu\",[Uu,tr]],[\"Equal\",[pd]],[\"Erf\",[Nu]],[\"Exp\",[Vu]],[\"Expand\",[il]],[\"FastGelu\",[sl]],[\"Floor\",[Wu]],[\"FusedConv\",[wo,_o]],[\"Gather\",[ll,dl]],[\"GatherElements\",[_l,bl]],[\"GatherBlockQuantized\",[hl,gl]],[\"GatherND\",[pl,ml]],[\"Gelu\",[Lu]],[\"Gemm\",[$l,vl]],[\"GlobalAveragePool\",[nc,rc]],[\"GlobalMaxPool\",[uc,sc]],[\"Greater\",[gd]],[\"GreaterOrEqual\",[bd]],[\"GridSample\",[Sl,Tl]],[\"GroupQueryAttention\",[Ol]],[\"HardSigmoid\",[Qu,Zu]],[\"InstanceNormalization\",[Ml]],[\"LayerNormalization\",[Ul]],[\"LeakyRelu\",[Gu,tr]],[\"Less\",[yd]],[\"LessOrEqual\",[_d]],[\"Log\",[id]],[\"MatMul\",[Vl]],[\"MatMulNBits\",[Ll,Gl]],[\"MaxPool\",[ic,ac]],[\"Mul\",[md]],[\"MultiHeadAttention\",[kl,Al]],[\"Neg\",[Fu]],[\"Not\",[Hu]],[\"Pad\",[Fl]],[\"Pow\",[fd]],[\"QuickGelu\",[ad,tr]],[\"Range\",[mc]],[\"Reciprocal\",[qu]],[\"ReduceMin\",[cu]],[\"ReduceMean\",[au]],[\"ReduceMax\",[lu]],[\"ReduceSum\",[mu]],[\"ReduceProd\",[pu]],[\"ReduceL1\",[su]],[\"ReduceL2\",[uu]],[\"ReduceLogSum\",[hu]],[\"ReduceLogSumExp\",[du]],[\"ReduceSumSquare\",[fu]],[\"Relu\",[Ku]],[\"Resize\",[wc,vc]],[\"RotaryEmbedding\",[xc]],[\"ScatterND\",[gc,hc]],[\"Sigmoid\",[ju]],[\"Sin\",[Yu]],[\"Sinh\",[Xu]],[\"Slice\",[Ac,kc]],[\"SkipLayerNormalization\",[Tc]],[\"Split\",[El,Pl]],[\"Sqrt\",[Ju]],[\"Softmax\",[Pc,zc]],[\"Sub\",[hd]],[\"Tan\",[ed]],[\"Tanh\",[rd]],[\"ThresholdedRelu\",[od,tr]],[\"Tile\",[Bc]],[\"Transpose\",[Ks,js]],[\"Where\",[Rc]]])});var on,Wc=G(()=>{\"use strict\";Ge();tt();ce();on=class{constructor(t){this.backend=t;this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,n){this.repo.set(t,n)}run(t,n,r,o,a){Ne(t.programInfo.name);let s=this.backend.device,d=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let l=[];for(let f of n)l.push({binding:l.length,resource:{buffer:f.buffer}});for(let f of r)l.push({binding:l.length,resource:{buffer:f.buffer}});a&&l.push({binding:l.length,resource:a});let p=s.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:l,label:t.programInfo.name});if(this.backend.sessionStatus===\"capturing\"){let f={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:p,dispatchGroup:o};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(f)}d.setPipeline(t.computePipeline),d.setBindGroup(0,p),d.dispatchWorkgroups(...o),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType===\"at-passes\")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),Be(t.programInfo.name)}dispose(){}build(t,n){Ne(t.name);let r=this.backend.device,o=[];[{feature:\"shader-f16\",extension:\"f16\"},{feature:\"subgroups\",extension:\"subgroups\"},{feature:\"subgroups-f16\",extension:\"subgroups_f16\"}].forEach(h=>{r.features.has(h.feature)&&o.push(`enable ${h.extension};`)});let s=Fs(n,this.backend.device.limits),d=t.getShaderSource(s),l=`${o.join(`\n`)}\n${s.additionalImplementations}\n${d}`,p=r.createShaderModule({code:l,label:t.name});me(\"verbose\",()=>`[WebGPU] ${t.name} shader code: ${l}`);let f=r.createComputePipeline({compute:{module:p,entryPoint:\"main\"},layout:\"auto\",label:t.name});return Be(t.name),{programInfo:t,computePipeline:f,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(t){let n=typeof t==\"number\"?t:t.x,r=typeof t==\"number\"?1:t.y||1,o=typeof t==\"number\"?1:t.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(n<=a&&r<=a&&o<=a)return[n,r,o];let s=n*r*o,d=Math.ceil(Math.sqrt(s));if(d>a){if(d=Math.ceil(Math.cbrt(s)),d>a)throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");return[d,d,d]}else return[d,d,1]}}});var Qy,Yy,Io,Ao,an,Lc=G(()=>{\"use strict\";Ge();te();tt();Jn();Ws();Vc();Wc();Qy=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let o=e[r].dataType;switch(t[r]){case\"none\":{n.push(\"\");break}case\"type\":{n.push(`${o}`);break}case\"rank\":{let a=e[r].dims.length;n.push(`${o};${a}`);break}case\"dims\":{let a=e[r].dims.join(\",\");n.push(`${o};${a}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join(\"|\")},Yy=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+=\"[\"+e.shaderCache.hint+\"]\"),r+=\":\"+n+`:${Qy(t,e.shaderCache?.inputDependencies??new Array(t.length).fill(\"dims\"))}`,r},Io=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},Ao=class{constructor(t){this.subgroupsSupported=t.features.has(\"subgroups\"),this.subgroupsF16Supported=t.features.has(\"subgroups\");let n=t.limits;!this.subgroupsSupported||!n.minSubgroupSize||!n.maxSubgroupSize?this.subgroupSizeRange=void 0:this.subgroupSizeRange=[n.minSubgroupSize,n.maxSubgroupSize]}},an=class{constructor(){this.currentSessionId=null;this.currentKernelId=null;this.commandEncoder=null;this.computePassEncoder=null;this.maxDispatchNumber=16;this.pendingDispatchNumber=0;this.pendingKernels=[];this.pendingQueries=new Map;this.sessionStatus=\"default\";this.capturedCommandList=new Map;this.capturedPendingKernels=new Map;this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,n){this.env=t;let r=[],o={requiredLimits:{maxComputeWorkgroupStorageSize:n.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize,maxBufferSize:n.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:n.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:n.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:n.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:n.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r},a=s=>n.features.has(s)&&r.push(s)&&!0;a(\"chromium-experimental-timestamp-query-inside-passes\")||a(\"timestamp-query\"),a(\"shader-f16\"),a(\"subgroups\")&&a(\"subgroups-f16\"),this.device=await n.requestDevice(o),this.deviceInfo=new Ao(this.device),this.adapterInfo=new Io(n.info||await n.requestAdapterInfo()),this.gpuDataManager=Vs(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ur(t.logLevel,!!t.debug),this.device.onuncapturederror=s=>{s.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${s.error.message}`)},Object.defineProperty(this.env.webgpu,\"device\",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,\"adapter\",{value:n,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<\"u\"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),n={};this.queryType===\"at-passes\"&&(n.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(n)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ne(),this.endComputePass();let t;this.queryType!==\"none\"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!==\"none\"&&t.mapAsync(GPUMapMode.READ).then(()=>{let n=new BigUint64Array(t.getMappedRange()),r=this.pendingQueries.get(t);for(let o=0;o<n.length/2;o++){let a=r[o],s=a.kernelId,d=this.kernels.get(s),l=d.kernelType,p=d.kernelName,f=a.programName,h=a.inputTensorViews,y=a.outputTensorViews,_=n[o*2],b=n[o*2+1];typeof this.queryTimeBase>\"u\"&&(this.queryTimeBase=_);let w=Number(_-this.queryTimeBase),S=Number(b-this.queryTimeBase);if(!Number.isSafeInteger(w)||!Number.isSafeInteger(S))throw new RangeError(\"incorrect timestamp range\");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:h.map($=>({dims:$.dims,dataType:_t($.dataType)})),outputsMetadata:y.map($=>({dims:$.dims,dataType:_t($.dataType)})),kernelId:s,kernelType:l,kernelName:p,programName:f,startTime:w,endTime:S});else{let $=\"\";h.forEach((T,C)=>{$+=`input[${C}]: [${T.dims}] | ${_t(T.dataType)}, `});let v=\"\";y.forEach((T,C)=>{v+=`output[${C}]: [${T.dims}] | ${_t(T.dataType)}, `}),console.log(`[profiling] kernel \"${s}|${l}|${p}|${f}\" ${$}${v}execution time: ${S-w} ns`)}vr(\"GPU\",`${f}::${_}::${b}`)}t.unmap(),this.pendingQueries.delete(t)}),Be()}run(t,n,r,o,a,s){Ne(t.name);let d=[];for(let T=0;T<n.length;++T){let C=n[T].data;if(C===0)continue;let A=this.gpuDataManager.get(C);if(!A)throw new Error(`no GPU data for input: ${C}`);d.push(A)}let{outputs:l,dispatchGroup:p,programUniforms:f}=t.getRunData(n),h=r.length===0?l.map((T,C)=>C):r;if(h.length!==l.length)throw new Error(`Output size ${h.length} must be equal to ${l.length}.`);let y=[],_=[];for(let T=0;T<l.length;++T){if(!Number.isInteger(h[T])||h[T]<-3||h[T]>=s)throw new Error(`Invalid output index: ${h[T]}`);if(h[T]===-3)continue;let C=h[T]===-1,A=h[T]===-2,k=C||A?a(l[T].dataType,l[T].dims):o(h[T],l[T].dataType,l[T].dims);if(y.push(k),k.data===0)continue;let O=this.gpuDataManager.get(k.data);if(!O)throw new Error(`no GPU data for output: ${k.data}`);if(C&&this.temporaryData.push(O),A){let M=this.kernelPersistentData.get(this.currentKernelId);M||(M=[],this.kernelPersistentData.set(this.currentKernelId,M)),M.push(O)}_.push(O)}if(d.length!==n.length||_.length!==y.length){if(_.length===0)return Be(t.name),y;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let b;if(f){let T=0,C=[];f.forEach(M=>{let V=typeof M.data==\"number\"?[M.data]:M.data;if(V.length===0)return;let F=M.type===10?2:4,j,ne;M.type===10?(ne=V.length>4?16:V.length>2?8:V.length*F,j=V.length>4?16:F*V.length):(ne=V.length<=2?V.length*F:16,j=16),T=Math.ceil(T/ne)*ne,C.push(T);let W=M.type===10?8:4;T+=V.length>4?Math.ceil(V.length/W)*j:V.length*F});let A=16;T=Math.ceil(T/A)*A;let k=new ArrayBuffer(T);f.forEach((M,V)=>{let F=C[V],j=typeof M.data==\"number\"?[M.data]:M.data;if(M.type===6)new Int32Array(k,F,j.length).set(j);else if(M.type===12)new Uint32Array(k,F,j.length).set(j);else if(M.type===10)new Uint16Array(k,F,j.length).set(j);else if(M.type===1)new Float32Array(k,F,j.length).set(j);else throw new Error(`Unsupported uniform type: ${_t(M.type)}`)});let O=this.gpuDataManager.create(T,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(O.buffer,0,k,0,T),this.gpuDataManager.release(O.id),b={offset:0,size:T,buffer:O.buffer}}let w=this.programManager.normalizeDispatchGroupSize(p),S=w[1]===1&&w[2]===1,$=Yy(t,n,S),v=this.programManager.getArtifact($);if(v||(v=this.programManager.build(t,w),this.programManager.setArtifact($,v),me(\"info\",()=>`[artifact] key: ${$}, programName: ${t.name}`)),f&&v.uniformVariablesInfo){if(f.length!==v.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${f.length} in program \"${v.programInfo.name}\".`);for(let T=0;T<f.length;T++){let C=f[T],A=C.type,k=typeof C.data==\"number\"?1:C.data.length,[O,M]=v.uniformVariablesInfo[T];if(A!==O||k!==M)throw new Error(`Uniform variable ${T} mismatch: expect type ${O} with size ${M}, got type ${A} with size ${k} in program \"${v.programInfo.name}\".`)}}if(me(\"info\",()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${w[0]}x${w[1]}x${w[2]}`),this.queryType!==\"none\"||this.sessionStatus===\"capturing\"){let T={kernelId:this.currentKernelId,programName:v.programInfo.name,inputTensorViews:n,outputTensorViews:y};this.pendingKernels.push(T),this.sessionStatus===\"capturing\"&&this.capturedPendingKernels.get(this.currentSessionId).push(T)}return this.programManager.run(v,d,_,w,b),Be(t.name),y}upload(t,n){this.gpuDataManager.upload(t,n)}memcpy(t,n){this.gpuDataManager.memcpy(t,n)}async download(t,n){await this.gpuDataManager.download(t,n)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,n,r,o){let a=Nc.get(t);if(!a)throw new Error(`kernel not implemented: ${t}`);let s={kernelType:t,kernelName:o,kernelEntry:a[0],attributes:[a[1],r]};this.kernels.set(n,s)}releaseKernel(t){let n=this.kernelPersistentData.get(t);if(n){for(let r of n)this.gpuDataManager.release(r.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,n,r){let o=this.kernels.get(t);if(!o)throw new Error(`kernel not created: ${t}`);let a=o.kernelType,s=o.kernelName,d=o.kernelEntry,l=o.attributes;if(this.currentKernelId!==null)throw new Error(`kernel \"[${a}] ${s}\" is not allowed to be called recursively`);this.currentKernelId=t,l[0]&&(l[1]=l[0](l[1]),l[0]=void 0),me(\"info\",()=>`[WebGPU] Start to run kernel \"[${a}] ${s}\"...`);let p=this.env.debug;this.temporaryData=[];try{return p&&this.device.pushErrorScope(\"validation\"),d(n,l[1]),0}catch(f){return r.push(Promise.resolve(`[WebGPU] Kernel \"[${a}] ${s}\" failed. ${f}`)),1}finally{p&&r.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel \"[${a}] ${s}\": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,n,r,o){let a=this.sessionExternalDataMapping.get(t);a||(a=new Map,this.sessionExternalDataMapping.set(t,a));let s=a.get(n),d=this.gpuDataManager.registerExternalBuffer(r,o,s);return a.set(n,[d,r]),d}unregisterBuffers(t){let n=this.sessionExternalDataMapping.get(t);n&&(n.forEach(r=>this.gpuDataManager.unregisterExternalBuffer(r[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let n=this.gpuDataManager.get(t);if(!n)throw new Error(`no GPU data for buffer: ${t}`);return n.buffer}createDownloader(t,n,r){return async()=>{let o=await no(this,t,n);return Nr(o.buffer,r)}}writeTimestamp(t){this.queryType===\"inside-passes\"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){this.queryType=\"none\",(this.env.webgpu.profiling?.mode===\"default\"||(typeof this.env.trace>\"u\"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\")?this.queryType=\"inside-passes\":this.device.features.has(\"timestamp-query\")&&(this.queryType=\"at-passes\"),this.queryType!==\"none\"&&typeof this.querySet>\"u\"&&(this.querySet=this.device.createQuerySet({type:\"timestamp\",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){me(\"info\",\"captureBegin\"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus=\"capturing\"}captureEnd(){me(\"info\",\"captureEnd\"),this.flush(),this.sessionStatus=\"default\"}replay(){me(\"info\",\"replay\"),this.sessionStatus=\"replaying\";let t=this.capturedCommandList.get(this.currentSessionId),n=this.capturedPendingKernels.get(this.currentSessionId),r=t.length;this.pendingKernels=[];for(let o=0;o<r;o++){let a=this.getComputePassEncoder(),s=t[o];this.writeTimestamp(this.pendingDispatchNumber*2),a.setPipeline(s.computePipeline),a.setBindGroup(0,s.bindGroup),a.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!==\"none\"&&this.pendingKernels.push(n[o]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType===\"at-passes\")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus=\"default\"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}});var Xy,Gc,Jy,Hc,sn,un,ko,Fc,qc=G(()=>{\"use strict\";tt();Xy=1,Gc=()=>Xy++,Jy=new Map([[\"float32\",32],[\"float16\",16],[\"int32\",32],[\"uint32\",32],[\"int64\",64],[\"uint64\",64],[\"int8\",8],[\"uint8\",8],[\"int4\",4],[\"uint4\",4]]),Hc=(e,t)=>{let n=Jy.get(e);if(!n)throw new Error(\"Unsupported data type.\");return t.length>0?Math.ceil(t.reduce((r,o)=>r*o)*n/8):0},sn=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Hc(this.dataType,this.tensorShape)}destroy(){me(\"verbose\",()=>\"[WebNN] TensorWrapper.destroy\"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,n,r){return this.mlContext===t&&this.dataType===n&&this.tensorShape.length===r.length&&this.tensorShape.every((o,a)=>o===r[a])}},un=class{constructor(t,n){this.tensorManager=t;this.wrapper=n}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,n,r,o){let a=this.tensorManager.getMLContext(t);if(this.wrapper){if(this.wrapper.canReuseTensor(a,n,r))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==Hc(n,r))throw new Error(\"Unable to copy data to tensor with different size.\");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let s=typeof MLTensorUsage>\"u\"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,n,r,s,!0,!0),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else me(\"verbose\",()=>\"Data size does not match tensor size. Releasing tensor.\"),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error(\"Tensor has not been created.\");return t?this.wrapper.read(t):this.wrapper.read()}},ko=class{constructor(t){this.backend=t;this.tensorTrackersById=new Map;this.freeTensors=[];this.externalTensors=new Set}getMLContext(t){let n=this.backend.getMLContext(t);if(!n)throw new Error(\"MLContext not found for session.\");return n}reserveTensorId(){let t=Gc();return this.tensorTrackersById.set(t,new un(this)),t}releaseTensorId(t){let n=this.tensorTrackersById.get(t);n&&(this.tensorTrackersById.delete(t),n.tensorWrapper&&this.releaseTensor(n.tensorWrapper))}async ensureTensor(t,n,r,o,a){me(\"verbose\",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${n}, dataType: ${r}, shape: ${o}, copyOld: ${a}}`);let s=this.tensorTrackersById.get(n);if(!s)throw new Error(\"Tensor not found.\");return s.ensureTensor(t,r,o,a)}upload(t,n){let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");r.upload(n)}async download(t,n){me(\"verbose\",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${n?.byteLength}}`);let r=this.tensorTrackersById.get(t);if(!r)throw new Error(\"Tensor not found.\");return r.download(n)}releaseTensorsForSession(t){for(let n of this.freeTensors)n.sessionId===t&&n.destroy();this.freeTensors=this.freeTensors.filter(n=>n.sessionId!==t)}registerTensor(t,n,r,o){let a=this.getMLContext(t),s=Gc(),d=new sn({sessionId:t,context:a,tensor:n,dataType:r,shape:o});return this.tensorTrackersById.set(s,new un(this,d)),this.externalTensors.add(d),s}async getCachedTensor(t,n,r,o,a,s){let d=this.getMLContext(t);for(let[p,f]of this.freeTensors.entries())if(f.canReuseTensor(d,n,r)){me(\"verbose\",()=>`[WebNN] Reusing tensor {dataType: ${n}, shape: ${r}}`);let h=this.freeTensors.splice(p,1)[0];return h.sessionId=t,h}me(\"verbose\",()=>`[WebNN] MLContext.createTensor {dataType: ${n}, shape: ${r}}`);let l=await d.createTensor({dataType:n,shape:r,dimensions:r,usage:o,writable:a,readable:s});return new sn({sessionId:t,context:d,tensor:l,dataType:n,shape:r})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},Fc=(...e)=>new ko(...e)});var Eo,eb,dn,Kc=G(()=>{\"use strict\";te();bt();Jn();qc();tt();Eo=new Map([[1,\"float32\"],[10,\"float16\"],[6,\"int32\"],[12,\"uint32\"],[7,\"int64\"],[13,\"uint64\"],[22,\"int4\"],[21,\"uint4\"],[3,\"int8\"],[2,\"uint8\"],[9,\"uint8\"]]),eb=(e,t)=>{if(e===t)return!0;if(e===void 0||t===void 0)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((o,a)=>o===r[a]&&e[o]===t[o])},dn=class{constructor(t){this.tensorManager=Fc(this);this.mlContextBySessionId=new Map;this.sessionIdsByMLContext=new Map;this.mlContextCache=[];this.sessionGraphInputs=new Map;this.temporaryGraphInputs=[];this.temporarySessionTensorIds=new Map;Ur(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error(\"No active session\");return this.activeSessionId}onRunStart(t){me(\"verbose\",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){me(\"verbose\",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let n=this.temporarySessionTensorIds.get(t);if(n){for(let r of n)me(\"verbose\",()=>`[WebNN] releasing temporary tensor {tensorId: ${r}}`),this.tensorManager.releaseTensorId(r);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let r=this.mlContextCache.findIndex(o=>o.gpuDevice===t);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:o}),o}}else if(t===void 0){let r=this.mlContextCache.findIndex(o=>o.options===void 0&&o.gpuDevice===void 0);if(r!==-1)return this.mlContextCache[r].mlContext;{let o=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:o}),o}}let n=this.mlContextCache.findIndex(r=>eb(r.options,t));if(n!==-1)return this.mlContextCache[n].mlContext;{let r=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:r}),r}}registerMLContext(t,n){this.mlContextBySessionId.set(t,n);let r=this.sessionIdsByMLContext.get(n);r||(r=new Set,this.sessionIdsByMLContext.set(n,r)),r.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t);let n=this.mlContextBySessionId.get(t);if(!n)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let r=this.sessionIdsByMLContext.get(n);if(r.delete(t),r.size===0){this.sessionIdsByMLContext.delete(n);let o=this.mlContextCache.findIndex(a=>a.mlContext===n);o!==-1&&this.mlContextCache.splice(o,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){me(\"verbose\",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,n,r,o,a){let s=Eo.get(r);if(!s)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,n,s,o,a)}async createTemporaryTensor(t,n,r){me(\"verbose\",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${n}, shape: ${r}}`);let o=Eo.get(n);if(!o)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,a,o,r,!1);let s=this.temporarySessionTensorIds.get(t);return s?s.push(a):this.temporarySessionTensorIds.set(t,[a]),a}uploadTensor(t,n){if(!Ie().shouldTransferToMLTensor)throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");me(\"verbose\",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${n.byteLength}}`),this.tensorManager.upload(t,n)}async downloadTensor(t,n){return this.tensorManager.download(t,n)}createMLTensorDownloader(t,n){return async()=>{let r=await this.tensorManager.download(t);return Nr(r,n)}}registerMLTensor(t,n,r,o){let a=Eo.get(r);if(!a)throw new Error(`Unsupported ONNX data type: ${r}`);let s=this.tensorManager.registerTensor(t,n,a,o);return me(\"verbose\",()=>`[WebNN] registerMLTensor {tensor: ${n}, dataType: ${a}, dimensions: ${o}} -> {tensorId: ${s}}`),s}registerMLConstant(t,n,r,o,a,s){if(!s)throw new Error(\"External mounted files are not available.\");let d=t;t.startsWith(\"./\")&&(d=t.substring(2));let l=s.get(d);if(!l)throw new Error(`File with name ${d} not found in preloaded files.`);if(n+r>l.byteLength)throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");let p=l.slice(n,n+r).buffer,f;switch(a.dataType){case\"float32\":f=new Float32Array(p);break;case\"float16\":f=new Uint16Array(p);break;case\"int32\":f=new Int32Array(p);break;case\"uint32\":f=new Uint32Array(p);break;case\"int64\":f=new BigInt64Array(p);break;case\"uint64\":f=new BigUint64Array(p);break;case\"int8\":f=new Int8Array(p);break;case\"int4\":case\"uint4\":case\"uint8\":f=new Uint8Array(p);break;default:throw new Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return me(\"verbose\",()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}}`),o.constant(a,f)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}isGraphInput(t,n){let r=this.sessionGraphInputs.get(t);return r?r.includes(n):!1}flush(){}}});var jc={};Zt(jc,{init:()=>tb});var ir,Po,tb,Zc=G(()=>{\"use strict\";te();Lc();tt();ae();Kc();ir=class e{constructor(t,n,r,o){this.module=t;this.dataType=n;this.data=r;this.dims=o}getFloat32Array(){if(this.dataType!==1)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,t)}getBigInt64Array(){if(this.dataType!==7)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,t)}getInt32Array(){if(this.dataType!==6)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,t)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error(\"Invalid data type\");let t=E.size(this.dims);return t===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,t)}reshape(t){if(E.size(t)!==E.size(this.dims))throw new Error(\"Invalid new shape\");return new e(this.module,this.dataType,this.data,t)}},Po=class{constructor(t,n,r){this.module=t;this.backend=n;this.customDataOffset=0;this.customDataSize=0;this.adapterInfo=n.adapterInfo,this.deviceInfo=n.deviceInfo;let o=t.PTR_SIZE,a=r/t.PTR_SIZE,s=o===4?\"i32\":\"i64\";this.opKernelContext=Number(t.getValue(o*a++,s));let d=Number(t.getValue(o*a++,s));this.outputCount=Number(t.getValue(o*a++,s)),this.customDataOffset=Number(t.getValue(o*a++,\"*\")),this.customDataSize=Number(t.getValue(o*a++,s));let l=[];for(let p=0;p<d;p++){let f=Number(t.getValue(o*a++,s)),h=Number(t.getValue(o*a++,\"*\")),y=Number(t.getValue(o*a++,s)),_=[];for(let b=0;b<y;b++)_.push(Number(t.getValue(o*a++,s)));l.push(new ir(t,f,h,_))}this.inputs=l}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,n){let r=n?.inputs?.map(d=>typeof d==\"number\"?this.inputs[d]:d)??this.inputs,o=n?.outputs??[],a=(d,l,p)=>new ir(this.module,l,this.output(d,p),p),s=(d,l)=>{let p=wt(d,l);if(!p)throw new Error(`Unsupported data type: ${d}`);let f=p>0?this.backend.gpuDataManager.create(p).id:0;return new ir(this.module,d,f,l)};return this.backend.run(t,r,o,a,s,this.outputCount)}output(t,n){let r=this.module.stackSave();try{let o=this.module.PTR_SIZE,a=o===4?\"i32\":\"i64\",s=this.module.stackAlloc((1+n.length)*o);this.module.setValue(s,n.length,a);for(let d=0;d<n.length;d++)this.module.setValue(s+o*(d+1),n[d],a);return this.module._JsepOutput(this.opKernelContext,t,s)}catch(o){throw new Error(`Failed to generate kernel's output[${t}] with dims [${n}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`)}finally{this.module.stackRestore(r)}}},tb=async(e,t,n,r)=>{let o=t.jsepInit;if(!o)throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");if(e===\"webgpu\"){let a=new an;await a.initialize(n,r),o(\"webgpu\",[a,s=>a.alloc(Number(s)),s=>a.free(s),(s,d,l,p=!1)=>{if(p)me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(s)}, dst=${Number(d)}, size=${Number(l)}`),a.memcpy(Number(s),Number(d));else{me(\"verbose\",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(s)}, gpuDataId=${Number(d)}, size=${Number(l)}`);let f=t.HEAPU8.subarray(Number(s>>>0),Number(s>>>0)+Number(l));a.upload(Number(d),f)}},async(s,d,l)=>{me(\"verbose\",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${s}, dataOffset=${d}, size=${l}`),await a.download(Number(s),()=>t.HEAPU8.subarray(Number(d)>>>0,Number(d+l)>>>0))},(s,d,l)=>a.createKernel(s,Number(d),l,t.UTF8ToString(t._JsepGetNodeName(Number(d)))),s=>a.releaseKernel(s),(s,d,l,p)=>{me(\"verbose\",()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${s}, contextDataOffset=${d}`);let f=new Po(t,a,Number(d));return a.computeKernel(Number(s),f,p)},()=>a.captureBegin(),()=>a.captureEnd(),()=>a.replay()])}else{let a=new dn(n);o(\"webnn\",[a,()=>a.reserveTensorId(),s=>a.releaseTensorId(s),async(s,d,l,p,f)=>a.ensureTensor(s,d,l,p,f),(s,d)=>{a.uploadTensor(s,d)},async(s,d)=>a.downloadTensor(s,d)])}}});var rb,Cr,Ir,zt,nb,Yt,Ar,kr,Qc,Er,Pr,zr,qn=G(()=>{\"use strict\";zs();Ds();te();bt();Dr();Xn();rb=(e,t)=>{Ie()._OrtInit(e,t)!==0&&he(\"Can't initialize onnxruntime.\")},Cr=async e=>{rb(e.wasm.numThreads,Jt(e.logLevel))},Ir=async(e,t)=>{{let n=(Zc(),br(jc)).init;if(t===\"webgpu\"){if(typeof navigator>\"u\"||!navigator.gpu)throw new Error(\"WebGPU is not supported in current environment\");let r=e.webgpu.adapter;if(r){if(typeof r.limits!=\"object\"||typeof r.features!=\"object\"||typeof r.requestDevice!=\"function\")throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\")}else{let o=e.webgpu.powerPreference;if(o!==void 0&&o!==\"low-power\"&&o!==\"high-performance\")throw new Error(`Invalid powerPreference setting: \"${o}\"`);let a=e.webgpu.forceFallbackAdapter;if(a!==void 0&&typeof a!=\"boolean\")throw new Error(`Invalid forceFallbackAdapter setting: \"${a}\"`);if(r=await navigator.gpu.requestAdapter({powerPreference:o,forceFallbackAdapter:a}),!r)throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.')}await n(\"webgpu\",Ie(),e,r)}if(t===\"webnn\"){if(typeof navigator>\"u\"||!navigator.ml)throw new Error(\"WebNN is not supported in current environment\");await n(\"webnn\",Ie(),e)}}},zt=new Map,nb=e=>{let t=Ie(),n=t.stackSave();try{let r=t.PTR_SIZE,o=t.stackAlloc(2*r);t._OrtGetInputOutputCount(e,o,o+r)!==0&&he(\"Can't get session input/output count.\");let s=r===4?\"i32\":\"i64\";return[Number(t.getValue(o,s)),Number(t.getValue(o+r,s))]}finally{t.stackRestore(n)}},Yt=e=>{let t=Ie(),n=t._malloc(e.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Ar=async(e,t)=>{let n,r,o=Ie();Array.isArray(e)?[n,r]=e:e.buffer===o.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Yt(e);let a=0,s=0,d=0,l=[],p=[],f=[];try{if([s,l]=Os(t),t?.externalData&&o.mountExternalData){let v=[];for(let T of t.externalData){let C=typeof T==\"string\"?T:T.path;v.push(er(typeof T==\"string\"?T:T.data).then(A=>{o.mountExternalData(C,A)}))}await Promise.all(v)}for(let v of t?.executionProviders??[])if((typeof v==\"string\"?v:v.name)===\"webnn\"){if(o.shouldTransferToMLTensor=!1,typeof v!=\"string\"){let C=v,A=C?.context,k=C?.gpuDevice,O=C?.deviceType,M=C?.powerPreference;A?o.currentContext=A:k?o.currentContext=await o.jsepCreateMLContext(k):o.currentContext=await o.jsepCreateMLContext({deviceType:O,powerPreference:M})}else o.currentContext=await o.jsepCreateMLContext();break}a=await o._OrtCreateSession(n,r,s),a===0&&he(\"Can't create a session.\"),o.jsepOnCreateSession?.(),o.currentContext&&(o.jsepRegisterMLContext(a,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[h,y]=nb(a),_=!!t?.enableGraphCapture,b=[],w=[],S=[];for(let v=0;v<h;v++){let T=o._OrtGetInputName(a,v);T===0&&he(\"Can't get an input name.\"),p.push(T),b.push(o.UTF8ToString(T))}for(let v=0;v<y;v++){let T=o._OrtGetOutputName(a,v);T===0&&he(\"Can't get an output name.\"),f.push(T);let C=o.UTF8ToString(T);w.push(C);{if(_&&t?.preferredOutputLocation===void 0){S.push(\"gpu-buffer\");continue}let A=typeof t?.preferredOutputLocation==\"string\"?t.preferredOutputLocation:t?.preferredOutputLocation?.[C]??\"cpu\";if(A!==\"cpu\"&&A!==\"cpu-pinned\"&&A!==\"gpu-buffer\"&&A!==\"ml-tensor\")throw new Error(`Not supported preferred output location: ${A}.`);if(_&&A!==\"gpu-buffer\")throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);S.push(A)}}let $=null;return S.some(v=>v===\"gpu-buffer\"||v===\"ml-tensor\")&&(d=o._OrtCreateBinding(a),d===0&&he(\"Can't create IO binding.\"),$={handle:d,outputPreferredLocations:S,outputPreferredLocationsEncoded:S.map(v=>Yn(v))}),zt.set(a,[a,p,f,$,_,!1]),[a,b,w]}catch(h){throw p.forEach(y=>o._OrtFree(y)),f.forEach(y=>o._OrtFree(y)),d!==0&&o._OrtReleaseBinding(d)!==0&&he(\"Can't release IO binding.\"),a!==0&&o._OrtReleaseSession(a)!==0&&he(\"Can't release session.\"),h}finally{o._free(n),s!==0&&o._OrtReleaseSessionOptions(s)!==0&&he(\"Can't release session options.\"),l.forEach(h=>o._free(h)),o.unmountExternalData?.()}},kr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,o,a,s,d]=n;s&&(d&&t._OrtClearBoundOutputs(s.handle)!==0&&he(\"Can't clear bound outputs.\"),t._OrtReleaseBinding(s.handle)!==0&&he(\"Can't release IO binding.\")),t.jsepOnReleaseSession?.(e),o.forEach(l=>t._OrtFree(l)),a.forEach(l=>t._OrtFree(l)),t._OrtReleaseSession(r)!==0&&he(\"Can't release session.\"),zt.delete(e)},Qc=async(e,t,n,r,o,a=!1)=>{if(!e){t.push(0);return}let s=Ie(),d=s.PTR_SIZE,l=e[0],p=e[1],f=e[3],h=f,y,_;if(l===\"string\"&&(f===\"gpu-buffer\"||f===\"ml-tensor\"))throw new Error(\"String tensor is not supported on GPU.\");if(a&&f!==\"gpu-buffer\")throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if(f===\"gpu-buffer\"){let S=e[2].gpuBuffer;_=wt(Rt(l),p);let $=s.jsepRegisterBuffer;if(!$)throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');y=$(r,o,S,_)}else if(f===\"ml-tensor\"){let S=e[2].mlTensor;_=wt(Rt(l),p);let $=s.jsepRegisterMLTensor;if(!$)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');y=$(r,S,Rt(l),p)}else{let S=e[2];if(Array.isArray(S)){_=d*S.length,y=s._malloc(_),n.push(y);for(let $=0;$<S.length;$++){if(typeof S[$]!=\"string\")throw new TypeError(`tensor data at index ${$} is not a string`);s.setValue(y+$*d,Pe(S[$],n),\"*\")}}else{let $=s.jsepIsGraphInput;if(l!==\"string\"&&$){let v=s._OrtGetInputName(r,o),T=s.UTF8ToString(v);if($(r,T)){let C=Rt(l);_=wt(C,p),h=\"ml-tensor\";let A=s.jsepCreateTemporaryTensor,k=s.jsepUploadTensor;if(!A||!k)throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');let O=await A(r,C,p);k(O,new Uint8Array(S.buffer,S.byteOffset,S.byteLength)),y=O}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}else _=S.byteLength,y=s._malloc(_),n.push(y),s.HEAPU8.set(new Uint8Array(S.buffer,S.byteOffset,_),y)}}let b=s.stackSave(),w=s.stackAlloc(4*p.length);try{p.forEach(($,v)=>s.setValue(w+v*d,$,d===4?\"i32\":\"i64\"));let S=s._OrtCreateTensor(Rt(l),y,_,w,p.length,Yn(h));S===0&&he(`Can't create tensor for input/output. session=${r}, index=${o}.`),t.push(S)}finally{s.stackRestore(b)}},Er=async(e,t,n,r,o,a)=>{let s=Ie(),d=s.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],f=l[1],h=l[2],y=l[3],_=l[4],b=l[5],w=t.length,S=r.length,$=0,v=[],T=[],C=[],A=[],k=s.stackSave(),O=s.stackAlloc(w*d),M=s.stackAlloc(w*d),V=s.stackAlloc(S*d),F=s.stackAlloc(S*d);try{[$,v]=Ps(a);for(let W=0;W<w;W++)await Qc(n[W],T,A,e,t[W],_);for(let W=0;W<S;W++)await Qc(o[W],C,A,e,w+r[W],_);for(let W=0;W<w;W++)s.setValue(O+W*d,T[W],\"*\"),s.setValue(M+W*d,f[t[W]],\"*\");for(let W=0;W<S;W++)s.setValue(V+W*d,C[W],\"*\"),s.setValue(F+W*d,h[r[W]],\"*\");if(y&&!b){let{handle:W,outputPreferredLocations:J,outputPreferredLocationsEncoded:ve}=y;if(f.length!==w)throw new Error(`input count from feeds (${w}) is expected to be always equal to model's input count (${f.length}).`);for(let Q=0;Q<w;Q++){let ee=t[Q];await s._OrtBindInput(W,f[ee],T[Q])!==0&&he(`Can't bind input[${Q}] for session=${e}.`)}for(let Q=0;Q<S;Q++){let ee=r[Q];o[Q]?.[3]?s._OrtBindOutput(W,h[ee],C[Q],0)!==0&&he(`Can't bind pre-allocated output[${Q}] for session=${e}.`):s._OrtBindOutput(W,h[ee],0,ve[ee])!==0&&he(`Can't bind output[${Q}] to ${J[Q]} for session=${e}.`)}zt.set(e,[p,f,h,y,_,!0])}s.jsepOnRunStart?.(p);let j;y?j=await s._OrtRunWithBinding(p,y.handle,S,V,$):j=await s._OrtRun(p,M,O,w,F,S,V,$),j!==0&&he(\"failed to call OrtRun().\");let ne=[];for(let W=0;W<S;W++){let J=Number(s.getValue(V+W*d,\"*\"));if(J===C[W]){ne.push(o[W]);continue}let ve=s.stackSave(),Q=s.stackAlloc(4*d),ee=!1,le,Z=0;try{s._OrtGetTensorData(J,Q,Q+d,Q+2*d,Q+3*d)!==0&&he(`Can't access output tensor data on index ${W}.`);let ke=d===4?\"i32\":\"i64\",Se=Number(s.getValue(Q,ke));Z=s.getValue(Q+d,\"*\");let D=s.getValue(Q+d*2,\"*\"),R=Number(s.getValue(Q+d*3,ke)),Y=[];for(let xe=0;xe<R;xe++)Y.push(Number(s.getValue(D+xe*d,ke)));s._OrtFree(D)!==0&&he(\"Can't free memory for tensor dims.\");let fe=Y.reduce((xe,be)=>xe*be,1);le=_t(Se);let Fe=y?.outputPreferredLocations[r[W]];if(le===\"string\"){if(Fe===\"gpu-buffer\"||Fe===\"ml-tensor\")throw new Error(\"String tensor is not supported on GPU.\");let xe=[];for(let be=0;be<fe;be++){let Ye=s.getValue(Z+be*d,\"*\"),Gt=s.getValue(Z+(be+1)*d,\"*\"),xt=be===fe-1?void 0:Gt-Ye;xe.push(s.UTF8ToString(Ye,xt))}ne.push([le,Y,xe,\"cpu\"])}else if(Fe===\"gpu-buffer\"&&fe>0){let xe=s.jsepGetBuffer;if(!xe)throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');let be=xe(Z),Ye=wt(Se,fe);if(Ye===void 0||!Mr(le))throw new Error(`Unsupported data type: ${le}`);ee=!0,ne.push([le,Y,{gpuBuffer:be,download:s.jsepCreateDownloader(be,Ye,le),dispose:()=>{s._OrtReleaseTensor(J)!==0&&he(\"Can't release tensor.\")}},\"gpu-buffer\"])}else if(Fe===\"ml-tensor\"&&fe>0){let xe=s.jsepEnsureTensor;if(!xe)throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');if(wt(Se,fe)===void 0||!Rr(le))throw new Error(`Unsupported data type: ${le}`);let Ye=await xe(e,Z,Se,Y,!1);ee=!0,ne.push([le,Y,{mlTensor:Ye,download:s.jsepCreateMLTensorDownloader(Z,le),dispose:()=>{s.jsepReleaseTensorId(Z),s._OrtReleaseTensor(J)}},\"ml-tensor\"])}else{let xe=Br(le),be=new xe(fe);new Uint8Array(be.buffer,be.byteOffset,be.byteLength).set(s.HEAPU8.subarray(Z,Z+be.byteLength)),ne.push([le,Y,be,\"cpu\"])}}finally{s.stackRestore(ve),le===\"string\"&&Z&&s._free(Z),ee||s._OrtReleaseTensor(J),s.jsepOnRunEnd?.(p)}}return y&&!_&&(s._OrtClearBoundOutputs(y.handle)!==0&&he(\"Can't clear bound outputs.\"),zt.set(e,[p,f,h,y,_,!1])),ne}finally{s.stackRestore(k),T.forEach(j=>s._OrtReleaseTensor(j)),C.forEach(j=>s._OrtReleaseTensor(j)),A.forEach(j=>s._free(j)),$!==0&&s._OrtReleaseRunOptions($),v.forEach(j=>s._free(j))}},Pr=e=>{let t=Ie(),n=zt.get(e);if(!n)throw new Error(\"invalid session id\");let r=n[0],o=t._OrtEndProfiling(r);o===0&&he(\"Can't get an profile file name.\"),t._OrtFree(o)},zr=e=>{let t=[];for(let n of e){let r=n[2];!Array.isArray(r)&&\"buffer\"in r&&t.push(r.buffer)}return t}});var Ot,He,ar,cn,pn,ln,zo,Oo,Wt,Lt,ib,Yc,Xc,Jc,ep,tp,rp,np,Do=G(()=>{\"use strict\";Ge();qn();bt();Sr();Ot=()=>!!we.wasm.proxy&&typeof document<\"u\",ar=!1,cn=!1,pn=!1,Oo=new Map,Wt=(e,t)=>{let n=Oo.get(e);n?n.push(t):Oo.set(e,[t])},Lt=()=>{if(ar||!cn||pn||!He)throw new Error(\"worker not ready\")},ib=e=>{switch(e.data.type){case\"init-wasm\":ar=!1,e.data.err?(pn=!0,zo[1](e.data.err)):(cn=!0,zo[0]()),ln&&(URL.revokeObjectURL(ln),ln=void 0);break;case\"init-ep\":case\"copy-from\":case\"create\":case\"release\":case\"run\":case\"end-profiling\":{let t=Oo.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}default:}},Yc=async()=>{if(!cn){if(ar)throw new Error(\"multiple calls to 'initWasm()' detected.\");if(pn)throw new Error(\"previous call to 'initWasm()' failed.\");if(ar=!0,Ot())return new Promise((e,t)=>{He?.terminate(),As().then(([n,r])=>{try{He=r,He.onerror=a=>t(a),He.onmessage=ib,zo=[e,t];let o={type:\"init-wasm\",in:we};!o.in.wasm.wasmPaths&&(n||\"file:///Users/soham/modul/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\"))&&(o.in.wasm.wasmPaths={wasm:/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href}),He.postMessage(o),ln=n}catch(o){t(o)}},t)});try{await Tr(we.wasm),await Cr(we),cn=!0}catch(e){throw pn=!0,e}finally{ar=!1}}},Xc=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"init-ep\",[t,n]);let r={type:\"init-ep\",in:{epName:e,env:we}};He.postMessage(r)});await Ir(we,e)},Jc=async e=>Ot()?(Lt(),new Promise((t,n)=>{Wt(\"copy-from\",[t,n]);let r={type:\"copy-from\",in:{buffer:e}};He.postMessage(r,[e.buffer])})):Yt(e),ep=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');return Lt(),new Promise((n,r)=>{Wt(\"create\",[n,r]);let o={type:\"create\",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),He.postMessage(o,a)})}else return Ar(e,t)},tp=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"release\",[t,n]);let r={type:\"release\",in:e};He.postMessage(r)});kr(e)},rp=async(e,t,n,r,o,a)=>{if(Ot()){if(n.some(s=>s[3]!==\"cpu\"))throw new Error(\"input tensor on GPU is not supported for proxy.\");if(o.some(s=>s))throw new Error(\"pre-allocated output tensor is not supported for proxy.\");return Lt(),new Promise((s,d)=>{Wt(\"run\",[s,d]);let l=n,p={type:\"run\",in:{sessionId:e,inputIndices:t,inputs:l,outputIndices:r,options:a}};He.postMessage(p,zr(l))})}else return Er(e,t,n,r,o,a)},np=async e=>{if(Ot())return Lt(),new Promise((t,n)=>{Wt(\"end-profiling\",[t,n]);let r={type:\"end-profiling\",in:e};He.postMessage(r)});Pr(e)}});var op,ab,mn,ip=G(()=>{\"use strict\";Ge();Do();te();xr();Xn();op=(e,t)=>{switch(e.location){case\"cpu\":return[e.type,e.dims,e.data,\"cpu\"];case\"gpu-buffer\":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},\"gpu-buffer\"];case\"ml-tensor\":return[e.type,e.dims,{mlTensor:e.mlTensor},\"ml-tensor\"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ab=e=>{switch(e[3]){case\"cpu\":return new qe(e[0],e[2],e[1]);case\"gpu-buffer\":{let t=e[0];if(!Mr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:o}=e[2];return qe.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:o})}case\"ml-tensor\":{let t=e[0];if(!Rr(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:o}=e[2];return qe.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:o})}default:throw new Error(`invalid data location: ${e[3]}`)}},mn=class{async fetchModelAndCopyToWasmMemory(t){return Jc(await er(t))}async loadModel(t,n){Ne();let r;typeof t==\"string\"?r=await this.fetchModelAndCopyToWasmMemory(t):r=t,[this.sessionId,this.inputNames,this.outputNames]=await ep(r,n),Be()}async dispose(){return tp(this.sessionId)}async run(t,n,r){Ne();let o=[],a=[];Object.entries(t).forEach(y=>{let _=y[0],b=y[1],w=this.inputNames.indexOf(_);if(w===-1)throw new Error(`invalid input '${_}'`);o.push(b),a.push(w)});let s=[],d=[];Object.entries(n).forEach(y=>{let _=y[0],b=y[1],w=this.outputNames.indexOf(_);if(w===-1)throw new Error(`invalid output '${_}'`);s.push(b),d.push(w)});let l=o.map((y,_)=>op(y,()=>`input \"${this.inputNames[a[_]]}\"`)),p=s.map((y,_)=>y?op(y,()=>`output \"${this.outputNames[d[_]]}\"`):null),f=await rp(this.sessionId,a,l,d,p,r),h={};for(let y=0;y<f.length;y++)h[this.outputNames[d[y]]]=s[y]??ab(f[y]);return Be(),h}startProfiling(){}endProfiling(){np(this.sessionId)}}});var sp={};Zt(sp,{OnnxruntimeWebAssemblyBackend:()=>fn,initializeFlags:()=>ap,wasmBackend:()=>sb});var ap,fn,sb,up=G(()=>{\"use strict\";Ge();Do();ip();ap=()=>{if((typeof we.wasm.initTimeout!=\"number\"||we.wasm.initTimeout<0)&&(we.wasm.initTimeout=0),we.wasm.simd===!1&&console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof we.wasm.proxy!=\"boolean\"&&(we.wasm.proxy=!1),typeof we.wasm.trace!=\"boolean\"&&(we.wasm.trace=!1),typeof we.wasm.numThreads!=\"number\"||!Number.isInteger(we.wasm.numThreads)||we.wasm.numThreads<=0)if(typeof self<\"u\"&&!self.crossOriginIsolated)we.wasm.numThreads=1;else{let e=typeof navigator>\"u\"?Nn(\"node:os\").cpus().length:navigator.hardwareConcurrency;we.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},fn=class{async init(t){ap(),await Yc(),await Xc(t)}async createInferenceSessionHandler(t,n){let r=new mn;return await r.loadModel(t,n),Promise.resolve(r)}},sb=new fn});Ge();Ge();Ge();var hs=\"1.21.0\";var lT=Fn;{let e=(up(),br(sp)).wasmBackend;Ct(\"webgpu\",e,5),Ct(\"webnn\",e,5),Ct(\"cpu\",e,10),Ct(\"wasm\",e,10)}Object.defineProperty(we.versions,\"web\",{value:hs,enumerable:!0});\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n//# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzPzE2NGEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QyxrQ0FBa0MsdUNBQXVDLG9FQUFvRSw2Q0FBNkMsaUJBQWlCLDJEQUEyRCwyREFBMkQsRUFBRSxtQ0FBbUMsZUFBZSx1QkFBdUIsdUJBQXVCLEVBQUUsZ0JBQWdCLGdHQUFnRyxtREFBbUQsRUFBRSxVQUFVLGtCQUFrQixlQUFlLFNBQVMsS0FBSyw2QkFBNkIsYUFBYSw4QkFBOEIscUZBQXFGLGdCQUFnQix3QkFBd0IscUJBQXFCLEVBQUUsS0FBSyx1QkFBdUIsNkVBQTZFLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxTQUFTLG9CQUFvQix1QkFBdUIsWUFBWSxZQUFZLGtDQUFrQyxpQkFBaUIsT0FBTyxXQUFXLE9BQU8sMkNBQTJDLGNBQWMsZ0JBQWdCLGlDQUFpQyxrQ0FBa0MsNkJBQTZCLHNCQUFzQixJQUFJLDJGQUEyRixTQUFTLHNCQUFzQixFQUFFLHdCQUF3QixRQUFRLHVCQUF1QixjQUFjLDRHQUE0RyxnQkFBZ0Isa0JBQWtCLDJCQUEyQixhQUFhLDZCQUE2QiwwREFBMEQsYUFBYSxPQUFPLElBQUksTUFBTSxjQUFjLEdBQUcsUUFBUSxhQUFhLDJFQUEyRSxFQUFFLHNEQUFzRCxFQUFFLEdBQUcsc0RBQXNELHNCQUFzQix1REFBdUQsSUFBSSxFQUFFLGNBQWMsYUFBYSxLQUFLLEVBQUUsaUJBQWlCLGFBQWEsWUFBWSxFQUFFLG9CQUFvQixhQUFhLEtBQUssaUJBQWlCLE9BQU8sU0FBUyxVQUFVLFdBQVcsVUFBVSxpQkFBaUIsZUFBZSxrSUFBa0ksRUFBRSxHQUFHLE1BQU0sZ0JBQWdCLFlBQVkscUNBQXFDLGNBQWMsRUFBRSxFQUFFLGlCQUFpQixhQUFhLEtBQUssTUFBTSxFQUFFLG9C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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3NvaGFtL21vZHVsL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMS4wXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIFVuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgQWY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIga2Y9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIEVmPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIE5uPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LG4pPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtuXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgRz0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBadD0oZSx0KT0+e2Zvcih2YXIgbiBpbiB0KVVuKGUsbix7Z2V0OnRbbl0sZW51bWVyYWJsZTohMH0pfSxQZj0oZSx0LG4scik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2Yga2YodCkpIUVmLmNhbGwoZSxvKSYmbyE9PW4mJlVuKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShyPUFmKHQsbykpfHxyLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGJyPWU9PlBmKFVuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciBfcixUdCxDdCx6ZixXYSxWbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3I9bmV3IE1hcCxUdD1bXSxDdD0oZSx0LG4pPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgcj1fci5nZXQoZSk7aWYocj09PXZvaWQgMClfci5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5Om59KTtlbHNle2lmKHIucHJpb3JpdHk+bilyZXR1cm47aWYoci5wcmlvcml0eT09PW4mJnIuYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke259YCl9aWYobj49MCl7bGV0IG89VHQuaW5kZXhPZihlKTtvIT09LTEmJlR0LnNwbGljZShvLDEpO2ZvcihsZXQgYT0wO2E8VHQubGVuZ3RoO2ErKylpZihfci5nZXQoVHRbYV0pLnByaW9yaXR5PD1uKXtUdC5zcGxpY2UoYSwwLGUpO3JldHVybn1UdC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0semY9YXN5bmMgZT0+e2xldCB0PV9yLmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCBuPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIG58fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKHIpe3JldHVybiBufHwodC5lcnJvcj1gJHtyfWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0sV2E9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxuPXQubWFwKGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiP2w6bC5uYW1lKSxyPW4ubGVuZ3RoPT09MD9UdDpuLG8sYT1bXSxzPW5ldyBTZXQ7Zm9yKGxldCBsIG9mIHIpe2xldCBwPWF3YWl0IHpmKGwpO3R5cGVvZiBwPT1cInN0cmluZ1wiP2EucHVzaCh7bmFtZTpsLGVycjpwfSk6KG98fChvPXApLG89PT1wJiZzLmFkZChsKSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2EubWFwKGw9PmBbJHtsLm5hbWV9XSAke2wuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6bCxlcnI6cH1vZiBhKW4uaW5jbHVkZXMobCkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bH1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7cH1gKTtsZXQgZD10LmZpbHRlcihsPT5zLmhhcyh0eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KGwscCk9PnA9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2Q6UmVmbGVjdC5nZXQobCxwKX0pXX19KTt2YXIgTGE9RygoKT0+e1widXNlIHN0cmljdFwiO1ZuKCl9KTt2YXIgR2EsSGE9RygoKT0+e1widXNlIHN0cmljdFwiO0dhPVwiMS4yMS4wXCJ9KTt2YXIgRmEsVWUsV249RygoKT0+e1widXNlIHN0cmljdFwiO0hhKCk7RmE9XCJ3YXJuaW5nXCIsVWU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246R2F9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtGYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIEZhfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFVlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIHdlLHFhPUcoKCk9PntcInVzZSBzdHJpY3RcIjtXbigpO3dlPVVlfSk7dmFyIEthLGphLFphPUcoKCk9PntcInVzZSBzdHJpY3RcIjtLYT0oZSx0KT0+e2xldCBuPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtuLndpZHRoPWUuZGltc1szXSxuLmhlaWdodD1lLmRpbXNbMl07bGV0IHI9bi5nZXRDb250ZXh0KFwiMmRcIik7aWYociE9bnVsbCl7bGV0IG8sYTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGE9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10sYT1lLmRpbXNbMl0pO2xldCBzPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGQ9dD8ubm9ybSxsLHA7ZD09PXZvaWQgMHx8ZC5tZWFuPT09dm9pZCAwP2w9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGQubWVhbj09XCJudW1iZXJcIj9sPVtkLm1lYW4sZC5tZWFuLGQubWVhbixkLm1lYW5dOihsPVtkLm1lYW5bMF0sZC5tZWFuWzFdLGQubWVhblsyXSwwXSxkLm1lYW5bM10hPT12b2lkIDAmJihsWzNdPWQubWVhblszXSkpLGQ9PT12b2lkIDB8fGQuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgZC5iaWFzPT1cIm51bWJlclwiP3A9W2QuYmlhcyxkLmJpYXMsZC5iaWFzLGQuYmlhc106KHA9W2QuYmlhc1swXSxkLmJpYXNbMV0sZC5iaWFzWzJdLDBdLGQuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109ZC5iaWFzWzNdKSk7bGV0IGY9YSpvLGg9MCx5PWYsXz1mKjIsYj0tMTtzPT09XCJSR0JBXCI/KGg9MCx5PWYsXz1mKjIsYj1mKjMpOnM9PT1cIlJHQlwiPyhoPTAseT1mLF89ZioyKTpzPT09XCJSQkdcIiYmKGg9MCxfPWYseT1mKjIpO2ZvcihsZXQgdz0wO3c8YTt3KyspZm9yKGxldCBTPTA7UzxvO1MrKyl7bGV0ICQ9KGUuZGF0YVtoKytdLXBbMF0pKmxbMF0sdj0oZS5kYXRhW3krK10tcFsxXSkqbFsxXSxUPShlLmRhdGFbXysrXS1wWzJdKSpsWzJdLEM9Yj09PS0xPzI1NTooZS5kYXRhW2IrK10tcFszXSkqbFszXTtyLmZpbGxTdHlsZT1cInJnYmEoXCIrJCtcIixcIit2K1wiLFwiK1QrXCIsXCIrQytcIilcIixyLmZpbGxSZWN0KFMsdywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiBuKXJldHVybiBuLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0samE9KGUsdCk9PntsZXQgbj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxyO2lmKG4hPW51bGwpe2xldCBvLGEsczt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGE9ZS5kaW1zWzFdLHM9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10sYT1lLmRpbXNbMl0scz1lLmRpbXNbMV0pO2xldCBkPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLHAsZjtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP3A9W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KHA9W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDI1NV0sbC5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/Zj1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9mPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihmPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihmWzNdPWwuYmlhc1szXSkpO2xldCBoPWEqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJnM9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxzPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgeT00LF89MCxiPTEsdz0yLFM9MywkPTAsdj1oLFQ9aCoyLEM9LTE7ZD09PVwiUkdCQVwiPygkPTAsdj1oLFQ9aCoyLEM9aCozKTpkPT09XCJSR0JcIj8oJD0wLHY9aCxUPWgqMik6ZD09PVwiUkJHXCImJigkPTAsVD1oLHY9aCoyKSxyPW4uY3JlYXRlSW1hZ2VEYXRhKG8sYSk7Zm9yKGxldCBBPTA7QTxhKm87Xys9eSxiKz15LHcrPXksUys9eSxBKyspci5kYXRhW19dPShlLmRhdGFbJCsrXS1mWzBdKSpwWzBdLHIuZGF0YVtiXT0oZS5kYXRhW3YrK10tZlsxXSkqcFsxXSxyLmRhdGFbd109KGUuZGF0YVtUKytdLWZbMl0pKnBbMl0sci5kYXRhW1NdPUM9PT0tMT8yNTU6KGUuZGF0YVtDKytdLWZbM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiByfX0pO3ZhciBMbixRYSxZYSxYYSxKYSxlcyx0cz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d3IoKTtMbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0Om4sd2lkdGg6cn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0sYSxzO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/YT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTphPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9zPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOnM9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGQ9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbD10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPW4qcixmPWw9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLGg9NCx5PTAsXz0xLGI9Mix3PTMsUz0wLCQ9cCx2PXAqMixUPS0xO2Q9PT1cIlJHQlwiJiYoaD0zLHk9MCxfPTEsYj0yLHc9LTEpLGw9PT1cIlJHQkFcIj9UPXAqMzpsPT09XCJSQkdcIj8oUz0wLHY9cCwkPXAqMik6bD09PVwiQkdSXCImJih2PTAsJD1wLFM9cCoyKTtmb3IobGV0IEE9MDtBPHA7QSsrLHkrPWgsYis9aCxfKz1oLHcrPWgpZltTKytdPShlW3ldK3NbMF0pL2FbMF0sZlskKytdPShlW19dK3NbMV0pL2FbMV0sZlt2KytdPShlW2JdK3NbMl0pL2FbMl0sVCE9PS0xJiZ3IT09LTEmJihmW1QrK109KGVbd10rc1szXSkvYVszXSk7cmV0dXJuIGw9PT1cIlJHQkFcIj9uZXcgRGUoXCJmbG9hdDMyXCIsZixbMSw0LG4scl0pOm5ldyBEZShcImZsb2F0MzJcIixmLFsxLDMsbixyXSl9LFFhPWFzeW5jKGUsdCk9PntsZXQgbj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQscj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsYT10eXBlb2YgZT09XCJzdHJpbmdcIixzLGQ9dD8/e30sbD0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHA9Zj0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZmIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fGYgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/Zi5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihuKXtsZXQgZj1sKCk7Zi53aWR0aD1lLndpZHRoLGYuaGVpZ2h0PWUuaGVpZ2h0O2xldCBoPXAoZik7aWYoaCE9bnVsbCl7bGV0IHk9ZS5oZWlnaHQsXz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJih5PXQucmVzaXplZEhlaWdodCxfPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihkPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7ZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9eSxkLndpZHRoPV99ZWxzZSBkLnRlbnNvckZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD15LGQud2lkdGg9XztoLmRyYXdJbWFnZShlLDAsMCkscz1oLmdldEltYWdlRGF0YSgwLDAsXyx5KS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKHIpe2xldCBmLGg7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8oZj10LnJlc2l6ZWRIZWlnaHQsaD10LnJlc2l6ZWRXaWR0aCk6KGY9ZS5oZWlnaHQsaD1lLndpZHRoKSx0IT09dm9pZCAwJiYoZD10KSxkLmZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1mLGQud2lkdGg9aCx0IT09dm9pZCAwKXtsZXQgeT1sKCk7eS53aWR0aD1oLHkuaGVpZ2h0PWY7bGV0IF89cCh5KTtpZihfIT1udWxsKV8ucHV0SW1hZ2VEYXRhKGUsMCwwKSxzPV8uZ2V0SW1hZ2VEYXRhKDAsMCxoLGYpLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2Ugcz1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IGY9bCgpO2Yud2lkdGg9ZS53aWR0aCxmLmhlaWdodD1lLmhlaWdodDtsZXQgaD1wKGYpO2lmKGghPW51bGwpe2xldCB5PWUuaGVpZ2h0LF89ZS53aWR0aDtyZXR1cm4gaC5kcmF3SW1hZ2UoZSwwLDAsXyx5KSxzPWguZ2V0SW1hZ2VEYXRhKDAsMCxfLHkpLmRhdGEsZC5oZWlnaHQ9eSxkLndpZHRoPV8sTG4ocyxkKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihhKXJldHVybiBuZXcgUHJvbWlzZSgoZixoKT0+e2xldCB5PWwoKSxfPXAoeSk7aWYoIWV8fCFfKXJldHVybiBoKCk7bGV0IGI9bmV3IEltYWdlO2IuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIixiLnNyYz1lLGIub25sb2FkPSgpPT57eS53aWR0aD1iLndpZHRoLHkuaGVpZ2h0PWIuaGVpZ2h0LF8uZHJhd0ltYWdlKGIsMCwwLHkud2lkdGgseS5oZWlnaHQpO2xldCB3PV8uZ2V0SW1hZ2VEYXRhKDAsMCx5LndpZHRoLHkuaGVpZ2h0KTtkLmhlaWdodD15LmhlaWdodCxkLndpZHRoPXkud2lkdGgsZihMbih3LmRhdGEsZCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKHMhPT12b2lkIDApcmV0dXJuIExuKHMsZCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LFlhPShlLHQpPT57bGV0e3dpZHRoOm4saGVpZ2h0OnIsZG93bmxvYWQ6byxkaXNwb3NlOmF9PXQscz1bMSxyLG4sNF07cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczpzLGRvd25sb2FkOm8sZGlzcG9zZTphfSl9LFhhPShlLHQpPT57bGV0e2RhdGFUeXBlOm4sZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTphfT10O3JldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6bj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTphfSl9LEphPShlLHQpPT57bGV0e2RhdGFUeXBlOm4sZGltczpyLGRvd25sb2FkOm8sZGlzcG9zZTphfT10O3JldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpuPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6cixkb3dubG9hZDpvLGRpc3Bvc2U6YX0pfSxlcz0oZSx0LG4pPT5uZXcgRGUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpuPz9bdC5sZW5ndGhdfSl9KTt2YXIgSXQsUXQscnMsbnMsb3M9RygoKT0+e1widXNlIHN0cmljdFwiO0l0PW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSksUXQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLHJzPSExLG5zPSgpPT57aWYoIXJzKXtycz0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLG49Z2xvYmFsVGhpcy5GbG9hdDE2QXJyYXkscj10eXBlb2YgbjxcInVcIiYmbi5mcm9tO2UmJihJdC5zZXQoXCJpbnQ2NFwiLEJpZ0ludDY0QXJyYXkpLFF0LnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihJdC5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSksUXQuc2V0KEJpZ1VpbnQ2NEFycmF5LFwidWludDY0XCIpKSxyPyhJdC5zZXQoXCJmbG9hdDE2XCIsbiksUXQuc2V0KG4sXCJmbG9hdDE2XCIpKTpJdC5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgaXMsYXMsc3M9RygoKT0+e1widXNlIHN0cmljdFwiO3dyKCk7aXM9ZT0+e2xldCB0PTE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspe2xldCByPWVbbl07aWYodHlwZW9mIHIhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihyKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke3J9YCk7aWYocjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7bn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke3J9YCk7dCo9cn1yZXR1cm4gdH0sYXM9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBEZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyBEZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgRGUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IERlKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIERlLHdyPUcoKCk9PntcInVzZSBzdHJpY3RcIjtaYSgpO3RzKCk7b3MoKTtzcygpO0RlPWNsYXNze2NvbnN0cnVjdG9yKHQsbixyKXtucygpO2xldCBvLGE7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsYT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgZD1JdC5nZXQobyk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgZCxsO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCxsPXIsdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KG4pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2Q9bn1lbHNle2xldCBwPUl0LmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkobikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmcD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7cC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2Q9cC5mcm9tKG4sQmlnSW50KTpkPXAuZnJvbShuKX1lbHNlIGlmKG4gaW5zdGFuY2VvZiBwKWQ9bjtlbHNlIGlmKG4gaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWQ9VWludDhBcnJheS5mcm9tKG4pO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSBpZih0PT09XCJmbG9hdDE2XCImJm4gaW5zdGFuY2VvZiBVaW50MTZBcnJheSYmcCE9PVVpbnQxNkFycmF5KWQ9bmV3IGdsb2JhbFRoaXMuRmxvYXQxNkFycmF5KG4uYnVmZmVyLG4uYnl0ZU9mZnNldCxuLmxlbmd0aCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobD1uLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixkPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixkPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgcD1RdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPXAsZD10fWlmKGw9PT12b2lkIDApbD1bZC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2E9bCx0aGlzLmNwdURhdGE9ZCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBzPWlzKGEpO2lmKHRoaXMuY3B1RGF0YSYmcyE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChzLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7c30pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1hLHRoaXMuc2l6ZT1zfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxuKXtyZXR1cm4gUWEodCxuKX1zdGF0aWMgZnJvbVRleHR1cmUodCxuKXtyZXR1cm4gWWEodCxuKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LG4pe3JldHVybiBYYSh0LG4pfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxuKXtyZXR1cm4gSmEodCxuKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LG4scil7cmV0dXJuIGVzKHQsbixyKX10b0RhdGFVUkwodCl7cmV0dXJuIEthKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIGphKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IG49YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9bix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxufWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIGFzKHRoaXMsdCl9fX0pO3ZhciBxZSxHbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d3IoKTtxZT1EZX0pO3ZhciB2cix1cyxOZSxCZSxIbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt2cj0oZSx0KT0+eyh0eXBlb2YgVWUudHJhY2U+XCJ1XCI/IVVlLndhc20udHJhY2U6IVVlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSx1cz0oZSx0KT0+e2xldCBuPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLHI9ITE7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aDtvKyspe2lmKHImJiFuW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGE9YEZVTkNfJHtlfTo6JHtuW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoYSs9YDo6JHt0fWApLHZyKFwiQ1BVXCIsYSk7cmV0dXJufW5bb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYocj0hMCl9fSxOZT1lPT57KHR5cGVvZiBVZS50cmFjZT5cInVcIj8hVWUud2FzbS50cmFjZTohVWUudHJhY2UpfHx1cyhcIkJFR0lOXCIsZSl9LEJlPWU9PnsodHlwZW9mIFVlLnRyYWNlPlwidVwiPyFVZS53YXNtLnRyYWNlOiFVZS50cmFjZSl8fHVzKFwiRU5EXCIsZSl9fSk7dmFyICRyLGRzPUcoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpO0duKCk7SG4oKTskcj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LG4scil7TmUoKTtsZXQgbz17fSxhPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIHFlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IHM9ITA7aWYodHlwZW9mIG49PVwib2JqZWN0XCIpe2lmKG49PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYobiBpbnN0YW5jZW9mIHFlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkobikpe2lmKG4ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7cz0hMTtmb3IobGV0IHAgb2Ygbil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO29bcF09bnVsbH1pZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG4pO2ZvcihsZXQgaCBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKGYuaW5kZXhPZihoKSE9PS0xKXtsZXQgeT1uW2hdOyh5PT09bnVsbHx8eSBpbnN0YW5jZW9mIHFlKSYmKHA9ITAscz0hMSxvW2hdPXkpfWlmKHApe2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGE9bn19ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihzKWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW9bcF09bnVsbDtsZXQgZD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbyxhKSxsPXt9O2ZvcihsZXQgcCBpbiBkKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQscCkpe2xldCBmPWRbcF07ZiBpbnN0YW5jZW9mIHFlP2xbcF09ZjpsW3BdPW5ldyBxZShmLnR5cGUsZi5kYXRhLGYuZGltcyl9cmV0dXJuIEJlKCksbH1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LG4scixvKXtOZSgpO2xldCBhLHM9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGE9dCx0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpcz1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoYT10LHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClzPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBmPXQsaD0wLHk9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClzPW47ZWxzZSBpZih0eXBlb2Ygbj09XCJudW1iZXJcIil7aWYoaD1uLCFOdW1iZXIuaXNTYWZlSW50ZWdlcihoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKGg8MHx8aD49Zi5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke2YuYnl0ZUxlbmd0aH0pLmApO2lmKHk9dC5ieXRlTGVuZ3RoLWgsdHlwZW9mIHI9PVwibnVtYmVyXCIpe2lmKHk9ciwhTnVtYmVyLmlzU2FmZUludGVnZXIoeSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZih5PD0wfHxoK3k+Zi5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke2YuYnl0ZUxlbmd0aC1ofV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKXM9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2E9bmV3IFVpbnQ4QXJyYXkoZixoLHkpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbZCxsXT1hd2FpdCBXYShzKSxwPWF3YWl0IGQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoYSxsKTtyZXR1cm4gQmUoKSxuZXcgZShwKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgT2YsbHM9RygoKT0+e1widXNlIHN0cmljdFwiO2RzKCk7T2Y9JHJ9KTt2YXIgY3M9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIHBzPUcoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBtcz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgZnM9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEZuPXt9O1p0KEZuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5PZixUUkFDRTooKT0+dnIsVFJBQ0VfRlVOQ19CRUdJTjooKT0+TmUsVFJBQ0VfRlVOQ19FTkQ6KCk9PkJlLFRlbnNvcjooKT0+cWUsZW52OigpPT53ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PkN0fSk7dmFyIEdlPUcoKCk9PntcInVzZSBzdHJpY3RcIjtMYSgpO3FhKCk7bHMoKTtHbigpO2NzKCk7cHMoKTtIbigpO21zKCk7ZnMoKX0pO3ZhciB4cj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgYnM9e307WnQoYnMse2RlZmF1bHQ6KCk9PkRmfSk7dmFyIGdzLHlzLERmLF9zPUcoKCk9PntcInVzZSBzdHJpY3RcIjtxbigpO2J0KCk7U3IoKTtncz1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLHlzPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PWdzO3lzJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46bn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6VHIobi53YXNtKS50aGVuKCgpPT57Q3IobikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0scj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOnJ9KX0pfSxyPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6cn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOnIsZW52Om99PW47SXIobyxyKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxhPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6YX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6cn09bixvPVl0KHIpO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOnIsb3B0aW9uczpvfT1uO0FyKHIsbykudGhlbihhPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6YX0pfSxhPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6YX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOmtyKG4pLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpyLGlucHV0SW5kaWNlczpvLGlucHV0czphLG91dHB1dEluZGljZXM6cyxvcHRpb25zOmR9PW47RXIocixvLGEscyxuZXcgQXJyYXkocy5sZW5ndGgpLmZpbGwobnVsbCksZCkudGhlbihsPT57bC5zb21lKHA9PnBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpsfSx6cihbLi4uYSwuLi5sXSkpfSxsPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bH0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOlByKG4pLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gocil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6cn0pfX0pO0RmPXlzP251bGw6ZT0+bmV3IFdvcmtlcihlPz9WZSx7dHlwZTpcIm1vZHVsZVwiLG5hbWU6Z3N9KX0pO3ZhciB2cz17fTtadCh2cyx7ZGVmYXVsdDooKT0+QmZ9KTt2YXIgS24sd3MsQmYsTWYsJHM9RygoKT0+e1widXNlIHN0cmljdFwiO3dzPShLbj1pbXBvcnQubWV0YS51cmwsYXN5bmMgZnVuY3Rpb24oZT17fSl7dmFyIHQsbixyPWUsbz1uZXcgUHJvbWlzZSgoaSx1KT0+e3Q9aSxuPXV9KSxhPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIscz10eXBlb2YgV29ya2VyR2xvYmFsU2NvcGU8XCJ1XCIsZD1zJiZzZWxmLm5hbWU/LnN0YXJ0c1dpdGgoXCJlbS1wdGhyZWFkXCIpO3IubW91bnRFeHRlcm5hbERhdGE9KGksdSk9PntpLnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGk9aS5zdWJzdHJpbmcoMikpLChyLkJkfHwoci5CZD1uZXcgTWFwKSkuc2V0KGksdSl9LHIudW5tb3VudEV4dGVybmFsRGF0YT0oKT0+e2RlbGV0ZSByLkJkfTt2YXIgbD1nbG9iYWxUaGlzLlNoYXJlZEFycmF5QnVmZmVyPz9uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjAsbWF4aW11bTowLHNoYXJlZDohMH0pLmJ1ZmZlci5jb25zdHJ1Y3RvcjtsZXQgcD0oKT0+e2xldCBpPShjLG0sZyk9PiguLi54KT0+e2xldCBJPUplLHo9bT8uKCk7eD1jKC4uLngpO2xldCBCPW0/LigpO3JldHVybiB6IT09QiYmKGM9QixnKHopLG09Zz1udWxsKSxKZSE9ST9uZXcgUHJvbWlzZSgoTCxxKT0+e0VuPXtyZXNvbHZlOkwscmVqZWN0OnF9fSk6eH0sdT1jPT5hc3luYyguLi5tKT0+e3RyeXtpZihyLkNkKXRocm93IEVycm9yKFwiU2Vzc2lvbiBhbHJlYWR5IHN0YXJ0ZWRcIik7bGV0IGc9ci5DZD17YmU6bVswXSxlcnJvcnM6W119LHg9YXdhaXQgYyguLi5tKTtpZihyLkNkIT09Zyl0aHJvdyBFcnJvcihcIlNlc3Npb24gbWlzbWF0Y2hcIik7ci5EZD8uZmx1c2goKTtsZXQgST1nLmVycm9ycztpZigwPEkubGVuZ3RoKXtsZXQgej1hd2FpdCBQcm9taXNlLmFsbChJKTtpZih6PXouZmlsdGVyKEI9PkIpLDA8ei5sZW5ndGgpdGhyb3cgRXJyb3Ioei5qb2luKGBcbmApKX1yZXR1cm4geH1maW5hbGx5e3IuQ2Q9bnVsbH19O3IuX09ydENyZWF0ZVNlc3Npb249aShyLl9PcnRDcmVhdGVTZXNzaW9uLCgpPT5yLl9PcnRDcmVhdGVTZXNzaW9uLGM9PnIuX09ydENyZWF0ZVNlc3Npb249Yyksci5fT3J0UnVuPXUoaShyLl9PcnRSdW4sKCk9PnIuX09ydFJ1bixjPT5yLl9PcnRSdW49YykpLHIuX09ydFJ1bldpdGhCaW5kaW5nPXUoaShyLl9PcnRSdW5XaXRoQmluZGluZywoKT0+ci5fT3J0UnVuV2l0aEJpbmRpbmcsYz0+ci5fT3J0UnVuV2l0aEJpbmRpbmc9YykpLHIuX09ydEJpbmRJbnB1dD1pKHIuX09ydEJpbmRJbnB1dCwoKT0+ci5fT3J0QmluZElucHV0LGM9PnIuX09ydEJpbmRJbnB1dD1jKSxwPXZvaWQgMH07ci5qc2VwSW5pdD0oaSx1KT0+e2lmKHA/LigpLGk9PT1cIndlYmdwdVwiKXtbci5EZCxyLlJkLHIuVmQsci5IZCxyLlVkLHIuaGMsci5XZCxyLlpkLHIuU2Qsci5UZCxyLlhkXT11O2xldCBjPXIuRGQ7ci5qc2VwUmVnaXN0ZXJCdWZmZXI9KG0sZyx4LEkpPT5jLnJlZ2lzdGVyQnVmZmVyKG0sZyx4LEkpLHIuanNlcEdldEJ1ZmZlcj1tPT5jLmdldEJ1ZmZlcihtKSxyLmpzZXBDcmVhdGVEb3dubG9hZGVyPShtLGcseCk9PmMuY3JlYXRlRG93bmxvYWRlcihtLGcseCksci5qc2VwT25DcmVhdGVTZXNzaW9uPW09PntjLm9uQ3JlYXRlU2Vzc2lvbihtKX0sci5qc2VwT25SZWxlYXNlU2Vzc2lvbj1tPT57Yy5vblJlbGVhc2VTZXNzaW9uKG0pfSxyLmpzZXBPblJ1blN0YXJ0PW09PmMub25SdW5TdGFydChtKSxyLiRkPShtLGcpPT57Yy51cGxvYWQobSxnKX19ZWxzZSBpZihpPT09XCJ3ZWJublwiKXtbci5EZCxyLllkLHIuSWQsci5qc2VwRW5zdXJlVGVuc29yLHIuSmQsci5qc2VwRG93bmxvYWRUZW5zb3JdPXUsci5qc2VwUmVsZWFzZVRlbnNvcklkPXIuSWQsci5qc2VwVXBsb2FkVGVuc29yPXIuSmQ7bGV0IGM9ci5EZDtyLmpzZXBPblJ1blN0YXJ0PW09PmMub25SdW5TdGFydChtKSxyLmpzZXBPblJ1bkVuZD1jLm9uUnVuRW5kLmJpbmQoYyksci5qc2VwUmVnaXN0ZXJNTENvbnRleHQ9KG0sZyk9PntjLnJlZ2lzdGVyTUxDb250ZXh0KG0sZyl9LHIuanNlcE9uUmVsZWFzZVNlc3Npb249bT0+e2Mub25SZWxlYXNlU2Vzc2lvbihtKX0sci5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyPShtLGcpPT5jLmNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihtLGcpLHIuanNlcFJlZ2lzdGVyTUxUZW5zb3I9KG0sZyx4LEkpPT5jLnJlZ2lzdGVyTUxUZW5zb3IobSxnLHgsSSksci5qc2VwQ3JlYXRlTUxDb250ZXh0PW09PmMuY3JlYXRlTUxDb250ZXh0KG0pLHIuanNlcFJlZ2lzdGVyTUxDb25zdGFudD0obSxnLHgsSSx6KT0+Yy5yZWdpc3Rlck1MQ29uc3RhbnQobSxnLHgsSSx6LHIuQmQpLHIuanNlcFJlZ2lzdGVyR3JhcGhJbnB1dD1jLnJlZ2lzdGVyR3JhcGhJbnB1dC5iaW5kKGMpLHIuanNlcElzR3JhcGhJbnB1dD1jLmlzR3JhcGhJbnB1dC5iaW5kKGMpLHIuanNlcENyZWF0ZVRlbXBvcmFyeVRlbnNvcj1jLmNyZWF0ZVRlbXBvcmFyeVRlbnNvci5iaW5kKGMpfX07dmFyIGYsaCx5PU9iamVjdC5hc3NpZ24oe30sciksXz0oaSx1KT0+e3Rocm93IHV9LGI9XCJcIjsoYXx8cykmJihzP2I9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKGI9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLEtuJiYoYj1LbiksYj1iLnN0YXJ0c1dpdGgoXCJibG9iOlwiKT9cIlwiOmIuc2xpY2UoMCxiLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpLHMmJihoPWk9Pnt2YXIgdT1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIHUub3BlbihcIkdFVFwiLGksITEpLHUucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIix1LnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkodS5yZXNwb25zZSl9KSxmPWFzeW5jIGk9PntpZihsZShpKSlyZXR1cm4gbmV3IFByb21pc2UoKGMsbSk9Pnt2YXIgZz1uZXcgWE1MSHR0cFJlcXVlc3Q7Zy5vcGVuKFwiR0VUXCIsaSwhMCksZy5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGcub25sb2FkPSgpPT57Zy5zdGF0dXM9PTIwMHx8Zy5zdGF0dXM9PTAmJmcucmVzcG9uc2U/YyhnLnJlc3BvbnNlKTptKGcuc3RhdHVzKX0sZy5vbmVycm9yPW0sZy5zZW5kKG51bGwpfSk7dmFyIHU9YXdhaXQgZmV0Y2goaSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSk7aWYodS5vaylyZXR1cm4gdS5hcnJheUJ1ZmZlcigpO3Rocm93IEVycm9yKHUuc3RhdHVzK1wiIDogXCIrdS51cmwpfSk7dmFyIHc9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxTPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSwkPXcsdj1TO09iamVjdC5hc3NpZ24ocix5KSx5PW51bGw7dmFyIFQsQyxBLGssTyxNLFYsRixqLG5lLFcsSix2ZSxRPXIud2FzbUJpbmFyeSxlZT0hMSxsZT1pPT5pLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO2Z1bmN0aW9uIFooKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLGt9ZnVuY3Rpb24gcGUoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLE99ZnVuY3Rpb24ga2UoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLE19ZnVuY3Rpb24gU2UoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLFZ9ZnVuY3Rpb24gRCgpe3JldHVybiBULmJ1ZmZlciE9ay5idWZmZXImJmJlKCksRn1mdW5jdGlvbiBSKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSxqfWZ1bmN0aW9uIFkoKXtyZXR1cm4gVC5idWZmZXIhPWsuYnVmZmVyJiZiZSgpLG5lfWZ1bmN0aW9uIGZlKCl7cmV0dXJuIFQuYnVmZmVyIT1rLmJ1ZmZlciYmYmUoKSx2ZX1pZihkKXtsZXQgaT1mdW5jdGlvbih1KXt0cnl7dmFyIGM9dS5kYXRhLG09Yy55ZDtpZihtPT09XCJsb2FkXCIpe2xldCBnPVtdO3NlbGYub25tZXNzYWdlPXg9PmcucHVzaCh4KSxzZWxmLnN0YXJ0V29ya2VyPSgpPT57cG9zdE1lc3NhZ2Uoe3lkOlwibG9hZGVkXCJ9KTtmb3IobGV0IHggb2YgZylpKHgpO3NlbGYub25tZXNzYWdlPWl9O2ZvcihsZXQgeCBvZiBjLk9kKXJbeF0mJiFyW3hdLnByb3h5fHwoclt4XT0oLi4uSSk9Pntwb3N0TWVzc2FnZSh7eWQ6XCJjYWxsSGFuZGxlclwiLE5kOngsYXJnczpJfSl9LHg9PVwicHJpbnRcIiYmKCQ9clt4XSkseD09XCJwcmludEVyclwiJiYodj1yW3hdKSk7VD1jLmhlLGJlKCksRmUoYy5pZSl9ZWxzZSBpZihtPT09XCJydW5cIil7Y3AoYy54ZCksRG4oYy54ZCwwLDAsMSwwLDApLExvKCksQW4oYy54ZCkseGV8fChNaSgpLHhlPSEwKTt0cnl7cHAoYy5kZSxjLkZkKX1jYXRjaChnKXtpZihnIT1cInVud2luZFwiKXRocm93IGd9fWVsc2UgYy50YXJnZXQhPT1cInNldGltbWVkaWF0ZVwiJiYobT09PVwiY2hlY2tNYWlsYm94XCI/eGUmJnVyKCk6bSYmKHYoYHdvcmtlcjogcmVjZWl2ZWQgdW5rbm93biBjb21tYW5kICR7bX1gKSx2KGMpKSl9Y2F0Y2goZyl7dGhyb3cgUmkoKSxnfX07dmFyIHViPWksRmUseGU9ITE7dj1mdW5jdGlvbiguLi51KXt1PXUuam9pbihcIiBcIiksY29uc29sZS5lcnJvcih1KX0sc2VsZi5hbGVydD1mdW5jdGlvbiguLi51KXtwb3N0TWVzc2FnZSh7eWQ6XCJhbGVydFwiLHRleHQ6dS5qb2luKFwiIFwiKSxmZTpncigpfSl9LHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249dT0+e3Rocm93IHUucmVhc29ufHx1fSxzZWxmLm9ubWVzc2FnZT1pfWZ1bmN0aW9uIGJlKCl7dmFyIGk9VC5idWZmZXI7ci5IRUFQOD1rPW5ldyBJbnQ4QXJyYXkoaSksci5IRUFQMTY9TT1uZXcgSW50MTZBcnJheShpKSxyLkhFQVBVOD1PPW5ldyBVaW50OEFycmF5KGkpLHIuSEVBUFUxNj1WPW5ldyBVaW50MTZBcnJheShpKSxyLkhFQVAzMj1GPW5ldyBJbnQzMkFycmF5KGkpLHIuSEVBUFUzMj1qPW5ldyBVaW50MzJBcnJheShpKSxyLkhFQVBGMzI9bmU9bmV3IEZsb2F0MzJBcnJheShpKSxyLkhFQVBGNjQ9dmU9bmV3IEZsb2F0NjRBcnJheShpKSxyLkhFQVA2ND1XPW5ldyBCaWdJbnQ2NEFycmF5KGkpLHIuSEVBUFU2ND1KPW5ldyBCaWdVaW50NjRBcnJheShpKX1mdW5jdGlvbiBZZSgpe2Q/c3RhcnRXb3JrZXIocik6VS5CYigpfWR8fChUPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjU2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSksYmUoKSk7dmFyIEd0LHh0PTAsSHQ9bnVsbDtmdW5jdGlvbiBCbygpe2lmKC0teHQ9PTAmJkh0KXt2YXIgaT1IdDtIdD1udWxsLGkoKX19ZnVuY3Rpb24gdXQoaSl7dGhyb3cgdihpPVwiQWJvcnRlZChcIitpK1wiKVwiKSxlZT0hMCxpPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IoaStcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbihpKSxpfWZ1bmN0aW9uIE1vKCl7cmV0dXJue2E6e1RhOmxwLFZhOmRwLFc6bXAsbGE6ZnAsYjpncCx1OnlwLFI6YnAsWmE6X3AsZDp3cCxwYjpxbyxnOmhwLFQ6Wm8sR2E6UW8sbGI6WG8sbmI6Sm8sSGE6ZWksRWE6dGksd2I6cmksRGE6bmkscGE6b2ksbWI6aWksamI6YWksRmE6c2ksa2I6dWksTWE6dnAsemE6eHAsZWI6U3AsY2I6Q3AseWE6QXAsVjprcCxOOkVwLGRiOlBwLG1hOlVwLGZiOk5wLHpiOlZwLGhiOldwLHFiOkxwLGFiOkdwLEFhOkhwLHliOkFuLEphOkZwLFM6cXAsV2E6S3AsJDpRcCxHOllwLEU6SnAsbTpUbixIOmVtLEI6bm0sWDpvbSxKOmltLHY6YW0sTzpzbSxEOnVtLHQ6ZG0sQTpsbSx6OmNtLHc6cG0scjptbSx0YjpmbSx1YjpobSx2YjpnbSxyYjokaSxzYjp4aSxiYjpTaSxPYTpibSxMYTp2bSx5OiRtLGphOnhtLEJhOlNtLEthOl9tLHFhOlRtLElhOkNtLGliOkltLFU6eW0sZmE6QW0sU2E6a20sZ2I6RW0sUWE6UG0sUGE6em0sQWI6QWksQ2E6a2ksb2I6X24sYWE6RWksb2E6UGkseGI6emksbmE6T2ksJGE6YWYsaWE6X2Ysc2E6U2YsZ2E6bmYsZGE6cGYsdWE6JGYscDp0ZixlOk5tLGM6Um0sZWE6bGYsZjpWbSxuOkxtLGs6WW0sWTpIbSxrYTpYbSxqOnJmLHdhOmRmLFJhOklmLGNhOnlmLFVhOkNmLFA6Y2YsSzpxbSxfOmdmLFE6b2YsWjp3Zix4OkZtLGw6VW0sdmE6aGYsaTpNbSxoOkdtLHJhOlRmLHRhOnhmLG86V20scTpLbSxzOlptLEk6UW0sQzplZixMOkptLHhhOnVmLF9hOnNmLEY6YmYsWWE6bWYsYmE6dmYsTTpqbSxYYTpmZixoYTpEbSxhOlQsTmE6Ym59fX12YXIgaG49ezEzMTk0MjY6KCk9PnR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwiLDEzMTk0ODM6KGksdSxjLG0sZyk9PntpZihyPT09dm9pZCAwfHwhci5CZClyZXR1cm4gMTtpZigoaT1BZShOdW1iZXIoaT4+PjApKSkuc3RhcnRzV2l0aChcIi4vXCIpJiYoaT1pLnN1YnN0cmluZygyKSksIShpPXIuQmQuZ2V0KGkpKSlyZXR1cm4gMjtpZih1PU51bWJlcih1Pj4+MCksYz1OdW1iZXIoYz4+PjApLG09TnVtYmVyKG0+Pj4wKSx1K2M+aS5ieXRlTGVuZ3RoKXJldHVybiAzO3RyeXtsZXQgeD1pLnN1YmFycmF5KHUsdStjKTtzd2l0Y2goZyl7Y2FzZSAwOnBlKCkuc2V0KHgsbT4+PjApO2JyZWFrO2Nhc2UgMTpyLiRkKG0seCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gNH1yZXR1cm4gMH1jYXRjaHtyZXR1cm4gNH19LDEzMjAxOTg6KGksdSxjKT0+e3IuSmQoaSxwZSgpLnN1YmFycmF5KHU+Pj4wLHUrYz4+PjApKX0sMTMyMDI2MTooKT0+ci5ZZCgpLDEzMjAzMDI6aT0+e3IuSWQoaSl9LDEzMjAzMzg6KCk9PntyLlNkKCl9LDEzMjAzNjk6KCk9PntyLlRkKCl9LDEzMjAzOTg6KCk9PntyLlhkKCl9LDEzMjA0MjM6aT0+ci5SZChpKSwxMzIwNDU2Omk9PnIuVmQoaSksMTMyMDQ4ODooaSx1LGMpPT57ci5IZChOdW1iZXIoaSksTnVtYmVyKHUpLE51bWJlcihjKSwhMCl9LDEzMjA1NTE6KGksdSxjKT0+e3IuSGQoTnVtYmVyKGkpLE51bWJlcih1KSxOdW1iZXIoYykpfSwxMzIwNjA4Omk9PntyLmhjKFwiQWJzXCIsaSx2b2lkIDApfSwxMzIwNjU5Omk9PntyLmhjKFwiTmVnXCIsaSx2b2lkIDApfSwxMzIwNzEwOmk9PntyLmhjKFwiRmxvb3JcIixpLHZvaWQgMCl9LDEzMjA3NjM6aT0+e3IuaGMoXCJDZWlsXCIsaSx2b2lkIDApfSwxMzIwODE1Omk9PntyLmhjKFwiUmVjaXByb2NhbFwiLGksdm9pZCAwKX0sMTMyMDg3MzppPT57ci5oYyhcIlNxcnRcIixpLHZvaWQgMCl9LDEzMjA5MjU6aT0+e3IuaGMoXCJFeHBcIixpLHZvaWQgMCl9LDEzMjA5NzY6aT0+e3IuaGMoXCJFcmZcIixpLHZvaWQgMCl9LDEzMjEwMjc6aT0+e3IuaGMoXCJTaWdtb2lkXCIsaSx2b2lkIDApfSwxMzIxMDgyOihpLHUsYyk9PntyLmhjKFwiSGFyZFNpZ21vaWRcIixpLHthbHBoYTp1LGJldGE6Y30pfSwxMzIxMTYxOmk9PntyLmhjKFwiTG9nXCIsaSx2b2lkIDApfSwxMzIxMjEyOmk9PntyLmhjKFwiU2luXCIsaSx2b2lkIDApfSwxMzIxMjYzOmk9PntyLmhjKFwiQ29zXCIsaSx2b2lkIDApfSwxMzIxMzE0Omk9PntyLmhjKFwiVGFuXCIsaSx2b2lkIDApfSwxMzIxMzY1Omk9PntyLmhjKFwiQXNpblwiLGksdm9pZCAwKX0sMTMyMTQxNzppPT57ci5oYyhcIkFjb3NcIixpLHZvaWQgMCl9LDEzMjE0Njk6aT0+e3IuaGMoXCJBdGFuXCIsaSx2b2lkIDApfSwxMzIxNTIxOmk9PntyLmhjKFwiU2luaFwiLGksdm9pZCAwKX0sMTMyMTU3MzppPT57ci5oYyhcIkNvc2hcIixpLHZvaWQgMCl9LDEzMjE2MjU6aT0+e3IuaGMoXCJBc2luaFwiLGksdm9pZCAwKX0sMTMyMTY3ODppPT57ci5oYyhcIkFjb3NoXCIsaSx2b2lkIDApfSwxMzIxNzMxOmk9PntyLmhjKFwiQXRhbmhcIixpLHZvaWQgMCl9LDEzMjE3ODQ6aT0+e3IuaGMoXCJUYW5oXCIsaSx2b2lkIDApfSwxMzIxODM2Omk9PntyLmhjKFwiTm90XCIsaSx2b2lkIDApfSwxMzIxODg3OihpLHUsYyk9PntyLmhjKFwiQ2xpcFwiLGkse21pbjp1LG1heDpjfSl9LDEzMjE5NTY6aT0+e3IuaGMoXCJDbGlwXCIsaSx2b2lkIDApfSwxMzIyMDA4OihpLHUpPT57ci5oYyhcIkVsdVwiLGkse2FscGhhOnV9KX0sMTMyMjA2NjppPT57ci5oYyhcIkdlbHVcIixpLHZvaWQgMCl9LDEzMjIxMTg6aT0+e3IuaGMoXCJSZWx1XCIsaSx2b2lkIDApfSwxMzIyMTcwOihpLHUpPT57ci5oYyhcIkxlYWt5UmVsdVwiLGkse2FscGhhOnV9KX0sMTMyMjIzNDooaSx1KT0+e3IuaGMoXCJUaHJlc2hvbGRlZFJlbHVcIixpLHthbHBoYTp1fSl9LDEzMjIzMDQ6KGksdSk9PntyLmhjKFwiQ2FzdFwiLGkse3RvOnV9KX0sMTMyMjM2MjppPT57ci5oYyhcIkFkZFwiLGksdm9pZCAwKX0sMTMyMjQxMzppPT57ci5oYyhcIlN1YlwiLGksdm9pZCAwKX0sMTMyMjQ2NDppPT57ci5oYyhcIk11bFwiLGksdm9pZCAwKX0sMTMyMjUxNTppPT57ci5oYyhcIkRpdlwiLGksdm9pZCAwKX0sMTMyMjU2NjppPT57ci5oYyhcIlBvd1wiLGksdm9pZCAwKX0sMTMyMjYxNzppPT57ci5oYyhcIkVxdWFsXCIsaSx2b2lkIDApfSwxMzIyNjcwOmk9PntyLmhjKFwiR3JlYXRlclwiLGksdm9pZCAwKX0sMTMyMjcyNTppPT57ci5oYyhcIkdyZWF0ZXJPckVxdWFsXCIsaSx2b2lkIDApfSwxMzIyNzg3Omk9PntyLmhjKFwiTGVzc1wiLGksdm9pZCAwKX0sMTMyMjgzOTppPT57ci5oYyhcIkxlc3NPckVxdWFsXCIsaSx2b2lkIDApfSwxMzIyODk4OihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZU1lYW5cIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzIzMDczOihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZU1heFwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjMyNDc6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlTWluXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzQyMTooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VQcm9kXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzU5NjooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VTdW1cIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzIzNzcwOihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZUwxXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyMzk0MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VMMlwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjQxMTY6KGksdSxjLG0sZyk9PntyLmhjKFwiUmVkdWNlTG9nU3VtXCIsaSx7a2VlcERpbXM6ISF1LG5vb3BXaXRoRW1wdHlBeGVzOiEhYyxheGVzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W119KX0sMTMyNDI5MzooaSx1LGMsbSxnKT0+e3IuaGMoXCJSZWR1Y2VTdW1TcXVhcmVcIixpLHtrZWVwRGltczohIXUsbm9vcFdpdGhFbXB0eUF4ZXM6ISFjLGF4ZXM6bT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIobSk+Pj4wLE51bWJlcihnKT4+PjApKTpbXX0pfSwxMzI0NDczOihpLHUsYyxtLGcpPT57ci5oYyhcIlJlZHVjZUxvZ1N1bUV4cFwiLGkse2tlZXBEaW1zOiEhdSxub29wV2l0aEVtcHR5QXhlczohIWMsYXhlczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMjQ2NTM6aT0+e3IuaGMoXCJXaGVyZVwiLGksdm9pZCAwKX0sMTMyNDcwNjooaSx1LGMpPT57ci5oYyhcIlRyYW5zcG9zZVwiLGkse3Blcm06dT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodSk+Pj4wLE51bWJlcihjKT4+PjApKTpbXX0pfSwxMzI0ODMwOihpLHUsYyxtKT0+e3IuaGMoXCJEZXB0aFRvU3BhY2VcIixpLHtibG9ja3NpemU6dSxtb2RlOkFlKGMpLGZvcm1hdDptP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMjQ5NjM6KGksdSxjLG0pPT57ci5oYyhcIkRlcHRoVG9TcGFjZVwiLGkse2Jsb2Nrc2l6ZTp1LG1vZGU6QWUoYyksZm9ybWF0Om0/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMyNTA5NjooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUsTGUpPT57ci5oYyhcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnUsZGlsYXRpb25zOltjXSxncm91cDptLGtlcm5lbFNoYXBlOltnXSxwYWRzOlt4LEldLHN0cmlkZXM6W3pdLHdJc0NvbnN0OigpPT4hIVooKVtMPj4+MF0sb3V0cHV0UGFkZGluZzpxP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihxKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLG91dHB1dFNoYXBlOnVlP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih1ZSk+Pj4wLE51bWJlcigkZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpBZShMZSl9KX0sMTMyNTUyOTooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnUsZGlsYXRpb25zOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihjKT4+PjAsMisoTnVtYmVyKGMpPj4+MCk+Pj4wKSksZ3JvdXA6bSxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoZyk+Pj4wLDIrKE51bWJlcihnKT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHgpPj4+MCw0KyhOdW1iZXIoeCk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsMisoTnVtYmVyKEkpPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhWigpW0I+Pj4wXSxvdXRwdXRQYWRkaW5nOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6WD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcih1ZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpBZSgkZSl9KX0sMTMyNjE5MDooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUsTGUpPT57ci5oYyhcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnUsZGlsYXRpb25zOltjXSxncm91cDptLGtlcm5lbFNoYXBlOltnXSxwYWRzOlt4LEldLHN0cmlkZXM6W3pdLHdJc0NvbnN0OigpPT4hIVooKVtMPj4+MF0sb3V0cHV0UGFkZGluZzpxP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihxKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLG91dHB1dFNoYXBlOnVlP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih1ZSk+Pj4wLE51bWJlcigkZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpBZShMZSl9KX0sMTMyNjYyMzooaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpPT57ci5oYyhcIkNvbnZUcmFuc3Bvc2VcIixpLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOnUsZGlsYXRpb25zOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihjKT4+PjAsMisoTnVtYmVyKGMpPj4+MCk+Pj4wKSksZ3JvdXA6bSxrZXJuZWxTaGFwZTpBcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoZyk+Pj4wLDIrKE51bWJlcihnKT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHgpPj4+MCw0KyhOdW1iZXIoeCk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsMisoTnVtYmVyKEkpPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhWigpW0I+Pj4wXSxvdXRwdXRQYWRkaW5nOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6WD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcih1ZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpBZSgkZSl9KX0sMTMyNzI4NDooaSx1KT0+e3IuaGMoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDp1P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMjczNzU6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJBdmVyYWdlUG9vbFwiLGkse2Zvcm1hdDokZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDp1LGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOm0sc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdLGtlcm5lbF9zaGFwZTp6P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih6KT4+PjAsTnVtYmVyKEIpPj4+MCkpOltdLHBhZHM6TD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoTCk+Pj4wLE51bWJlcihxKT4+PjApKTpbXSxzdHJpZGVzOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdfSl9LDEzMjc4NTQ6KGksdSk9PntyLmhjKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI3OTQ1OihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiQXZlcmFnZVBvb2xcIixpLHtmb3JtYXQ6JGU/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxjZWlsX21vZGU6Yyxjb3VudF9pbmNsdWRlX3BhZDptLHN0b3JhZ2Vfb3JkZXI6ZyxkaWxhdGlvbnM6eD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeCk+Pj4wLE51bWJlcihJKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxwYWRzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sc3RyaWRlczpYP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKHVlKT4+PjApKTpbXX0pfSwxMzI4NDI0OihpLHUpPT57ci5oYyhcIkdsb2JhbE1heFBvb2xcIixpLHtmb3JtYXQ6dT9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzI4NTExOihpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSk9PntyLmhjKFwiTWF4UG9vbFwiLGkse2Zvcm1hdDokZT9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDp1LGNlaWxfbW9kZTpjLGNvdW50X2luY2x1ZGVfcGFkOm0sc3RvcmFnZV9vcmRlcjpnLGRpbGF0aW9uczp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdLGtlcm5lbF9zaGFwZTp6P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih6KT4+PjAsTnVtYmVyKEIpPj4+MCkpOltdLHBhZHM6TD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoTCk+Pj4wLE51bWJlcihxKT4+PjApKTpbXSxzdHJpZGVzOlg/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIodWUpPj4+MCkpOltdfSl9LDEzMjg5ODY6KGksdSk9PntyLmhjKFwiR2xvYmFsTWF4UG9vbFwiLGkse2Zvcm1hdDp1P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMjkwNzM6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+e3IuaGMoXCJNYXhQb29sXCIsaSx7Zm9ybWF0OiRlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOnUsY2VpbF9tb2RlOmMsY291bnRfaW5jbHVkZV9wYWQ6bSxzdG9yYWdlX29yZGVyOmcsZGlsYXRpb25zOng/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHgpPj4+MCxOdW1iZXIoSSk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOno/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKHopPj4+MCxOdW1iZXIoQik+Pj4wKSk6W10scGFkczpMP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihMKT4+PjAsTnVtYmVyKHEpPj4+MCkpOltdLHN0cmlkZXM6WD9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcih1ZSk+Pj4wKSk6W119KX0sMTMyOTU0ODooaSx1LGMsbSxnKT0+e3IuaGMoXCJHZW1tXCIsaSx7YWxwaGE6dSxiZXRhOmMsdHJhbnNBOm0sdHJhbnNCOmd9KX0sMTMyOTY1MjppPT57ci5oYyhcIk1hdE11bFwiLGksdm9pZCAwKX0sMTMyOTcwNjooaSx1LGMsbSk9PntyLmhjKFwiQXJnTWF4XCIsaSx7a2VlcERpbXM6ISF1LHNlbGVjdExhc3RJbmRleDohIWMsYXhpczptfSl9LDEzMjk4MTQ6KGksdSxjLG0pPT57ci5oYyhcIkFyZ01pblwiLGkse2tlZXBEaW1zOiEhdSxzZWxlY3RMYXN0SW5kZXg6ISFjLGF4aXM6bX0pfSwxMzI5OTIyOihpLHUpPT57ci5oYyhcIlNvZnRtYXhcIixpLHtheGlzOnV9KX0sMTMyOTk4NTooaSx1KT0+e3IuaGMoXCJDb25jYXRcIixpLHtheGlzOnV9KX0sMTMzMDA0NTooaSx1LGMsbSxnKT0+e3IuaGMoXCJTcGxpdFwiLGkse2F4aXM6dSxudW1PdXRwdXRzOmMsc3BsaXRTaXplczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMzAyMDE6aT0+e3IuaGMoXCJFeHBhbmRcIixpLHZvaWQgMCl9LDEzMzAyNTU6KGksdSk9PntyLmhjKFwiR2F0aGVyXCIsaSx7YXhpczpOdW1iZXIodSl9KX0sMTMzMDMyNjooaSx1KT0+e3IuaGMoXCJHYXRoZXJFbGVtZW50c1wiLGkse2F4aXM6TnVtYmVyKHUpfSl9LDEzMzA0MDU6KGksdSk9PntyLmhjKFwiR2F0aGVyTkRcIixpLHtiYXRjaF9kaW1zOk51bWJlcih1KX0pfSwxMzMwNDg0OihpLHUsYyxtLGcseCxJLHosQixMLHEpPT57ci5oYyhcIlJlc2l6ZVwiLGkse2FudGlhbGlhczp1LGF4ZXM6Yz9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLE51bWJlcihtKT4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpBZShnKSxjdWJpY0NvZWZmQTp4LGV4Y2x1ZGVPdXRzaWRlOkksZXh0cmFwb2xhdGlvblZhbHVlOnosa2VlcEFzcGVjdFJhdGlvUG9saWN5OkFlKEIpLG1vZGU6QWUoTCksbmVhcmVzdE1vZGU6QWUocSl9KX0sMTMzMDg0NjooaSx1LGMsbSxnLHgsSSk9PntyLmhjKFwiU2xpY2VcIixpLHtzdGFydHM6dT9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIodSk+Pj4wLE51bWJlcihjKT4+PjApKTpbXSxlbmRzOm0/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKG0pPj4+MCxOdW1iZXIoZyk+Pj4wKSk6W10sYXhlczp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdfSl9LDEzMzExMTA6aT0+e3IuaGMoXCJUaWxlXCIsaSx2b2lkIDApfSwxMzMxMTYyOihpLHUsYyk9PntyLmhjKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsaSx7ZXBzaWxvbjp1LGZvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzEyNzY6KGksdSxjKT0+e3IuaGMoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsZm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMzMTM5MDppPT57ci5oYyhcIlJhbmdlXCIsaSx2b2lkIDApfSwxMzMxNDQzOihpLHUpPT57ci5oYyhcIkVpbnN1bVwiLGkse2VxdWF0aW9uOkFlKHUpfSl9LDEzMzE1MjQ6KGksdSxjLG0sZyk9PntyLmhjKFwiUGFkXCIsaSx7bW9kZTp1LHZhbHVlOmMscGFkczptP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcihtKT4+PjAsTnVtYmVyKGcpPj4+MCkpOltdfSl9LDEzMzE2Njc6KGksdSxjLG0sZyx4KT0+e3IuaGMoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsbW9tZW50dW06YyxzcGF0aWFsOiEhZyx0cmFpbmluZ01vZGU6ISFtLGZvcm1hdDp4P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzE4MzY6KGksdSxjLG0sZyx4KT0+e3IuaGMoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixpLHtlcHNpbG9uOnUsbW9tZW50dW06YyxzcGF0aWFsOiEhZyx0cmFpbmluZ01vZGU6ISFtLGZvcm1hdDp4P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDEzMzIwMDU6KGksdSxjKT0+e3IuaGMoXCJDdW1TdW1cIixpLHtleGNsdXNpdmU6TnVtYmVyKHUpLHJldmVyc2U6TnVtYmVyKGMpfSl9LDEzMzIxMDI6KGksdSxjKT0+e3IuaGMoXCJEZXF1YW50aXplTGluZWFyXCIsaSx7YXhpczp1LGJsb2NrU2l6ZTpjfSl9LDEzMzIxOTI6KGksdSxjLG0sZyk9PntyLmhjKFwiR3JpZFNhbXBsZVwiLGkse2FsaWduX2Nvcm5lcnM6dSxtb2RlOkFlKGMpLHBhZGRpbmdfbW9kZTpBZShtKSxmb3JtYXQ6Zz9cIk5IV0NcIjpcIk5DSFdcIn0pfSwxMzMyMzYyOihpLHUsYyxtLGcpPT57ci5oYyhcIkdyaWRTYW1wbGVcIixpLHthbGlnbl9jb3JuZXJzOnUsbW9kZTpBZShjKSxwYWRkaW5nX21vZGU6QWUobSksZm9ybWF0Omc/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sMTMzMjUzMjooaSx1KT0+e3IuaGMoXCJTY2F0dGVyTkRcIixpLHtyZWR1Y3Rpb246QWUodSl9KX0sMTMzMjYxNzooaSx1LGMsbSxnLHgsSSx6LEIpPT57ci5oYyhcIkF0dGVudGlvblwiLGkse251bUhlYWRzOnUsaXNVbmlkaXJlY3Rpb25hbDpjLG1hc2tGaWx0ZXJWYWx1ZTptLHNjYWxlOmcsZG9Sb3Rhcnk6eCxxa3ZIaWRkZW5TaXplczpJP0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih6KT4+PjAsTnVtYmVyKHopK0k+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIUJ9KX0sMTMzMjg4OTppPT57ci5oYyhcIkJpYXNBZGRcIixpLHZvaWQgMCl9LDEzMzI5NDQ6aT0+e3IuaGMoXCJCaWFzU3BsaXRHZWx1XCIsaSx2b2lkIDApfSwxMzMzMDA1Omk9PntyLmhjKFwiRmFzdEdlbHVcIixpLHZvaWQgMCl9LDEzMzMwNjE6KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlLExlLGp0KT0+e3IuaGMoXCJDb252XCIsaSx7Zm9ybWF0Olg/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6dSxkaWxhdGlvbnM6Yz9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoYyk+Pj4wLE51bWJlcihtKT4+PjApKTpbXSxncm91cDpnLGtlcm5lbF9zaGFwZTp4P0FycmF5LmZyb20oRCgpLnN1YmFycmF5KE51bWJlcih4KT4+PjAsTnVtYmVyKEkpPj4+MCkpOltdLHBhZHM6ej9BcnJheS5mcm9tKEQoKS5zdWJhcnJheShOdW1iZXIoeik+Pj4wLE51bWJlcihCKT4+PjApKTpbXSxzdHJpZGVzOkw/QXJyYXkuZnJvbShEKCkuc3ViYXJyYXkoTnVtYmVyKEwpPj4+MCxOdW1iZXIocSk+Pj4wKSk6W10sd19pc19jb25zdDooKT0+ISFaKClbTnVtYmVyKHVlKT4+PjBdLGFjdGl2YXRpb246QWUoJGUpLGFjdGl2YXRpb25fcGFyYW1zOkxlP0FycmF5LmZyb20oWSgpLnN1YmFycmF5KE51bWJlcihMZSk+Pj4wLE51bWJlcihqdCk+Pj4wKSk6W119KX0sMTMzMzY0NTppPT57ci5oYyhcIkdlbHVcIixpLHZvaWQgMCl9LDEzMzM2OTc6KGksdSxjLG0sZyx4LEkseixCKT0+e3IuaGMoXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIsaSx7bnVtSGVhZHM6dSxrdk51bUhlYWRzOmMsc2NhbGU6bSxzb2Z0Y2FwOmcsZG9Sb3Rhcnk6eCxyb3RhcnlJbnRlcmxlYXZlZDpJLHNtb290aFNvZnRtYXg6eixsb2NhbFdpbmRvd1NpemU6Qn0pfSwxMzMzOTE0OihpLHUsYyxtKT0+e3IuaGMoXCJMYXllck5vcm1hbGl6YXRpb25cIixpLHtheGlzOnUsZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFtfSl9LDEzMzQwMjU6KGksdSxjLG0pPT57ci5oYyhcIkxheWVyTm9ybWFsaXphdGlvblwiLGkse2F4aXM6dSxlcHNpbG9uOmMsc2ltcGxpZmllZDohIW19KX0sMTMzNDEzNjooaSx1LGMsbSxnLHgpPT57ci5oYyhcIk1hdE11bE5CaXRzXCIsaSx7azp1LG46YyxhY2N1cmFjeUxldmVsOm0sYml0czpnLGJsb2NrU2l6ZTp4fSl9LDEzMzQyNjM6KGksdSxjLG0sZyx4KT0+e3IuaGMoXCJNdWx0aUhlYWRBdHRlbnRpb25cIixpLHtudW1IZWFkczp1LGlzVW5pZGlyZWN0aW9uYWw6YyxtYXNrRmlsdGVyVmFsdWU6bSxzY2FsZTpnLGRvUm90YXJ5Onh9KX0sMTMzNDQyMjooaSx1KT0+e3IuaGMoXCJRdWlja0dlbHVcIixpLHthbHBoYTp1fSl9LDEzMzQ0ODY6KGksdSxjLG0sZyk9PntyLmhjKFwiUm90YXJ5RW1iZWRkaW5nXCIsaSx7aW50ZXJsZWF2ZWQ6ISF1LG51bUhlYWRzOmMscm90YXJ5RW1iZWRkaW5nRGltOm0sc2NhbGU6Z30pfSwxMzM0NjI1OihpLHUsYyk9PntyLmhjKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246dSxzaW1wbGlmaWVkOiEhY30pfSwxMzM0NzI3OihpLHUsYyk9PntyLmhjKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLGkse2Vwc2lsb246dSxzaW1wbGlmaWVkOiEhY30pfSwxMzM0ODI5OihpLHUsYyxtKT0+e3IuaGMoXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLGkse2dhdGhlckF4aXM6dSxxdWFudGl6ZUF4aXM6YyxibG9ja1NpemU6bX0pfSwxMzM0OTUwOmk9PntyLldkKGkpfSwxMzM0OTg0OihpLHUpPT5yLlpkKE51bWJlcihpKSxOdW1iZXIodSksci5DZC5iZSxyLkNkLmVycm9ycyl9O2Z1bmN0aW9uIGRwKGksdSxjKXtyZXR1cm4gZ2koYXN5bmMoKT0+e2F3YWl0IHIuVWQoTnVtYmVyKGkpLE51bWJlcih1KSxOdW1iZXIoYykpfSl9ZnVuY3Rpb24gbHAoKXtyZXR1cm4gdHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCJ9Y2xhc3MgZ257bmFtZT1cIkV4aXRTdGF0dXNcIjtjb25zdHJ1Y3Rvcih1KXt0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHt1fSlgLHRoaXMuc3RhdHVzPXV9fXZhciBSbz1pPT57aS50ZXJtaW5hdGUoKSxpLm9ubWVzc2FnZT0oKT0+e319LHluPVtdLFVvPWk9PntmdC5sZW5ndGg9PTAmJihIbygpLEdvKGZ0WzBdKSk7dmFyIHU9ZnQucG9wKCk7aWYoIXUpcmV0dXJuIDY7RnQucHVzaCh1KSxTdFtpLnhkXT11LHUueGQ9aS54ZDt2YXIgYz17eWQ6XCJydW5cIixkZTppLmNlLEZkOmkuRmQseGQ6aS54ZH07cmV0dXJuIHUucG9zdE1lc3NhZ2UoYyxpLkxkKSwwfSxtdD0wLFRlPShpLHUsLi4uYyk9Pntmb3IodmFyIG09MipjLmxlbmd0aCxnPWllKCkseD1Nbig4Km0pLEk9eD4+PjMsej0wO3o8Yy5sZW5ndGg7eisrKXt2YXIgQj1jW3pdO3R5cGVvZiBCPT1cImJpZ2ludFwiPyhXW0krMip6XT0xbixXW0krMip6KzFdPUIpOihXW0krMip6XT0wbixmZSgpW0krMip6KzE+Pj4wXT1CKX1yZXR1cm4gaT1VaShpLDAsbSx4LHUpLG9lKGcpLGl9O2Z1bmN0aW9uIGJuKGkpe2lmKGQpcmV0dXJuIFRlKDAsMSxpKTtpZihBPWksISgwPG10KSl7Zm9yKHZhciB1IG9mIEZ0KVJvKHUpO2Zvcih1IG9mIGZ0KVJvKHUpO2Z0PVtdLEZ0PVtdLFN0PXt9LGVlPSEwfV8oMCxuZXcgZ24oaSkpfWZ1bmN0aW9uIE5vKGkpe2lmKGQpcmV0dXJuIFRlKDEsMCxpKTtfbihpKX12YXIgX249aT0+e2lmKEE9aSxkKXRocm93IE5vKGkpLFwidW53aW5kXCI7Ym4oaSl9LGZ0PVtdLEZ0PVtdLFZvPVtdLFN0PXt9LFdvPWk9Pnt2YXIgdT1pLnhkO2RlbGV0ZSBTdFt1XSxmdC5wdXNoKGkpLEZ0LnNwbGljZShGdC5pbmRleE9mKGkpLDEpLGkueGQ9MCxOaSh1KX07ZnVuY3Rpb24gTG8oKXtWby5mb3JFYWNoKGk9PmkoKSl9dmFyIEdvPWk9Pm5ldyBQcm9taXNlKHU9PntpLm9ubWVzc2FnZT1nPT57dmFyIHg9KGc9Zy5kYXRhKS55ZDtpZihnLkVkJiZnLkVkIT1ncigpKXt2YXIgST1TdFtnLkVkXTtJP0kucG9zdE1lc3NhZ2UoZyxnLkxkKTp2KGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHt4fVwiIHRvIHRhcmdldCBwdGhyZWFkICR7Zy5FZH0sIGJ1dCB0aGF0IHRocmVhZCBubyBsb25nZXIgZXhpc3RzIWApfWVsc2UgeD09PVwiY2hlY2tNYWlsYm94XCI/dXIoKTp4PT09XCJzcGF3blRocmVhZFwiP1VvKGcpOng9PT1cImNsZWFudXBUaHJlYWRcIj9XbyhTdFtnLmVlXSk6eD09PVwibG9hZGVkXCI/KGkubG9hZGVkPSEwLHUoaSkpOng9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke2cuZmV9OiAke2cudGV4dH1gKTpnLnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/aS5wb3N0TWVzc2FnZShnKTp4PT09XCJjYWxsSGFuZGxlclwiP3JbZy5OZF0oLi4uZy5hcmdzKTp4JiZ2KGB3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgJHt4fWApfSxpLm9uZXJyb3I9Zz0+e3Rocm93IHYoYHdvcmtlciBzZW50IGFuIGVycm9yISAke2cuZmlsZW5hbWV9OiR7Zy5saW5lbm99OiAke2cubWVzc2FnZX1gKSxnfTt2YXIgYyxtPVtdO2ZvcihjIG9mW10pci5wcm9wZXJ0eUlzRW51bWVyYWJsZShjKSYmbS5wdXNoKGMpO2kucG9zdE1lc3NhZ2Uoe3lkOlwibG9hZFwiLE9kOm0saGU6VCxpZTpDfSl9KTtmdW5jdGlvbiBIbygpe3ZhciBpPW5ldyBXb3JrZXIoaW1wb3J0Lm1ldGEudXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9uZXcgVVJMKFwib3J0LndlYmdwdS5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCk6bmV3IFVSTChpbXBvcnQubWV0YS51cmwpLHt0eXBlOlwibW9kdWxlXCIsd29ya2VyRGF0YTpcImVtLXB0aHJlYWRcIixuYW1lOlwiZW0tcHRocmVhZFwifSk7ZnQucHVzaChpKX12YXIgY3A9aT0+e2JlKCk7dmFyIHU9UigpW2krNTI+Pj4yPj4+MF07aT1SKClbaSs1Nj4+PjI+Pj4wXSxMaSh1LHUtaSksb2UodSl9LHBwPShpLHUpPT57bXQ9MCxpPVJuKGksdSksMDxtdD9BPWk6Qm4oaSl9LHNyPVtdO2Z1bmN0aW9uIG1wKGkpe3ZhciB1PW5ldyB3bihpPj4+PTApO2lmKFooKVt1LndkKzEyPj4+MF09PTApe3ZhciBjPTE7WigpW3Uud2QrMTI+Pj4wXT1jfXJldHVybiBjPTAsWigpW3Uud2QrMTM+Pj4wXT1jLHNyLnB1c2godSksSGkoaSkscWkoaSl9dmFyIER0PTAsZnA9KCk9PntzZSgwLDApO3ZhciBpPXNyLnBvcCgpO0dpKGkuR2QpLER0PTB9O2NsYXNzIHdue2NvbnN0cnVjdG9yKHUpe3RoaXMuR2Q9dSx0aGlzLndkPXUtMjR9fWZ1bmN0aW9uIGhwKGkpe3Rocm93IER0fHw9aT4+PjAsRHR9dmFyIHZuPWk9Pnt2YXIgdT1EdDtpZighdSlyZXR1cm4gS3QoMCksMDt2YXIgYz1uZXcgd24odSk7UigpW2Mud2QrMTY+Pj4yPj4+MF09dTt2YXIgbT1SKClbYy53ZCs0Pj4+Mj4+PjBdO2lmKCFtKXJldHVybiBLdCgwKSx1O2Zvcih2YXIgZyBvZiBpKXtpZihnPT09MHx8Zz09PW0pYnJlYWs7aWYoRmkoZyxtLGMud2QrMTYpKXJldHVybiBLdChnKSx1fXJldHVybiBLdChtKSx1fTtmdW5jdGlvbiBncCgpe3JldHVybiB2bihbXSl9ZnVuY3Rpb24geXAoaSl7cmV0dXJuIHZuKFtpPj4+MF0pfWZ1bmN0aW9uIGJwKGksdSl7cmV0dXJuIHZuKFtpPj4+MCx1Pj4+MF0pfXZhciBfcD0oKT0+e3ZhciBpPXNyLnBvcCgpO2l8fHV0KFwibm8gZXhjZXB0aW9uIHRvIHRocm93XCIpO3ZhciB1PWkuR2Q7aWYoWigpW2kud2QrMTM+Pj4wXT09MCl7c3IucHVzaChpKTt2YXIgYz0xO1ooKVtpLndkKzEzPj4+MF09YyxjPTAsWigpW2kud2QrMTI+Pj4wXT1jfXRocm93IER0PXV9O2Z1bmN0aW9uIHdwKGksdSxjKXt2YXIgbT1uZXcgd24oaT4+Pj0wKTt0aHJvdyB1Pj4+PTAsYz4+Pj0wLFIoKVttLndkKzE2Pj4+Mj4+PjBdPTAsUigpW20ud2QrND4+PjI+Pj4wXT11LFIoKVttLndkKzg+Pj4yPj4+MF09YyxEdD1pfWZ1bmN0aW9uIEZvKGksdSxjLG0pe3JldHVybiBkP1RlKDIsMSxpLHUsYyxtKTpxbyhpLHUsYyxtKX1mdW5jdGlvbiBxbyhpLHUsYyxtKXtpZihpPj4+PTAsYz4+Pj0wLG0+Pj49MCxsPT09dm9pZCAwKXJldHVybiA2O3ZhciBnPVtdO3JldHVybiBkJiZnLmxlbmd0aD09PTA/Rm8oaSx1Pj4+PTAsYyxtKTooaT17Y2U6Yyx4ZDppLEZkOm0sTGQ6Z30sZD8oaS55ZD1cInNwYXduVGhyZWFkXCIscG9zdE1lc3NhZ2UoaSxnKSwwKTpVbyhpKSl9dmFyIEtvPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXI6dm9pZCAwLGpvPShpLHU9MCxjPU5hTik9Pnt2YXIgbT0odT4+Pj0wKStjO2ZvcihjPXU7aVtjXSYmIShjPj1tKTspKytjO2lmKDE2PGMtdSYmaS5idWZmZXImJktvKXJldHVybiBLby5kZWNvZGUoaS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9pLnN1YmFycmF5KHUsYyk6aS5zbGljZSh1LGMpKTtmb3IobT1cIlwiO3U8Yzspe3ZhciBnPWlbdSsrXTtpZigxMjgmZyl7dmFyIHg9NjMmaVt1KytdO2lmKCgyMjQmZyk9PTE5MiltKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCgzMSZnKTw8Nnx4KTtlbHNle3ZhciBJPTYzJmlbdSsrXTs2NTUzNj4oZz0oMjQwJmcpPT0yMjQ/KDE1JmcpPDwxMnx4PDw2fEk6KDcmZyk8PDE4fHg8PDEyfEk8PDZ8NjMmaVt1KytdKT9tKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpOihnLT02NTUzNixtKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2fGc+PjEwLDU2MzIwfDEwMjMmZykpfX1lbHNlIG0rPVN0cmluZy5mcm9tQ2hhckNvZGUoZyl9cmV0dXJuIG19LEFlPShpLHUpPT4oaT4+Pj0wKT9qbyhwZSgpLGksdSk6XCJcIjtmdW5jdGlvbiBabyhpLHUsYyl7cmV0dXJuIGQ/VGUoMywxLGksdSxjKTowfWZ1bmN0aW9uIFFvKGksdSl7aWYoZClyZXR1cm4gVGUoNCwxLGksdSl9dmFyIFlvPWk9Pntmb3IodmFyIHU9MCxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBtPWkuY2hhckNvZGVBdChjKTsxMjc+PW0/dSsrOjIwNDc+PW0/dSs9Mjo1NTI5Njw9bSYmNTczNDM+PW0/KHUrPTQsKytjKTp1Kz0zfXJldHVybiB1fSxCdD0oaSx1LGMpPT57dmFyIG09cGUoKTtpZih1Pj4+PTAsMDxjKXt2YXIgZz11O2M9dStjLTE7Zm9yKHZhciB4PTA7eDxpLmxlbmd0aDsrK3gpe3ZhciBJPWkuY2hhckNvZGVBdCh4KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmaS5jaGFyQ29kZUF0KCsreCkpLDEyNz49SSl7aWYodT49YylicmVhazttW3UrKz4+PjBdPUl9ZWxzZXtpZigyMDQ3Pj1JKXtpZih1KzE+PWMpYnJlYWs7bVt1Kys+Pj4wXT0xOTJ8ST4+Nn1lbHNle2lmKDY1NTM1Pj1JKXtpZih1KzI+PWMpYnJlYWs7bVt1Kys+Pj4wXT0yMjR8ST4+MTJ9ZWxzZXtpZih1KzM+PWMpYnJlYWs7bVt1Kys+Pj4wXT0yNDB8ST4+MTgsbVt1Kys+Pj4wXT0xMjh8ST4+MTImNjN9bVt1Kys+Pj4wXT0xMjh8ST4+NiY2M31tW3UrKz4+PjBdPTEyOHw2MyZJfX1tW3U+Pj4wXT0wLGk9dS1nfWVsc2UgaT0wO3JldHVybiBpfTtmdW5jdGlvbiBYbyhpLHUpe2lmKGQpcmV0dXJuIFRlKDUsMSxpLHUpfWZ1bmN0aW9uIEpvKGksdSxjKXtpZihkKXJldHVybiBUZSg2LDEsaSx1LGMpfWZ1bmN0aW9uIGVpKGksdSxjKXtyZXR1cm4gZD9UZSg3LDEsaSx1LGMpOjB9ZnVuY3Rpb24gdGkoaSx1KXtpZihkKXJldHVybiBUZSg4LDEsaSx1KX1mdW5jdGlvbiByaShpLHUsYyl7aWYoZClyZXR1cm4gVGUoOSwxLGksdSxjKX1mdW5jdGlvbiBuaShpLHUsYyxtKXtpZihkKXJldHVybiBUZSgxMCwxLGksdSxjLG0pfWZ1bmN0aW9uIG9pKGksdSxjLG0pe2lmKGQpcmV0dXJuIFRlKDExLDEsaSx1LGMsbSl9ZnVuY3Rpb24gaWkoaSx1LGMsbSl7aWYoZClyZXR1cm4gVGUoMTIsMSxpLHUsYyxtKX1mdW5jdGlvbiBhaShpKXtpZihkKXJldHVybiBUZSgxMywxLGkpfWZ1bmN0aW9uIHNpKGksdSl7aWYoZClyZXR1cm4gVGUoMTQsMSxpLHUpfWZ1bmN0aW9uIHVpKGksdSxjKXtpZihkKXJldHVybiBUZSgxNSwxLGksdSxjKX12YXIgZGksaHQsdnA9KCk9PnV0KFwiXCIpLFhlPWk9Pntmb3IodmFyIHU9XCJcIjtwZSgpW2k+Pj4wXTspdSs9ZGlbcGUoKVtpKys+Pj4wXV07cmV0dXJuIHV9LCRuPXt9LHhuPXt9LCRwPXt9O2Z1bmN0aW9uIGR0KGksdSxjPXt9KXtyZXR1cm4gZnVuY3Rpb24obSxnLHg9e30pe3ZhciBJPWcubmFtZTtpZighbSl0aHJvdyBuZXcgaHQoYHR5cGUgXCIke0l9XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKHhuLmhhc093blByb3BlcnR5KG0pKXtpZih4LlBkKXJldHVybjt0aHJvdyBuZXcgaHQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke0l9JyB0d2ljZWApfXhuW21dPWcsZGVsZXRlICRwW21dLCRuLmhhc093blByb3BlcnR5KG0pJiYoZz0kblttXSxkZWxldGUgJG5bbV0sZy5mb3JFYWNoKHo9PnooKSkpfShpLHUsYyl9dmFyIGxpPShpLHUsYyk9Pntzd2l0Y2godSl7Y2FzZSAxOnJldHVybiBjP209PlooKVttPj4+MF06bT0+cGUoKVttPj4+MF07Y2FzZSAyOnJldHVybiBjP209PmtlKClbbT4+PjE+Pj4wXTptPT5TZSgpW20+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBjP209PkQoKVttPj4+Mj4+PjBdOm09PlIoKVttPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gYz9tPT5XW20+Pj4zXTptPT5KW20+Pj4zXTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZWdlciB3aWR0aCAoJHt1fSk6ICR7aX1gKX19O2Z1bmN0aW9uIHhwKGksdSxjKXtjPj4+PTAsZHQoaT4+Pj0wLHtuYW1lOnU9WGUodT4+PjApLGZyb21XaXJlVHlwZTptPT5tLHRvV2lyZVR5cGU6ZnVuY3Rpb24obSxnKXtpZih0eXBlb2YgZyE9XCJiaWdpbnRcIiYmdHlwZW9mIGchPVwibnVtYmVyXCIpdGhyb3cgZz1nPT09bnVsbD9cIm51bGxcIjoobT10eXBlb2YgZyk9PVwib2JqZWN0XCJ8fG09PT1cImFycmF5XCJ8fG09PT1cImZ1bmN0aW9uXCI/Zy50b1N0cmluZygpOlwiXCIrZyxuZXcgVHlwZUVycm9yKGBDYW5ub3QgY29udmVydCBcIiR7Z31cIiB0byAke3RoaXMubmFtZX1gKTtyZXR1cm4gdHlwZW9mIGc9PVwibnVtYmVyXCImJihnPUJpZ0ludChnKSksZ30semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6bGkodSxjLHUuaW5kZXhPZihcInVcIik9PS0xKSxBZDpudWxsfSl9dmFyIGd0PTg7ZnVuY3Rpb24gU3AoaSx1LGMsbSl7ZHQoaT4+Pj0wLHtuYW1lOnU9WGUodT4+PjApLGZyb21XaXJlVHlwZTpmdW5jdGlvbihnKXtyZXR1cm4hIWd9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZyx4KXtyZXR1cm4geD9jOm19LHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZ1bmN0aW9uKGcpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShwZSgpW2c+Pj4wXSl9LEFkOm51bGx9KX12YXIgU249W10sbHQ9W107ZnVuY3Rpb24gVG4oaSl7OTwoaT4+Pj0wKSYmLS1sdFtpKzFdPT0wJiYobHRbaV09dm9pZCAwLFNuLnB1c2goaSkpfXZhciBSZT1pPT57aWYoIWkpdGhyb3cgbmV3IGh0KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIraSk7cmV0dXJuIGx0W2ldfSxXZT1pPT57c3dpdGNoKGkpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IHU9U24ucG9wKCl8fGx0Lmxlbmd0aDtyZXR1cm4gbHRbdV09aSxsdFt1KzFdPTEsdX19O2Z1bmN0aW9uIENuKGkpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShSKClbaT4+PjI+Pj4wXSl9dmFyIFRwPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOmk9Pnt2YXIgdT1SZShpKTtyZXR1cm4gVG4oaSksdX0sdG9XaXJlVHlwZTooaSx1KT0+V2UodSksemQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sQWQ6bnVsbH07ZnVuY3Rpb24gQ3AoaSl7cmV0dXJuIGR0KGk+Pj4wLFRwKX12YXIgSXA9KGksdSk9Pntzd2l0Y2godSl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoWSgpW2M+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShmZSgpW2M+Pj4zPj4+MF0pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7dX0pOiAke2l9YCl9fTtmdW5jdGlvbiBBcChpLHUsYyl7Yz4+Pj0wLGR0KGk+Pj49MCx7bmFtZTp1PVhlKHU+Pj4wKSxmcm9tV2lyZVR5cGU6bT0+bSx0b1dpcmVUeXBlOihtLGcpPT5nLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOklwKHUsYyksQWQ6bnVsbH0pfWZ1bmN0aW9uIGtwKGksdSxjLG0sZyl7aWYoaT4+Pj0wLGM+Pj49MCx1PVhlKHU+Pj4wKSxnPT09LTEmJihnPTQyOTQ5NjcyOTUpLGc9ej0+eixtPT09MCl7dmFyIHg9MzItOCpjO2c9ej0+ejw8eD4+Pnh9dmFyIEk9dS5pbmNsdWRlcyhcInVuc2lnbmVkXCIpP2Z1bmN0aW9uKHosQil7cmV0dXJuIEI+Pj4wfTpmdW5jdGlvbih6LEIpe3JldHVybiBCfTtkdChpLHtuYW1lOnUsZnJvbVdpcmVUeXBlOmcsdG9XaXJlVHlwZTpJLHpkOmd0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmxpKHUsYyxtIT09MCksQWQ6bnVsbH0pfWZ1bmN0aW9uIEVwKGksdSxjKXtmdW5jdGlvbiBtKHgpe3ZhciBJPVIoKVt4Pj4+Mj4+PjBdO3JldHVybiB4PVIoKVt4KzQ+Pj4yPj4+MF0sbmV3IGcoWigpLmJ1ZmZlcix4LEkpfXZhciBnPVtJbnQ4QXJyYXksVWludDhBcnJheSxJbnQxNkFycmF5LFVpbnQxNkFycmF5LEludDMyQXJyYXksVWludDMyQXJyYXksRmxvYXQzMkFycmF5LEZsb2F0NjRBcnJheSxCaWdJbnQ2NEFycmF5LEJpZ1VpbnQ2NEFycmF5XVt1XTtkdChpPj4+PTAse25hbWU6Yz1YZShjPj4+MCksZnJvbVdpcmVUeXBlOm0semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6bX0se1BkOiEwfSl9ZnVuY3Rpb24gUHAoaSx1KXtkdChpPj4+PTAse25hbWU6dT1YZSh1Pj4+MCksZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGMpe2Zvcih2YXIgbSxnPVIoKVtjPj4+Mj4+PjBdLHg9Yys0LEk9eCx6PTA7ejw9ZzsrK3ope3ZhciBCPXgrejt6IT1nJiZwZSgpW0I+Pj4wXSE9MHx8KEk9QWUoSSxCLUkpLG09PT12b2lkIDA/bT1JOihtKz1cIlxcMFwiLG0rPUkpLEk9QisxKX1yZXR1cm4gZXQoYyksbX0sdG9XaXJlVHlwZTpmdW5jdGlvbihjLG0pe20gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciYmKG09bmV3IFVpbnQ4QXJyYXkobSkpO3ZhciBnPXR5cGVvZiBtPT1cInN0cmluZ1wiO2lmKCEoZ3x8bSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fG0gaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8bSBpbnN0YW5jZW9mIEludDhBcnJheSkpdGhyb3cgbmV3IGh0KFwiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBzdGQ6OnN0cmluZ1wiKTt2YXIgeD1nP1lvKG0pOm0ubGVuZ3RoLEk9eXIoNCt4KzEpLHo9SSs0O2lmKFIoKVtJPj4+Mj4+PjBdPXgsZylCdChtLHoseCsxKTtlbHNlIGlmKGcpZm9yKGc9MDtnPHg7KytnKXt2YXIgQj1tLmNoYXJDb2RlQXQoZyk7aWYoMjU1PEIpdGhyb3cgZXQoSSksbmV3IGh0KFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpO3BlKClbeitnPj4+MF09Qn1lbHNlIGZvcihnPTA7Zzx4OysrZylwZSgpW3orZz4+PjBdPW1bZ107cmV0dXJuIGMhPT1udWxsJiZjLnB1c2goZXQsSSksSX0semQ6Z3QscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sQWQoYyl7ZXQoYyl9fSl9dmFyIGNpPXR5cGVvZiBUZXh0RGVjb2RlcjxcInVcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGYtMTZsZVwiKTp2b2lkIDAsenA9KGksdSk9Pntmb3IodmFyIGM9aT4+MSxtPWMrdS8yOyEoYz49bSkmJlNlKClbYz4+PjBdOykrK2M7aWYoMzI8KGM8PD0xKS1pJiZjaSlyZXR1cm4gY2kuZGVjb2RlKHBlKCkuc2xpY2UoaSxjKSk7Zm9yKGM9XCJcIixtPTA7IShtPj11LzIpOysrbSl7dmFyIGc9a2UoKVtpKzIqbT4+PjE+Pj4wXTtpZihnPT0wKWJyZWFrO2MrPVN0cmluZy5mcm9tQ2hhckNvZGUoZyl9cmV0dXJuIGN9LE9wPShpLHUsYyk9PntpZihjPz89MjE0NzQ4MzY0NywyPmMpcmV0dXJuIDA7dmFyIG09dTtjPShjLT0yKTwyKmkubGVuZ3RoP2MvMjppLmxlbmd0aDtmb3IodmFyIGc9MDtnPGM7KytnKXt2YXIgeD1pLmNoYXJDb2RlQXQoZyk7a2UoKVt1Pj4+MT4+PjBdPXgsdSs9Mn1yZXR1cm4ga2UoKVt1Pj4+MT4+PjBdPTAsdS1tfSxEcD1pPT4yKmkubGVuZ3RoLEJwPShpLHUpPT57Zm9yKHZhciBjPTAsbT1cIlwiOyEoYz49dS80KTspe3ZhciBnPUQoKVtpKzQqYz4+PjI+Pj4wXTtpZihnPT0wKWJyZWFrOysrYyw2NTUzNjw9Zz8oZy09NjU1MzYsbSs9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5NnxnPj4xMCw1NjMyMHwxMDIzJmcpKTptKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGcpfXJldHVybiBtfSxNcD0oaSx1LGMpPT57aWYodT4+Pj0wLGM/Pz0yMTQ3NDgzNjQ3LDQ+YylyZXR1cm4gMDt2YXIgbT11O2M9bStjLTQ7Zm9yKHZhciBnPTA7ZzxpLmxlbmd0aDsrK2cpe3ZhciB4PWkuY2hhckNvZGVBdChnKTtpZig1NTI5Njw9eCYmNTczNDM+PXgmJih4PTY1NTM2KygoMTAyMyZ4KTw8MTApfDEwMjMmaS5jaGFyQ29kZUF0KCsrZykpLEQoKVt1Pj4+Mj4+PjBdPXgsKHUrPTQpKzQ+YylicmVha31yZXR1cm4gRCgpW3U+Pj4yPj4+MF09MCx1LW19LFJwPWk9Pntmb3IodmFyIHU9MCxjPTA7YzxpLmxlbmd0aDsrK2Mpe3ZhciBtPWkuY2hhckNvZGVBdChjKTs1NTI5Njw9bSYmNTczNDM+PW0mJisrYyx1Kz00fXJldHVybiB1fTtmdW5jdGlvbiBVcChpLHUsYyl7aWYoaT4+Pj0wLHU+Pj49MCxjPVhlKGM+Pj49MCksdT09PTIpdmFyIG09enAsZz1PcCx4PURwLEk9ej0+U2UoKVt6Pj4+MT4+PjBdO2Vsc2UgdT09PTQmJihtPUJwLGc9TXAseD1ScCxJPXo9PlIoKVt6Pj4+Mj4+PjBdKTtkdChpLHtuYW1lOmMsZnJvbVdpcmVUeXBlOno9Pntmb3IodmFyIEIsTD1SKClbej4+PjI+Pj4wXSxxPXorNCxYPTA7WDw9TDsrK1gpe3ZhciB1ZT16KzQrWCp1O1ghPUwmJkkodWUpIT0wfHwocT1tKHEsdWUtcSksQj09PXZvaWQgMD9CPXE6KEIrPVwiXFwwXCIsQis9cSkscT11ZSt1KX1yZXR1cm4gZXQoeiksQn0sdG9XaXJlVHlwZTooeixCKT0+e2lmKHR5cGVvZiBCIT1cInN0cmluZ1wiKXRocm93IG5ldyBodChgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtjfWApO3ZhciBMPXgoQikscT15cig0K0wrdSk7cmV0dXJuIFIoKVtxPj4+Mj4+PjBdPUwvdSxnKEIscSs0LEwrdSkseiE9PW51bGwmJnoucHVzaChldCxxKSxxfSx6ZDpndCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixBZCh6KXtldCh6KX19KX1mdW5jdGlvbiBOcChpLHUpe2R0KGk+Pj49MCx7UWQ6ITAsbmFtZTp1PVhlKHU+Pj4wKSx6ZDowLGZyb21XaXJlVHlwZTooKT0+e30sdG9XaXJlVHlwZTooKT0+e319KX1mdW5jdGlvbiBWcChpKXtEbihpPj4+MCwhcywxLCFhLDEzMTA3MiwhMSksTG8oKX12YXIgSW49aT0+e2lmKCFlZSl0cnl7aWYoaSgpLCEoMDxtdCkpdHJ5e2Q/Qm4oQSk6X24oQSl9Y2F0Y2godSl7dSBpbnN0YW5jZW9mIGdufHx1PT1cInVud2luZFwifHxfKDAsdSl9fWNhdGNoKHUpe3UgaW5zdGFuY2VvZiBnbnx8dT09XCJ1bndpbmRcInx8XygwLHUpfX07ZnVuY3Rpb24gQW4oaSl7aT4+Pj0wLHR5cGVvZiBBdG9taWNzLmdlPT1cImZ1bmN0aW9uXCImJihBdG9taWNzLmdlKEQoKSxpPj4+MixpKS52YWx1ZS50aGVuKHVyKSxpKz0xMjgsQXRvbWljcy5zdG9yZShEKCksaT4+PjIsMSkpfXZhciB1cj0oKT0+e3ZhciBpPWdyKCk7aSYmKEFuKGkpLEluKFdpKSl9O2Z1bmN0aW9uIFdwKGksdSl7KGk+Pj49MCk9PXU+Pj4wP3NldFRpbWVvdXQodXIpOmQ/cG9zdE1lc3NhZ2Uoe0VkOmkseWQ6XCJjaGVja01haWxib3hcIn0pOihpPVN0W2ldKSYmaS5wb3N0TWVzc2FnZSh7eWQ6XCJjaGVja01haWxib3hcIn0pfXZhciBrbj1bXTtmdW5jdGlvbiBMcChpLHUsYyxtLGcpe2Zvcih1Pj4+PTAsbS89Mixrbi5sZW5ndGg9bSxjPWc+Pj4wPj4+MyxnPTA7ZzxtO2crKylrbltnXT1XW2MrMipnXT9XW2MrMipnKzFdOmZlKClbYysyKmcrMT4+PjBdO3JldHVybih1P2huW3VdOkJtW2ldKSguLi5rbil9dmFyIEdwPSgpPT57bXQ9MH07ZnVuY3Rpb24gSHAoaSl7aT4+Pj0wLGQ/cG9zdE1lc3NhZ2Uoe3lkOlwiY2xlYW51cFRocmVhZFwiLGVlOml9KTpXbyhTdFtpXSl9ZnVuY3Rpb24gRnAoaSl7fXZhciBkcj0oaSx1KT0+e3ZhciBjPXhuW2ldO2lmKGM9PT12b2lkIDApdGhyb3cgaT1CaShpKSxjPVhlKGkpLGV0KGkpLG5ldyBodChgJHt1fSBoYXMgdW5rbm93biB0eXBlICR7Y31gKTtyZXR1cm4gY30scGk9KGksdSxjKT0+e3ZhciBtPVtdO3JldHVybiBpPWkudG9XaXJlVHlwZShtLGMpLG0ubGVuZ3RoJiYoUigpW3U+Pj4yPj4+MF09V2UobSkpLGl9O2Z1bmN0aW9uIHFwKGksdSxjKXtyZXR1cm4gdT4+Pj0wLGM+Pj49MCxpPVJlKGk+Pj4wKSx1PWRyKHUsXCJlbXZhbDo6YXNcIikscGkodSxjLGkpfWZ1bmN0aW9uIEtwKGksdSl7cmV0dXJuIHU+Pj49MCxpPVJlKGk+Pj4wKSwodT1kcih1LFwiZW12YWw6OmFzXCIpKS50b1dpcmVUeXBlKG51bGwsaSl9dmFyIGxyPWk9Pnt0cnl7aSgpfWNhdGNoKHUpe3V0KHUpfX0seXQ9MCxKZT1udWxsLG1pPTAsY3I9W10sZmk9e30saGk9e30sanA9MCxFbj1udWxsLFpwPVtdO2Z1bmN0aW9uIGdpKGkpe3JldHVybiBmdW5jdGlvbih1KXtpZighZWUpe2lmKHl0PT09MCl7dmFyIGM9ITEsbT0hMTt1KChnPTApPT57aWYoIWVlJiYobWk9ZyxjPSEwLG0pKXt5dD0yLGxyKCgpPT5OYShKZSkpLHR5cGVvZiBNYWluTG9vcDxcInVcIiYmTWFpbkxvb3AuTWQmJk1haW5Mb29wLnJlc3VtZSgpLGc9ITE7dHJ5e3ZhciB4PWZ1bmN0aW9uKCl7dmFyIEI9RCgpW0plKzg+Pj4yPj4+MF07cmV0dXJuIEI9VVtoaVtCXV0sLS1tdCxCKCl9KCl9Y2F0Y2goQil7eD1CLGc9ITB9dmFyIEk9ITE7aWYoIUplKXt2YXIgej1Fbjt6JiYoRW49bnVsbCwoZz96LnJlamVjdDp6LnJlc29sdmUpKHgpLEk9ITApfWlmKGcmJiFJKXRocm93IHh9fSksbT0hMCxjfHwoeXQ9MSxKZT1mdW5jdGlvbigpe3ZhciBnPXlyKDY1NTQ4KSx4PWcrMTI7UigpW2c+Pj4yPj4+MF09eCxSKClbZys0Pj4+Mj4+PjBdPXgrNjU1MzYseD1jclswXTt2YXIgST1maVt4XTtyZXR1cm4gST09PXZvaWQgMCYmKEk9anArKyxmaVt4XT1JLGhpW0ldPXgpLHg9SSxEKClbZys4Pj4+Mj4+PjBdPXgsZ30oKSx0eXBlb2YgTWFpbkxvb3A8XCJ1XCImJk1haW5Mb29wLk1kJiZNYWluTG9vcC5wYXVzZSgpLGxyKCgpPT5SYShKZSkpKX1lbHNlIHl0PT09Mj8oeXQ9MCxscihWYSksZXQoSmUpLEplPW51bGwsWnAuZm9yRWFjaChJbikpOnV0KGBpbnZhbGlkIHN0YXRlOiAke3l0fWApO3JldHVybiBtaX19KHU9PntpKCkudGhlbih1KX0pfWZ1bmN0aW9uIFFwKGkpe3JldHVybiBpPj4+PTAsZ2koYXN5bmMoKT0+e3ZhciB1PWF3YWl0IFJlKGkpO3JldHVybiBXZSh1KX0pfXZhciBwcj1bXTtmdW5jdGlvbiBZcChpLHUsYyxtKXtyZXR1cm4gYz4+Pj0wLG0+Pj49MCwoaT1wcltpPj4+MF0pKG51bGwsdT1SZSh1Pj4+MCksYyxtKX12YXIgWHA9e30sbXI9aT0+e3ZhciB1PVhwW2ldO3JldHVybiB1PT09dm9pZCAwP1hlKGkpOnV9O2Z1bmN0aW9uIEpwKGksdSxjLG0sZyl7cmV0dXJuIGM+Pj49MCxtPj4+PTAsZz4+Pj0wLChpPXByW2k+Pj4wXSkodT1SZSh1Pj4+MCksdVtjPW1yKGMpXSxtLGcpfXZhciB5aT0oKT0+dHlwZW9mIGdsb2JhbFRoaXM9PVwib2JqZWN0XCI/Z2xvYmFsVGhpczpGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7ZnVuY3Rpb24gZW0oaSl7cmV0dXJuKGk+Pj49MCk9PTA/V2UoeWkoKSk6KGk9bXIoaSksV2UoeWkoKVtpXSkpfXZhciB0bT1pPT57dmFyIHU9cHIubGVuZ3RoO3JldHVybiBwci5wdXNoKGkpLHV9LHJtPShpLHUpPT57Zm9yKHZhciBjPUFycmF5KGkpLG09MDttPGk7KyttKWNbbV09ZHIoUigpW3UrNCptPj4+Mj4+PjBdLFwicGFyYW1ldGVyIFwiK20pO3JldHVybiBjfSxiaT0oaSx1KT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KHUsXCJuYW1lXCIse3ZhbHVlOml9KTtmdW5jdGlvbiBubShpLHUsYyl7dmFyIG09KHU9cm0oaSx1Pj4+MCkpLnNoaWZ0KCk7aS0tO3ZhciBnPWByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZnVuYywgZGVzdHJ1Y3RvcnNSZWYsIGFyZ3MpIHtcbmAseD0wLEk9W107Yz09PTAmJkkucHVzaChcIm9ialwiKTtmb3IodmFyIHo9W1wicmV0VHlwZVwiXSxCPVttXSxMPTA7TDxpOysrTClJLnB1c2goXCJhcmdcIitMKSx6LnB1c2goXCJhcmdUeXBlXCIrTCksQi5wdXNoKHVbTF0pLGcrPWAgIHZhciBhcmcke0x9ID0gYXJnVHlwZSR7TH0ucmVhZFZhbHVlRnJvbVBvaW50ZXIoYXJncyR7eD9cIitcIit4OlwiXCJ9KTtcbmAseCs9dVtMXS56ZDtyZXR1cm4gZys9YCAgdmFyIHJ2ID0gJHtjPT09MT9cIm5ldyBmdW5jXCI6XCJmdW5jLmNhbGxcIn0oJHtJLmpvaW4oXCIsIFwiKX0pO1xuYCxtLlFkfHwoei5wdXNoKFwiZW12YWxfcmV0dXJuVmFsdWVcIiksQi5wdXNoKHBpKSxnKz1gICByZXR1cm4gZW12YWxfcmV0dXJuVmFsdWUocmV0VHlwZSwgZGVzdHJ1Y3RvcnNSZWYsIHJ2KTtcbmApLHoucHVzaChnK2B9O1xuYCksaT1mdW5jdGlvbihxKXt2YXIgWD1GdW5jdGlvbjtpZighKFggaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIFh9IHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uYCk7dmFyIHVlPWJpKFgubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtyZXR1cm4gdWUucHJvdG90eXBlPVgucHJvdG90eXBlLHVlPW5ldyB1ZSwocT1YLmFwcGx5KHVlLHEpKWluc3RhbmNlb2YgT2JqZWN0P3E6dWV9KHopKC4uLkIpLGM9YG1ldGhvZENhbGxlcjwoJHt1Lm1hcChxPT5xLm5hbWUpLmpvaW4oXCIsIFwiKX0pID0+ICR7bS5uYW1lfT5gLHRtKGJpKGMsaSkpfWZ1bmN0aW9uIG9tKGkpe3JldHVybiBpPW1yKGk+Pj4wKSxXZShyW2ldKX1mdW5jdGlvbiBpbShpLHUpe3JldHVybiB1Pj4+PTAsaT1SZShpPj4+MCksdT1SZSh1KSxXZShpW3VdKX1mdW5jdGlvbiBhbShpKXs5PChpPj4+PTApJiYobHRbaSsxXSs9MSl9ZnVuY3Rpb24gc20oKXtyZXR1cm4gV2UoW10pfWZ1bmN0aW9uIHVtKGkpe2k9UmUoaT4+PjApO2Zvcih2YXIgdT1BcnJheShpLmxlbmd0aCksYz0wO2M8aS5sZW5ndGg7YysrKXVbY109aVtjXTtyZXR1cm4gV2UodSl9ZnVuY3Rpb24gZG0oaSl7cmV0dXJuIFdlKG1yKGk+Pj4wKSl9ZnVuY3Rpb24gbG0oKXtyZXR1cm4gV2Uoe30pfWZ1bmN0aW9uIGNtKGkpe2Zvcih2YXIgdT1SZShpPj4+PTApO3UubGVuZ3RoOyl7dmFyIGM9dS5wb3AoKTt1LnBvcCgpKGMpfVRuKGkpfWZ1bmN0aW9uIHBtKGksdSxjKXt1Pj4+PTAsYz4+Pj0wLGk9UmUoaT4+PjApLHU9UmUodSksYz1SZShjKSxpW3VdPWN9ZnVuY3Rpb24gbW0oaSx1KXtyZXR1cm4gdT4+Pj0wLGk9KGk9ZHIoaT4+PjAsXCJfZW12YWxfdGFrZV92YWx1ZVwiKSkucmVhZFZhbHVlRnJvbVBvaW50ZXIodSksV2UoaSl9ZnVuY3Rpb24gZm0oaSx1KXtpPS05MDA3MTk5MjU0NzQwOTkyPml8fDkwMDcxOTkyNTQ3NDA5OTI8aT9OYU46TnVtYmVyKGkpLHU+Pj49MCxpPW5ldyBEYXRlKDFlMyppKSxEKClbdT4+PjI+Pj4wXT1pLmdldFVUQ1NlY29uZHMoKSxEKClbdSs0Pj4+Mj4+PjBdPWkuZ2V0VVRDTWludXRlcygpLEQoKVt1Kzg+Pj4yPj4+MF09aS5nZXRVVENIb3VycygpLEQoKVt1KzEyPj4+Mj4+PjBdPWkuZ2V0VVRDRGF0ZSgpLEQoKVt1KzE2Pj4+Mj4+PjBdPWkuZ2V0VVRDTW9udGgoKSxEKClbdSsyMD4+PjI+Pj4wXT1pLmdldFVUQ0Z1bGxZZWFyKCktMTkwMCxEKClbdSsyND4+PjI+Pj4wXT1pLmdldFVUQ0RheSgpLGk9KGkuZ2V0VGltZSgpLURhdGUuVVRDKGkuZ2V0VVRDRnVsbFllYXIoKSwwLDEsMCwwLDAsMCkpLzg2NGU1fDAsRCgpW3UrMjg+Pj4yPj4+MF09aX12YXIgX2k9aT0+aSU0PT0wJiYoaSUxMDAhPTB8fGklNDAwPT0wKSx3aT1bMCwzMSw2MCw5MSwxMjEsMTUyLDE4MiwyMTMsMjQ0LDI3NCwzMDUsMzM1XSx2aT1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTtmdW5jdGlvbiBobShpLHUpe2k9LTkwMDcxOTkyNTQ3NDA5OTI+aXx8OTAwNzE5OTI1NDc0MDk5MjxpP05hTjpOdW1iZXIoaSksdT4+Pj0wLGk9bmV3IERhdGUoMWUzKmkpLEQoKVt1Pj4+Mj4+PjBdPWkuZ2V0U2Vjb25kcygpLEQoKVt1KzQ+Pj4yPj4+MF09aS5nZXRNaW51dGVzKCksRCgpW3UrOD4+PjI+Pj4wXT1pLmdldEhvdXJzKCksRCgpW3UrMTI+Pj4yPj4+MF09aS5nZXREYXRlKCksRCgpW3UrMTY+Pj4yPj4+MF09aS5nZXRNb250aCgpLEQoKVt1KzIwPj4+Mj4+PjBdPWkuZ2V0RnVsbFllYXIoKS0xOTAwLEQoKVt1KzI0Pj4+Mj4+PjBdPWkuZ2V0RGF5KCk7dmFyIGM9KF9pKGkuZ2V0RnVsbFllYXIoKSk/d2k6dmkpW2kuZ2V0TW9udGgoKV0raS5nZXREYXRlKCktMXwwO0QoKVt1KzI4Pj4+Mj4+PjBdPWMsRCgpW3UrMzY+Pj4yPj4+MF09LTYwKmkuZ2V0VGltZXpvbmVPZmZzZXQoKSxjPW5ldyBEYXRlKGkuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIG09bmV3IERhdGUoaS5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTtpPTB8KGMhPW0mJmkuZ2V0VGltZXpvbmVPZmZzZXQoKT09TWF0aC5taW4obSxjKSksRCgpW3UrMzI+Pj4yPj4+MF09aX1mdW5jdGlvbiBnbShpKXtpPj4+PTA7dmFyIHU9bmV3IERhdGUoRCgpW2krMjA+Pj4yPj4+MF0rMTkwMCxEKClbaSsxNj4+PjI+Pj4wXSxEKClbaSsxMj4+PjI+Pj4wXSxEKClbaSs4Pj4+Mj4+PjBdLEQoKVtpKzQ+Pj4yPj4+MF0sRCgpW2k+Pj4yPj4+MF0sMCksYz1EKClbaSszMj4+PjI+Pj4wXSxtPXUuZ2V0VGltZXpvbmVPZmZzZXQoKSxnPW5ldyBEYXRlKHUuZ2V0RnVsbFllYXIoKSw2LDEpLmdldFRpbWV6b25lT2Zmc2V0KCkseD1uZXcgRGF0ZSh1LmdldEZ1bGxZZWFyKCksMCwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9TWF0aC5taW4oeCxnKTtyZXR1cm4gMD5jP0QoKVtpKzMyPj4+Mj4+PjBdPSsoZyE9eCYmST09bSk6MDxjIT0oST09bSkmJihnPU1hdGgubWF4KHgsZyksdS5zZXRUaW1lKHUuZ2V0VGltZSgpKzZlNCooKDA8Yz9JOmcpLW0pKSksRCgpW2krMjQ+Pj4yPj4+MF09dS5nZXREYXkoKSxjPShfaSh1LmdldEZ1bGxZZWFyKCkpP3dpOnZpKVt1LmdldE1vbnRoKCldK3UuZ2V0RGF0ZSgpLTF8MCxEKClbaSsyOD4+PjI+Pj4wXT1jLEQoKVtpPj4+Mj4+PjBdPXUuZ2V0U2Vjb25kcygpLEQoKVtpKzQ+Pj4yPj4+MF09dS5nZXRNaW51dGVzKCksRCgpW2krOD4+PjI+Pj4wXT11LmdldEhvdXJzKCksRCgpW2krMTI+Pj4yPj4+MF09dS5nZXREYXRlKCksRCgpW2krMTY+Pj4yPj4+MF09dS5nZXRNb250aCgpLEQoKVtpKzIwPj4+Mj4+PjBdPXUuZ2V0WWVhcigpLGk9dS5nZXRUaW1lKCksQmlnSW50KGlzTmFOKGkpPy0xOmkvMWUzKX1mdW5jdGlvbiAkaShpLHUsYyxtLGcseCxJKXtyZXR1cm4gZD9UZSgxNiwxLGksdSxjLG0sZyx4LEkpOi01Mn1mdW5jdGlvbiB4aShpLHUsYyxtLGcseCl7aWYoZClyZXR1cm4gVGUoMTcsMSxpLHUsYyxtLGcseCl9dmFyIHF0PXt9LHltPSgpPT5wZXJmb3JtYW5jZS50aW1lT3JpZ2luK3BlcmZvcm1hbmNlLm5vdygpO2Z1bmN0aW9uIFNpKGksdSl7aWYoZClyZXR1cm4gVGUoMTgsMSxpLHUpO2lmKHF0W2ldJiYoY2xlYXJUaW1lb3V0KHF0W2ldLmlkKSxkZWxldGUgcXRbaV0pLCF1KXJldHVybiAwO3ZhciBjPXNldFRpbWVvdXQoKCk9PntkZWxldGUgcXRbaV0sSW4oKCk9PlZpKGkscGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKSkpfSx1KTtyZXR1cm4gcXRbaV09e2lkOmMsa2U6dX0sMH1mdW5jdGlvbiBibShpLHUsYyxtKXtpPj4+PTAsdT4+Pj0wLGM+Pj49MCxtPj4+PTA7dmFyIGc9bmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLHg9bmV3IERhdGUoZywwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7Zz1uZXcgRGF0ZShnLDYsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKTt2YXIgST1NYXRoLm1heCh4LGcpO1IoKVtpPj4+Mj4+PjBdPTYwKkksRCgpW3U+Pj4yPj4+MF09Kyh4IT1nKSxpPSh1PXo9Pnt2YXIgQj1NYXRoLmFicyh6KTtyZXR1cm5gVVRDJHswPD16P1wiLVwiOlwiK1wifSR7U3RyaW5nKE1hdGguZmxvb3IoQi82MCkpLnBhZFN0YXJ0KDIsXCIwXCIpfSR7U3RyaW5nKEIlNjApLnBhZFN0YXJ0KDIsXCIwXCIpfWB9KSh4KSx1PXUoZyksZzx4PyhCdChpLGMsMTcpLEJ0KHUsbSwxNykpOihCdChpLG0sMTcpLEJ0KHUsYywxNykpfXZhciBfbT0oKT0+RGF0ZS5ub3coKSx3bT0xO2Z1bmN0aW9uIHZtKGksdSxjKXtpZighKDA8PWkmJjM+PWkpKXJldHVybiAyODtpZihpPT09MClpPURhdGUubm93KCk7ZWxzZXtpZighd20pcmV0dXJuIDUyO2k9cGVyZm9ybWFuY2UudGltZU9yaWdpbitwZXJmb3JtYW5jZS5ub3coKX1yZXR1cm4gV1tjPj4+MD4+PjNdPUJpZ0ludChNYXRoLnJvdW5kKDFlNippKSksMH12YXIgUG49W10sVGk9KGksdSk9PntQbi5sZW5ndGg9MDtmb3IodmFyIGM7Yz1wZSgpW2krKz4+PjBdOyl7dmFyIG09YyE9MTA1O3UrPShtJj1jIT0xMTIpJiZ1JTg/NDowLFBuLnB1c2goYz09MTEyP1IoKVt1Pj4+Mj4+PjBdOmM9PTEwNj9XW3U+Pj4zXTpjPT0xMDU/RCgpW3U+Pj4yPj4+MF06ZmUoKVt1Pj4+Mz4+PjBdKSx1Kz1tPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uICRtKGksdSxjKXtyZXR1cm4gaT4+Pj0wLHU9VGkodT4+PjAsYz4+PjApLGhuW2ldKC4uLnUpfWZ1bmN0aW9uIHhtKGksdSxjKXtyZXR1cm4gaT4+Pj0wLHU9VGkodT4+PjAsYz4+PjApLGhuW2ldKC4uLnUpfXZhciBTbT0oKT0+e307ZnVuY3Rpb24gVG0oaSx1KXtyZXR1cm4gdihBZShpPj4+MCx1Pj4+MCkpfXZhciBDbT0oKT0+e3Rocm93IG10Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEltKCl7cmV0dXJuIDQyOTQ5MDE3NjB9dmFyIEFtPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiBrbSgpe3JldHVybiB1dChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gRW0oaSl7aT4+Pj0wO3ZhciB1PXBlKCkubGVuZ3RoO2lmKGk8PXV8fDQyOTQ5MDE3NjA8aSlyZXR1cm4hMTtmb3IodmFyIGM9MTs0Pj1jO2MqPTIpe3ZhciBtPXUqKDErLjIvYyk7bT1NYXRoLm1pbihtLGkrMTAwNjYzMjk2KTtlOnttPShNYXRoLm1pbig0Mjk0OTAxNzYwLDY1NTM2Kk1hdGguY2VpbChNYXRoLm1heChpLG0pLzY1NTM2KSktVC5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzZ8MDt0cnl7VC5ncm93KG0pLGJlKCk7dmFyIGc9MTticmVhayBlfWNhdGNoe31nPXZvaWQgMH1pZihnKXJldHVybiEwfXJldHVybiExfXZhciBmcj0oKT0+KHV0KFwiQ2Fubm90IHVzZSBjb252ZXJ0RnJhbWVUb1BDIChuZWVkZWQgYnkgX19idWlsdGluX3JldHVybl9hZGRyZXNzKSB3aXRob3V0IC1zVVNFX09GRlNFVF9DT05WRVJURVJcIiksMCksTXQ9e30sQ2k9aT0+e2kuZm9yRWFjaCh1PT57dmFyIGM9ZnIoKTtjJiYoTXRbY109dSl9KX07ZnVuY3Rpb24gUG0oKXt2YXIgaT1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCk7cmV0dXJuIGlbMF09PVwiRXJyb3JcIiYmaS5zaGlmdCgpLENpKGkpLE10LktkPWZyKCksTXQuYWU9aSxNdC5LZH1mdW5jdGlvbiB6bShpLHUsYyl7aWYoaT4+Pj0wLHU+Pj49MCxNdC5LZD09aSl2YXIgbT1NdC5hZTtlbHNlKG09RXJyb3IoKS5zdGFjay50b1N0cmluZygpLnNwbGl0KGBcbmApKVswXT09XCJFcnJvclwiJiZtLnNoaWZ0KCksQ2kobSk7Zm9yKHZhciBnPTM7bVtnXSYmZnIoKSE9aTspKytnO2ZvcihpPTA7aTxjJiZtW2krZ107KytpKUQoKVt1KzQqaT4+PjI+Pj4wXT1mcigpO3JldHVybiBpfXZhciB6bixPbj17fSxJaT0oKT0+e2lmKCF6bil7dmFyIGksdT17VVNFUjpcIndlYl91c2VyXCIsTE9HTkFNRTpcIndlYl91c2VyXCIsUEFUSDpcIi9cIixQV0Q6XCIvXCIsSE9NRTpcIi9ob21lL3dlYl91c2VyXCIsTEFORzoodHlwZW9mIG5hdmlnYXRvcj09XCJvYmplY3RcIiYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8XCJDXCIpLnJlcGxhY2UoXCItXCIsXCJfXCIpK1wiLlVURi04XCIsXzpcIi4vdGhpcy5wcm9ncmFtXCJ9O2ZvcihpIGluIE9uKU9uW2ldPT09dm9pZCAwP2RlbGV0ZSB1W2ldOnVbaV09T25baV07dmFyIGM9W107Zm9yKGkgaW4gdSljLnB1c2goYCR7aX09JHt1W2ldfWApO3puPWN9cmV0dXJuIHpufTtmdW5jdGlvbiBBaShpLHUpe2lmKGQpcmV0dXJuIFRlKDE5LDEsaSx1KTtpPj4+PTAsdT4+Pj0wO3ZhciBjPTA7cmV0dXJuIElpKCkuZm9yRWFjaCgobSxnKT0+e3ZhciB4PXUrYztmb3IoZz1SKClbaSs0Kmc+Pj4yPj4+MF09eCx4PTA7eDxtLmxlbmd0aDsrK3gpWigpW2crKz4+PjBdPW0uY2hhckNvZGVBdCh4KTtaKClbZz4+PjBdPTAsYys9bS5sZW5ndGgrMX0pLDB9ZnVuY3Rpb24ga2koaSx1KXtpZihkKXJldHVybiBUZSgyMCwxLGksdSk7aT4+Pj0wLHU+Pj49MDt2YXIgYz1JaSgpO1IoKVtpPj4+Mj4+PjBdPWMubGVuZ3RoO3ZhciBtPTA7cmV0dXJuIGMuZm9yRWFjaChnPT5tKz1nLmxlbmd0aCsxKSxSKClbdT4+PjI+Pj4wXT1tLDB9ZnVuY3Rpb24gRWkoaSl7cmV0dXJuIGQ/VGUoMjEsMSxpKTo1Mn1mdW5jdGlvbiBQaShpLHUsYyxtKXtyZXR1cm4gZD9UZSgyMiwxLGksdSxjLG0pOjUyfWZ1bmN0aW9uIHppKGksdSxjLG0pe3JldHVybiBkP1RlKDIzLDEsaSx1LGMsbSk6NzB9dmFyIE9tPVtudWxsLFtdLFtdXTtmdW5jdGlvbiBPaShpLHUsYyxtKXtpZihkKXJldHVybiBUZSgyNCwxLGksdSxjLG0pO3U+Pj49MCxjPj4+PTAsbT4+Pj0wO2Zvcih2YXIgZz0wLHg9MDt4PGM7eCsrKXt2YXIgST1SKClbdT4+PjI+Pj4wXSx6PVIoKVt1KzQ+Pj4yPj4+MF07dSs9ODtmb3IodmFyIEI9MDtCPHo7QisrKXt2YXIgTD1wZSgpW0krQj4+PjBdLHE9T21baV07TD09PTB8fEw9PT0xMD8oKGk9PT0xPyQ6dikoam8ocSkpLHEubGVuZ3RoPTApOnEucHVzaChMKX1nKz16fXJldHVybiBSKClbbT4+PjI+Pj4wXT1nLDB9ZnVuY3Rpb24gRG0oaSl7cmV0dXJuIGk+Pj4wfWR8fGZ1bmN0aW9uKCl7Zm9yKHZhciBpPXIubnVtVGhyZWFkcy0xO2ktLTspSG8oKTt5bi51bnNoaWZ0KCgpPT57eHQrKyxmdW5jdGlvbih1KXtkP3UoKTpQcm9taXNlLmFsbChmdC5tYXAoR28pKS50aGVuKHUpfSgoKT0+Qm8oKSl9KX0oKTtmb3IodmFyIERpPUFycmF5KDI1NiksaHI9MDsyNTY+aHI7KytocilEaVtocl09U3RyaW5nLmZyb21DaGFyQ29kZShocik7ZGk9RGksaHQ9ci5CaW5kaW5nRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihpKXtzdXBlcihpKSx0aGlzLm5hbWU9XCJCaW5kaW5nRXJyb3JcIn19LHIuSW50ZXJuYWxFcnJvcj1jbGFzcyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKGkpe3N1cGVyKGkpLHRoaXMubmFtZT1cIkludGVybmFsRXJyb3JcIn19LGx0LnB1c2goMCwxLHZvaWQgMCwxLG51bGwsMSwhMCwxLCExLDEpLHIuY291bnRfZW12YWxfaGFuZGxlcz0oKT0+bHQubGVuZ3RoLzItNS1Tbi5sZW5ndGg7dmFyIFUsQm09W2JuLE5vLEZvLFpvLFFvLFhvLEpvLGVpLHRpLHJpLG5pLG9pLGlpLGFpLHNpLHVpLCRpLHhpLFNpLEFpLGtpLEVpLFBpLHppLE9pXTsoYXN5bmMgZnVuY3Rpb24oKXtmdW5jdGlvbiBpKG0sZyl7cmV0dXJuIFU9bS5leHBvcnRzLFU9ZnVuY3Rpb24oKXt2YXIgeD1VLEk9e307Zm9yKGxldFt6LEJdb2YgT2JqZWN0LmVudHJpZXMoeCkpSVt6XT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e2NyLnB1c2goeik7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7ZWV8fChjci5wb3AoKSxKZSYmeXQ9PT0xJiZjci5sZW5ndGg9PT0wJiYoeXQ9MCxtdCs9MSxscihVYSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLmxlKCkpKX19OkI7cmV0dXJuIEl9KCksVT1mdW5jdGlvbigpe3ZhciB4PVUsST1CPT5MPT5CKEwpPj4+MCx6PUI9PigpPT5CKCk+Pj4wO3JldHVybih4PU9iamVjdC5hc3NpZ24oe30seCkpLkNiPUkoeC5DYikseC5mYz16KHguZmMpLHguaWM9SSh4LmljKSx4LnZjPUkoeC52YykseC53Yz16KHgud2MpLHguQWM9SSh4LkFjKSx4fSgpLFZvLnB1c2goVS5qYyksQz1nLEJvKCksVX14dCsrO3ZhciB1PU1vKCk7aWYoci5pbnN0YW50aWF0ZVdhc20pcmV0dXJuIG5ldyBQcm9taXNlKG09PntyLmluc3RhbnRpYXRlV2FzbSh1LChnLHgpPT57aShnLHgpLG0oZy5leHBvcnRzKX0pfSk7aWYoZClyZXR1cm4gbmV3IFByb21pc2UobT0+e0ZlPWc9Pnt2YXIgeD1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UoZyxNbygpKTttKGkoeCxnKSl9fSk7R3Q/Pz1yLmxvY2F0ZUZpbGU/ci5sb2NhdGVGaWxlP3IubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsYik6YitcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmO3RyeXt2YXIgYz1hd2FpdCBhc3luYyBmdW5jdGlvbihtKXt2YXIgZz1HdDtpZighUSYmdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nPT1cImZ1bmN0aW9uXCImJiFsZShnKSl0cnl7dmFyIHg9ZmV0Y2goZyx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHgsbSl9Y2F0Y2goSSl7dihgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7SX1gKSx2KFwiZmFsbGluZyBiYWNrIHRvIEFycmF5QnVmZmVyIGluc3RhbnRpYXRpb25cIil9cmV0dXJuIGFzeW5jIGZ1bmN0aW9uKEkseil7dHJ5e3ZhciBCPWF3YWl0IGFzeW5jIGZ1bmN0aW9uKEwpe2lmKCFRKXRyeXt2YXIgcT1hd2FpdCBmKEwpO3JldHVybiBuZXcgVWludDhBcnJheShxKX1jYXRjaHt9aWYoTD09R3QmJlEpTD1uZXcgVWludDhBcnJheShRKTtlbHNle2lmKCFoKXRocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwiO0w9aChMKX1yZXR1cm4gTH0oSSk7cmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKEIseil9Y2F0Y2goTCl7dihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtMfWApLHV0KEwpfX0oZyxtKX0odSk7cmV0dXJuIGkoYy5pbnN0YW5jZSxjLm1vZHVsZSl9Y2F0Y2gobSl7cmV0dXJuIG4obSksUHJvbWlzZS5yZWplY3QobSl9fSkoKTt2YXIgQmk9aT0+KEJpPVUuQ2IpKGkpLE1pPSgpPT4oTWk9VS5EYikoKTtyLl9PcnRJbml0PShpLHUpPT4oci5fT3J0SW5pdD1VLkViKShpLHUpLHIuX09ydEdldExhc3RFcnJvcj0oaSx1KT0+KHIuX09ydEdldExhc3RFcnJvcj1VLkZiKShpLHUpLHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPShpLHUsYyxtLGcseCxJLHosQixMKT0+KHIuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zPVUuR2IpKGksdSxjLG0sZyx4LEkseixCLEwpLHIuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPShpLHUpPT4oci5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXI9VS5IYikoaSx1KSxyLl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9KGksdSxjKT0+KHIuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZT1VLkliKShpLHUsYyksci5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PShpLHUsYyk9PihyLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnk9VS5KYikoaSx1LGMpLHIuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1pPT4oci5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zPVUuS2IpKGkpLHIuX09ydENyZWF0ZVNlc3Npb249KGksdSxjKT0+KHIuX09ydENyZWF0ZVNlc3Npb249VS5MYikoaSx1LGMpLHIuX09ydFJlbGVhc2VTZXNzaW9uPWk9PihyLl9PcnRSZWxlYXNlU2Vzc2lvbj1VLk1iKShpKSxyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PShpLHUsYyk9PihyLl9PcnRHZXRJbnB1dE91dHB1dENvdW50PVUuTmIpKGksdSxjKSxyLl9PcnRHZXRJbnB1dE5hbWU9KGksdSk9PihyLl9PcnRHZXRJbnB1dE5hbWU9VS5PYikoaSx1KSxyLl9PcnRHZXRPdXRwdXROYW1lPShpLHUpPT4oci5fT3J0R2V0T3V0cHV0TmFtZT1VLlBiKShpLHUpLHIuX09ydEZyZWU9aT0+KHIuX09ydEZyZWU9VS5RYikoaSksci5fT3J0Q3JlYXRlVGVuc29yPShpLHUsYyxtLGcseCk9PihyLl9PcnRDcmVhdGVUZW5zb3I9VS5SYikoaSx1LGMsbSxnLHgpLHIuX09ydEdldFRlbnNvckRhdGE9KGksdSxjLG0sZyk9PihyLl9PcnRHZXRUZW5zb3JEYXRhPVUuU2IpKGksdSxjLG0sZyksci5fT3J0UmVsZWFzZVRlbnNvcj1pPT4oci5fT3J0UmVsZWFzZVRlbnNvcj1VLlRiKShpKSxyLl9PcnRDcmVhdGVSdW5PcHRpb25zPShpLHUsYyxtKT0+KHIuX09ydENyZWF0ZVJ1bk9wdGlvbnM9VS5VYikoaSx1LGMsbSksci5fT3J0QWRkUnVuQ29uZmlnRW50cnk9KGksdSxjKT0+KHIuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PVUuVmIpKGksdSxjKSxyLl9PcnRSZWxlYXNlUnVuT3B0aW9ucz1pPT4oci5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9VS5XYikoaSksci5fT3J0Q3JlYXRlQmluZGluZz1pPT4oci5fT3J0Q3JlYXRlQmluZGluZz1VLlhiKShpKSxyLl9PcnRCaW5kSW5wdXQ9KGksdSxjKT0+KHIuX09ydEJpbmRJbnB1dD1VLlliKShpLHUsYyksci5fT3J0QmluZE91dHB1dD0oaSx1LGMsbSk9PihyLl9PcnRCaW5kT3V0cHV0PVUuWmIpKGksdSxjLG0pLHIuX09ydENsZWFyQm91bmRPdXRwdXRzPWk9PihyLl9PcnRDbGVhckJvdW5kT3V0cHV0cz1VLl9iKShpKSxyLl9PcnRSZWxlYXNlQmluZGluZz1pPT4oci5fT3J0UmVsZWFzZUJpbmRpbmc9VS4kYikoaSksci5fT3J0UnVuV2l0aEJpbmRpbmc9KGksdSxjLG0sZyk9PihyLl9PcnRSdW5XaXRoQmluZGluZz1VLmFjKShpLHUsYyxtLGcpLHIuX09ydFJ1bj0oaSx1LGMsbSxnLHgsSSx6KT0+KHIuX09ydFJ1bj1VLmJjKShpLHUsYyxtLGcseCxJLHopLHIuX09ydEVuZFByb2ZpbGluZz1pPT4oci5fT3J0RW5kUHJvZmlsaW5nPVUuY2MpKGkpLHIuX0pzZXBPdXRwdXQ9KGksdSxjKT0+KHIuX0pzZXBPdXRwdXQ9VS5kYykoaSx1LGMpLHIuX0pzZXBHZXROb2RlTmFtZT1pPT4oci5fSnNlcEdldE5vZGVOYW1lPVUuZWMpKGkpO3ZhciBncj0oKT0+KGdyPVUuZmMpKCksZXQ9ci5fZnJlZT1pPT4oZXQ9ci5fZnJlZT1VLmdjKShpKSx5cj1yLl9tYWxsb2M9aT0+KHlyPXIuX21hbGxvYz1VLmljKShpKSxEbj0oaSx1LGMsbSxnLHgpPT4oRG49VS5rYykoaSx1LGMsbSxnLHgpLFJpPSgpPT4oUmk9VS5sYykoKSxVaT0oaSx1LGMsbSxnKT0+KFVpPVUubWMpKGksdSxjLG0sZyksTmk9aT0+KE5pPVUubmMpKGkpLEJuPWk9PihCbj1VLm9jKShpKSxWaT0oaSx1KT0+KFZpPVUucGMpKGksdSksV2k9KCk9PihXaT1VLnFjKSgpLHNlPShpLHUpPT4oc2U9VS5yYykoaSx1KSxLdD1pPT4oS3Q9VS5zYykoaSksTGk9KGksdSk9PihMaT1VLnRjKShpLHUpLG9lPWk9PihvZT1VLnVjKShpKSxNbj1pPT4oTW49VS52YykoaSksaWU9KCk9PihpZT1VLndjKSgpLEdpPWk9PihHaT1VLnhjKShpKSxIaT1pPT4oSGk9VS55YykoaSksRmk9KGksdSxjKT0+KEZpPVUuemMpKGksdSxjKSxxaT1pPT4ocWk9VS5BYykoaSksS2k9ci5keW5DYWxsX2lpaT0oaSx1LGMpPT4oS2k9ci5keW5DYWxsX2lpaT1VLkJjKShpLHUsYyksamk9ci5keW5DYWxsX3ZpPShpLHUpPT4oamk9ci5keW5DYWxsX3ZpPVUuQ2MpKGksdSksUm49ci5keW5DYWxsX2lpPShpLHUpPT4oUm49ci5keW5DYWxsX2lpPVUuRGMpKGksdSksWmk9ci5keW5DYWxsX3ZpaT0oaSx1LGMpPT4oWmk9ci5keW5DYWxsX3ZpaT1VLkVjKShpLHUsYyksUWk9ci5keW5DYWxsX2lpaWk9KGksdSxjLG0pPT4oUWk9ci5keW5DYWxsX2lpaWk9VS5GYykoaSx1LGMsbSksWWk9ci5keW5DYWxsX3ZpaWk9KGksdSxjLG0pPT4oWWk9ci5keW5DYWxsX3ZpaWk9VS5HYykoaSx1LGMsbSksWGk9ci5keW5DYWxsX2lpaWlpPShpLHUsYyxtLGcpPT4oWGk9ci5keW5DYWxsX2lpaWlpPVUuSGMpKGksdSxjLG0sZyksSmk9ci5keW5DYWxsX3ZpaWlpPShpLHUsYyxtLGcpPT4oSmk9ci5keW5DYWxsX3ZpaWlpPVUuSWMpKGksdSxjLG0sZyksZWE9ci5keW5DYWxsX3ZpaWlpaWk9KGksdSxjLG0sZyx4LEkpPT4oZWE9ci5keW5DYWxsX3ZpaWlpaWk9VS5KYykoaSx1LGMsbSxnLHgsSSksdGE9ci5keW5DYWxsX3ZpaWlpaWlpPShpLHUsYyxtLGcseCxJLHopPT4odGE9ci5keW5DYWxsX3ZpaWlpaWlpPVUuS2MpKGksdSxjLG0sZyx4LEkseikscmE9ci5keW5DYWxsX2ppPShpLHUpPT4ocmE9ci5keW5DYWxsX2ppPVUuTGMpKGksdSksbmE9ci5keW5DYWxsX3Y9aT0+KG5hPXIuZHluQ2FsbF92PVUuTWMpKGkpLG9hPXIuZHluQ2FsbF92aWlpaWk9KGksdSxjLG0sZyx4KT0+KG9hPXIuZHluQ2FsbF92aWlpaWk9VS5OYykoaSx1LGMsbSxnLHgpLGlhPXIuZHluQ2FsbF9pPWk9PihpYT1yLmR5bkNhbGxfaT1VLk9jKShpKSxhYT1yLmR5bkNhbGxfZmlpPShpLHUsYyk9PihhYT1yLmR5bkNhbGxfZmlpPVUuUGMpKGksdSxjKSxzYT1yLmR5bkNhbGxfdmlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQik9PihzYT1yLmR5bkNhbGxfdmlpaWlpaWlpPVUuUWMpKGksdSxjLG0sZyx4LEkseixCKSx1YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSk9Pih1YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWk9VS5SYykoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKSxkYT1yLmR5bkNhbGxfamlpaT0oaSx1LGMsbSk9PihkYT1yLmR5bkNhbGxfamlpaT1VLlNjKShpLHUsYyxtKSxsYT1yLmR5bkNhbGxfZGlpPShpLHUsYyk9PihsYT1yLmR5bkNhbGxfZGlpPVUuVGMpKGksdSxjKSxjYT1yLmR5bkNhbGxfdmlpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIsTCk9PihjYT1yLmR5bkNhbGxfdmlpaWlpaWlpaT1VLlVjKShpLHUsYyxtLGcseCxJLHosQixMKSxwYT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpPShpLHUsYyxtLGcseCxJLHosQixMLHEsWCk9PihwYT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpPVUuVmMpKGksdSxjLG0sZyx4LEkseixCLEwscSxYKSxtYT1yLmR5bkNhbGxfaWlpaWlpPShpLHUsYyxtLGcseCk9PihtYT1yLmR5bkNhbGxfaWlpaWlpPVUuV2MpKGksdSxjLG0sZyx4KSxmYT1yLmR5bkNhbGxfaWlqPShpLHUsYyk9PihmYT1yLmR5bkNhbGxfaWlqPVUuWGMpKGksdSxjKSxoYT1yLmR5bkNhbGxfaWlpaWlpaWlpaT0oaSx1LGMsbSxnLHgsSSx6LEIsTCk9PihoYT1yLmR5bkNhbGxfaWlpaWlpaWlpaT1VLlljKShpLHUsYyxtLGcseCxJLHosQixMKSxnYT1yLmR5bkNhbGxfaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSk9PihnYT1yLmR5bkNhbGxfaWlpaWlpaWlpaWk9VS5aYykoaSx1LGMsbSxnLHgsSSx6LEIsTCxxKSx5YT1yLmR5bkNhbGxfdmlqPShpLHUsYyk9Pih5YT1yLmR5bkNhbGxfdmlqPVUuX2MpKGksdSxjKSxiYT1yLmR5bkNhbGxfaWlpZj0oaSx1LGMsbSk9PihiYT1yLmR5bkNhbGxfaWlpZj1VLiRjKShpLHUsYyxtKSxfYT1yLmR5bkNhbGxfaWlpaj0oaSx1LGMsbSk9PihfYT1yLmR5bkNhbGxfaWlpaj1VLmFkKShpLHUsYyxtKSx3YT1yLmR5bkNhbGxfZmlpaT0oaSx1LGMsbSk9Pih3YT1yLmR5bkNhbGxfZmlpaT1VLmJkKShpLHUsYyxtKSx2YT1yLmR5bkNhbGxfdmlpaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlLCRlKT0+KHZhPXIuZHluQ2FsbF92aWlpaWlpaWlpaWlpaT1VLmNkKShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSksJGE9ci5keW5DYWxsX3ZqaWlpPShpLHUsYyxtLGcpPT4oJGE9ci5keW5DYWxsX3ZqaWlpPVUuZGQpKGksdSxjLG0sZykseGE9ci5keW5DYWxsX3ZpZj0oaSx1LGMpPT4oeGE9ci5keW5DYWxsX3ZpZj1VLmVkKShpLHUsYyksU2E9ci5keW5DYWxsX2lpaWlpaWk9KGksdSxjLG0sZyx4LEkpPT4oU2E9ci5keW5DYWxsX2lpaWlpaWk9VS5mZCkoaSx1LGMsbSxnLHgsSSksVGE9ci5keW5DYWxsX2lpaWlqPShpLHUsYyxtLGcpPT4oVGE9ci5keW5DYWxsX2lpaWlqPVUuZ2QpKGksdSxjLG0sZyksQ2E9ci5keW5DYWxsX2lpaWlpaWlpPShpLHUsYyxtLGcseCxJLHopPT4oQ2E9ci5keW5DYWxsX2lpaWlpaWlpPVUuaGQpKGksdSxjLG0sZyx4LEkseiksSWE9ci5keW5DYWxsX3ZpaWlpaWlpaWlpaWk9KGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlKT0+KElhPXIuZHluQ2FsbF92aWlpaWlpaWlpaWlpPVUuaWQpKGksdSxjLG0sZyx4LEkseixCLEwscSxYLHVlKSxBYT1yLmR5bkNhbGxfZGlpaT0oaSx1LGMsbSk9PihBYT1yLmR5bkNhbGxfZGlpaT1VLmpkKShpLHUsYyxtKSxrYT1yLmR5bkNhbGxfamlpaWk9KGksdSxjLG0sZyk9PihrYT1yLmR5bkNhbGxfamlpaWk9VS5rZCkoaSx1LGMsbSxnKSxFYT1yLmR5bkNhbGxfdmlpaWo9KGksdSxjLG0sZyk9PihFYT1yLmR5bkNhbGxfdmlpaWo9VS5sZCkoaSx1LGMsbSxnKSxQYT1yLmR5bkNhbGxfZmlpaWk9KGksdSxjLG0sZyk9PihQYT1yLmR5bkNhbGxfZmlpaWk9VS5tZCkoaSx1LGMsbSxnKSx6YT1yLmR5bkNhbGxfdmlpaWY9KGksdSxjLG0sZyk9Pih6YT1yLmR5bkNhbGxfdmlpaWY9VS5uZCkoaSx1LGMsbSxnKSxPYT1yLmR5bkNhbGxfZGlpaWk9KGksdSxjLG0sZyk9PihPYT1yLmR5bkNhbGxfZGlpaWk9VS5vZCkoaSx1LGMsbSxnKSxEYT1yLmR5bkNhbGxfdmlpaWQ9KGksdSxjLG0sZyk9PihEYT1yLmR5bkNhbGxfdmlpaWQ9VS5wZCkoaSx1LGMsbSxnKSxCYT1yLmR5bkNhbGxfaWlpaWppaT0oaSx1LGMsbSxnLHgsSSk9PihCYT1yLmR5bkNhbGxfaWlpaWppaT1VLnFkKShpLHUsYyxtLGcseCxJKSxNYT1yLmR5bkNhbGxfaWlpaWlpaj0oaSx1LGMsbSxnLHgsSSk9PihNYT1yLmR5bkNhbGxfaWlpaWlpaj1VLnJkKShpLHUsYyxtLGcseCxJKSxSYT1pPT4oUmE9VS5zZCkoaSksVWE9KCk9PihVYT1VLnRkKSgpLE5hPWk9PihOYT1VLnVkKShpKSxWYT0oKT0+KFZhPVUudmQpKCk7ZnVuY3Rpb24gTW0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e1ppKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gUm0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3JldHVybiBLaShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIFVtKGksdSl7dmFyIGM9aWUoKTt0cnl7amkoaSx1KX1jYXRjaChtKXtpZihvZShjKSxtIT09bSswKXRocm93IG07c2UoMSwwKX19ZnVuY3Rpb24gTm0oaSx1KXt2YXIgYz1pZSgpO3RyeXtyZXR1cm4gUm4oaSx1KX1jYXRjaChtKXtpZihvZShjKSxtIT09bSswKXRocm93IG07c2UoMSwwKX19ZnVuY3Rpb24gVm0oaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIFFpKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBXbShpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e0ppKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIExtKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7cmV0dXJuIFhpKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIEdtKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e1lpKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBIbShpLHUsYyxtLGcseCxJKXt2YXIgej1pZSgpO3RyeXtyZXR1cm4gU2EoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fWZ1bmN0aW9uIEZtKGkpe3ZhciB1PWllKCk7dHJ5e25hKGkpfWNhdGNoKGMpe2lmKG9lKHUpLGMhPT1jKzApdGhyb3cgYztzZSgxLDApfX1mdW5jdGlvbiBxbShpLHUsYyl7dmFyIG09aWUoKTt0cnl7cmV0dXJuIGZhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gS20oaSx1LGMsbSxnLHgpe3ZhciBJPWllKCk7dHJ5e29hKGksdSxjLG0sZyx4KX1jYXRjaCh6KXtpZihvZShJKSx6IT09eiswKXRocm93IHo7c2UoMSwwKX19ZnVuY3Rpb24gam0oaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3lhKGksdSxjKX1jYXRjaChnKXtpZihvZShtKSxnIT09ZyswKXRocm93IGc7c2UoMSwwKX19ZnVuY3Rpb24gWm0oaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7ZWEoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fWZ1bmN0aW9uIFFtKGksdSxjLG0sZyx4LEkseil7dmFyIEI9aWUoKTt0cnl7dGEoaSx1LGMsbSxnLHgsSSx6KX1jYXRjaChMKXtpZihvZShCKSxMIT09TCswKXRocm93IEw7c2UoMSwwKX19ZnVuY3Rpb24gWW0oaSx1LGMsbSxnLHgpe3ZhciBJPWllKCk7dHJ5e3JldHVybiBtYShpLHUsYyxtLGcseCl9Y2F0Y2goeil7aWYob2UoSSkseiE9PXorMCl0aHJvdyB6O3NlKDEsMCl9fWZ1bmN0aW9uIFhtKGksdSxjLG0sZyx4LEkseil7dmFyIEI9aWUoKTt0cnl7cmV0dXJuIENhKGksdSxjLG0sZyx4LEkseil9Y2F0Y2goTCl7aWYob2UoQiksTCE9PUwrMCl0aHJvdyBMO3NlKDEsMCl9fWZ1bmN0aW9uIEptKGksdSxjLG0sZyx4LEkseixCLEwpe3ZhciBxPWllKCk7dHJ5e2NhKGksdSxjLG0sZyx4LEkseixCLEwpfWNhdGNoKFgpe2lmKG9lKHEpLFghPT1YKzApdGhyb3cgWDtzZSgxLDApfX1mdW5jdGlvbiBlZihpLHUsYyxtLGcseCxJLHosQil7dmFyIEw9aWUoKTt0cnl7c2EoaSx1LGMsbSxnLHgsSSx6LEIpfWNhdGNoKHEpe2lmKG9lKEwpLHEhPT1xKzApdGhyb3cgcTtzZSgxLDApfX1mdW5jdGlvbiB0ZihpKXt2YXIgdT1pZSgpO3RyeXtyZXR1cm4gaWEoaSl9Y2F0Y2goYyl7aWYob2UodSksYyE9PWMrMCl0aHJvdyBjO3NlKDEsMCl9fWZ1bmN0aW9uIHJmKGksdSxjLG0sZyx4LEkseixCLEwpe3ZhciBxPWllKCk7dHJ5e3JldHVybiBoYShpLHUsYyxtLGcseCxJLHosQixMKX1jYXRjaChYKXtpZihvZShxKSxYIT09WCswKXRocm93IFg7c2UoMSwwKX19ZnVuY3Rpb24gbmYoaSx1LGMpe3ZhciBtPWllKCk7dHJ5e3JldHVybiBhYShpLHUsYyl9Y2F0Y2goZyl7aWYob2UobSksZyE9PWcrMCl0aHJvdyBnO3NlKDEsMCl9fWZ1bmN0aW9uIG9mKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiBkYShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7cmV0dXJuIHNlKDEsMCksMG59fWZ1bmN0aW9uIGFmKGksdSxjKXt2YXIgbT1pZSgpO3RyeXtyZXR1cm4gbGEoaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBzZihpLHUsYyxtLGcseCxJLHosQixMLHEsWCl7dmFyIHVlPWllKCk7dHJ5e3BhKGksdSxjLG0sZyx4LEkseixCLEwscSxYKX1jYXRjaCgkZSl7aWYob2UodWUpLCRlIT09JGUrMCl0aHJvdyAkZTtzZSgxLDApfX1mdW5jdGlvbiB1ZihpLHUsYyxtLGcseCxJLHosQixMLHEpe3ZhciBYPWllKCk7dHJ5e3VhKGksdSxjLG0sZyx4LEkseixCLEwscSl9Y2F0Y2godWUpe2lmKG9lKFgpLHVlIT09dWUrMCl0aHJvdyB1ZTtzZSgxLDApfX1mdW5jdGlvbiBkZihpLHUsYyxtLGcseCxJLHosQixMLHEpe3ZhciBYPWllKCk7dHJ5e3JldHVybiBnYShpLHUsYyxtLGcseCxJLHosQixMLHEpfWNhdGNoKHVlKXtpZihvZShYKSx1ZSE9PXVlKzApdGhyb3cgdWU7c2UoMSwwKX19ZnVuY3Rpb24gbGYoaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIGJhKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiBjZihpLHUsYyxtKXt2YXIgZz1pZSgpO3RyeXtyZXR1cm4gX2EoaSx1LGMsbSl9Y2F0Y2goeCl7aWYob2UoZykseCE9PXgrMCl0aHJvdyB4O3NlKDEsMCl9fWZ1bmN0aW9uIHBmKGksdSxjLG0pe3ZhciBnPWllKCk7dHJ5e3JldHVybiB3YShpLHUsYyxtKX1jYXRjaCh4KXtpZihvZShnKSx4IT09eCswKXRocm93IHg7c2UoMSwwKX19ZnVuY3Rpb24gbWYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUsJGUpe3ZhciBMZT1pZSgpO3RyeXt2YShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSwkZSl9Y2F0Y2goanQpe2lmKG9lKExlKSxqdCE9PWp0KzApdGhyb3cganQ7c2UoMSwwKX19ZnVuY3Rpb24gZmYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXskYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiBoZihpLHUsYyl7dmFyIG09aWUoKTt0cnl7eGEoaSx1LGMpfWNhdGNoKGcpe2lmKG9lKG0pLGchPT1nKzApdGhyb3cgZztzZSgxLDApfX1mdW5jdGlvbiBnZihpLHUpe3ZhciBjPWllKCk7dHJ5e3JldHVybiByYShpLHUpfWNhdGNoKG0pe2lmKG9lKGMpLG0hPT1tKzApdGhyb3cgbTtyZXR1cm4gc2UoMSwwKSwwbn19ZnVuY3Rpb24geWYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtyZXR1cm4gVGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gYmYoaSx1LGMsbSxnLHgsSSx6LEIsTCxxLFgsdWUpe3ZhciAkZT1pZSgpO3RyeXtJYShpLHUsYyxtLGcseCxJLHosQixMLHEsWCx1ZSl9Y2F0Y2goTGUpe2lmKG9lKCRlKSxMZSE9PUxlKzApdGhyb3cgTGU7c2UoMSwwKX19ZnVuY3Rpb24gX2YoaSx1LGMsbSl7dmFyIGc9aWUoKTt0cnl7cmV0dXJuIEFhKGksdSxjLG0pfWNhdGNoKHgpe2lmKG9lKGcpLHghPT14KzApdGhyb3cgeDtzZSgxLDApfX1mdW5jdGlvbiB3ZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBrYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtyZXR1cm4gc2UoMSwwKSwwbn19ZnVuY3Rpb24gdmYoaSx1LGMsbSxnKXt2YXIgeD1pZSgpO3RyeXtFYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiAkZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3JldHVybiBQYShpLHUsYyxtLGcpfWNhdGNoKEkpe2lmKG9lKHgpLEkhPT1JKzApdGhyb3cgSTtzZSgxLDApfX1mdW5jdGlvbiB4ZihpLHUsYyxtLGcpe3ZhciB4PWllKCk7dHJ5e3phKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIFNmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7cmV0dXJuIE9hKGksdSxjLG0sZyl9Y2F0Y2goSSl7aWYob2UoeCksSSE9PUkrMCl0aHJvdyBJO3NlKDEsMCl9fWZ1bmN0aW9uIFRmKGksdSxjLG0sZyl7dmFyIHg9aWUoKTt0cnl7RGEoaSx1LGMsbSxnKX1jYXRjaChJKXtpZihvZSh4KSxJIT09SSswKXRocm93IEk7c2UoMSwwKX19ZnVuY3Rpb24gQ2YoaSx1LGMsbSxnLHgsSSl7dmFyIHo9aWUoKTt0cnl7cmV0dXJuIEJhKGksdSxjLG0sZyx4LEkpfWNhdGNoKEIpe2lmKG9lKHopLEIhPT1CKzApdGhyb3cgQjtzZSgxLDApfX1mdW5jdGlvbiBJZihpLHUsYyxtLGcseCxJKXt2YXIgej1pZSgpO3RyeXtyZXR1cm4gTWEoaSx1LGMsbSxnLHgsSSl9Y2F0Y2goQil7aWYob2UoeiksQiE9PUIrMCl0aHJvdyBCO3NlKDEsMCl9fXJldHVybiByLnN0YWNrU2F2ZT0oKT0+aWUoKSxyLnN0YWNrUmVzdG9yZT1pPT5vZShpKSxyLnN0YWNrQWxsb2M9aT0+TW4oaSksci5zZXRWYWx1ZT1mdW5jdGlvbihpLHUsYz1cImk4XCIpe3N3aXRjaChjLmVuZHNXaXRoKFwiKlwiKSYmKGM9XCIqXCIpLGMpe2Nhc2VcImkxXCI6Y2FzZVwiaThcIjpaKClbaT4+PjBdPXU7YnJlYWs7Y2FzZVwiaTE2XCI6a2UoKVtpPj4+MT4+PjBdPXU7YnJlYWs7Y2FzZVwiaTMyXCI6RCgpW2k+Pj4yPj4+MF09dTticmVhaztjYXNlXCJpNjRcIjpXW2k+Pj4zXT1CaWdJbnQodSk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpZKClbaT4+PjI+Pj4wXT11O2JyZWFrO2Nhc2VcImRvdWJsZVwiOmZlKClbaT4+PjM+Pj4wXT11O2JyZWFrO2Nhc2VcIipcIjpSKClbaT4+PjI+Pj4wXT11O2JyZWFrO2RlZmF1bHQ6dXQoYGludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICR7Y31gKX19LHIuZ2V0VmFsdWU9ZnVuY3Rpb24oaSx1PVwiaThcIil7c3dpdGNoKHUuZW5kc1dpdGgoXCIqXCIpJiYodT1cIipcIiksdSl7Y2FzZVwiaTFcIjpjYXNlXCJpOFwiOnJldHVybiBaKClbaT4+PjBdO2Nhc2VcImkxNlwiOnJldHVybiBrZSgpW2k+Pj4xPj4+MF07Y2FzZVwiaTMyXCI6cmV0dXJuIEQoKVtpPj4+Mj4+PjBdO2Nhc2VcImk2NFwiOnJldHVybiBXW2k+Pj4zXTtjYXNlXCJmbG9hdFwiOnJldHVybiBZKClbaT4+PjI+Pj4wXTtjYXNlXCJkb3VibGVcIjpyZXR1cm4gZmUoKVtpPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gUigpW2k+Pj4yPj4+MF07ZGVmYXVsdDp1dChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHt1fWApfX0sci5VVEY4VG9TdHJpbmc9QWUsci5zdHJpbmdUb1VURjg9QnQsci5sZW5ndGhCeXRlc1VURjg9WW8sZnVuY3Rpb24gaSgpe2lmKDA8eHQpSHQ9aTtlbHNlIGlmKGQpdChyKSxZZSgpO2Vsc2V7Zm9yKDswPHluLmxlbmd0aDspeW4uc2hpZnQoKShyKTswPHh0P0h0PWk6KHIuY2FsbGVkUnVuPSEwLGVlfHwoWWUoKSx0KHIpKSl9fSgpLHIuUFRSX1NJWkU9NCxvfSksQmY9d3MsTWY9Z2xvYmFsVGhpcy5zZWxmPy5uYW1lPy5zdGFydHNXaXRoKFwiZW0tcHRocmVhZFwiKTtNZiYmd3MoKX0pO3ZhciBUcyxSZixWZSxDcyxqbixVZixOZixJcyxWZix4cyxBcyxTcyxrcyxTcj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHIoKTtUcz10eXBlb2YgbG9jYXRpb24+XCJ1XCI/dm9pZCAwOmxvY2F0aW9uLm9yaWdpbixSZj0oKT0+e2lmKCEhMSlyZXR1cm4gaW1wb3J0Lm1ldGEudXJsPy5zdGFydHNXaXRoKFwiZmlsZTpcIik/bmV3IFVSTChuZXcgVVJMKFwib3J0LndlYmdwdS5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCkuaHJlZixUcykuaHJlZjppbXBvcnQubWV0YS51cmx9LFZlPVJmKCksQ3M9KCk9PntpZihWZSYmIVZlLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSlyZXR1cm4gVmUuc3Vic3RyaW5nKDAsVmUubGFzdEluZGV4T2YoXCIvXCIpKzEpfSxqbj0oZSx0KT0+e3RyeXtsZXQgbj10Pz9WZTtyZXR1cm4obj9uZXcgVVJMKGUsbik6bmV3IFVSTChlKSkub3JpZ2luPT09VHN9Y2F0Y2h7cmV0dXJuITF9fSxVZj0oZSx0KT0+e2xldCBuPXQ/P1ZlO3RyeXtyZXR1cm4obj9uZXcgVVJMKGUsbik6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxOZj0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLElzPWFzeW5jIGU9PntsZXQgbj1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKG4pfSxWZj1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCx4cz0oX3MoKSxicihicykpLmRlZmF1bHQsQXM9YXN5bmMoKT0+e2lmKCFWZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlwiKTtpZihqbihWZSkpcmV0dXJuW3ZvaWQgMCx4cygpXTtsZXQgZT1hd2FpdCBJcyhWZSk7cmV0dXJuW2UseHMoZSldfSxTcz0oJHMoKSxicih2cykpLmRlZmF1bHQsa3M9YXN5bmMoZSx0LG4pPT57aWYoIWUmJiF0JiZTcyYmVmUmJmpuKFZlKSlyZXR1cm5bdm9pZCAwLFNzXTt7bGV0IHI9XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzXCIsbz1lPz9VZihyLHQpLGE9ISExJiZuJiZvJiYham4obyx0KSxzPWE/YXdhaXQgSXMobyk6bz8/TmYocix0KTtyZXR1cm5bYT9zOnZvaWQgMCxhd2FpdCBWZihzKV19fX0pO3ZhciBabixRbixPcixFcyxXZixMZixUcixJZSxidD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U3IoKTtRbj0hMSxPcj0hMSxFcz0hMSxXZj0oKT0+e2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sTGY9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sVHI9YXN5bmMgZT0+e2lmKFFuKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihPcil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihFcyl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtPcj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LG49ZS5udW1UaHJlYWRzO2lmKCFMZigpKXRocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cIik7bGV0IHI9V2YoKTtuPjEmJiFyJiYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK24rXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLGNvbnNvbGUud2FybihcIldlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy5cIiksZS5udW1UaHJlYWRzPW49MSk7bGV0IG89ZS53YXNtUGF0aHMsYT10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOnZvaWQgMCxzPW8/Lm1qcyxkPXM/LmhyZWY/P3MsbD1vPy53YXNtLHA9bD8uaHJlZj8/bCxmPWUud2FzbUJpbmFyeSxbaCx5XT1hd2FpdCBrcyhkLGEsbj4xKSxfPSExLGI9W107aWYodD4wJiZiLnB1c2gobmV3IFByb21pc2Uodz0+e3NldFRpbWVvdXQoKCk9PntfPSEwLHcoKX0sdCl9KSksYi5wdXNoKG5ldyBQcm9taXNlKCh3LFMpPT57bGV0ICQ9e251bVRocmVhZHM6bn07aWYoZikkLndhc21CaW5hcnk9ZjtlbHNlIGlmKHB8fGEpJC5sb2NhdGVGaWxlPXY9PnA/P2ErdjtlbHNlIGlmKGQmJmQuaW5kZXhPZihcImJsb2I6XCIpIT09MCkkLmxvY2F0ZUZpbGU9dj0+bmV3IFVSTCh2LGQpLmhyZWY7ZWxzZSBpZihoKXtsZXQgdj1DcygpO3YmJigkLmxvY2F0ZUZpbGU9VD0+ditUKX15KCQpLnRoZW4odj0+e09yPSExLFFuPSEwLFpuPXYsdygpLGgmJlVSTC5yZXZva2VPYmplY3RVUkwoaCl9LHY9PntPcj0hMSxFcz0hMCxTKHYpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKGIpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxJZT0oKT0+e2lmKFFuJiZabilyZXR1cm4gWm47dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9fSk7dmFyIFBlLFh0LGhlLERyPUcoKCk9PntcInVzZSBzdHJpY3RcIjtidCgpO1BlPShlLHQpPT57bGV0IG49SWUoKSxyPW4ubGVuZ3RoQnl0ZXNVVEY4KGUpKzEsbz1uLl9tYWxsb2Mocik7cmV0dXJuIG4uc3RyaW5nVG9VVEY4KGUsbyxyKSx0LnB1c2gobyksb30sWHQ9KGUsdCxuLHIpPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihuLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtuLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbyxhXSk9PntsZXQgcz10P3QrbzpvO2lmKHR5cGVvZiBhPT1cIm9iamVjdFwiKVh0KGEscytcIi5cIixuLHIpO2Vsc2UgaWYodHlwZW9mIGE9PVwic3RyaW5nXCJ8fHR5cGVvZiBhPT1cIm51bWJlclwiKXIocyxhLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIGE9PVwiYm9vbGVhblwiKXIocyxhP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBhfWApfSl9LGhlPWU9PntsZXQgdD1JZSgpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHI9dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKnIpO3QuX09ydEdldExhc3RFcnJvcihvLG8rcik7bGV0IGE9TnVtYmVyKHQuZ2V0VmFsdWUobyxyPT09ND9cImkzMlwiOlwiaTY0XCIpKSxzPXQuZ2V0VmFsdWUobytyLFwiKlwiKSxkPXM/dC5VVEY4VG9TdHJpbmcocyk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHthfSwgRVJST1JfTUVTU0FHRTogJHtkfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fX0pO3ZhciBQcyx6cz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YnQoKTtEcigpO1BzPWU9PntsZXQgdD1JZSgpLG49MCxyPVtdLG89ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApby5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApby5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihvLnRlcm1pbmF0ZT0hMSk7bGV0IGE9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYoYT1QZShlLnRhZyxyKSksbj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG8ubG9nU2V2ZXJpdHlMZXZlbCxvLmxvZ1ZlcmJvc2l0eUxldmVsLCEhby50ZXJtaW5hdGUsYSksbj09PTAmJmhlKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmWHQoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChzLGQpPT57bGV0IGw9UGUocyxyKSxwPVBlKGQscik7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkobixsLHApIT09MCYmaGUoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7c30gLSAke2R9LmApfSksW24scl19Y2F0Y2goYSl7dGhyb3cgbiE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKG4pLHIuZm9yRWFjaChzPT50Ll9mcmVlKHMpKSxhfX19KTt2YXIgR2YsSGYsRmYscWYsT3MsRHM9RygoKT0+e1widXNlIHN0cmljdFwiO2J0KCk7RHIoKTtHZj1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSxIZj1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0sRmY9ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKG49Pih0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm4ubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LHFmPShlLHQsbik9Pntmb3IobGV0IHIgb2YgdCl7bGV0IG89dHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWU7c3dpdGNoKG8pe2Nhc2VcIndlYm5uXCI6aWYobz1cIldFQk5OXCIsdHlwZW9mIHIhPVwic3RyaW5nXCIpe2xldCBkPXI/LmRldmljZVR5cGU7aWYoZCl7bGV0IGw9UGUoXCJkZXZpY2VUeXBlXCIsbikscD1QZShkLG4pO0llKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwscCkhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZH0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKG89XCJKU1wiLHR5cGVvZiByIT1cInN0cmluZ1wiKXtsZXQgcz1yO2lmKHM/LnByZWZlcnJlZExheW91dCl7aWYocy5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmcy5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke3MucHJlZmVycmVkTGF5b3V0fWApO2xldCBkPVBlKFwicHJlZmVycmVkTGF5b3V0XCIsbiksbD1QZShzLnByZWZlcnJlZExheW91dCxuKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGwpIT09MCYmaGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7cy5wcmVmZXJyZWRMYXlvdXR9LmApfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299YCl9bGV0IGE9UGUobyxuKTtJZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGEpIT09MCYmaGUoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b30uYCl9fSxPcz1lPT57bGV0IHQ9SWUoKSxuPTAscj1bXSxvPWV8fHt9O0ZmKG8pO3RyeXtsZXQgYT1HZihvLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLHM9SGYoby5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksZD10eXBlb2Ygby5sb2dJZD09XCJzdHJpbmdcIj9QZShvLmxvZ0lkLHIpOjAsbD1vLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIobCl8fGw8MHx8bD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bH1gKTtsZXQgcD1vLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDB8fHA+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3B9YCk7bGV0IGY9dHlwZW9mIG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9QZShvLm9wdGltaXplZE1vZGVsRmlsZVBhdGgscik6MDtpZihuPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGEsISFvLmVuYWJsZUNwdU1lbUFyZW5hLCEhby5lbmFibGVNZW1QYXR0ZXJuLHMsISFvLmVuYWJsZVByb2ZpbGluZywwLGQsbCxwLGYpLG49PT0wJiZoZShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG8uZXhlY3V0aW9uUHJvdmlkZXJzJiZxZihuLG8uZXhlY3V0aW9uUHJvdmlkZXJzLHIpLG8uZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygby5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke28uZW5hYmxlR3JhcGhDYXB0dXJlfWApO2xldCBoPVBlKFwiZW5hYmxlR3JhcGhDYXB0dXJlXCIscikseT1QZShvLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLHIpO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGgseSkhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCl9aWYoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbaCx5XW9mIE9iamVjdC5lbnRyaWVzKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiBoIT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke2h9YCk7aWYodHlwZW9mIHkhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKHkpfHx5PDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7eX1gKTtsZXQgXz1QZShoLHIpO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShuLF8seSkhPT0wJiZoZShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7aH0gLSAke3l9LmApfXJldHVybiBvLmV4dHJhIT09dm9pZCAwJiZYdChvLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKGgseSk9PntsZXQgXz1QZShoLHIpLGI9UGUoeSxyKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkobixfLGIpIT09MCYmaGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke2h9IC0gJHt5fS5gKX0pLFtuLHJdfWNhdGNoKGEpe3Rocm93IG4hPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobikhPT0wJiZoZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxyLmZvckVhY2gocz0+dC5fZnJlZShzKSksYX19fSk7dmFyIFJ0LF90LHd0LEJyLEp0LE1yLFJyLFluLHRlPUcoKCk9PntcInVzZSBzdHJpY3RcIjtSdD1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7Y2FzZVwiaW50NFwiOnJldHVybiAyMjtjYXNlXCJ1aW50NFwiOnJldHVybiAyMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxfdD1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7Y2FzZSAyMjpyZXR1cm5cImludDRcIjtjYXNlIDIxOnJldHVyblwidWludDRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSx3dD0oZSx0KT0+e2xldCBuPVstMSw0LDEsMSwyLDIsNCw4LC0xLDEsMiw4LDQsOCwtMSwtMSwtMSwtMSwtMSwtMSwtMSwuNSwuNV1bZV0scj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQucmVkdWNlKChvLGEpPT5vKmEsMSk7cmV0dXJuIG4+MD9NYXRoLmNlaWwocipuKTp2b2lkIDB9LEJyPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiB0eXBlb2YgRmxvYXQxNkFycmF5PFwidVwiJiZGbG9hdDE2QXJyYXkuZnJvbT9GbG9hdDE2QXJyYXk6VWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LEp0PWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fSxNcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFJyPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDY0XCJ8fGU9PT1cImludDhcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsWW49ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIDU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIGVyLFhuPUcoKCk9PntcInVzZSBzdHJpY3RcIjt4cigpO2VyPWFzeW5jIGU9PntpZih0eXBlb2YgZT09XCJzdHJpbmdcIilpZighMSl0cnl7bGV0e3JlYWRGaWxlOnR9PU5uKFwibm9kZTpmcy9wcm9taXNlc1wiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdChlKSl9Y2F0Y2godCl7aWYodC5jb2RlPT09XCJFUlJfRlNfRklMRV9UT09fTEFSR0VcIil7bGV0e2NyZWF0ZVJlYWRTdHJlYW06bn09Tm4oXCJub2RlOmZzXCIpLHI9bihlKSxvPVtdO2ZvciBhd2FpdChsZXQgYSBvZiByKW8ucHVzaChhKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChvKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IG49dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLHI9bj9wYXJzZUludChuLDEwKTowO2lmKHI8MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgbz10LmJvZHkuZ2V0UmVhZGVyKCksYTt0cnl7YT1uZXcgQXJyYXlCdWZmZXIocil9Y2F0Y2goZCl7aWYoZCBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBsPU1hdGguY2VpbChyLzY1NTM2KTthPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6bCxtYXhpbXVtOmx9KS5idWZmZXJ9ZWxzZSB0aHJvdyBkfWxldCBzPTA7Zm9yKDs7KXtsZXR7ZG9uZTpkLHZhbHVlOmx9PWF3YWl0IG8ucmVhZCgpO2lmKGQpYnJlYWs7bGV0IHA9bC5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KGEscyxwKS5zZXQobCkscys9cH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYSwwLHIpfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9fSk7dmFyIEtmLGpmLEJzLE1zLFVyLFpmLG1lLHR0PUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO0tmPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0samY9KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7S2ZbZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LFVyPShlLHQpPT57QnM9ZSxNcz10fSxaZj0oZSx0KT0+e2xldCBuPUp0KGUpLHI9SnQoQnMpO24+PXImJmpmKG4sdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LG1lPSguLi5lKT0+e01zJiZaZiguLi5lKX19KTt2YXIgTnIsSm49RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7TnI9KGUsdCk9Pm5ldyhCcih0KSkoZSl9KTt2YXIgVnI9RygoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFJzLGVvLHRvLFFmLFlmLFVzLG5vLHJvLFZzLFdzPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0dCgpO1ZyKCk7UnM9bmV3IE1hcChbWzY0LDI1MF0sWzEyOCwyMDBdLFsyNTYsMjAwXSxbNTEyLDIwMF0sWzIwNDgsMjMwXSxbNDA5NiwyMDBdLFs4MTkyLDUwXSxbMTYzODQsNTBdLFszMjc2OCw1MF0sWzY1NTM2LDUwXSxbMTMxMDcyLDUwXSxbMjYyMTQ0LDUwXSxbNTI0Mjg4LDUwXSxbMTA0ODU3Niw1MF0sWzIwOTcxNTIsMzBdLFs0MTk0MzA0LDIwXSxbODM4ODYwOCwxMF0sWzEyNTgyOTEyLDEwXSxbMTY3NzcyMTYsMTBdLFsyNjIxNDQwMCwxNV0sWzMzNTU0NDMyLDIyXSxbNDQyMzY4MDAsMl0sWzU4OTgyNDAwLDZdLFs2NzEwODg2NCw2XSxbMTM0MjE3NzI4LDZdLFsxNjc3NzIxNjAsNl1dKSxlbz1bXSx0bz1lPT5NYXRoLmNlaWwoTnVtYmVyKGUpLzE2KSoxNixRZj1lPT57Zm9yKGxldCB0PTA7dDxlby5sZW5ndGg7dCsrKXtsZXQgbj1lb1t0XTtpZihlPD1uKXJldHVybiBufXJldHVybiBNYXRoLmNlaWwoZS8xNikqMTZ9LFlmPTEsVXM9KCk9PllmKyssbm89YXN5bmMoZSx0LG4scik9PntsZXQgbz10byhuKSxhPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCBzPWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCkscy5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLGEsMCxvKSxlLmZsdXNoKCksYXdhaXQgYS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBkPWEuZ2V0TWFwcGVkUmFuZ2UoKTtpZihyKXtsZXQgbD1yKCk7cmV0dXJuIGwuc2V0KG5ldyBVaW50OEFycmF5KGQsMCxuKSksbH1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShkLnNsaWNlKDAsbikpfWZpbmFsbHl7YS5kZXN0cm95KCl9fSxybz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXA7Zm9yKGxldFtuXW9mIFJzKWVvLnB1c2gobiksdGhpcy5mcmVlQnVmZmVycy5zZXQobixbXSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KG4sW10pO3RoaXMuc2Vzc2lvbkNvdW50PTB9dXBsb2FkKHQsbil7bGV0IHI9bi5idWZmZXIsbz1uLmJ5dGVPZmZzZXQsYT1uLmJ5dGVMZW5ndGgscz10byhhKSxkPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKE51bWJlcihkLm9yaWdpbmFsU2l6ZSkhPT1hKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2Qub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7YX1gKTtsZXQgbD10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOnMsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSkscD1sLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkocCkuc2V0KG5ldyBVaW50OEFycmF5KHIsbyxhKSksbC51bm1hcCgpO2xldCBmPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTtmLmNvcHlCdWZmZXJUb0J1ZmZlcihsLDAsZC5ncHVEYXRhLmJ1ZmZlciwwLHMpLHRoaXMuYmFja2VuZC5kZXZpY2UucXVldWUuc3VibWl0KFtmLmZpbmlzaCgpXSksbC5kZXN0cm95KCksbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKX1tZW1jcHkodCxuKXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KG4pO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYoci5vcmlnaW5hbFNpemUhPT1vLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBhPXRvKHIub3JpZ2luYWxTaXplKSxzPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHMuY29weUJ1ZmZlclRvQnVmZmVyKHIuZ3B1RGF0YS5idWZmZXIsMCxvLmdwdURhdGEuYnVmZmVyLDAsYSl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LG4scil7bGV0IG87aWYocil7aWYobz1yWzBdLHQ9PT1yWzFdKXJldHVybiBtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke259KSA9PiBpZD0ke299LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCksbztpZih0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpKXRocm93IG5ldyBFcnJvcihgUmVnaXN0ZXJpbmcgYSBkaWZmZXJlbnQgZXh0ZXJuYWwgYnVmZmVyIHVuZGVyIGdyYXBoIGNhcHR1cmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cbiAgICAgICAgICAgICBQbGVhc2UgdXNlIHRoZSBwcmV2aW91cyBleHRlcm5hbCBidWZmZXIhYCl9ZWxzZSBvPVVzKCk7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChvLHtncHVEYXRhOntpZDpvLHR5cGU6MCxidWZmZXI6dH0sb3JpZ2luYWxTaXplOm59KSxtZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke259KSA9PiBpZD0ke299LCByZWdpc3RlcmVkLmApLG99dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe3QhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3R9YCkpfWNyZWF0ZSh0LG49R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IHI9UWYodCksbyxhPShuJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSxzPShuJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihhfHxzKXtsZXQgcD0oYT90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzKS5nZXQocik7cD9wLmxlbmd0aD4wP289cC5wb3AoKTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnIsdXNhZ2U6bn0pOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6cix1c2FnZTpufSl9ZWxzZSBvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnIsdXNhZ2U6bn0pO2xldCBkPXtpZDpVcygpLHR5cGU6MCxidWZmZXI6b307cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChkLmlkLHtncHVEYXRhOmQsb3JpZ2luYWxTaXplOk51bWJlcih0KX0pLG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtkLmlkfWApLGR9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgbj10eXBlb2YgdD09XCJiaWdpbnRcIj9OdW1iZXIodCk6dCxyPXRoaXMuc3RvcmFnZUNhY2hlLmdldChuKTtpZighcil7aWYodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZT09PTApcmV0dXJuIDA7dGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIil9cmV0dXJuIG1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke259KSwgZ3B1RGF0YUlkPSR7ci5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShuKSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2goci5ncHVEYXRhLmJ1ZmZlciksci5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxuKXtsZXQgcj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoTnVtYmVyKHQpKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IG5vKHRoaXMuYmFja2VuZCxyLmdwdURhdGEuYnVmZmVyLHIub3JpZ2luYWxTaXplLG4pfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2lmKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoIT09MClpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiZGVmYXVsdFwiKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZyl7bGV0IG49UnMuZ2V0KHQuc2l6ZSk7aWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFKXtsZXQgcj10aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpfHxbXTtuPT09dm9pZCAwfHxyLmxlbmd0aD49bj90LmRlc3Ryb3koKTpyLnB1c2godCl9ZWxzZSBpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pe2xldCByPXRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpfHxbXTtuPT09dm9pZCAwfHxyLmxlbmd0aD49bj90LmRlc3Ryb3koKTpyLnB1c2godCl9ZWxzZSB0LmRlc3Ryb3koKX10aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWVsc2V7bGV0IHQ9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCk7dHx8KHQ9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLnNldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCx0KSk7Zm9yKGxldCBuIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpdC5wdXNoKG4pO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119fWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChuPT57bi5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXB9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5zZXNzaW9uQ291bnQrPTF9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgbj10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHQpO24mJihuLmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZSh0KSksdGhpcy5zZXNzaW9uQ291bnQtPTEsdGhpcy5zZXNzaW9uQ291bnQ9PT0wJiYobWUoXCJ3YXJuaW5nXCIsKCk9PlwiW1dlYkdQVV0gQ2xlYXJpbmcgd2ViZ3B1IGJ1ZmZlciBjYWNoZVwiKSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHI9PntyLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXApfX0sVnM9KC4uLmUpPT5uZXcgcm8oLi4uZSl9KTt2YXIgb28scmUsQ2U9RygoKT0+e1widXNlIHN0cmljdFwiO29vPWNsYXNze2NvbnN0cnVjdG9yKHQpe09iamVjdC5hc3NpZ24odGhpcyx0KX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5rZXl8fCh0aGlzLmtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKHQ9PmAke3RoaXNbdF19YCkuam9pbihcIjtcIikpLHRoaXMua2V5fX0scmU9ZT0+bmV3IG9vKGUpfSk7dmFyIGlvLHJ0LEUsa3QsV3IsTHMsR3MsYWU9RygoKT0+e1widXNlIHN0cmljdFwiO2lvPWNsYXNze3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxuKXtyZXR1cm4gdFsxXSE9PW5bMF0/dm9pZCAwOlt0WzBdLG5bMV1dfX0scnQ9Y2xhc3N7c3RhdGljIGNhbGNTaGFwZSh0LG4scj0hMSl7bGV0IG89dC5sZW5ndGgsYT1uLmxlbmd0aDtpZihvPT09MClyZXR1cm4gbjtpZihhPT09MClyZXR1cm4gdDtsZXQgcz1NYXRoLm1heCh0Lmxlbmd0aCxuLmxlbmd0aCksZD1uZXcgQXJyYXkocyk7aWYocil7aWYobzwyfHxhPDIpcmV0dXJuO2xldCBsPWlvLmNhbGNNYXRNdWxTaGFwZShbdFtvLTJdLHRbby0xXV0sW25bYS0yXSxuW2EtMV1dKTtpZihsPT09dm9pZCAwKXJldHVybjtbZFtzLTJdLGRbcy0xXV09bH1mb3IobGV0IGw9cj8zOjE7bDw9cztsKyspe2xldCBwPW8tbDwwPzE6dFtvLWxdLGY9YS1sPDA/MTpuW2EtbF07aWYocCE9PWYmJnA+MSYmZj4xKXJldHVybjtsZXQgaD1NYXRoLm1heChwLGYpO2lmKHAmJmYpZFtzLWxdPU1hdGgubWF4KHAsZik7ZWxzZXtpZihoPjEpcmV0dXJuO2Rbcy1sXT0wfX1yZXR1cm4gZH1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LG4pe2xldCByPXQubGVuZ3RoLG89bi5sZW5ndGg7aWYocj5vKXJldHVybiExO2ZvcihsZXQgYT0xO2E8PXI7YSsrKWlmKHRbci1hXSE9PTEmJnRbci1hXSE9PW5bby1hXSlyZXR1cm4hMTtyZXR1cm4hMH19LEU9Y2xhc3MgZXtzdGF0aWMgc2l6ZSh0KXtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCx0Lmxlbmd0aCl9c3RhdGljIGNvbnZlcnRTaGFwZSh0LG49NCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107bGV0IG89bmV3IEFycmF5KHIpLGE9ci0xO2Zvcig7YT49MDspe2lmKHRbYV0lbj09PTApe29bYV09dFthXS9uO2JyZWFrfWlmKG4ldFthXSE9PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnZlcnQgc2hhcGVcIik7b1thXT0xLG4vPXRbYV0sYS0tfWZvcihhLS07YT49MDthLS0pb1thXT10W2FdO3JldHVybiBvfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LG4pe2lmKG48MHx8bj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7bn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsbix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LG4pe2lmKG48MHx8bj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7bn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsbil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxuLHIpe2xldCBvPTE7Zm9yKGxldCBhPW47YTxyO2ErKyl7aWYodFthXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7byo9TnVtYmVyKHRbYV0pfXJldHVybiBvfXN0YXRpYyBjb21wdXRlU3RyaWRlcyh0KXtsZXQgbj10Lmxlbmd0aDtpZihuPT09MClyZXR1cm5bXTtpZihuPT09MSlyZXR1cm5bMV07bGV0IHI9bmV3IEFycmF5KG4pO3Jbbi0xXT0xLHJbbi0yXT10W24tMV07Zm9yKGxldCBvPW4tMztvPj0wOy0tbylyW29dPXJbbysxXSp0W28rMV07cmV0dXJuIHJ9c3RhdGljIG5vcm1hbGl6ZUF4aXModCxuKXtpZih0PC1uJiZ0Pj1uKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3Qrbjp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQsbil7cmV0dXJuIHQubWFwKHI9PnRoaXMubm9ybWFsaXplQXhpcyhyLG4/P3QubGVuZ3RoKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LG4pe3JldHVybiBuP24ubWFwKHI9PnRbcl0pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQsbil7bGV0IHI9dC5sZW5ndGg7cmV0dXJuIHQubWFwKChvLGEpPT5vK25bYV0rblthK3JdKX1zdGF0aWMgYXJlRXF1YWwodCxuKXtyZXR1cm4gdC5sZW5ndGghPT1uLmxlbmd0aD8hMTp0LmV2ZXJ5KChyLG8pPT5yPT09bltvXSl9fSxrdD1jbGFzcyBle3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyh0LG4scixvLGEscyl7aWYoIXQmJnIubGVuZ3RoIT09bi5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKHQpZm9yKGxldCBkPTA7ZDxuLmxlbmd0aC0yO2QrKylkPj1yLmxlbmd0aD9yLnB1c2gobltkKzJdKTpyW2RdPW5bZCsyXTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrKylpZihkPG8ubGVuZ3RoKXtpZihvW2RdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspaWYoZDxhLmxlbmd0aCl7aWYoYVtkXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBhLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aCoyO2QrKylpZihkPHMubGVuZ3RoKXtpZihzW2RdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIHMucHVzaCgwKTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrKyl7aWYocltkXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYoc1tkXT49cltkXXx8c1tkK3IubGVuZ3RoXT49cltkXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHQsbixyLG8sYSxzLGQpe2lmKGQpe2lmKGEubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG4ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoby5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGw9MDtsPHQubGVuZ3RoLTI7bCsrKWUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtsKyhzPzE6MildLG5bbF0scltsXSxvW2xdLGEsbCxsK3QubGVuZ3RoLTIsZCl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQsbixyLG8sYSxzLGQpe2lmKG4ubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtsZXQgbD1bblswXSxuWzFdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIodCxuLGwscixvLGEscyxkKSxsfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKHQsbixyLG8sYSxzLGQpe2lmKHQubGVuZ3RoPD0wfHxuLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2xldCBsPVt0WzBdLG5bMF1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcighMSx0LGwscixvLGEscyxkKSxsfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIodCxuLHIsbyxhLHMsZCxsKXtpZih0KWZvcihsZXQgcD0wO3A8bi5sZW5ndGgtMjtwKyspci5wdXNoKDEpO2Vsc2UgZm9yKGxldCBwPTA7cDxuLmxlbmd0aC0yO3ArKylyLnB1c2goZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShuW3ArMl0sb1twXSxhW3BdLHNbcF0sZCxwLHArbi5sZW5ndGgtMixsKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKHQsbixyLG8sYSxzLGQsbCl7bGV0IHA9ciooby0xKSsxO2lmKGwmJmwhPT1cIk5PVFNFVFwiKXN3aXRjaChsKXtjYXNlXCJWQUxJRFwiOnJldHVybiBhW3NdPTAsYVtkXT0wLE1hdGguZmxvb3IoKHQtcCkvbisxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKHIhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7bGV0IGg9KCh0K24tMSkvbi0xKSpuK28tdDtyZXR1cm4gYVtzXT1NYXRoLmZsb29yKGw9PT1cIlNBTUVfTE9XRVJcIj8oaCsxKS8yOmgvMiksYVtkXT1oLWFbc10sTWF0aC5mbG9vcigodCtoLW8pL24rMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9ZWxzZSByZXR1cm4gTWF0aC5mbG9vcigodCthW3NdK2FbZF0tcCkvbisxKX19LFdyPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LG4scixvLGEpe2lmKHQubGVuZ3RoIT09Mnx8ci5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBzLGQsbDtuPyhzPXRbMV0sZD10WzBdKToocz10WzBdLGQ9dFsxXSk7bGV0IHA9LTE7aWYobz8obD1yWzBdLHA9MSk6KGw9clsxXSxwPTApLHJbcF0hPT1kKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihzPD0wfHxsPD0wfHxkPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKGEmJiFydC5pc1ZhbGlkQnJvYWRjYXN0KGEsW3MsbF0pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVybltzLGwsZF19fSxMcz0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsR3M9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9KTt2YXIgRXQsc28sX2UsemUsSCxnZSx1byxQdCxLZSxLLExyLFAsTixIcyxHcixhbyxGcyxjZT1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0V0PTY0LHNvPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goTnVtYmVyKGUpKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07Y2FzZSAyMjpyZXR1cm5cImkzMlwiO2Nhc2UgMjE6cmV0dXJuXCJ1MzJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7ZX1gKX19LF9lPShlLHQ9MSk9PntsZXQgbj1zbyhlLHQpO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm5bMF19LHplPShlLHQ9MSk9PntsZXQgbj1zbyhlLHQpO3JldHVybiB0eXBlb2Ygbj09XCJzdHJpbmdcIj9uOm5bMV19LEg9KC4uLmUpPT57bGV0IHQ9W107cmV0dXJuIGUuZm9yRWFjaChuPT57bi5sZW5ndGghPT0wJiZ0LnB1c2goe3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOkUuY29tcHV0ZVN0cmlkZXMobil9KX0pLHR9LGdlPWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSx1bz0oZT1cImYzMlwiLHQsbj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke259KWA6YHZlYyR7dH08JHtlfT4oJHtufSlgLFB0PShlLHQsbik9PmU9PT1cImYzMlwiP246dD09PTE/YGYzMigke259KWA6YHZlYyR7dH08ZjMyPigke259KWAsS2U9KGUsdCk9PnQ9PT00P2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56ICsgJHtlfS53KWA6dD09PTI/YCgke2V9LnggKyAke2V9LnkpYDp0PT09Mz9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueilgOmUsSz0oZSx0LG4scik9PmUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmbj40P3R5cGVvZiB0PT1cInN0cmluZ1wiP3I9PT1cImYxNlwiP2Ake2V9Wygke3R9KSAvIDhdWygke3R9KSAlIDggLyA0XVsoJHt0fSkgJSA4ICUgNF1gOmAke2V9Wygke3R9KSAvIDRdWygke3R9KSAlIDRdYDpyPT09XCJmMTZcIj9gJHtlfVske01hdGguZmxvb3IodC84KX1dWyR7TWF0aC5mbG9vcih0JTgvNCl9XVske3QlOCU0fV1gOmAke2V9WyR7TWF0aC5mbG9vcih0LzQpfV1bJHt0JTR9XWA6bj4xP2Ake2V9WyR7dH1dYDplLExyPShlLHQsbixyLG8pPT57bGV0IGE9dHlwZW9mIG49PVwibnVtYmVyXCIscz1hP246bi5sZW5ndGgsZD1bLi4ubmV3IEFycmF5KHMpLmtleXMoKV0sbD1zPDI/XCJ1MzJcIjpzPD00P2B2ZWMke3N9PHUzMj5gOmBhcnJheTx1MzIsICR7c30+YCxwPXNvKHQsbyksZj10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMV0saD10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMF0seT17aW5kaWNlczpsLHZhbHVlOmYsc3RvcmFnZTpoLHRlbnNvcjp0fSxfPVI9PnR5cGVvZiBSPT1cInN0cmluZ1wiP1I6YCR7Un11YCxiPXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0sdz1hP1widW5pZm9ybXMuXCI6XCJcIixTPWAke3d9JHtlfV9zaGFwZWAsJD1gJHt3fSR7ZX1fc3RyaWRlc2Asdj1cIlwiO2ZvcihsZXQgUj0wO1I8cy0xO1IrKyl2Kz1gXG4gICAgbGV0IGRpbSR7Un0gPSBjdXJyZW50IC8gJHtLKCQsUixzKX07XG4gICAgbGV0IHJlc3Qke1J9ID0gY3VycmVudCAlICR7SygkLFIscyl9O1xuICAgIGluZGljZXNbJHtSfV0gPSBkaW0ke1J9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtSfTtcbiAgICBgO3YrPWBpbmRpY2VzWyR7cy0xfV0gPSBjdXJyZW50O2A7bGV0IFQ9czwyP1wiXCI6YFxuICBmbiBvMmlfJHtlfShvZmZzZXQ6IHUzMikgLT4gJHt5LmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHt5LmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7dn1cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWAsQz1SPT4oYi5vZmZzZXRUb0luZGljZXM9ITAsczwyP1I6YG8yaV8ke2V9KCR7Un0pYCksQT1bXTtpZihzPj0yKWZvcihsZXQgUj1zLTE7Uj49MDtSLS0pQS5wdXNoKGAke0soJCxSLHMpfSAqIChpbmRpY2VzWyR7Un1dKWApO2xldCBrPXM8Mj9cIlwiOmBcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHt5LmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke0Euam9pbihcIitcIil9O1xuICB9YCxPPVI9PihiLmluZGljZXNUb09mZnNldD0hMCxzPDI/UjpgaTJvXyR7ZX0oJHtSfSlgKSxNPSguLi5SKT0+cz09PTA/XCIwdVwiOmAke3kuaW5kaWNlc30oJHtSLm1hcChfKS5qb2luKFwiLFwiKX0pYCxWPShSLFkpPT5zPDI/YCR7Un1gOmAke0soUixZLHMpfWAsRj0oUixZLGZlKT0+czwyP2Ake1J9PSR7ZmV9O2A6YCR7SyhSLFkscyl9PSR7ZmV9O2Asaj17fSxuZT0oUixZKT0+e2IuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IGZlPWAke1kubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGZlIGluIGopcmV0dXJuYCR7ZmV9KCR7Un0pYDtsZXQgRmU9W107Zm9yKGxldCB4ZT1zLTE7eGU+PTA7eGUtLSl7bGV0IGJlPVkuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix4ZStZLnJhbmstcyk7RmUucHVzaChgJHtWKCQseGUpfSAqICgke2JlfSAlICR7VihTLHhlKX0pYCl9cmV0dXJuIGpbZmVdPWBmbiAke2ZlfShvdXRwdXRJbmRpY2VzOiAke1kudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtGZS5sZW5ndGg+MD9GZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xuICAgICAgICAgICB9YCxgJHtmZX0oJHtSfSlgfSxXPShSLFkpPT4oKCk9PntpZih5LnN0b3JhZ2U9PT15LnZhbHVlKXJldHVybmAke2V9WyR7Un1dPSR7WX07YDtpZih5LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ5LnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske1J9XT12ZWMyPHUzMj4odTMyKCR7WX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke1l9IDwgMCkpO2A7aWYoeS5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmeS52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtSfV09dmVjMjx1MzI+KHUzMigke1l9KSwgMHUpO2A7aWYoeS5zdG9yYWdlPT09XCJ1MzJcIiYmeS52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7Un1dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7WX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHt5LnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7eS52YWx1ZX0geWV0YCl9KSgpLEo9Uj0+KCgpPT57aWYoeS5zdG9yYWdlPT09eS52YWx1ZSlyZXR1cm5gJHtlfVske1J9XWA7aWYoeS5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmeS52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7Un1dLngpYDtpZih5LnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZ5LnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtSfV0ueClgO2lmKHkuc3RvcmFnZT09PVwidTMyXCImJnkudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtSfV0gJiAweEZGdSksIGJvb2woJHtlfVske1J9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtSfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtSfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7eS5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke3kudmFsdWV9IHlldGApfSkoKSx2ZT1zPDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7eS5pbmRpY2VzfSkgLT4gJHtmfSB7XG4gICAgcmV0dXJuICR7SihgaTJvXyR7ZX0oaW5kaWNlcylgKX07XG4gIH1gLFE9czwyP1wiXCI6KCgpPT57bGV0IFI9ZC5tYXAoZmU9PmBkJHtmZX06IHUzMmApLmpvaW4oXCIsIFwiKSxZPWQubWFwKGZlPT5gZCR7ZmV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtSfSkgLT4gJHtmfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7TShZKX0pO1xuICB9YH0pKCksZWU9KC4uLlIpPT57aWYoUi5sZW5ndGghPT1zKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke3N9YCk7bGV0IFk9Ui5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIHM9PT0wP0ooXCIwdVwiKTpzPT09MT9KKFlbMF0pOihiLmdldD0hMCxiLmdldEJ5SW5kaWNlcz0hMCxiLmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtZfSlgKX0sbGU9Uj0+czwyP0ooUik6KGIuZ2V0QnlJbmRpY2VzPSEwLGIuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfUJ5SW5kaWNlcygke1J9KWApLFo9czwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke3kuaW5kaWNlc30sIHZhbHVlOiAke2Z9KSB7XG4gICAgJHtXKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAscGU9czwyP1wiXCI6KCgpPT57bGV0IFI9ZC5tYXAoZmU9PmBkJHtmZX06IHUzMmApLmpvaW4oXCIsIFwiKSxZPWQubWFwKGZlPT5gZCR7ZmV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gc2V0XyR7ZX0oJHtSfSwgdmFsdWU6ICR7Zn0pIHtcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke00oWSl9LCB2YWx1ZSk7XG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBSPVtdLFk9ITE7cmV0dXJuIGIub2Zmc2V0VG9JbmRpY2VzJiYoUi5wdXNoKFQpLFk9ITApLGIuaW5kaWNlc1RvT2Zmc2V0JiYoUi5wdXNoKGspLFk9ITApLGIuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJihPYmplY3QudmFsdWVzKGopLmZvckVhY2goZmU9PlIucHVzaChmZSkpLFk9ITApLGIuc2V0JiYoUi5wdXNoKHBlKSxZPSEwKSxiLnNldEJ5SW5kaWNlcyYmKFIucHVzaChaKSxZPSEwKSxiLmdldCYmKFIucHVzaChRKSxZPSEwKSxiLmdldEJ5SW5kaWNlcyYmKFIucHVzaCh2ZSksWT0hMCksIWEmJlkmJlIudW5zaGlmdChgY29uc3QgJHtTfSA9ICR7eS5pbmRpY2VzfSgke24uam9pbihcIixcIil9KTtgLGBjb25zdCAkeyR9ID0gJHt5LmluZGljZXN9KCR7RS5jb21wdXRlU3RyaWRlcyhuKS5qb2luKFwiLFwiKX0pO2ApLFIuam9pbihgXG5gKX0sdHlwZTp5LG9mZnNldFRvSW5kaWNlczpDLGluZGljZXNUb09mZnNldDpPLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Om5lLGluZGljZXM6TSxpbmRpY2VzR2V0OlYsaW5kaWNlc1NldDpGLHNldDooLi4uUik9PntpZihSLmxlbmd0aCE9PXMrMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHtzfWApO2xldCBZPVJbc107aWYodHlwZW9mIFkhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IGZlPVIuc2xpY2UoMCxzKS5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIHM9PT0wP1coXCIwdVwiLFkpOnM9PT0xP1coZmVbMF0sWSk6KGIuc2V0PSEwLGIuc2V0QnlJbmRpY2VzPSEwLGIuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2ZlfSwgJHtZfSlgKX0sc2V0QnlPZmZzZXQ6VyxzZXRCeUluZGljZXM6KFIsWSk9PnM8Mj9XKFIsWSk6KGIuc2V0QnlJbmRpY2VzPSEwLGIuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1J9LCAke1l9KTtgKSxnZXQ6ZWUsZ2V0QnlPZmZzZXQ6SixnZXRCeUluZGljZXM6bGUsdXNhZ2U6cixuYW1lOmUsc3RyaWRlczokLHNoYXBlOlMscmFuazpzfX0sUD0oZSx0LG4scj0xKT0+THIoZSx0LG4sXCJpbnB1dFwiLHIpLE49KGUsdCxuLHI9MSk9PkxyKGUsdCxuLFwib3V0cHV0XCIsciksSHM9KGUsdCxuKT0+THIoZSx0LG4sXCJhdG9taWNPdXRwdXRcIiwxKSxHcj0oZSx0LG4scj0xKT0+THIoZSx0LG4sXCJpbnRlcm5hbFwiLHIpLGFvPWNsYXNze2NvbnN0cnVjdG9yKHQsbil7dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cD10O3RoaXMubGltaXRzPW47dGhpcy5pbnRlcm5hbFZhcmlhYmxlcz1bXTt0aGlzLnZhcmlhYmxlcz1bXTt0aGlzLnVuaWZvcm1zPVtdO3RoaXMudmFyaWFibGVJbmRleD0wfWd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXModCl7cmV0dXJuYGlmIChnbG9iYWxfaWR4ID49ICR7dHlwZW9mIHQ9PVwibnVtYmVyXCI/YCR7dH11YDp0fSkgeyByZXR1cm47IH1gfW1haW5TdGFydCh0PUV0KXtsZXQgbj10eXBlb2YgdD09XCJudW1iZXJcIj90OnRbMF0scj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMV0sbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnRbMl07aWYobj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh8fHI+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZfHxvPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWil0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske259LCAke3J9LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBzaXplIFske3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWH0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9XS5gKTtpZihuKnIqbz50aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXApdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtufSwgJHtyfSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgaW52b2NhdGlvbnMgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXB9LmApO2xldCBhPXRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMV09PT0xJiZ0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzJdPT09MSxzPWE/YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+YDpgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihudW1fd29ya2dyb3VwcykgbnVtX3dvcmtncm91cHMgOiB2ZWMzPHUzMj5gLGQ9YT9gbGV0IGdsb2JhbF9pZHggPSBnbG9iYWxfaWQueDtcbiAgICAgICAgIGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueDtgOmBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLnogKiBudW1fd29ya2dyb3Vwc1swXSAqIG51bV93b3JrZ3JvdXBzWzFdICtcbiAgICAgICAgICAgICB3b3JrZ3JvdXBfaWQueSAqIG51bV93b3JrZ3JvdXBzWzBdICsgd29ya2dyb3VwX2lkLng7XG4gICAgICAgICBsZXQgZ2xvYmFsX2lkeCA9IHdvcmtncm91cF9pbmRleCAqICR7bipyKm99dSArIGxvY2FsX2lkeDtgO3JldHVybmBAY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHtufSwgJHtyfSwgJHtvfSlcbiAgZm4gbWFpbigke3N9KSB7XG4gICAgJHtkfVxuICBgfWFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl7dC5yYW5rIT09MCYmKHQuc2hhcGUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc2hhcGUucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5yYW5rfSksdC5zdHJpZGVzLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnN0cmlkZXMucmVwbGFjZShcInVuaWZvcm1zLlwiLFwiXCIpLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5yYW5rfSkpfWRlY2xhcmVWYXJpYWJsZSh0LG4pe2lmKHQudXNhZ2U9PT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnRlcm5hbCB2YXJpYWJsZSB3aXRoIGRlY2xhcmVWYXJpYWJsZSgpLiB1c2UgcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMudmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpO2xldCByPXQudXNhZ2U9PT1cImlucHV0XCI/XCJyZWFkXCI6XCJyZWFkX3dyaXRlXCIsbz10LnVzYWdlPT09XCJhdG9taWNPdXRwdXRcIj9cImF0b21pYzxpMzI+XCI6dC50eXBlLnN0b3JhZ2U7cmV0dXJuYEBncm91cCgwKSBAYmluZGluZygke259KSB2YXI8c3RvcmFnZSwgJHtyfT4gJHt0Lm5hbWV9OiBhcnJheTwke299PjtgfWRlY2xhcmVWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQubWFwKG49PnRoaXMuZGVjbGFyZVZhcmlhYmxlKG4sdGhpcy52YXJpYWJsZUluZGV4KyspKS5qb2luKGBcbmApfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSh0KXtpZih0LnVzYWdlIT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW5wdXQgb3Igb3V0cHV0IHZhcmlhYmxlIHdpdGggcmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKCkuIHVzZSBkZWNsYXJlVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KX1yZWdpc3RlckludGVybmFsVmFyaWFibGVzKC4uLnQpe3JldHVybiB0LmZvckVhY2gobj0+dGhpcy5yZWdpc3RlckludGVybmFsVmFyaWFibGUobikpLHRoaXN9cmVnaXN0ZXJVbmlmb3JtKHQsbixyPTEpe3JldHVybiB0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dCx0eXBlOm4sbGVuZ3RoOnJ9KSx0aGlzfXJlZ2lzdGVyVW5pZm9ybXModCl7cmV0dXJuIHRoaXMudW5pZm9ybXM9dGhpcy51bmlmb3Jtcy5jb25jYXQodCksdGhpc311bmlmb3JtRGVjbGFyYXRpb24oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgdD1bXTtmb3IobGV0e25hbWU6bix0eXBlOnIsbGVuZ3RoOm99b2YgdGhpcy51bmlmb3JtcylpZihvJiZvPjQpcj09PVwiZjE2XCI/dC5wdXNoKGBAYWxpZ24oMTYpICR7bn06YXJyYXk8bWF0Mng0PCR7cn0+LCAke01hdGguY2VpbChvLzgpfT5gKTp0LnB1c2goYCR7bn06YXJyYXk8dmVjNDwke3J9PiwgJHtNYXRoLmNlaWwoby80KX0+YCk7ZWxzZXtsZXQgYT1vPT1udWxsfHxvPT09MT9yOmB2ZWMke299PCR7cn0+YDt0LnB1c2goYCR7bn06JHthfWApfXJldHVybmBcbiAgICAgIHN0cnVjdCBVbmlmb3JtcyB7ICR7dC5qb2luKFwiLCBcIil9IH07XG4gICAgICBAZ3JvdXAoMCkgQGJpbmRpbmcoJHt0aGlzLnZhcmlhYmxlSW5kZXh9KSB2YXI8dW5pZm9ybT4gdW5pZm9ybXM6IFVuaWZvcm1zO2B9Z2V0IGFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMoKXtyZXR1cm4gdGhpcy51bmlmb3JtRGVjbGFyYXRpb24oKSt0aGlzLnZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCkrdGhpcy5pbnRlcm5hbFZhcmlhYmxlcy5tYXAodD0+dC5pbXBsKCkpLmpvaW4oYFxuYCl9Z2V0IHZhcmlhYmxlc0luZm8oKXtpZih0aGlzLnVuaWZvcm1zLmxlbmd0aD09PTApcmV0dXJuO2xldCB0PW49PlsxMiwxMCwxLDZdW1tcInUzMlwiLFwiZjE2XCIsXCJmMzJcIixcImkzMlwiXS5pbmRleE9mKG4pXTtyZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXAobj0+W3Qobi50eXBlKSxuLmxlbmd0aD8/MV0pfX0sRnM9KGUsdCk9Pm5ldyBhbyhlLHQpfSk7dmFyIFhmLHFzLEpmLGVoLHRoLHJoLE9lLEtzLGpzLGN0PUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO1hmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3Bvc2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYodC5sZW5ndGghPT0wJiZ0Lmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBwZXJtIHNpemUgJHt0Lmxlbmd0aH0gZG9lcyBub3QgbWF0Y2ggaW5wdXQgcmFuayAke2VbMF0uZGltcy5sZW5ndGh9YCl9LHFzPShlLHQpPT50Lmxlbmd0aCE9PTA/dDpbLi4ubmV3IEFycmF5KGUpLmtleXMoKV0ucmV2ZXJzZSgpLEpmPShlLHQpPT5FLnNvcnRCYXNlZE9uUGVybShlLHFzKGUubGVuZ3RoLHQpKSxlaD0oZSx0LG4scik9PntsZXQgbz1gZm4gcGVybShpOiAke3IudHlwZS5pbmRpY2VzfSkgLT4gJHtuLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke24udHlwZS5pbmRpY2VzfTtgO2ZvcihsZXQgYT0wO2E8dDsrK2Epbys9YGFbJHtlW2FdfV09aVske2F9XTtgO3JldHVybiBvKz1cInJldHVybiBhO31cIn0sdGg9KGUsdCk9PntsZXQgbj1bXSxyPVtdO2ZvcihsZXQgbz0wO288ZS5sZW5ndGg7KytvKWVbb10hPT0xJiZuLnB1c2goZVtvXSksZVt0W29dXSE9PTEmJnIucHVzaCh0W29dKTtyZXR1cm57bmV3U2hhcGU6bixuZXdQZXJtOnJ9fSxyaD0oZSx0KT0+e2xldCBuPTA7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYodFtlW3JdXSE9PTEpe2lmKGVbcl08bilyZXR1cm4hMTtuPWVbcl19cmV0dXJuITB9LE9lPShlLHQpPT57bGV0IG49ZS5kYXRhVHlwZSxyPWUuZGltcy5sZW5ndGgsbz1xcyhyLHQpLGE9SmYoZS5kaW1zLG8pLHM9ZS5kaW1zLGQ9YSxsPXI8Mnx8cmgobyxlLmRpbXMpLHA7aWYobClyZXR1cm4gcD13PT57bGV0IFM9UChcImlucHV0XCIsbixzLDQpLCQ9TihcIm91dHB1dFwiLG4sZCw0KTtyZXR1cm5gXG4gICR7dy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoUywkKX1cbiAgJHt3Lm1haW5TdGFydCgpfVxuICAgICR7dy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZUNvcHlcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCB3PUUuc2l6ZShhKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwody82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbCh3LzQpfV19fSxnZXRTaGFkZXJTb3VyY2U6cH07bGV0e25ld1NoYXBlOmYsbmV3UGVybTpofT10aChlLmRpbXMsbykseT1FLmFyZUVxdWFsKGgsWzIsMywxXSksXz1FLmFyZUVxdWFsKGgsWzMsMSwyXSk7aWYoZi5sZW5ndGg9PT0yfHx5fHxfKXtzPXk/W2ZbMF0sZlsxXSpmWzJdXTpfP1tmWzBdKmZbMV0sZlsyXV06ZixkPVtzWzFdLHNbMF1dO2xldCB3PTE2O3JldHVybiBwPVM9PntsZXQgJD1QKFwiYVwiLG4scy5sZW5ndGgpLHY9TihcIm91dHB1dFwiLG4sZC5sZW5ndGgpO3JldHVybmBcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICB2YXI8d29ya2dyb3VwPiB0aWxlIDogYXJyYXk8YXJyYXk8JHt2LnR5cGUudmFsdWV9LCAke3crMX0+LCAke3d9PjtcbiAgJHtTLm1haW5TdGFydChbdyx3LDFdKX1cbiAgICBsZXQgc3RyaWRlID0gKHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSAtIDEpIC8gJHt3fSArIDE7XG4gICAgbGV0IHdvcmtncm91cF9pZF94ID0gd29ya2dyb3VwX2luZGV4ICUgc3RyaWRlO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeSA9IHdvcmtncm91cF9pbmRleCAvIHN0cmlkZTtcbiAgICBsZXQgaW5wdXRfY29sID0gd29ya2dyb3VwX2lkX3kgKiAke3d9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IGlucHV0X3JvdyA9IHdvcmtncm91cF9pZF94ICogJHt3fXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChpbnB1dF9yb3cgPCB1bmlmb3Jtcy5hX3NoYXBlWzBdICYmIGlucHV0X2NvbCA8IHVuaWZvcm1zLmFfc2hhcGVbMV0pIHtcbiAgICAgIHRpbGVbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAkeyQuZ2V0QnlJbmRpY2VzKGAkeyQudHlwZS5pbmRpY2VzfShpbnB1dF9yb3csIGlucHV0X2NvbClgKX07XG4gICAgfVxuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGxldCBvdXRwdXRfY29sID0gd29ya2dyb3VwX2lkX3ggKiAke3d9dSArIGxvY2FsX2lkLng7XG4gICAgbGV0IG91dHB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeSAqICR7d311ICsgbG9jYWxfaWQueTtcbiAgICBpZiAob3V0cHV0X3JvdyA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVswXSAmJiBvdXRwdXRfY29sIDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdKSB7XG4gICAgICAke3Yuc2V0QnlJbmRpY2VzKGAke3YudHlwZS5pbmRpY2VzfShvdXRwdXRfcm93LCBvdXRwdXRfY29sKWAsXCJ0aWxlW2xvY2FsX2lkLnhdW2xvY2FsX2lkLnldXCIpfVxuICAgIH1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgUz1FLnNpemUoYSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGRbMV0vdykseTpNYXRoLmNlaWwoZFswXS93KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOlN9LC4uLkgocyxkKV19fSxnZXRTaGFkZXJTb3VyY2U6cH19cmV0dXJuIHA9dz0+e2xldCBTPVAoXCJhXCIsbixzLmxlbmd0aCksJD1OKFwib3V0cHV0XCIsbixkLmxlbmd0aCk7cmV0dXJuYFxuICAke3cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKFMsJCl9XG5cbiAgJHtlaChvLHIsUywkKX1cblxuICAke3cubWFpblN0YXJ0KCl9XG4gICAgJHt3Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHskLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAkeyQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsUy5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IHc9RS5zaXplKGEpO3JldHVybntvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh3LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnd9LC4uLkgocyxkKV19fSxnZXRTaGFkZXJTb3VyY2U6cH19LEtzPShlLHQpPT57WGYoZS5pbnB1dHMsdC5wZXJtKSxlLmNvbXB1dGUoT2UoZS5pbnB1dHNbMF0sdC5wZXJtKSl9LGpzPWU9PnJlKHtwZXJtOmUucGVybX0pfSk7dmFyIG5oLG9oLGloLGFoLHNoLHVoLGRoLGxoLGNoLHBoLG50LFpzLFFzLFlzLFhzLEpzLGV1LHR1LHJ1LG51LG91LGl1PUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtIcigpO2N0KCk7bmg9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgZXhwKGNhbmRpZGF0ZSlcIixsMTpcImJlc3RWYWx1ZSArIGFicyhjYW5kaWRhdGUpXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0sb2g9e21heDpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlID4gYmVzdFZhbHVlKVwiLG1pbjpcInNlbGVjdChiZXN0VmFsdWUsIGNhbmRpZGF0ZSwgY2FuZGlkYXRlIDwgYmVzdFZhbHVlKVwiLG1lYW46XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixzdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixwcm9kOlwiYmVzdFZhbHVlICogY2FuZGlkYXRlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtRXhwOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDE6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxpaD17bWF4OlwiX0Fbb2Zmc2V0XVwiLG1pbjpcIl9BW29mZnNldF1cIixtZWFuOlwiMFwiLHN1bTpcIjBcIixwcm9kOlwiMVwiLHN1bVNxdWFyZTpcIjBcIixsb2dTdW1FeHA6XCIwXCIsbDE6XCIwXCIsbDI6XCIwXCIsbG9nU3VtOlwiMFwifSxhaD17bWF4OlwiYmVzdFZhbHVlXCIsbWluOlwiYmVzdFZhbHVlXCIsc3VtOlwiYmVzdFZhbHVlXCIscHJvZDpcImJlc3RWYWx1ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZVwiLGxvZ1N1bUV4cDpcImxvZyhiZXN0VmFsdWUpXCIsbDE6XCJiZXN0VmFsdWVcIixsMjpcInNxcnQoYmVzdFZhbHVlKVwiLGxvZ1N1bTpcImxvZyhiZXN0VmFsdWUpXCJ9LHNoPShlLHQpPT57bGV0IG49W107Zm9yKGxldCByPXQtZTtyPHQ7KytyKW4ucHVzaChyKTtyZXR1cm4gbn0sdWg9KGUsdCk9PntsZXQgbj1bXSxyPWUubGVuZ3RoO2ZvcihsZXQgYT0wO2E8cjthKyspdC5pbmRleE9mKGEpPT09LTEmJm4ucHVzaChlW2FdKTtsZXQgbz10Lm1hcChhPT5lW2FdKTtyZXR1cm5bbixvXX0sZGg9KGUsdCk9PntsZXQgbj1lLmxlbmd0aCt0Lmxlbmd0aCxyPVtdLG89MDtmb3IobGV0IGE9MDthPG47YSsrKXQuaW5kZXhPZihhKT09PS0xP3IucHVzaChlW28rK10pOnIucHVzaCgxKTtyZXR1cm4gcn0sbGg9KGUsdCk9Pntmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZihlW2UubGVuZ3RoLW4tMV0hPT10LTEtbilyZXR1cm4hMTtyZXR1cm4hMH0sY2g9KGUsdCk9PntsZXQgbj1bXTtpZighbGgoZSx0KSl7Zm9yKGxldCByPTA7cjx0OysrcillLmluZGV4T2Yocik9PT0tMSYmbi5wdXNoKHIpO2UuZm9yRWFjaChyPT5uLnB1c2gocikpfXJldHVybiBufSxwaD0oZSx0LG4scixvLGEscyk9PntsZXQgZD1uWzBdLmRpbXMsbD1FLnNpemUoYSkscD1FLnNpemUocyksZj1QKFwiX0FcIixuWzBdLmRhdGFUeXBlLGQpLGg9TihcIm91dHB1dFwiLG8sYSkseT02NDtsPT09MSYmKHk9MjU2KTtsZXQgXz1gXG4gICAgICAgICAgdmFyPHdvcmtncm91cD4gYUJlc3RWYWx1ZXMgOiBhcnJheTxmMzIsICR7eX0+O1xuICAgICAgIGAsYj13PT5gXG4gICAgICAgICR7dy5yZWdpc3RlclVuaWZvcm0oXCJyZWR1Y2VTaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhmLGgpfVxuICAgICAgICAke199XG4gICAgICAgIGZuIERJVl9DRUlMKGEgOiB1MzIsIGIgOiB1MzIpIC0+IHUzMiB7XG4gICAgICAgICAgcmV0dXJuICgoYSAtIDF1KSAvIGIgKyAxdSk7XG4gICAgICAgICB9XG4gICAgICAgICAke3cubWFpblN0YXJ0KHkpfVxuXG4gICAgICAgICAgbGV0IG91dHB1dEluZGV4ID0gZ2xvYmFsX2lkeCAvICR7eX07XG4gICAgICAgICAgbGV0IG9mZnNldCA9IG91dHB1dEluZGV4ICogdW5pZm9ybXMucmVkdWNlU2l6ZTtcblxuICAgICAgICAgIHZhciBiZXN0VmFsdWUgPSBmMzIoJHtpaFtyXX0pO1xuICAgICAgICAgIGxldCBMZW5ndGggPSB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuICAgICAgICAgIGZvciAodmFyIGsgPSBsb2NhbF9pZHg7IGsgPCBMZW5ndGg7IGsgPSBrICsgJHt5fSkge1xuICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gZjMyKCR7Zi5nZXRCeU9mZnNldChcIm9mZnNldCArIGtcIil9KTtcbiAgICAgICAgICAgYmVzdFZhbHVlID0gJHtuaFtyXX07XG4gICAgICAgICAgfVxuICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihMZW5ndGgsICR7eX11KTtcbiAgICAgICAgIGZvciAodmFyIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1OyByZWR1Y2VTaXplID4gMXU7XG4gICAgICAgICAgICAgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnUpIHtcbiAgICAgICAgICAgbGV0IGludGVydmFsID0gRElWX0NFSUwocmVkdWNlU2l6ZSwgMnUpO1xuICAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgY3VycmVudFNpemUpIHtcbiAgICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBhQmVzdFZhbHVlc1tsb2NhbF9pZHggKyBpbnRlcnZhbF07XG4gICAgICAgICAgICBiZXN0VmFsdWUgPSAke29oW3JdfTtcbiAgICAgICAgICAgIGFCZXN0VmFsdWVzW2xvY2FsX2lkeF0gPSBiZXN0VmFsdWU7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmVkdWNlU2l6ZSA9IGludGVydmFsO1xuICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICB9XG5cbiAgICAgICAgIGlmIChsb2NhbF9pZHggPT0gMHUpIHtcbiAgICAgICAgICAke2guc2V0QnlPZmZzZXQoXCJvdXRwdXRJbmRleFwiLGAke3I9PT1cIm1lYW5cIj9gJHtoLnR5cGUuc3RvcmFnZX0oYmVzdFZhbHVlIC8gZjMyKHVuaWZvcm1zLnJlZHVjZVNpemUpKWA6YCR7aC50eXBlLnN0b3JhZ2V9KCR7YWhbcl19KWB9YCl9O1xuICAgICAgICAgfVxuICAgICAgICB9YDtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3R9OyR7eX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTpiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpsfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6cH1dfSl9fSxudD0oZSx0LG4scik9PntsZXQgbz1lLmlucHV0cy5sZW5ndGg9PT0xP246bG8oZS5pbnB1dHMsbiksYT1vLmF4ZXM7YS5sZW5ndGg9PT0wJiYhby5ub29wV2l0aEVtcHR5QXhlcyYmKGE9ZS5pbnB1dHNbMF0uZGltcy5tYXAoKF8sYik9PmIpKTtsZXQgcz1FLm5vcm1hbGl6ZUF4ZXMoYSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCksZD1zLGw9ZS5pbnB1dHNbMF0scD1jaChkLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKTtwLmxlbmd0aD4wJiYobD1lLmNvbXB1dGUoT2UoZS5pbnB1dHNbMF0scCkse2lucHV0czpbMF0sb3V0cHV0czpbLTFdfSlbMF0sZD1zaChkLmxlbmd0aCxsLmRpbXMubGVuZ3RoKSk7bGV0W2YsaF09dWgobC5kaW1zLGQpLHk9ZjtvLmtlZXBEaW1zJiYoeT1kaChmLHMpKSxlLmNvbXB1dGUocGgodCxvLmNhY2hlS2V5LFtsXSxyLGUuaW5wdXRzWzBdLmRhdGFUeXBlLHksaCkse2lucHV0czpbbF19KX0sWnM9KGUsdCk9PntudChlLFwiUmVkdWNlTWVhblNoYXJlZFwiLHQsXCJtZWFuXCIpfSxRcz0oZSx0KT0+e250KGUsXCJSZWR1Y2VMMVNoYXJlZFwiLHQsXCJsMVwiKX0sWXM9KGUsdCk9PntudChlLFwiUmVkdWNlTDJTaGFyZWRcIix0LFwibDJcIil9LFhzPShlLHQpPT57bnQoZSxcIlJlZHVjZUxvZ1N1bUV4cFNoYXJlZFwiLHQsXCJsb2dTdW1FeHBcIil9LEpzPShlLHQpPT57bnQoZSxcIlJlZHVjZU1heFNoYXJlZFwiLHQsXCJtYXhcIil9LGV1PShlLHQpPT57bnQoZSxcIlJlZHVjZU1pblNoYXJlZFwiLHQsXCJtaW5cIil9LHR1PShlLHQpPT57bnQoZSxcIlJlZHVjZVByb2RTaGFyZWRcIix0LFwicHJvZFwiKX0scnU9KGUsdCk9PntudChlLFwiUmVkdWNlU3VtU2hhcmVkXCIsdCxcInN1bVwiKX0sbnU9KGUsdCk9PntudChlLFwiUmVkdWNlU3VtU3F1YXJlU2hhcmVkXCIsdCxcInN1bVNxdWFyZVwiKX0sb3U9KGUsdCk9PntudChlLFwiUmVkdWNlTG9nU3VtU2hhcmVkXCIsdCxcImxvZ1N1bVwiKX19KTt2YXIgb3QsbWgsRnIsbG8saXQsZmgsaGgsZ2gseWgsYmgsX2gsd2gsdmgsJGgseGgsYXQsYXUsc3UsdXUsZHUsbHUsY3UscHUsbXUsZnUsaHUsSHI9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7aXUoKTtvdD1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2Ugb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZS5sZW5ndGg9PT0yJiZlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGF4ZXMgaW5wdXQgZGltcy5cIil9LG1oPWU9PltcIlwiLFwiXCIsYHZhciB2YWx1ZSA9ICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdLEZyPShlLHQsbixyLG8sYSxzPSExLGQ9ITEpPT57bGV0IGw9W10scD1uWzBdLmRpbXMsZj1wLmxlbmd0aCxoPUUubm9ybWFsaXplQXhlcyhvLGYpLHk9IWQmJmgubGVuZ3RoPT09MDtwLmZvckVhY2goKFMsJCk9Pnt5fHxoLmluZGV4T2YoJCk+PTA/cyYmbC5wdXNoKDEpOmwucHVzaChTKX0pO2xldCBfPWwubGVuZ3RoLGI9RS5zaXplKGwpO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6dCxnZXRTaGFkZXJTb3VyY2U6Uz0+e2xldCAkPVtdLHY9UChcIl9BXCIsblswXS5kYXRhVHlwZSxmKSxUPU4oXCJvdXRwdXRcIixhLF8pLEM9cih2LFQsaCksQT1DWzJdO2ZvcihsZXQgaz0wLE89MDtrPGY7aysrKXl8fGguaW5kZXhPZihrKT49MD8ocyYmTysrLEE9YGZvcih2YXIgaiR7a306IHUzMiA9IDA7IGoke2t9IDwgJHtwW2tdfTsgaiR7a30rKykge1xuICAgICAgICAgICAgICAgICAgJHtDWzJdLmluY2x1ZGVzKFwibGFzdF9pbmRleFwiKT9gbGV0IGxhc3RfaW5kZXggPSBqJHtrfTtgOlwiXCJ9XG4gICAgICAgICAgICAgICAgICAke3YuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixrLGBqJHtrfWApfVxuICAgICAgICAgICAgICAgICAgJHtBfVxuICAgICAgICAgICAgICAgIH1gKTooJC5wdXNoKGAke3YuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixrLFQuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsTykpfTtgKSxPKyspO3JldHVybmBcblxuICAgICAgICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHYsVCl9XG5cbiAgICAgICAgJHtTLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7di50eXBlLmluZGljZXN9O1xuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7VC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICR7JC5qb2luKGBcbmApfVxuICAgICAgICAgICR7Q1swXX0gICAgICAgLy8gaW5pdCBvcHMgZm9yIHJlZHVjZSBtYXgvbWluXG4gICAgICAgICAgJHtDWzFdfVxuICAgICAgICAgICR7QX1cbiAgICAgICAgICAke0NbM119XG4gICAgICAgICAgJHtDLmxlbmd0aD09PTQ/VC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpOkMuc2xpY2UoNCkuam9pbihgXG5gKX1cbiAgICAgICAgfWB9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYi82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpifSwuLi5IKHAsbCldfSl9fSxsbz0oZSx0KT0+e2xldCBuPVtdO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChyPT5uLnB1c2goTnVtYmVyKHIpKSkscmUoe2F4ZXM6bixrZWVwRGltczp0LmtlZXBEaW1zLG5vb3BXaXRoRW1wdHlBeGVzOnQubm9vcFdpdGhFbXB0eUF4ZXN9KX0saXQ9KGUsdCxuLHIpPT57bGV0IG89ZS5pbnB1dHMsYT1vLmxlbmd0aD09PTE/bjpsbyhvLG4pO2UuY29tcHV0ZShGcih0LHtoaW50OmEuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW29bMF1dLGEubm9vcFdpdGhFbXB0eUF4ZXMmJmEuYXhlcy5sZW5ndGg9PT0wP21oOnIsYS5heGVzLG9bMF0uZGF0YVR5cGUsYS5rZWVwRGltcyxhLm5vb3BXaXRoRW1wdHlBeGVzKSx7aW5wdXRzOlswXX0pfSxmaD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTG9nU3VtXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGhoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VMMVwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBhYnMoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdKX0sZ2g9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZUwyXCIsdCwocixvKT0+W2B2YXIgdCA9ICR7by50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gKHQgKiB0KTtgLFwidmFsdWUgPSBzcXJ0KHZhbHVlKTtcIl0pfSx5aD0oZSx0KT0+e290KGUuaW5wdXRzKSxpdChlLFwiUmVkdWNlTG9nU3VtRXhwXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGV4cCgke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sYmg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1heFwiLHQsKHIsbyxhKT0+e2xldCBzPVtdO2ZvcihsZXQgZD0wO2Q8ci5yYW5rO2QrKykoYS5pbmRleE9mKGQpPj0wfHxhLmxlbmd0aD09PTApJiZzLnB1c2goci5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsMCkpO3JldHVybltgJHtzLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWF4KHZhbHVlLCAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sX2g9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZU1lYW5cIix0LChyLG8sYSk9PntsZXQgcz0xO2ZvcihsZXQgZD0wO2Q8ci5yYW5rO2QrKykoYS5pbmRleE9mKGQpPj0wfHxhLmxlbmd0aD09PTApJiYocyo9ZS5pbnB1dHNbMF0uZGltc1tkXSk7cmV0dXJuW1widmFyIHN1bSA9IGYzMigwKTtcIixcIlwiLGBzdW0gKz0gZjMyKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxgbGV0IHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KHN1bSAvICR7c30pO2BdfSl9LHdoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VNaW5cIix0LChyLG8sYSk9PntsZXQgcz1bXTtmb3IobGV0IGQ9MDtkPHIucmFuaztkKyspKGEuaW5kZXhPZihkKT49MHx8YS5sZW5ndGg9PT0wKSYmcy5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1pbih2YWx1ZSwgJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LHZoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VQcm9kXCIsdCwocixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgxKTtgLFwiXCIsYHZhbHVlICo9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sJGg9KGUsdCk9PntvdChlLmlucHV0cyksaXQoZSxcIlJlZHVjZVN1bVwiLHQsKHIsbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LHhoPShlLHQpPT57b3QoZS5pbnB1dHMpLGl0KGUsXCJSZWR1Y2VTdW1TcXVhcmVcIix0LChyLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSB0ICogdDtgLFwiXCJdKX0sYXQ9KGUsdCxuKT0+e2lmKHQubGVuZ3RoPT09MClyZXR1cm4gbjtsZXQgcj0xLG89MTtmb3IobGV0IGE9MDthPHQubGVuZ3RoO2ErKyl0LmluZGV4T2YoYSk9PT0tMT9yKj1lW2FdOm8qPWVbYV07cmV0dXJuIG88MzImJnI+MTAyNH0sYXU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9faChlLHQpOlpzKGUsdCl9LHN1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/aGgoZSx0KTpRcyhlLHQpfSx1dT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2doKGUsdCk6WXMoZSx0KX0sZHU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT95aChlLHQpOlhzKGUsdCl9LGx1PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/YmgoZSx0KTpKcyhlLHQpfSxjdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3doKGUsdCk6ZXUoZSx0KX0scHU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT92aChlLHQpOnR1KGUsdCl9LG11PShlLHQpPT57YXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/JGgoZSx0KTpydShlLHQpfSxmdT0oZSx0KT0+e2F0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3hoKGUsdCk6bnUoZSx0KX0saHU9KGUsdCk9PnthdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9maChlLHQpOm91KGUsdCl9fSk7dmFyIGd1LHl1LGJ1LGNvLF91PUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO0NlKCk7SHIoKTtndT1lPT57aWYoIWV8fGUubGVuZ3RoPT09MHx8ZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJBcmdNaW5NYXhPcCBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHR5cGUuXCIpfSx5dT0oZSx0KT0+e2d1KGUuaW5wdXRzKTtsZXQgbj0ocixvLGEpPT57bGV0IHM9W107Zm9yKGxldCBkPTA7ZDxyLnJhbms7ZCsrKShhLmluZGV4T2YoZCk+PTB8fGEubGVuZ3RoPT09MCkmJnMucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake3Muam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI8PVwiOlwiPFwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke3IuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoRnIoXCJBcmdNaW5cIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0sbixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGJ1PShlLHQpPT57Z3UoZS5pbnB1dHMpO2xldCBuPShyLG8sYSk9PntsZXQgcz1bXTtmb3IobGV0IGQ9MDtkPHIucmFuaztkKyspKGEuaW5kZXhPZihkKT49MHx8YS5sZW5ndGg9PT0wKSYmcy5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7cy5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtyLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIj49XCI6XCI+XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7ci5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShGcihcImFyZ01heFwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxuLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sY289ZT0+cmUoZSl9KTt2YXIgU2gscG8sVGgsQ2gsSWgsVXQsQWgsd3UscXI9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtWcigpO2NlKCk7U2g9KGUsdCk9PntsZXQgbj1lWzBdLHI9ZVsxXSxvPWVbMl0sYT1lWzNdLHM9ZVs0XSxkPWVbNV07aWYocyYmZCl0aHJvdyBuZXcgRXJyb3IoXCJBdHRlbnRpb24gY2Fubm90IGhhdmUgYm90aCBwYXN0IGFuZCBhdHRlbnRpb25fYmlhc1wiKTtpZihuLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiaW5wdXRcIiBtdXN0IGhhdmUgMyBkaW1lbnNpb25zJyk7bGV0IGw9bi5kaW1zWzBdLHA9bi5kaW1zWzFdLGY9bi5kaW1zWzJdO2lmKG8uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnMnKTtpZihyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwid2VpZ2h0c1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09Zil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCAxIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAyIG9mIGlucHV0IDBcIik7aWYoby5kaW1zWzBdIT09ci5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDEgb2YgaW5wdXQgXCJ3ZWlnaHRzXCInKTtsZXQgaD1vLmRpbXNbMF0vMyx5PWgsXz15O2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoPjApe2lmKHQucWt2SGlkZGVuU2l6ZXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGF0dHJpYnV0ZSBzaG91bGQgaGF2ZSAzIGVsZW1lbnRzXCIpO2ZvcihsZXQgVCBvZiB0LnFrdkhpZGRlblNpemVzKWlmKFQldC5udW1IZWFkcyE9PTApdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBzaG91bGQgYmUgZGl2aXNpYmxlIGJ5IG51bV9oZWFkc1wiKTtoPXQucWt2SGlkZGVuU2l6ZXNbMF0seT10LnFrdkhpZGRlblNpemVzWzFdLF89dC5xa3ZIaWRkZW5TaXplc1syXX1sZXQgYj1wO2lmKGghPT15KXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgZmlyc3QgZWxlbWVudCBzaG91bGQgYmUgc2FtZSBhcyB0aGUgc2Vjb25kXCIpO2lmKG8uZGltc1swXSE9PWgreStfKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgc3VtIG9mIFEvSy9WIGhpZGRlbiBzaXplcycpO2xldCB3PTA7aWYocyl7aWYoeSE9PV8pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBleHBlY3Qga19oaWRkZW5fc2l6ZSA9PSB2X2hpZGRlbl9zaXplJyk7aWYocy5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBtdXN0IGhhdmUgNSBkaW1lbnNpb25zJyk7aWYocy5kaW1zWzBdIT09Mil0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpcnN0IGRpbWVuc2lvbiBtdXN0IGJlIDInKTtpZihzLmRpbXNbMV0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgc2Vjb25kIGRpbWVuc2lvbiBtdXN0IGJlIGJhdGNoX3NpemUnKTtpZihzLmRpbXNbMl0hPT10Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgdGhpcmQgZGltZW5zaW9uIG11c3QgYmUgbnVtX2hlYWRzJyk7aWYocy5kaW1zWzRdIT09eS90Lm51bUhlYWRzKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlmdGggZGltZW5zaW9uIG11c3QgYmUga19oaWRkZW5fc2l6ZSAvIG51bV9oZWFkcycpO3QucGFzdFByZXNlbnRTaGFyZUJ1ZmZlcnx8KHc9cy5kaW1zWzNdKX1sZXQgUz1iK3csJD0tMSx2PTA7aWYoYSl0aHJvdyBuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIik7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJwYXN0IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgbXVzdCBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGQuZGltc1swXSE9PWx8fGQuZGltc1sxXSE9PXQubnVtSGVhZHN8fGQuZGltc1syXSE9PXB8fGQuZGltc1szXSE9PVMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpwLHBhc3RTZXF1ZW5jZUxlbmd0aDp3LGt2U2VxdWVuY2VMZW5ndGg6Yix0b3RhbFNlcXVlbmNlTGVuZ3RoOlMsbWF4U2VxdWVuY2VMZW5ndGg6JCxpbnB1dEhpZGRlblNpemU6ZixoaWRkZW5TaXplOmgsdkhpZGRlblNpemU6XyxoZWFkU2l6ZTpNYXRoLmZsb29yKGgvdC5udW1IZWFkcyksdkhlYWRTaXplOk1hdGguZmxvb3IoXy90Lm51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGlzVW5pZGlyZWN0aW9uYWw6ITEscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrRmlsdGVyVmFsdWU6dC5tYXNrRmlsdGVyVmFsdWUsbWFza1R5cGU6dixzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6ITEscGFzc1Bhc3RJbkt2OiExLHFrdkZvcm1hdDoxfX0scG89KGUsdCxuKT0+dCYmZT9gXG4gICAgICBsZXQgdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0ID0gdTMyKCR7dC5nZXRCeU9mZnNldChcIjBcIil9KTtcbiAgICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IG1heCh0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQsIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoKTtcbiAgICAgIGxldCBpc19zdWJzZXF1ZW50X3Byb21wdDogYm9vbCA9IHNlcXVlbmNlX2xlbmd0aCA+IDEgJiYgc2VxdWVuY2VfbGVuZ3RoICE9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIGxldCBpc19maXJzdF9wcm9tcHQ6IGJvb2wgPSBpc19zdWJzZXF1ZW50X3Byb21wdCA9PSBmYWxzZSAmJiBzZXF1ZW5jZV9sZW5ndGggPT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdTMyKCR7ZT8uZ2V0QnlPZmZzZXQoXCJiYXRjaElkeFwiKX0pICsgMTtcbiAgICAgIHZhciBwYXN0X3NlcXVlbmNlX2xlbmd0aDogdTMyID0gMDtcbiAgICAgIGlmIChpc19maXJzdF9wcm9tcHQgPT0gZmFsc2UpIHtcbiAgICAgICAgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggLSBzZXF1ZW5jZV9sZW5ndGg7XG4gICAgICB9XG4gICAgICAgYDpgXG4gICAgJHtuP1wibGV0IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGhcIjpcIlwifTtcbiAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgYCxUaD0oZSx0LG4scixvLGEscyxkKT0+e2xldCBsPWdlKHM/MTphKSxwPTY0LGY9YS9sO2Y8cCYmKHA9MzIpO2xldCBoPU1hdGguY2VpbChhL2wvcCkseT1be3R5cGU6MTIsZGF0YTp0fSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOmZ9LHt0eXBlOjEyLGRhdGE6aH1dLF89X2UoZS5kYXRhVHlwZSxsKSxiPXplKDEsbCksdz1bXCJ0eXBlXCJdO3MmJncucHVzaChcInR5cGVcIiksZCYmdy5wdXNoKFwidHlwZVwiKTtsZXQgUz0kPT57bGV0IHY9TihcInhcIixlLmRhdGFUeXBlLGUuZGltcyxsKSxUPVt2XSxDPXM/UChcInNlcV9sZW5zXCIscy5kYXRhVHlwZSxzLmRpbXMpOnZvaWQgMDtDJiZULnB1c2goQyk7bGV0IEE9ZD9QKFwidG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0XCIsZC5kYXRhVHlwZSxkLmRpbXMpOnZvaWQgMDtBJiZULnB1c2goQSk7bGV0IGs9emUoZS5kYXRhVHlwZSksTz1be25hbWU6XCJiYXRjaF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVsZW1lbnRzX3Blcl90aHJlYWRcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9tYXg6IGFycmF5PGYzMiwgJHtwfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRocmVhZF9zdW06IGFycmF5PGYzMiwgJHtwfT47XG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKE8pLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCl9XG4gICR7JC5tYWluU3RhcnQoW3AsMSwxXSl9XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuc2VxdWVuY2VfbGVuZ3RoO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7XG4gICAgJHtwbyhDLEEsITEpfVxuICAgIGxldCBsb2NhbF9vZmZzZXQgPSBsb2NhbF9pZHggKiB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkO1xuICAgIGxldCBvZmZzZXQgPSAoZ2xvYmFsX2lkeCAvICR7cH0pICogdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoICsgbG9jYWxfb2Zmc2V0O1xuICAgIGxldCBzZXFfY2F1c2FsX2xlbmd0aCA9ICR7cz9cInUzMihwYXN0X3NlcXVlbmNlX2xlbmd0aCArIHdvcmtncm91cF9pZC55ICsgMSlcIjpcInRvdGFsX3NlcXVlbmNlX2xlbmd0aFwifTtcbiAgICB2YXIgdGhyZWFkX21heF92ZWN0b3IgPSAke2J9KC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgdGhyZWFkX21heF92ZWN0b3IgPSBtYXgoJHtifSh4W29mZnNldCArIGldKSwgdGhyZWFkX21heF92ZWN0b3IpO1xuICAgIH1cbiAgICB0aHJlYWRfbWF4W2xvY2FsX2lkeF0gPSAkeygoKT0+e3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCJ0aHJlYWRfbWF4X3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cIm1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KVwiO2Nhc2UgNDpyZXR1cm5cIm1heChtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSksIG1heCh0aHJlYWRfbWF4X3ZlY3Rvci56LCB0aHJlYWRfbWF4X3ZlY3Rvci53KSlcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtsfWApfX0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBtYXhfdmFsdWUgPSAgZjMyKC0zLjQwMjgyM2UrMzhmKTtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIG1heF92YWx1ZSA9IG1heCh0aHJlYWRfbWF4W2ldLCBtYXhfdmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBzdW1fdmVjdG9yID0gJHtifSgwKTtcbiAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgc3VtX3ZlY3RvciArPSBleHAoJHtifSh4W29mZnNldCArIGldKSAtIG1heF92YWx1ZSk7XG4gICAgfVxuICAgIHRocmVhZF9zdW1bbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInN1bV92ZWN0b3JcIjtjYXNlIDI6cmV0dXJuXCJzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnlcIjtjYXNlIDQ6cmV0dXJuXCJzdW1fdmVjdG9yLnggKyBzdW1fdmVjdG9yLnkgKyBzdW1fdmVjdG9yLnogKyBzdW1fdmVjdG9yLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtsfWApfX0pKCl9O1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIHZhciBzdW06IGYzMiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtwfTsgaSsrKSB7XG4gICAgICBzdW0gKz0gdGhyZWFkX3N1bVtpXTtcbiAgICB9XG5cbiAgICBpZiAoc3VtID09IDApIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oJHtrfSgxLjApIC8gJHtrfShzZXFfY2F1c2FsX2xlbmd0aCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZjMyaW5wdXQgPSAke2J9KHhbb2Zmc2V0ICsgaV0pO1xuICAgICAgICB4W29mZnNldCArIGldID0gJHt2LnR5cGUudmFsdWV9KGV4cChmMzJpbnB1dCAtIG1heF92YWx1ZSkgLyBzdW0pO1xuICAgICAgfVxuICAgIH1cbiAgICAgICR7cz9gXG4gICAgICAgIGZvciAodmFyIHRvdGFsX3NlcV9pZDogdTMyID0gc2VxX2NhdXNhbF9sZW5ndGg7IHRvdGFsX3NlcV9pZCArIGxvY2FsX29mZnNldCA8IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgdG90YWxfc2VxX2lkKyspIHtcbiAgICAgICAgICB4W29mZnNldCArIHRvdGFsX3NlcV9pZF0gPSAke3YudHlwZS52YWx1ZX0oJHtrfSgwKSk7XG4gICAgICAgIH1gOlwiXCJ9O1xuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1NvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtwfTske199OyR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFNoYWRlclNvdXJjZTpTLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhL3ApLHk6byx6OnQqbn0scHJvZ3JhbVVuaWZvcm1zOnl9KX19LENoPShlLHQsbixyLG8sYSxzLGQsbCk9PntsZXQgcD1zK2Eua3ZTZXF1ZW5jZUxlbmd0aCxmPVthLmJhdGNoU2l6ZSxhLm51bUhlYWRzLGEuc2VxdWVuY2VMZW5ndGgscF0saD1lPjEmJnIseT1hLmt2TnVtSGVhZHM/YS5rdk51bUhlYWRzOmEubnVtSGVhZHMsXz1oP1thLmJhdGNoU2l6ZSx5LHAsYS5oZWFkU2l6ZV06dm9pZCAwLGI9YS5uUmVwcz9hLm5SZXBzOjEsdz1hLnNjYWxlPT09MD8xL01hdGguc3FydChhLmhlYWRTaXplKTphLnNjYWxlLFM9Z2UoYS5oZWFkU2l6ZSksJD1hLmhlYWRTaXplL1Msdj0xMixUPXt4Ok1hdGguY2VpbChwL3YpLHk6TWF0aC5jZWlsKGEuc2VxdWVuY2VMZW5ndGgvdiksejphLmJhdGNoU2l6ZSphLm51bUhlYWRzfSxDPVt7dHlwZToxMixkYXRhOmEuc2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOmEubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6YS5oZWFkU2l6ZX0se3R5cGU6MSxkYXRhOnd9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTphLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6Yn1dLEE9aCYmciYmRS5zaXplKHIuZGltcyk+MCxrPVtcInR5cGVcIixcInR5cGVcIl07QSYmay5wdXNoKFwidHlwZVwiKSxvJiZrLnB1c2goXCJ0eXBlXCIpLGQmJmsucHVzaChcInR5cGVcIiksbCYmay5wdXNoKFwidHlwZVwiKTtsZXQgTz1be2RpbXM6ZixkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XTtoJiZPLnB1c2goe2RpbXM6XyxkYXRhVHlwZTp0LmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9KTtsZXQgTT1WPT57bGV0IEY9UChcInFcIix0LmRhdGFUeXBlLHQuZGltcyxTKSxqPVAoXCJrZXlcIixuLmRhdGFUeXBlLG4uZGltcyxTKSxuZT1bRixqXTtpZihBKXtsZXQgWj1QKFwicGFzdF9rZXlcIixyLmRhdGFUeXBlLHIuZGltcyxTKTtuZS5wdXNoKFopfW8mJm5lLnB1c2goUChcImF0dGVudGlvbl9iaWFzXCIsby5kYXRhVHlwZSxvLmRpbXMpKTtsZXQgVz1kP1AoXCJzZXFfbGVuc1wiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7VyYmbmUucHVzaChXKTtsZXQgSj1sP1AoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixsLmRhdGFUeXBlLGwuZGltcyk6dm9pZCAwO0omJm5lLnB1c2goSik7bGV0IHZlPU4oXCJvdXRwdXRcIix0LmRhdGFUeXBlLGYpLFE9W3ZlXTtoJiZRLnB1c2goTihcInByZXNlbnRfa2V5XCIsdC5kYXRhVHlwZSxfLFMpKTtsZXQgZWU9emUoMSxTKSxsZT1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7dn11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke0YudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7Ri50eXBlLnN0b3JhZ2V9LCAke3Yqdn0+O1xuICAke1YucmVnaXN0ZXJVbmlmb3JtcyhsZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5uZSwuLi5RKX1cbiAgJHtWLm1haW5TdGFydChbdix2LDFdKX1cbiAgICAvLyB4IGhvbGRzIHRoZSBOIGFuZCB5IGhvbGRzIHRoZSBNXG4gICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQga3ZIZWFkSWR4ID0gJHtiPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGt2X251bV9oZWFkcyA9ICR7Yj09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IHdvcmtncm91cF9pZC55ICogVElMRV9TSVpFO1xuICAgIGxldCBuID0gd29ya2dyb3VwX2lkLnggKiBUSUxFX1NJWkU7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk47XG4gICAgJHtwbyhXLEosITApfVxuICAgIGxldCBhYnNLdkhlYWRJZHggPSBiYXRjaElkeCAqIGt2X251bV9oZWFkcyArIGt2SGVhZElkeDtcbiAgICBsZXQgcU9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLksgKyBtICogdW5pZm9ybXMuSztcbiAgICAke0EmJmg/XCJsZXQgcGFzdEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcIjpcIlwifTtcbiAgICBsZXQga09mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XG4gICAgJHtoP1wibGV0IHByZXNlbnRLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSztcIjpcIlwifVxuICAgIHZhciB2YWx1ZSA9ICR7ZWV9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChnbG9iYWxfaWQueSA8IHVuaWZvcm1zLk0gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHFbcU9mZnNldCArIGxvY2FsX2lkLnkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgJHtBJiZoP2BcbiAgICAgICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0gcGFzdF9rZXlbcGFzdEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgICAgICB9YDpgXG4gICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICB9YH1cbiAgICAgICR7aD9gaWYgKG4gKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgcHJlc2VudF9rZXlbcHJlc2VudEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdID0gdGlsZUtbaWR4XTtcbiAgICAgIH1gOlwiXCJ9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICAgIHZhbHVlICs9ICR7ZWV9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICBsZXQgaGVhZE9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGdsb2JhbF9pZC55ICogdW5pZm9ybXMuTiArIGdsb2JhbF9pZC54O1xuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCk9Pntzd2l0Y2goUyl7Y2FzZSAxOnJldHVyblwidmFsdWVcIjtjYXNlIDI6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueVwiO2Nhc2UgNDpyZXR1cm5cInZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHtTfWApfX0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7dmUudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7bz9cImF0dGVudGlvbl9iaWFzW291dHB1dElkeF1cIjpcIjAuMFwifTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7U307JHtvIT09dm9pZCAwfTske3IhPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOmt9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpPLGRpc3BhdGNoR3JvdXA6VCxwcm9ncmFtVW5pZm9ybXM6Q30pLGdldFNoYWRlclNvdXJjZTpNfX0sSWg9KGUsdCxuLHIsbyxhLHM9dm9pZCAwLGQ9dm9pZCAwKT0+e2xldCBsPWErby5rdlNlcXVlbmNlTGVuZ3RoLHA9by5uUmVwcz9vLm5SZXBzOjEsZj1vLnZIaWRkZW5TaXplKnAsaD1lPjEmJnIseT1vLmt2TnVtSGVhZHM/by5rdk51bUhlYWRzOm8ubnVtSGVhZHMsXz1oP1tvLmJhdGNoU2l6ZSx5LGwsby5oZWFkU2l6ZV06dm9pZCAwLGI9W28uYmF0Y2hTaXplLG8uc2VxdWVuY2VMZW5ndGgsZl0sdz0xMixTPXt4Ok1hdGguY2VpbChvLnZIZWFkU2l6ZS93KSx5Ok1hdGguY2VpbChvLnNlcXVlbmNlTGVuZ3RoL3cpLHo6by5iYXRjaFNpemUqby5udW1IZWFkc30sJD1be3R5cGU6MTIsZGF0YTpvLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6by52SGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6by5udW1IZWFkc30se3R5cGU6MTIsZGF0YTpvLmhlYWRTaXplfSx7dHlwZToxMixkYXRhOmZ9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpvLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6cH1dLHY9aCYmciYmRS5zaXplKHIuZGltcyk+MCxUPVtcInR5cGVcIixcInR5cGVcIl07diYmVC5wdXNoKFwidHlwZVwiKSxzJiZULnB1c2goXCJ0eXBlXCIpLGQmJlQucHVzaChcInR5cGVcIik7bGV0IEM9W3tkaW1zOmIsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07aCYmQy5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IEE9az0+e2xldCBPPVAoXCJwcm9ic1wiLHQuZGF0YVR5cGUsdC5kaW1zKSxNPVAoXCJ2XCIsbi5kYXRhVHlwZSxuLmRpbXMpLFY9W08sTV07diYmVi5wdXNoKFAoXCJwYXN0X3ZhbHVlXCIsci5kYXRhVHlwZSxyLmRpbXMpKTtsZXQgRj1zP1AoXCJzZXFfbGVuc1wiLHMuZGF0YVR5cGUscy5kaW1zKTp2b2lkIDA7cyYmVi5wdXNoKEYpO2xldCBqPWQ/UChcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7ZCYmVi5wdXNoKGopO2xldCBXPVtOKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxiKV07aCYmVy5wdXNoKE4oXCJwcmVzZW50X3ZhbHVlXCIsdC5kYXRhVHlwZSxfKSk7bGV0IEo9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ2X2hpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7d311O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtPLnR5cGUudmFsdWV9LCAke3cqd30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlVjogYXJyYXk8JHtPLnR5cGUudmFsdWV9LCAke3cqd30+O1xuICAke2sucmVnaXN0ZXJVbmlmb3JtcyhKKS5kZWNsYXJlVmFyaWFibGVzKC4uLlYsLi4uVyl9XG4gICR7ay5tYWluU3RhcnQoW3csdywxXSl9XG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQga3ZIZWFkSWR4ID0gJHtwPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICBsZXQga3ZfbnVtX2hlYWRzID0gJHtwPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG4gICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5LO1xuICAgJHtwbyhGLGosITApfVxuICAgbGV0IG9mZnNldEEgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7IC8vIGt2SGVhZElkeCBpcyByZWxhdGl2ZSB0byB0aGUgYmF0Y2hcbiAgICR7diYmaD9cImxldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuO1wiOlwiXCJ9O1xuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICR7aD9cImxldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47XCI6XCJcIn1cbiAgIHZhciB2YWx1ZSA9ICR7Ty50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7diYmaD9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YH1cbiAgICAgICAgJHtoP2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpUfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6QyxkaXNwYXRjaEdyb3VwOlMscHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6QX19LFV0PShlLHQsbixyLG8sYSxzLGQsbCxwLGY9dm9pZCAwLGg9dm9pZCAwKT0+e2xldCB5PU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsocz8xOjApKyhkPzE6MCkpLF89eT4xP3AucGFzdFNlcXVlbmNlTGVuZ3RoOjAsYj1fK3Aua3ZTZXF1ZW5jZUxlbmd0aCx3PWwmJkUuc2l6ZShsLmRpbXMpPjA/bDp2b2lkIDAsUz1bdCxuXTt5PjEmJnMmJkUuc2l6ZShzLmRpbXMpPjAmJlMucHVzaChzKSx3JiZTLnB1c2godyksZiYmUy5wdXNoKGYpLGgmJlMucHVzaChoKTtsZXQgJD1lLmNvbXB1dGUoQ2goeSx0LG4scyx3LHAsXyxmLGgpLHtpbnB1dHM6UyxvdXRwdXRzOnk+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShUaCgkLHAuYmF0Y2hTaXplLHAubnVtSGVhZHMsXyxwLnNlcXVlbmNlTGVuZ3RoLGIsZixoKSx7aW5wdXRzOmYmJmg/WyQsZixoXTpbJF0sb3V0cHV0czpbXX0pO2xldCB2PVskLHJdO3k+MSYmZCYmRS5zaXplKGQuZGltcyk+MCYmdi5wdXNoKGQpLGYmJnYucHVzaChmKSxoJiZ2LnB1c2goaCksZS5jb21wdXRlKEloKHksJCxyLGQscCxfLGYsaCkse2lucHV0czp2LG91dHB1dHM6eT4xP1swLDJdOlswXX0pfSxBaD0oZSx0KT0+e2xldCBuPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0scj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsYT10LmhlYWRTaXplLHM9MTIsZD17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9zKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL3MpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sbD1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLHA9W3t0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxmPWg9PntsZXQgeT1OKFwib3V0cHV0X3FcIixsWzBdLmRhdGFUeXBlLG4pLF89TihcIm91dHB1dF9rXCIsbFswXS5kYXRhVHlwZSxuKSxiPU4oXCJvdXRwdXRfdlwiLGxbMF0uZGF0YVR5cGUsbiksdz1QKFwiaW5wdXRcIixsWzBdLmRhdGFUeXBlLGxbMF0uZGltcyksUz1QKFwid2VpZ2h0XCIsbFsxXS5kYXRhVHlwZSxsWzFdLmRpbXMpLCQ9UChcImJpYXNcIixsWzJdLmRhdGFUeXBlLGxbMl0uZGltcyksdj13LnR5cGUuc3RvcmFnZSxUPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3N9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke3Z9LCAke3Mqc30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHt2fSwgJHtzKnN9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7dn0sICR7cypzfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke3Z9LCAke3Mqc30+O1xuICAke2gucmVnaXN0ZXJVbmlmb3JtcyhUKS5kZWNsYXJlVmFyaWFibGVzKHcsUywkLHksXyxiKX1cbiAgJHtoLm1haW5TdGFydChbcyxzLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke3Z9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOm4sZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6bixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDpkLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOmZ9LHtpbnB1dHM6bCxvdXRwdXRzOlstMSwtMSwtMV19KX0sd3U9KGUsdCk9PntsZXQgbj1TaChlLmlucHV0cyx0KSxbcixvLGFdPUFoKGUsbik7cmV0dXJuIFV0KGUscixvLGEsZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0sbil9fSk7dmFyIGtoLEVoLFBoLHZ1LCR1PUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3RlKCk7YWUoKTtDZSgpO2NlKCk7a2g9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0c1wiKTtsZXQgbj0ocixvLGEpPT57bGV0IHM9by5sZW5ndGg7aWYocyE9PXIubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHthfTogbnVtIGRpbWVuc2lvbnMgIT0gJHtzfWApO28uZm9yRWFjaCgoZCxsKT0+e2lmKGQhPT1yW2xdKXRocm93IG5ldyBFcnJvcihgJHthfTogZGltWyR7bH1dIGRvIG5vdCBtYXRjaGApfSl9O2lmKGVbMF0uZGltcy5sZW5ndGg+MSl7bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIj90LnNwYXRpYWw/ZVswXS5kaW1zLnNsaWNlKC0xKTplWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChlWzBdLmRpbXMuc2xpY2UoMSxlWzBdLmRpbXMubGVuZ3RoLTEpKTplWzBdLmRpbXMuc2xpY2UoMSx0LnNwYXRpYWw/Mjp2b2lkIDApO24oZVsxXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLG4oZVsyXS5kaW1zLHIsXCJJbnZhbGlkIGlucHV0IEJcIiksbihlWzNdLmRpbXMscixcIkludmFsaWQgaW5wdXQgbWVhblwiKSxuKGVbNF0uZGltcyxyLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9ZWxzZSBuKGVbMV0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLG4oZVsyXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgQlwiKSxuKGVbM10uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IG1lYW5cIiksbihlWzRdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9LEVoPShlLHQpPT57bGV0e2Vwc2lsb246bixzcGF0aWFsOnIsZm9ybWF0Om99PXQsYT1lWzBdLmRpbXMscz1yP2dlKGFbYS5sZW5ndGgtMV0pOjEsZD1vPT09XCJOSFdDXCImJmEubGVuZ3RoPjE/czoxLGw9RS5zaXplKGEpL3MscD1yLGY9cD9hLmxlbmd0aDphLGg9UChcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxzKSx5PVAoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGQpLF89UChcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxkKSxiPVAoXCJpbnB1dE1lYW5cIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxkKSx3PVAoXCJpbnB1dFZhclwiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGQpLFM9TihcInlcIixlWzBdLmRhdGFUeXBlLGYscyksJD0oKT0+e2xldCBUPVwiXCI7aWYocilUPWBsZXQgY09mZnNldCA9ICR7YS5sZW5ndGg9PT0xP1wiMHVcIjpvPT09XCJOSFdDXCI/YG91dHB1dEluZGljZXNbJHthLmxlbmd0aC0xfV0gLyAke3N9YDpcIm91dHB1dEluZGljZXNbMV1cIn07YDtlbHNlIGlmKG89PT1cIk5DSFdcIilUPWBcbiAgICAgICAgICAgICR7Uy5pbmRpY2VzU2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiMFwiLFwiMFwiKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHtTLmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtUPWB2YXIgY0luZGljZXMgPSAke3kudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7YS5sZW5ndGgtMX1dO2A7Zm9yKGxldCBDPTE7Qzx5LnJhbms7QysrKVQrPWBjSW5kaWNlc1ske0N9XSA9IG91dHB1dEluZGljZXNbJHtDfV07YDtUKz1gbGV0IGNPZmZzZXQgPSAke3kuaW5kaWNlc1RvT2Zmc2V0KFwiY0luZGljZXNcIil9O2B9cmV0dXJuIFR9LHY9VD0+YFxuICBjb25zdCBlcHNpbG9uID0gJHtufTtcbiAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGgseSxfLGIsdyxTKX1cbiAgJHtULm1haW5TdGFydCgpfVxuICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtzfWApfTtcbiAgICAkeyQoKX1cbiAgICBsZXQgc2NhbGUgPSAke3kuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgYmlhcyA9ICR7Xy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke2IuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke3cuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgeCA9ICR7aC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke3J9XyR7c31gLGlucHV0RGVwZW5kZW5jaWVzOnA/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTp2LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnA/W3t0eXBlOjEyLGRhdGE6bH0sLi4uSChhKV06W3t0eXBlOjEyLGRhdGE6bH1dfSl9fSxQaD1lPT5yZShlKSx2dT0oZSx0KT0+e2xldHtpbnB1dHM6bixvdXRwdXRDb3VudDpyfT1lLG89UGgoey4uLnQsb3V0cHV0Q291bnQ6cn0pO2lmKHdlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYma2gobixvKSx0LnRyYWluaW5nTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtlLmNvbXB1dGUoRWgobixvKSl9fSk7dmFyIHpoLE9oLHh1LFN1PUcoKCk9PntcInVzZSBzdHJpY3RcIjthZSgpO2NlKCk7emg9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sT2g9ZT0+e2xldCB0PWVbMF0uZGltcyxuPWVbMF0uZGltc1syXSxyPUUuc2l6ZSh0KS80LG89ZVswXS5kYXRhVHlwZSxhPVAoXCJpbnB1dFwiLG8sdCw0KSxzPVAoXCJiaWFzXCIsbyxbbl0sNCksZD1QKFwicmVzaWR1YWxcIixvLHQsNCksbD1OKFwib3V0cHV0XCIsbyx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci82NCl9fSksZ2V0U2hhZGVyU291cmNlOmY9PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke259dSAvIDQ7XG4gICR7Zi5kZWNsYXJlVmFyaWFibGVzKGEscyxkLGwpfVxuXG4gICR7Zi5tYWluU3RhcnQoKX1cbiAgICAke2YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhyKX1cbiAgICBsZXQgdmFsdWUgPSAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke3MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0seHU9ZT0+e3poKGUuaW5wdXRzKSxlLmNvbXB1dGUoT2goZS5pbnB1dHMpKX19KTt2YXIgRGgseWUsVHUsQ3UsSXUsQXUsa3UsRXUsUHUsenUsT3UsQmgsRHUsQnUsTXUsUnUsdHIsVXUsS3IsTnUsVnUsV3UsTHUsR3UsSHUsRnUscXUsS3UsanUsWnUsUXUsWXUsWHUsSnUsZWQsdGQscmQsbW8sZm8sbmQsb2QsaWQsTWgsUmgsYWQsanI9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7RGg9KGUsdCxuLHIsbyxhLHMpPT57bGV0IGQ9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBvPT1cInN0cmluZ1wiP2w9YCR7b30oYSlgOmw9byhcImFcIik7bGV0IHA9UChcImlucHV0RGF0YVwiLG4sW2RdLDQpLGY9TihcIm91dHB1dERhdGFcIixyLFtkXSw0KSxoPVt7bmFtZTpcInZlY19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIHMmJmgucHVzaCguLi5zKSxgXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhoKS5kZWNsYXJlVmFyaWFibGVzKHAsZil9XG5cbiAgJHthPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuXG4gICAgbGV0IGEgPSAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke2Yuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSx5ZT0oZSx0LG4scixvLGE9ZS5kYXRhVHlwZSxzLGQpPT57bGV0IGw9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKEUuc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIHMmJmwucHVzaCguLi5zKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnA9PkRoKHAsRS5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxhLG4scixkKSxnZXRSdW5EYXRhOnA9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOmF9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChFLnNpemUocFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LFR1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LEN1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sSXU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LEF1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sa3U9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LEV1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sUHU9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LHp1PWU9PnJlKGUpLE91PShlLHQpPT57bGV0IG47c3dpdGNoKHQudG8pe2Nhc2UgMTA6bj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpuPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpuPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2Om49XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6bj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJDYXN0XCIsbix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LEJoPWU9PntsZXQgdCxuLHI9ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9cj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixuPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9cj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEsbj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIHJlKHttaW46dCxtYXg6bn0pfSxEdT0oZSx0KT0+e2xldCBuPXR8fEJoKGUuaW5wdXRzKSxyPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIHZlYzQ8JHtyfT4odW5pZm9ybXMubWluKSwgdmVjNDwke3J9Pih1bmlmb3Jtcy5tYXgpKWAsdm9pZCAwLG4uY2FjaGVLZXksdm9pZCAwLFt7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOm4ubWlufSx7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOm4ubWF4fV0sW3tuYW1lOlwibWluXCIsdHlwZTpyfSx7bmFtZTpcIm1heFwiLHR5cGU6cn1dKSx7aW5wdXRzOlswXX0pfSxCdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LE11PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LFJ1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sdHI9ZT0+cmUoZSksVXU9KGUsdCk9PntsZXQgbj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiRWx1XCIscj0+YGVsdV92ZjMyKCR7cn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke259KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtufSkgLT4gJHtufSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7bn0+KSAtPiB2ZWM0PCR7bn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxLcj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsTnU9ZT0+e2xldCB0PXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJFcmZcIixuPT5gZXJmX3ZmMzIoJHtufSlgLEtyKHQpKSl9LFZ1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LFd1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxMdT1lPT57bGV0IHQ9emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkdlbHVcIixuPT5gMC41ICogJHtufSAqICgxLjAgKyBlcmZfdmYzMigke259ICogMC43MDcxMDY3ODExODY1NDc1KSlgLEtyKHQpKSl9LEd1PShlLHQpPT57bGV0IG49emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLHI9PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke3J9LCAke3J9LCAke3J9ID49IHZlYzQ8JHtufT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7bn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LEh1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LEZ1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LHF1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxLdT1lPT57bGV0IHQ9emUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlJlbHVcIixuPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtufSwgJHtufSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LGp1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxadT1lPT5yZShlKSxRdT0oZSx0KT0+e2xldCBuPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLHI9PmBtYXgodmVjNDwke259PigwLjApLCBtaW4odmVjNDwke259PigxLjApLCAke3QuYWxwaGF9ICogJHtyfSArIHZlYzQ8JHtufT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSxZdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxYdT1lPT57ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LEp1PWU9PntlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0sZWQ9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sdGQ9ZT0+YHNpZ24oJHtlfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2V9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHtlfSkpKWAscmQ9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIlRhbmhcIix0ZCkpfSxtbz0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7dGQoXCJ2XCIpfTtcbn1cbmAsZm89ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsbmQ9ZT0+e2xldCB0PXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoeWUoZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLGZvLG1vKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxvZD0oZSx0KT0+e2xldCBuPXplKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIscj0+YHNlbGVjdCh2ZWM0PCR7bn0+KDAuMCksICR7cn0sICR7cn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtufT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0saWQ9ZT0+e2UuY29tcHV0ZSh5ZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sTWg9KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsUmg9ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAsYWQ9KGUsdCk9PntsZXQgbj16ZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKHllKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsUmgsTWgobix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFVoLE5oLHVkLGRkPUcoKCk9PntcInVzZSBzdHJpY3RcIjthZSgpO2NlKCk7anIoKTtVaD1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxOaD1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IG49UChcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCkscj1QKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGE9RS5zaXplKHQpLzQscz1fZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKG4scixvKX1cblxuICAke0tyKHMpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhhKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sdWQ9ZT0+e1VoKGUuaW5wdXRzKSxlLmNvbXB1dGUoTmgoZS5pbnB1dHMpKX19KTt2YXIgVmgsV2gsc3QsbGQsY2QscGQsbWQsZmQsaGQsZ2QseWQsYmQsX2Qsd2Q9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO1ZoPShlLHQsbixyLG8sYSxzLGQsbCxwLGYsaCk9PntsZXQgeSxfO3R5cGVvZiBkPT1cInN0cmluZ1wiP3k9Xz0odixUKT0+YCR7ZH0oKCR7dn0pLCgke1R9KSlgOnR5cGVvZiBkPT1cImZ1bmN0aW9uXCI/eT1fPWQ6KHk9ZC5zY2FsYXIsXz1kLnZlY3Rvcik7bGV0IGI9TihcIm91dHB1dERhdGFcIixmLHIubGVuZ3RoLDQpLHc9UChcImFEYXRhXCIsbCx0Lmxlbmd0aCw0KSxTPVAoXCJiRGF0YVwiLHAsbi5sZW5ndGgsNCksJDtpZihvKWlmKGEpe2xldCB2PUUuc2l6ZSh0KT09PTEsVD1FLnNpemUobik9PT0xLEM9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxBPW4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA7dnx8VD8kPWIuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh2P2Ake3cudHlwZS52YWx1ZX0oJHt3LmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOncuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFQ/YCR7Uy50eXBlLnZhbHVlfSgke1MuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6Uy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTokPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtiLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7dy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7Uy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIixiKX07XG4gICAgICAgICAgICAke2Iuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhzfHxDP3cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7dy50eXBlLnZhbHVlfSgke3cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxzfHxBP1MuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7Uy50eXBlLnZhbHVlfSgke1MuZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSAkPWIuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh3LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCB2PShULEMsQT1cIlwiKT0+e2xldCBrPWBhRGF0YVtpbmRleEEke0N9XVtjb21wb25lbnRBJHtDfV1gLE89YGJEYXRhW2luZGV4QiR7Q31dW2NvbXBvbmVudEIke0N9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke0N9ID0gJHtiLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtDfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7Q30gPSAke3cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke0N9YCxiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7Q30gPSAke1MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke0N9YCxiKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtDfSA9IG9mZnNldEEke0N9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtDfSA9IG9mZnNldEIke0N9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7Q30gPSBvZmZzZXRBJHtDfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke0N9ID0gb2Zmc2V0QiR7Q30gJSA0dTtcbiAgICAgICAgICAgICR7VH1bJHtDfV0gPSAke0F9KCR7eShrLE8pfSk7XG4gICAgICAgICAgYH07Zj09PTk/JD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOiQ9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHcsUyxiKX1cblxuICAgICAgICAke2g/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH0sV2g9KGUsdCxuLHIsbyxhLHM9bi5kYXRhVHlwZSk9PntsZXQgZD1uLmRpbXMubWFwKHc9Pk51bWJlcih3KT8/MSksbD1yLmRpbXMubWFwKHc9Pk51bWJlcih3KT8/MSkscD0hRS5hcmVFcXVhbChkLGwpLGY9ZCxoPUUuc2l6ZShkKSx5PSExLF89ITEsYj1bcF07aWYocCl7bGV0IHc9cnQuY2FsY1NoYXBlKGQsbCwhMSk7aWYoIXcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7Zj13LnNsaWNlKCksaD1FLnNpemUoZik7bGV0IFM9RS5zaXplKGQpPT09MSwkPUUuc2l6ZShsKT09PTEsdj1kLmxlbmd0aD4wJiZkW2QubGVuZ3RoLTFdJTQ9PT0wLFQ9bC5sZW5ndGg+MCYmbFtsLmxlbmd0aC0xXSU0PT09MDtiLnB1c2goUyksYi5wdXNoKCQpLGIucHVzaCh2KSxiLnB1c2goVCk7bGV0IEM9MTtmb3IobGV0IEE9MTtBPGYubGVuZ3RoO0ErKyl7bGV0IGs9ZFtkLmxlbmd0aC1BXSxPPWxbbC5sZW5ndGgtQV07aWYoaz09PU8pQyo9aztlbHNlIGJyZWFrfUMlND09PTA/KF89ITAseT0hMCk6KFN8fCR8fHZ8fFQpJiYoeT0hMCl9ZWxzZSB5PSEwO3JldHVybiBiLnB1c2goeSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K2IubWFwKHc9PncudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnc9PlZoKHcsZCxsLGYseSxwLF8sbyxuLmRhdGFUeXBlLHIuZGF0YVR5cGUscyxhKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmYsZGF0YVR5cGU6c31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoRS5zaXplKGYpLzQpfSwuLi5IKGQsbCxmKV19KX19LHN0PShlLHQsbixyLG8sYSk9PntlLmNvbXB1dGUoV2godCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLG4scixhKSl9LGxkPWU9PntzdChlLFwiQWRkXCIsKHQsbik9PmAke3R9KyR7bn1gKX0sY2Q9ZT0+e3N0KGUsXCJEaXZcIiwodCxuKT0+YCR7dH0vJHtufWApfSxwZD1lPT57c3QoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PT0ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH09PSR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sbWQ9ZT0+e3N0KGUsXCJNdWxcIiwodCxuKT0+YCR7dH0qJHtufWApfSxmZD1lPT57bGV0IHQ9UChcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTtzdChlLFwiUG93XCIse3NjYWxhcjoocixvKT0+YHBvd19jdXN0b20oJHtyfSwke299KWAsdmVjdG9yOihyLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtyfSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LGhkPWU9PntzdChlLFwiU3ViXCIsKHQsbik9PmAke3R9LSR7bn1gKX0sZ2Q9ZT0+e3N0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9PiR7bn0pYCx2ZWN0b3I6KHQsbik9PmB2ZWM0PHUzMj4oJHt0fT4ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9LHlkPWU9PntzdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fTwke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH08JHtufSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxiZD1lPT57c3QoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxuKT0+YHUzMigke3R9Pj0ke259KWAsdmVjdG9yOih0LG4pPT5gdmVjNDx1MzI+KCR7dH0+PSR7bn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sX2Q9ZT0+e3N0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQsbik9PmB1MzIoJHt0fTw9JHtufSlgLHZlY3RvcjoodCxuKT0+YHZlYzQ8dTMyPigke3R9PD0ke259KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIEdoLEhoLEZoLHFoLHZkLCRkLHhkPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0doPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IG49MCxyPWVbbl0sbz1yLmRhdGFUeXBlLGE9ci5kaW1zLmxlbmd0aDtlLmZvckVhY2goKHMsZCk9PntpZihkIT09bil7aWYocy5kYXRhVHlwZSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYocy5kaW1zLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtzLmRpbXMuZm9yRWFjaCgobCxwKT0+e2lmKHAhPT10JiZsIT09ci5kaW1zW3BdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfSl9fSl9LEhoPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAsRmg9KGUsdCk9PntsZXQgbj1lLmxlbmd0aCxyPVtdO2ZvcihsZXQgbz0wO288bjsrK28pe2xldCBhPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtvXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtuPT09MT9yLnB1c2goYSk6bz09PTA/ci5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke299dSkgeyAke2F9IH1gKTpvPT09bi0xP3IucHVzaChgZWxzZSB7ICR7YX0gfWApOnIucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke299KSB7ICR7YX0gfWApfXJldHVybiByLmpvaW4oYFxuYCl9LHFoPShlLHQsbixyKT0+e2xldCBvPUUuc2l6ZShuKSxhPW5ldyBBcnJheShlLmxlbmd0aCkscz1uZXcgQXJyYXkoZS5sZW5ndGgpLGQ9MCxsPVtdLHA9W10sZj1be3R5cGU6MTIsZGF0YTpvfV07Zm9yKGxldCB3PTA7dzxlLmxlbmd0aDsrK3cpZCs9ZVt3XS5kaW1zW3RdLGFbd109ZCxwLnB1c2goZVt3XS5kaW1zLmxlbmd0aCksc1t3XT1QKGBpbnB1dCR7d31gLHIscFt3XSksbC5wdXNoKFwicmFua1wiKSxmLnB1c2goe3R5cGU6MTIsZGF0YTphW3ddfSk7Zm9yKGxldCB3PTA7dzxlLmxlbmd0aDsrK3cpZi5wdXNoKC4uLkgoZVt3XS5kaW1zKSk7Zi5wdXNoKC4uLkgobikpO2xldCBoPU4oXCJvdXRwdXRcIixyLG4ubGVuZ3RoKSx5PWguaW5kaWNlc0dldChcImluZGljZXNcIix0KSxfPUFycmF5LmZyb20oQXJyYXkoYS5sZW5ndGgpLmtleXMoKSkubWFwKHc9PmB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHt3fWApLmpvaW4oXCIsXCIpLGI9dz0+YFxuXG4gICR7KCgpPT57dy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIik7Zm9yKGxldCBTPTA7UzxlLmxlbmd0aDtTKyspdy5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke1N9YCxcInUzMlwiKTtyZXR1cm4gdy5kZWNsYXJlVmFyaWFibGVzKC4uLnMsaCl9KSgpfVxuXG4gICR7SGgoYS5sZW5ndGgsXyl9XG5cbiAgJHt3Lm1haW5TdGFydCgpfVxuICAgICR7dy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtoLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7eX0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHthLmxlbmd0aH11Pigke199KTtcbiAgICAgICR7eX0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7RmgocyxoKX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6bH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuLGRhdGFUeXBlOnJ9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6Yn19LHZkPShlLHQpPT57bGV0IG49ZS5pbnB1dHMscj1uWzBdLmRpbXMsbz1FLm5vcm1hbGl6ZUF4aXModC5heGlzLHIubGVuZ3RoKTtHaChuLG8pO2xldCBhPXIuc2xpY2UoKTthW29dPW4ucmVkdWNlKChkLGwpPT5kKyhsLmRpbXMubGVuZ3RoPm8/bC5kaW1zW29dOjApLDApO2xldCBzPW4uZmlsdGVyKGQ9PkUuc2l6ZShkLmRpbXMpPjApO2UuY29tcHV0ZShxaChzLG8sYSxuWzBdLmRhdGFUeXBlKSx7aW5wdXRzOnN9KX0sJGQ9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgamUsWmUsUWUsWnIsdnQ9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtqZT0oZSx0LG49XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke259KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtufSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtufSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7bn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke259KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxaZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxRZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxacj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbbixyXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOm4sYmV0YTpyfX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W24scl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtMcyxHc107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4OnIsY2xpcE1pbjpufX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6bn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIEVlLFNkLFFyPUcoKCk9PntcInVzZSBzdHJpY3RcIjtFZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxTZD1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgVGQsQ2Q9RygoKT0+e1widXNlIHN0cmljdFwiO1RkPWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgcnIsWXIsWHI9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3Z0KCk7cnI9KGUsdCxuLHIsbyk9PntsZXQgYT1yLW47cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6bn0pLm1hcCgocyxkKT0+YFxuICAgICAgaWYgKCR7Syh0LnNoYXBlLGQsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsSyhvLGQrYSxyKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LFlyPShlLHQsbixyLG89ITEsYSk9PntsZXQgcz1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1zW3MubGVuZ3RoLTJdLHA9ZFtkLmxlbmd0aC0xXSxmPXNbcy5sZW5ndGgtMV0saD1nZShwKSx5PWdlKGYpLF89Z2UobCksYj1FLnNpemUobikvaC9fLHc9ZS5sZW5ndGg+MixTPXI/ci5zbGljZSgwLC0yKTpuLnNsaWNlKDAsLTIpLHY9W0Uuc2l6ZShTKSxsLHBdLFQ9W3t0eXBlOjEyLGRhdGE6Yn0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6Zn1dO1plKHQsVCksVC5wdXNoKC4uLkgoUyxzLGQpKSx3JiZULnB1c2goLi4uSChlWzJdLmRpbXMpKSxULnB1c2goLi4uSCh2KSk7bGV0IEM9QT0+e2xldCBrPUdyKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUsUy5sZW5ndGgpLE89UChcImFcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoLHkpLE09UChcImJcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLGgpLFY9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdi5sZW5ndGgsaCksRj1fZShWLnR5cGUudGVuc29yKSxqPWplKHQsVi50eXBlLnZhbHVlLEYpLG5lPVtPLE1dLFc9XCJcIjtpZih3KXtsZXQgUT1vP2g6MTtuZS5wdXNoKFAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFEpKSxXPWAke28/YHZhbHVlICs9IGJpYXNbY29sIC8gJHtRfV07YDpgdmFsdWUgKz0gJHtWLnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2B9YH1sZXQgSj1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn1dO1FlKHQsSik7bGV0IHZlPSgpPT57bGV0IFE9YHZhciBhX2RhdGE6ICR7Ty50eXBlLnZhbHVlfTtgO2ZvcihsZXQgZWU9MDtlZTx5O2VlKyspUSs9YFxuICAgICAgICAgICAgICBsZXQgYl9kYXRhJHtlZX0gPSBiWyhiX29mZnNldCArIChrICsgJHtlZX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke2h9XTtgO2ZvcihsZXQgZWU9MDtlZTxfO2VlKyspe1ErPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2VlfSkgKiB1bmlmb3Jtcy5LICsgaykgLyAke3l9XTtgO2ZvcihsZXQgbGU9MDtsZTx5O2xlKyspUSs9YFxuICAgICAgICAgICAgdmFsdWVzWyR7ZWV9XSA9IGZtYSgke00udHlwZS52YWx1ZX0oYV9kYXRhJHt5PT09MT9cIlwiOmBbJHtsZX1dYH0pLCBiX2RhdGEke2xlfSwgdmFsdWVzWyR7ZWV9XSk7XG5gfXJldHVybiBRfTtyZXR1cm5gXG4gICR7QS5yZWdpc3RlclVuaWZvcm1zKEopLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5uZSxWKX1cbiAgJHtBLm1haW5TdGFydCgpfVxuICAgICR7QS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke2h9KSkgKiAke2h9O1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke2h9KTtcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke199O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke199O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke24ubGVuZ3RoPT09Mj9cIlwiOmBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJiYXRjaFwiKX07YH1cblxuICAgIHZhciBhX2luZGljZXM6ICR7Ty50eXBlLmluZGljZXN9O1xuICAgICR7cnIoXCJhX2luZGljZXNcIixPLE8ucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtPLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixPLnJhbmstMiwwKX1cbiAgICAke08uaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLE8ucmFuay0xLDApfVxuICAgIGxldCBhX29mZnNldCA9ICR7Ty5pbmRpY2VzVG9PZmZzZXQoXCJhX2luZGljZXNcIil9O1xuXG4gICAgdmFyIGJfaW5kaWNlczogJHtNLnR5cGUuaW5kaWNlc307XG4gICAgJHtycihcImJfaW5kaWNlc1wiLE0sTS5yYW5rLTIsay5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke00uaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLE0ucmFuay0yLDApfVxuICAgICR7TS5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsTS5yYW5rLTEsMCl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtNLmluZGljZXNUb09mZnNldChcImJfaW5kaWNlc1wiKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtWLnR5cGUudmFsdWV9LCAke199PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHt5fSkge1xuICAgICAgJHt2ZSgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke199dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke1d9XG4gICAgICAke2p9XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke1YudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke1YuaW5kaWNlc1RvT2Zmc2V0KFwiY3VyX2luZGljZXNcIil9O1xuICAgICAgJHtWLnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke2h9YCxcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1cbiAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxOYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYWN0aXZhdGlvbn07JHtofTske3l9OyR7X307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6dz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YT9hKG4pOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGIvNjQpfSxwcm9ncmFtVW5pZm9ybXM6VH0pLGdldFNoYWRlclNvdXJjZTpDfX19KTt2YXIgS2gsamgsaG8sSWQsWmgsZ28sUWgsbnIsSnI9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3Z0KCk7WHIoKTtRcigpO0toPShlLHQpPT5lP2BcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYDpgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgLGpoPShlLHQpPT5lP2BcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cbiAgICAgICAgfWA6YFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cbiAgICAgICAgfWAsaG89KGUsdCxuPVwiZjMyXCIscixvPSExLGE9MzIscz0hMSxkPTMyKT0+e2xldCBsPXRbMV0qZVsxXSxwPXRbMF0qZVswXSxmPW8/bDphLGg9bz9hOmwseT1mL3RbMF0sXz1hL3RbMV07aWYoISgobyYmeT09PTQmJmVbMV09PT00fHwhbyYmKHk9PT0zfHx5PT09NCkpJiZmJXRbMF09PT0wJiZhJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7b30gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke3l9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7eX0gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHtmfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7YX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHt5fTwke259PiwgJHtmL3l9PiwgJHtofT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7bn0+LCAke3AvZVswXX0+LCAke2F9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHt5fTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7YX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke3M/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICR7cj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7ci5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7bH07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7cz9gJHtNYXRoLmNlaWwoZC9hKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgdmFyIGtTdGFydCA9ICR7cz9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtufT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtffTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke0toKG8scil9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7cj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke3k9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XG5cbiAgICAgICAgICAke2poKG8seSl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gfSxJZD0oZSx0KT0+ZT9gXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGA6YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgLFpoPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLGdvPShlLHQsbj1cImYzMlwiLHIsbz0hMSxhPTMyLHM9ITEsZD0zMixsPSExKT0+e2xldCBwPWVbMV0qdFsxXSxmPWVbMF0qdFswXSxoPW8/cDphLHk9bz9hOnA7aWYoISh5JXRbMV09PT0wJiZoJXRbMF09PT0wJiZhJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHt5fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke2h9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHthfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCBfPXkvdFsxXSxiPWgvdFswXSx3PWEvdFsxXSxTPWw/YFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHtmfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHt5fTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2h9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgICR7SWQobyxyKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2F9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke2Z9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtyP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtvP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA6YFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke199O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke2J9O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke3d9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7Yn07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7SWQobyxyKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke3d9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7cj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke259LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke1poKG8pfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7bn0sICR7aH0+LCAke3l9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7bn0sICR7Zn0+LCAke2F9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHthfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7cz9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgICAke3I/YGxldCBiYXRjaEluZGljZXMgPSAke3Iub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICAgIGxldCBudW1fdGlsZXMgPSAke3M/YCR7TWF0aC5jZWlsKGQvYSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gICAgdmFyIGtTdGFydCA9ICR7cz9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7bn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG4gICAgJHtTfVxuICB9XG5gfSxRaD0oZSx0LG4scixvPSExKT0+e2xldFthLHMsZCxsXT1yLHA9X2UoclswXS50eXBlLnRlbnNvcik7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YS50eXBlLmluZGljZXN9KSAtPiAke0VlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7RWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBhSW5kaWNlczogJHtzLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7cnIoXCJhSW5kaWNlc1wiLHMscy5yYW5rLTIsYS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke3MuaW5kaWNlc1NldChcImFJbmRpY2VzXCIscy5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHtzLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLHMucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke3MuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7YS50eXBlLmluZGljZXN9KSAtPiAke0VlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7RWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBiSW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7cnIoXCJiSW5kaWNlc1wiLGQsZC5yYW5rLTIsYS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2QuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsZC5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2QuZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke0VlKGUscCl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke28/XCJiaWFzW2NvbEluXVwiOmAke0VlKGUscCl9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XG4gICAgICAgICR7bn1cbiAgICAgICAgJHtsLnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYH0sbnI9KGUsdCxuLHIsbz0hMSxhKT0+e2xldCBzPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPXMuc2xpY2UoMCwtMikscD1kLnNsaWNlKDAsLTIpLGY9cj9yLnNsaWNlKDAsLTIpOm4uc2xpY2UoMCwtMiksaD1FLnNpemUoZikseT1zW3MubGVuZ3RoLTJdLF89c1tzLmxlbmd0aC0xXSxiPWRbZC5sZW5ndGgtMV0sdz1fJTQ9PT0wJiZiJTQ9PT0wLFM9eTw9OD9bNCwxLDFdOls0LDQsMV0sJD1bOCw4LDFdLHY9W01hdGguY2VpbChiLyRbMF0vU1swXSksTWF0aC5jZWlsKHkvJFsxXS9TWzFdKSxNYXRoLmNlaWwoaC8kWzJdL1NbMl0pXSxUPXc/NDoxLEM9Wy4uLmwseSxfL1RdLEE9Qy5sZW5ndGgsaz1bLi4ucCxfLGIvVF0sTz1rLmxlbmd0aCxNPVtoLHksYi9UXSxWPVt7dHlwZTo2LGRhdGE6eX0se3R5cGU6NixkYXRhOmJ9LHt0eXBlOjYsZGF0YTpffV07WmUodCxWKSxWLnB1c2goLi4uSChmLEMsaykpO2xldCBGPVtcInJhbmtcIixcInJhbmtcIl0saj1lLmxlbmd0aD4yO2omJihWLnB1c2goLi4uSChlWzJdLmRpbXMpKSxGLnB1c2goXCJyYW5rXCIpKSxWLnB1c2goLi4uSChNKSk7bGV0IG5lPVc9PntsZXQgSj1mLmxlbmd0aCx2ZT1HcihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsSiwxKSxRPV9lKGVbMF0uZGF0YVR5cGUpLGVlPVAoXCJhXCIsZVswXS5kYXRhVHlwZSxBLFQpLGxlPVAoXCJiXCIsZVsxXS5kYXRhVHlwZSxPLFQpLFo9TihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsTS5sZW5ndGgsVCkscGU9W2VlLGxlXTtpZihqKXtsZXQgWT1vP1Q6MTtwZS5wdXNoKFAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFkpKX1sZXQga2U9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifV07UWUodCxrZSk7bGV0IFNlPV9lKFoudHlwZS50ZW5zb3IpLEQ9amUodCxaLnR5cGUudmFsdWUsU2UpLFI9UWgoVCxqLEQsW3ZlLGVlLGxlLFpdLG8pO3JldHVybmBcbiAgJHtXLnJlZ2lzdGVyVW5pZm9ybXMoa2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXModmUpLmRlY2xhcmVWYXJpYWJsZXMoLi4ucGUsWil9XG4gICR7Un1cbiAgJHt3P2hvKFMsJCxRLHZlKTpnbyhTLCQsUSx2ZSl9XG4gICAgICAgICAgICAgICAgICAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHtTfTske3QuYWN0aXZhdGlvbn07JHt3fTske299YCxpbnB1dERlcGVuZGVuY2llczpGfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmE/YShuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnZbMF0seTp2WzFdLHo6dlsyXX0scHJvZ3JhbVVuaWZvcm1zOlZ9KSxnZXRTaGFkZXJTb3VyY2U6bmV9fX0pO3ZhciBZaCxBZCxrZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTt0dCgpO2NlKCk7dnQoKTtRcigpO0NkKCk7SnIoKTtZaD0oZSx0LG4scixvPSExLGEscz00LGQ9NCxsPTQscD1cImYzMlwiKT0+e2xldCBmPUY9Pntzd2l0Y2goRil7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7cH0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0Z9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxoPUY9Pntzd2l0Y2goRil7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtGfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0seT1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsXz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLGI9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsdz1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIixTPWU/XCJyb3dcIjpcImNvbFwiLCQ9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke1N9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7U30gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHskfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7JH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAkeyR9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7RWUocyxwKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7Yn0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke3d9KSB7XG4gICAgICAke3l9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke2Yocyl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsVD1lP3QmJnI/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7c307XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtFZShzLHApfSgwLjApO2A6ciYmbj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHtzfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0VlKHMscCl9KDAuMCk7YCxDPWU/ciYmbj9oKGQpOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7aChkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7RWUoZCxwKX0oMC4wKTtgOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcbiAgICAgICR7aChkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7RWUoZCxwKX0oMC4wKTtgLEE9RWUobCxwKSxrPWU/RWUocyxwKTpFZShkLHApLE89ZT9FZShkLHApOkVlKHMscCksTT1qZShhLEEscCk7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7a30ge1xuICAgICAgJHtlP1Q6Q31cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke099IHtcbiAgICAgICR7ZT9DOlR9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7QX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgJHtffVxuICAgICAgJHtTZChvKX1cbiAgICAgICR7TX1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSxBZD0oZSx0LG4scixvLGEscyxkLGwpPT57bGV0IHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixmPXA/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSxoPW5bMF0seT1wP25bMl06blszXSxfPXA/blsxXTpuWzJdLGI9cD9uWzNdOm5bMV0sdz1wJiYoZiU0PT09MHx8ZiUzPT09MCkmJmIlND09PTAsUz1wP2I6eSpfLCQ9cD95Kl86Yix2PVs4LDgsMV0sVD1yPD04P1s0LDEsMV06WzQsNCwxXSxDPVtNYXRoLmNlaWwoUy92WzBdL1RbMF0pLE1hdGguY2VpbCgkL3ZbMV0vVFsxXSksTWF0aC5jZWlsKGgvdlsyXS9UWzJdKV07bWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke0N9YCk7bGV0IEE9dz9wJiZmJTQhPT0wPzM6NDoxLGs9dlsxXSpUWzFdLE89dlswXSpUWzBdLE09TWF0aC5tYXgodlswXSpBLHZbMV0pLFY9ciVrPT09MCxGPW8lTz09PTAsaj1hJU09PT0wLG5lPXc/W0EsNCw0XTpbMSwxLDFdLFc9W3t0eXBlOjYsZGF0YTpyfSx7dHlwZTo2LGRhdGE6b30se3R5cGU6NixkYXRhOmF9LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjYsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjYsZGF0YTp0LmRpbGF0aW9uc31dO1plKHQsVyksVy5wdXNoKC4uLkgoZVswXS5kaW1zLGVbMV0uZGltcykpO2xldCBKPVtcInJhbmtcIixcInJhbmtcIl07cyYmKFcucHVzaCguLi5IKGVbMl0uZGltcykpLEoucHVzaChcInJhbmtcIikpLFcucHVzaCguLi5IKG4pKTtsZXQgdmU9UT0+e2xldCBlZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwicGFkXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInN0cmlkZVwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJkaWxhdGlvblwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn1dO1FlKHQsZWUpO2xldCBsZT13PzQ6MSxaPV9lKGVbMF0uZGF0YVR5cGUpLHBlPWBcbiAgICAgIGZuIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4IDogaTMyLCB2YWx1ZSA6ICR7dz9gdmVjNDwke1p9PmA6Wn0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke3c/YHZlYzQ8JHtafT5gOlp9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7dz9gdmVjNDwke1p9PmA6Wn0pIHtcbiAgICAgICAgbGV0IGZsYXRJbmRleCA9IGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyh2ZWM0PGkzMj4oZDAsIGQxLCBkMiwgZDMpKTtcbiAgICAgICAgc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggJHt3P1wiLyA0XCI6XCJcIn0sIHZhbHVlKTtcbiAgICAgIH1gLGtlPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLEE9PT0zPzE6QSksU2U9UChcIndcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgsbGUpLEQ9W2tlLFNlXSxSPU4oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoLGxlKTtpZihzKXtsZXQgWT1QKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxsZSk7RC5wdXNoKFkpLHBlKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7dz9gdmVjNDwke1p9PmA6Wn0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHt3P1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7VGQoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7US5yZWdpc3RlclVuaWZvcm1zKGVlKS5kZWNsYXJlVmFyaWFibGVzKC4uLkQsUil9XG4gICAgICAgICR7cGV9XG4gICAgICAgICR7WWgocCxWLEYsaixzLHQsbmVbMF0sbmVbMV0sbmVbMl0sWil9XG4gICAgICAgICR7dz9obyhULHYsWix2b2lkIDAsIXAsTSk6Z28oVCx2LFosdm9pZCAwLCFwLE0sITEsdm9pZCAwLGQpfWB9O3JldHVybntuYW1lOlwiQ29udjJETWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtBfTske3d9OyR7Vn07JHtGfTske2p9OyR7a307JHtPfTske019YCxpbnB1dERlcGVuZGVuY2llczpKfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmw/bChuKTpuLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OkNbMF0seTpDWzFdLHo6Q1syXX0scHJvZ3JhbVVuaWZvcm1zOld9KSxnZXRTaGFkZXJTb3VyY2U6dmV9fX0pO3ZhciBYaCxFZCxlbixKaCxQZCxlZyx6ZCxPZCxEZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTt0dCgpO2FlKCk7Y2UoKTt2dCgpO1FyKCk7WGg9ZT0+e2xldCB0PTE7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspdCo9ZVtuXTtyZXR1cm4gdH0sRWQ9ZT0+dHlwZW9mIGU9PVwibnVtYmVyXCI/W2UsZSxlXTplLGVuPShlLHQpPT50PD0xP2U6ZSsoZS0xKSoodC0xKSxKaD0oZSx0LG4scj0xKT0+e2xldCBvPWVuKHQscik7cmV0dXJuIE1hdGguZmxvb3IoKGVbMF0qKG4tMSktbitvKS8yKX0sUGQ9KGUsdCxuLHIsbyk9PntvPT1udWxsJiYobz1KaChlLHRbMF0sclswXSkpO2xldCBhPVswLDAsMCxuXTtmb3IobGV0IHM9MDtzPDM7cysrKWVbc10rMipvPj10W3NdJiYoYVtzXT1NYXRoLnRydW5jKChlW3NdLXRbc10rMipvKS9yW3NdKzEpKTtyZXR1cm4gYX0sZWc9KGUsdCxuLHIsbyxhLHMsZCxsLHApPT57bGV0IGYsaCx5LF87aWYoZT09PVwiVkFMSURcIiYmKGU9MCksdHlwZW9mIGU9PVwibnVtYmVyXCIpe2Y9e3RvcDplLGJvdHRvbTplLGxlZnQ6ZSxyaWdodDplLGZyb250OmUsYmFjazplfTtsZXQgYj1QZChbdCxuLHIsMV0sW2QsbCxwXSwxLFtvLGEsc10sZSk7aD1iWzBdLHk9YlsxXSxfPWJbMl19ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtpZighZS5ldmVyeSgodyxTLCQpPT53PT09JFswXSkpdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke2V9YCk7Zj17dG9wOmVbMF0sYm90dG9tOmVbMV0sbGVmdDplWzJdLHJpZ2h0OmVbM10sZnJvbnQ6ZVs0XSxiYWNrOmVbNV19O2xldCBiPVBkKFt0LG4sciwxXSxbZCxsLHBdLDEsW28sYSxzXSxlWzBdKTtoPWJbMF0seT1iWzFdLF89YlsyXX1lbHNlIGlmKGU9PT1cIlNBTUVfVVBQRVJcIil7aD1NYXRoLmNlaWwodC9vKSx5PU1hdGguY2VpbChuL2EpLF89TWF0aC5jZWlsKHIvcyk7bGV0IGI9KGgtMSkqbytkLXQsdz0oeS0xKSphK2wtbixTPShfLTEpKnMrcC1yLCQ9TWF0aC5mbG9vcihiLzIpLHY9Yi0kLFQ9TWF0aC5mbG9vcih3LzIpLEM9dy1ULEE9TWF0aC5mbG9vcihTLzIpLGs9Uy1BO2Y9e3RvcDpULGJvdHRvbTpDLGxlZnQ6QSxyaWdodDprLGZyb250OiQsYmFjazp2fX1lbHNlIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke2V9YCk7cmV0dXJue3BhZEluZm86ZixvdXREZXB0aDpoLG91dEhlaWdodDp5LG91dFdpZHRoOl99fSx6ZD0oZSx0LG4scixvLGE9ITEscz1cImNoYW5uZWxzTGFzdFwiKT0+e2xldCBkLGwscCxmLGg7aWYocz09PVwiY2hhbm5lbHNMYXN0XCIpW2QsbCxwLGYsaF09ZTtlbHNlIGlmKHM9PT1cImNoYW5uZWxzRmlyc3RcIilbZCxoLGwscCxmXT1lO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHtzfWApO2xldFt5LCxfLGIsd109dCxbUywkLHZdPUVkKG4pLFtULEMsQV09RWQociksaz1lbihfLFQpLE89ZW4oYixDKSxNPWVuKHcsQSkse3BhZEluZm86VixvdXREZXB0aDpGLG91dEhlaWdodDpqLG91dFdpZHRoOm5lfT1lZyhvLGwscCxmLFMsJCx2LGssTyxNKSxXPWE/eSpoOnksSj1bMCwwLDAsMCwwXTtyZXR1cm4gcz09PVwiY2hhbm5lbHNGaXJzdFwiP0o9W2QsVyxGLGosbmVdOnM9PT1cImNoYW5uZWxzTGFzdFwiJiYoSj1bZCxGLGosbmUsV10pLHtiYXRjaFNpemU6ZCxkYXRhRm9ybWF0OnMsaW5EZXB0aDpsLGluSGVpZ2h0OnAsaW5XaWR0aDpmLGluQ2hhbm5lbHM6aCxvdXREZXB0aDpGLG91dEhlaWdodDpqLG91dFdpZHRoOm5lLG91dENoYW5uZWxzOlcscGFkSW5mbzpWLHN0cmlkZURlcHRoOlMsc3RyaWRlSGVpZ2h0OiQsc3RyaWRlV2lkdGg6dixmaWx0ZXJEZXB0aDpfLGZpbHRlckhlaWdodDpiLGZpbHRlcldpZHRoOncsZWZmZWN0aXZlRmlsdGVyRGVwdGg6ayxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6TyxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpNLGRpbGF0aW9uRGVwdGg6VCxkaWxhdGlvbkhlaWdodDpDLGRpbGF0aW9uV2lkdGg6QSxpblNoYXBlOmUsb3V0U2hhcGU6SixmaWx0ZXJTaGFwZTp0fX0sT2Q9KGUsdCxuLHIsbyxhKT0+e2xldCBzPWE9PT1cImNoYW5uZWxzTGFzdFwiLGQ9cz9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGw9ITEscD1bNjQsMSwxXSxmPXt4Om4ubWFwKCh2LFQpPT5UKX0saD1bTWF0aC5jZWlsKFhoKGYueC5tYXAodj0+blt2XSkpL3BbMF0pLDEsMV07bWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2h9YCk7bGV0IHk9bD9zJiZkJTQhPT0wPzM6NDoxLF89RS5zaXplKG4pLGI9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfV07WmUodCxiKSxiLnB1c2goLi4uSChlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IHc9W1wicmFua1wiLFwicmFua1wiXSxTPWUubGVuZ3RoPT09MztTJiYoYi5wdXNoKC4uLkgoZVsyXS5kaW1zKSksdy5wdXNoKFwicmFua1wiKSksYi5wdXNoKC4uLkgobikpO2xldCAkPXY9PntsZXQgVD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH1dO1FlKHQsVCk7bGV0IEM9bD80OjEsQT1fZShlWzBdLmRhdGFUeXBlKSxrPVAoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLHk9PT0zPzE6eSksTz1QKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxDKSxNPVtrLE9dLFY9TihcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgsQyksRj1cIlwiO2lmKFMpe2xldCBXPVAoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLEMpO00ucHVzaChXKSxGKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke2w/YHZlYzQ8JHtBfT5gOkF9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1ske3M/SyhcImNvb3Jkc1wiLDQsNSk6SyhcImNvb3Jkc1wiLDEsNSl9JHtsP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1sZXQgaj1FZSh5LEEpLG5lPWplKHQsaixBKTtyZXR1cm5gXG4gICAgICAgICAgICAke0Z9XG4gICAgICAgICAgICBmbiBnZXRYKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHtrLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuIGdldFcoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke08uZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICR7di5yZWdpc3RlclVuaWZvcm1zKFQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uTSxWKX1cbiAgICAgICAgICAke3YubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGNvb3JkcyA9ICR7Vi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgbGV0IGJhdGNoID0gJHtLKFwiY29vcmRzXCIsMCxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGQyID0gJHtzP0soXCJjb29yZHNcIixrLnJhbmstMSxrLnJhbmspOksoXCJjb29yZHNcIiwxLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeEZSQ0Nvcm5lciA9IHZlYzM8dTMyPigke3M/SyhcImNvb3Jkc1wiLDEsay5yYW5rKTpLKFwiY29vcmRzXCIsMixrLnJhbmspfSxcbiAgICAgICAgICAgICAgJHtzP0soXCJjb29yZHNcIiwyLGsucmFuayk6SyhcImNvb3Jkc1wiLDMsay5yYW5rKX0sXG4gICAgICAgICAgICAgICR7cz9LKFwiY29vcmRzXCIsMyxrLnJhbmspOksoXCJjb29yZHNcIiw0LGsucmFuayl9KSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgICAgICAgICAgICBsZXQgeEZDb3JuZXIgPSB4RlJDQ29ybmVyLng7XG4gICAgICAgICAgICAgIGxldCB4UkNvcm5lciA9IHhGUkNDb3JuZXIueTtcbiAgICAgICAgICAgICAgbGV0IHhDQ29ybmVyID0geEZSQ0Nvcm5lci56O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWSA9ICR7cz9LKFwidW5pZm9ybXMueF9zaGFwZVwiLDEsay5yYW5rKTpLKFwidW5pZm9ybXMueF9zaGFwZVwiLDIsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVaID0gJHtzP0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixrLnJhbmspOksoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMyxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVcgPSAke3M/SyhcInVuaWZvcm1zLnhfc2hhcGVcIiwzLGsucmFuayk6SyhcInVuaWZvcm1zLnhfc2hhcGVcIiw0LGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVSA9ICR7cz9LKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsay5yYW5rKTpLKFwidW5pZm9ybXMueF9zaGFwZVwiLDEsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgPSAoeFNoYXBlVSAvIDQpICogNDtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID0geFNoYXBlVSAlIDQ7XG5cbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gMC4wO1xuICAgICAgICAgICAgICBmb3IgKHZhciB3RiA9IDB1OyB3RiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzBdOyB3RisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhGID0geEZDb3JuZXIgKyB3RiAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBpZiAoeEYgPCAwIHx8IHhGID49IHhTaGFwZVkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHdSID0gMHU7IHdSIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMV07IHdSKyspIHtcbiAgICAgICAgICAgICAgICAgIGxldCB4UiA9IHhSQ29ybmVyICsgd1IgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IHhTaGFwZVopIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMHU7IHdDIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMl07IHdDKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHhDID0geENDb3JuZXIgKyB3QyAqIHVuaWZvcm1zLmRpbGF0aW9uc1syXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSB4U2hhcGVXKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMSA9IDB1OyBkMSA8IGlucHV0RGVwdGhOZWFyZXN0VmVjNDsgZDEgKz0gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICR7cz9gbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgOmBsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDIsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMywgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAyLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMywgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHtzP2B2YWx1ZSArPSBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgOmB2YWx1ZSArPSBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICogZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKTtgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke3M/YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICBgOmBsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHtzP2BsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICBgOmBsZXQgeFZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICR7Uz9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKVwiOlwiXCJ9O1xuICAgICAgICAgICAgICAke25lfVxuICAgICAgICAgICAgICByZXN1bHRbZ2xvYmFsX2lkeF0gPSBmMzIodmFsdWUpO1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkNvbnYzRE5haXZlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtzfTske3l9OyR7U31gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpoWzBdLHk6aFsxXSx6OmhbMl19LHByb2dyYW1Vbmlmb3JtczpifSksZ2V0U2hhZGVyU291cmNlOiR9fX0pO3ZhciBCZCxNZCxSZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7dnQoKTtCZD0oZSx0LG4scik9PntsZXQgbz1lLmxlbmd0aD4yLGE9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIscz1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD10LmZvcm1hdD09PVwiTkhXQ1wiLHA9bD9uWzNdOm5bMV0sZj1wL3QuZ3JvdXAsaD1sJiZmPj00P2dlKHApOjEseT1FLnNpemUobikvaCxfPVt7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOjEyLGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZToxMixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6MTIsZGF0YTpmfV07WmUodCxfKSxfLnB1c2goLi4uSChzLFtkWzBdLGRbMV0sZFsyXSxkWzNdL2hdKSk7bGV0IGI9bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl07Xy5wdXNoKC4uLkgoW25bMF0sblsxXSxuWzJdLG5bM10vaF0pKTtsZXQgdz1TPT57bGV0ICQ9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgsaCksdj1fZSgkLnR5cGUudGVuc29yKSxUPWplKHQsJC50eXBlLnZhbHVlLHYpLEM9UChcInhcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoKSxBPVAoXCJ3XCIsZVsxXS5kYXRhVHlwZSxkLmxlbmd0aCxoKSxrPVtDLEFdO28mJmsucHVzaChQKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGgpKTtsZXQgTz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dO1FlKHQsTyk7bGV0IE09bD9gXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7Qy5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIndIZWlnaHRcIixcIndXaWR0aFwiLFwid0luQ2hhbm5lbFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgOmBcbiAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XG4gICAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbM10pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4VmFsID0gJHtDLmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke0EuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7cmV0dXJuYFxuICAke1MucmVnaXN0ZXJVbmlmb3JtcyhPKS5kZWNsYXJlVmFyaWFibGVzKC4uLmssJCl9XG5cbiAgJHtTLm1haW5TdGFydCgpfVxuICAgICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7bD8zOjF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2w/MToyfV0sIG91dHB1dEluZGljZXNbJHtsPzI6M31dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgKiAke2h9IC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICB2YXIgaW5fY2hhbm5lbF9vZmZzZXQgPSBncm91cF9pZCAqIHVuaWZvcm1zLndfc2hhcGVbJHtsPzI6MX1dO1xuXG4gICAgdmFyIHZhbHVlOiAkeyQudHlwZS52YWx1ZX0gPSAkeyQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtNfVxuICAgICR7YX1cbiAgICAke1R9XG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHtofWAsaW5wdXREZXBlbmRlbmNpZXM6Yn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeS82NCl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOnd9fSxNZD0oZSx0LG4scik9PntsZXQgbz1lLmxlbmd0aD4yLGE9Z2UoblszXSkscz1nZShuWzJdKSxkPUUuc2l6ZShuKS9hL3MsbD1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdL2FdLHA9W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMV0uZGltc1szXS9hXSxmPVtuWzBdLG5bMV0sblsyXSxuWzNdL2FdLGg9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6NixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX1dO1plKHQsaCksaC5wdXNoKC4uLkgobCxwLGYpKTtsZXQgeT0ocy0xKSp0LnN0cmlkZXNbMV0rcFsxXSxfPWI9PntsZXQgdz1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxmLmxlbmd0aCxhKSxTPV9lKHcudHlwZS50ZW5zb3IpLCQ9amUodCx3LnR5cGUudmFsdWUsUyksdj1QKFwieFwiLGVbMF0uZGF0YVR5cGUsbC5sZW5ndGgsYSksVD1QKFwid1wiLGVbMV0uZGF0YVR5cGUscC5sZW5ndGgsYSksQz1bdixUXTtvJiZDLnB1c2goUChcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxhKSk7bGV0IEE9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsaz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtyZXR1cm4gUWUodCxrKSxgXG4gICR7Yi5yZWdpc3RlclVuaWZvcm1zKGspLmRlY2xhcmVWYXJpYWJsZXMoLi4uQyx3KX1cbiAgJHtiLm1haW5TdGFydCgpfVxuICAgICR7Yi5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke3N9dTtcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke3N9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt2LnR5cGUudmFsdWV9LCAke3l9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke3cudHlwZS52YWx1ZX0sICR7c30+O1xuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXG4gICAgZm9yICh2YXIgd19oZWlnaHQ6IHUzMiA9IDB1OyB3X2hlaWdodCA8ICR7cFswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke3l9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LmdldChcImJhdGNoXCIsXCJ1MzIoeF9oZWlnaHQpXCIsXCJ1MzIoeF93aWR0aClcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHtwWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHtULmdldChcIndfaGVpZ2h0XCIsXCJ3X3dpZHRoXCIsXCIwXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtzfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7c311OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7QX1cbiAgICAgICR7JH1cbiAgICAgICR7dy5zZXQoXCJiYXRjaFwiLFwicm93XCIsXCJjb2wgKyBpXCIsXCJvdXRwdXRfY2hhbm5lbFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnYtVmVjdG9yaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHthfTske3N9OyR7eX07JHtwWzBdfTske3BbMV19YCxpbnB1dERlcGVuZGVuY2llczpvP1tcInJhbmtcIixcInJhbmtcIixcInR5cGVcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyP3Iobik6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3JtczpofSksZ2V0U2hhZGVyU291cmNlOl99fX0pO3ZhciB0Zyx5byxyZyxibyxfbyxVZCxuZyxvZyx3byxOZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWUoKTtrZCgpO0RkKCk7SnIoKTtSZCgpO3Z0KCk7WHIoKTtjdCgpO3RnPShlLHQsbixyLG8sYSk9PntsZXQgcz1lWzBdLGQ9ZS5zbGljZShhPzE6MixhPzM6NCksbD1kLmxlbmd0aCxwPXRbMF0saD10LnNsaWNlKDIpLm1hcCgoYix3KT0+YisoYi0xKSooblt3XS0xKSksXz1kLm1hcCgoYix3KT0+YityW3ddK3JbdytsXSkubWFwKChiLHcpPT5NYXRoLmZsb29yKChiLWhbd10rb1t3XSkvb1t3XSkpO3JldHVybiBfLnNwbGljZSgwLDAscyksXy5zcGxpY2UoYT8zOjEsMCxwKSxffSx5bz1bMiwzLDEsMF0scmc9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoXCJncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgbj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0scj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihuIT09cil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW8qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7byoyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSxibz0oZSx0KT0+e2xldCBuPWUua2VybmVsU2hhcGUuc2xpY2UoKTtuLmxlbmd0aDx0WzFdLmRpbXMubGVuZ3RoLTImJm4ucHVzaCguLi5BcnJheSh0WzFdLmRpbXMubGVuZ3RoLTItbi5sZW5ndGgpLmZpbGwoMCkpO2ZvcihsZXQgYT0yO2E8dFsxXS5kaW1zLmxlbmd0aDsrK2EpblthLTJdPT09MCYmKG5bYS0yXT10WzFdLmRpbXNbYV0pO2xldCByPWUucGFkcy5zbGljZSgpO2t0LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLG4scixlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG89T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpuLHBhZHM6cn0pLG99LF9vPWU9PntsZXQgdD1acihlKSxuPWUuZm9ybWF0LHI9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxvPWUuZGlsYXRpb25zLGE9ZS5ncm91cCxzPWUua2VybmVsX3NoYXBlLGQ9ZS5wYWRzLGw9ZS5zdHJpZGVzLHA9ZS53X2lzX2NvbnN0KCk7cmV0dXJue2F1dG9QYWQ6cixmb3JtYXQ6bixkaWxhdGlvbnM6byxncm91cDphLGtlcm5lbFNoYXBlOnMscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sVWQ9KGUsdCxuLHIpPT57bGV0IG89bi5mb3JtYXQ9PT1cIk5IV0NcIixhPXRnKHRbMF0uZGltcyx0WzFdLmRpbXMsbi5kaWxhdGlvbnMsbi5wYWRzLG4uc3RyaWRlcyxvKTtpZihuLmdyb3VwIT09MSl7bGV0IGs9W3RbMF1dO2lmKG8pe2xldCBNPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKE9lKHRbMV0seW8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1NKSxrLnB1c2goTSl9ZWxzZSBrLnB1c2godFsxXSk7dC5sZW5ndGg9PT0zJiZrLnB1c2godFsyXSksIWUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJhbXBlcmVcIikmJm8mJnRbMV0uZGltc1swXT09PW4uZ3JvdXAmJnRbMV0uZGltc1sxXT09PTEmJm4uZGlsYXRpb25zWzBdPT09MSYmbi5kaWxhdGlvbnNbMV09PT0xP2UuY29tcHV0ZShNZChrLG4sYSxyKSx7aW5wdXRzOmt9KTplLmNvbXB1dGUoQmQoayxuLGEscikse2lucHV0czprfSk7cmV0dXJufWxldCBzPXQubGVuZ3RoPT09MyxkPXRbMF0uZGltc1tvPzE6Ml0sbD10WzBdLmRpbXNbbz8yOjNdLHA9dFswXS5kaW1zW28/MzoxXSxmPXRbMV0uZGltc1syXSxoPXRbMV0uZGltc1szXSx5PWFbbz8xOjJdLF89YVtvPzI6M10sYj1hW28/MzoxXSx3PW8mJmY9PT1kJiZoPT09bCYmbi5wYWRzWzBdPT09MCYmbi5wYWRzWzFdPT09MDtpZih3fHxmPT09MSYmaD09PTEmJm4uZGlsYXRpb25zWzBdPT09MSYmbi5kaWxhdGlvbnNbMV09PT0xJiZuLnN0cmlkZXNbMF09PT0xJiZuLnN0cmlkZXNbMV09PT0xJiZuLnBhZHNbMF09PT0wJiZuLnBhZHNbMV09PT0wKXtsZXQgaz1hWzBdLE8sTSxWLEY9W107aWYobyl7bGV0IFc9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoT2UodFsxXSx5bykse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtpZihuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPVcpLHcpe2xldCBKPWQqbCpwO089dFswXS5yZXNoYXBlKFsxLGssSl0pLE09Vy5yZXNoYXBlKFsxLEosYl0pLFY9WzEsayxiXX1lbHNlIE89dFswXS5yZXNoYXBlKFtrLGQqbCxwXSksTT1XLnJlc2hhcGUoWzEscCxiXSksVj1bayx5Kl8sYl07Ri5wdXNoKE8pLEYucHVzaChNKX1lbHNlIE89dFswXS5yZXNoYXBlKFtrLHAsZCpsXSksTT10WzFdLnJlc2hhcGUoWzEsYixwXSksVj1bayxiLHkqX10sRi5wdXNoKE0pLEYucHVzaChPKTtzJiZGLnB1c2godFsyXSk7bGV0IGo9VlsyXSxuZT1GWzBdLmRpbXNbRlswXS5kaW1zLmxlbmd0aC0xXTtqPDgmJm5lPDg/ZS5jb21wdXRlKFlyKEYsbixhLFYsbyxyKSx7aW5wdXRzOkZ9KTplLmNvbXB1dGUobnIoRixuLGEsVixvLHIpLHtpbnB1dHM6Rn0pO3JldHVybn1sZXQgUz0hMCwkPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKE9lKHRbMV0seW8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W24ud0lzQ29uc3Q/LTI6LTFdfSlbMF07bi53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD0kKTtsZXQgdj1bdFswXSwkXTtzJiZ2LnB1c2godFsyXSk7bGV0IFQ9bz95Kl86YixDPW8/Yjp5Kl8sQT1mKmgqcDtlLmNvbXB1dGUoQWQodixuLGEsVCxDLEEscyxTLHIpLHtpbnB1dHM6dn0pfSxuZz0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj1bZS5pbnB1dHNbMF0ucmVzaGFwZShuP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmci5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz1bMCx0LnBhZHNbMF0sMCx0LnBhZHNbMV1dLGE9WzFdLmNvbmNhdCh0LnN0cmlkZXMpLHM9WzFdLmNvbmNhdCh0LmRpbGF0aW9ucyksZD1bMV0uY29uY2F0KHQua2VybmVsU2hhcGUpLGw9Ym8oey4uLnQscGFkczpvLHN0cmlkZXM6YSxkaWxhdGlvbnM6cyxrZXJuZWxTaGFwZTpkfSxyKTtVZChlLHIsbCxwPT5uP1twWzBdLHBbMl0scFszXV06W3BbMF0scFsxXSxwWzNdXSl9LG9nPShlLHQsbik9PntsZXQgcj1uLmZvcm1hdD09PVwiTkhXQ1wiP1wiY2hhbm5lbHNMYXN0XCI6XCJjaGFubmVsc0ZpcnN0XCIsbz1ibyhuLHQpLGE9bi5hdXRvUGFkPT09XCJOT1RTRVRcIj9uLnBhZHM6bi5hdXRvUGFkLHM9emQodFswXS5kaW1zLHRbMV0uZGltcyxuLnN0cmlkZXMsbi5kaWxhdGlvbnMsYSwhMSxyKTtlLmNvbXB1dGUoT2QodCxvLHMub3V0U2hhcGUsW3MuZmlsdGVyRGVwdGgscy5maWx0ZXJIZWlnaHQscy5maWx0ZXJXaWR0aF0sW3MucGFkSW5mby5mcm9udCxzLnBhZEluZm8udG9wLHMucGFkSW5mby5sZWZ0XSxyKSl9LHdvPShlLHQpPT57aWYocmcoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKW5nKGUsdCk7ZWxzZSBpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpb2coZSxlLmlucHV0cyx0KTtlbHNle2xldCBuPWJvKHQsZS5pbnB1dHMpO1VkKGUsZS5pbnB1dHMsbil9fX0pO3ZhciBWZCxXZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTt0dCgpO2FlKCk7Y2UoKTtWZD0oZSx0LG4pPT57bGV0IHI9ZS5sZW5ndGg+MixvPXQub3V0cHV0U2hhcGUsYT10LmZvcm1hdD09PVwiTkhXQ1wiLHM9dC5ncm91cCxkPWVbMV0uZGltcyxsPWRbMl0vcyxwPWRbM10sZj1hP2dlKGwpOjEsaD1hP2dlKHApOjEseT1hP3A9PT0xP2Y6aDoxLF89RS5zaXplKG8pL2gsYj1bTWF0aC5jZWlsKF8vNjQpLDEsMV07bWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX2JhY2twcm9wX3dlYmdwdV0gZGlzcGF0Y2ggPSAke2J9YCk7bGV0IHc9W1wicmFua1wiLFwicmFua1wiXSxTPVt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXSwkPVt0Lmtlcm5lbFNoYXBlW2E/MToyXSx0Lmtlcm5lbFNoYXBlW2E/MjozXV0sdj1bdC5kaWxhdGlvbnNbMF0sdC5kaWxhdGlvbnNbMV1dLFQ9WyRbMF0rKHQuZGlsYXRpb25zWzBdPD0xPzA6KHQua2VybmVsU2hhcGVbYT8xOjJdLTEpKih0LmRpbGF0aW9uc1swXS0xKSksJFsxXSsodC5kaWxhdGlvbnNbMV08PTE/MDoodC5rZXJuZWxTaGFwZVthPzI6M10tMSkqKHQuZGlsYXRpb25zWzFdLTEpKV0sQz1bVFswXS0xLU1hdGguZmxvb3IoKHQucGFkc1swXSt0LnBhZHNbMl0pLzIpLFRbMV0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMV0rdC5wYWRzWzNdKS8yKV0sQT1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOlN9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTp2fSx7dHlwZToxMixkYXRhOlR9LHt0eXBlOjYsZGF0YTpDfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0sLi4uSChlWzBdLmRpbXMsZVsxXS5kaW1zKV07ciYmKEEucHVzaCguLi5IKGVbMl0uZGltcykpLHcucHVzaChcInJhbmtcIikpLEEucHVzaCguLi5IKG8pKTtsZXQgaz1PPT57bGV0IE09W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Uy5sZW5ndGh9LHtuYW1lOlwiZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOiQubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZWZmZWN0aXZlX2ZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpULmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpDLmxlbmd0aH0se25hbWU6XCJpbnB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dLFY9X2UoZVswXS5kYXRhVHlwZSksRj1hPzE6MixqPWE/MjozLG5lPWE/MzoxLFc9UChcIldcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgseSksSj1QKFwiRHlcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsZiksdmU9W0osV107ciYmdmUucHVzaChQKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsW29bbmVdXS5sZW5ndGgsaCkpO2xldCBRPU4oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLGgpLGVlPSgpPT57bGV0IFo9XCJcIjtpZihmPT09MSlaKz1gXG4gICAgICAgIGxldCB3X29mZnNldCA9ICR7Vy5pbmRpY2VzVG9PZmZzZXQoYCR7Vy50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX07XG4gICAgICAgIGxldCB3VmFsdWUgPSAke1cuZ2V0QnlPZmZzZXQoYHdfb2Zmc2V0IC8gJHt5fWApfTtcbiAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWUgKiB3VmFsdWU7YDtlbHNlIGlmKHA9PT0xKVorPWBcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtXLmdldEJ5T2Zmc2V0KGAke1cuaW5kaWNlc1RvT2Zmc2V0KGAke1cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHt5fWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YDtlbHNlIGZvcihsZXQgcGU9MDtwZTxmO3BlKyspWis9YFxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7cGV9ID0gJHtXLmdldEJ5T2Zmc2V0KGAke1cuaW5kaWNlc1RvT2Zmc2V0KGAke1cudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCArICR7cGV9LCB3T3V0Q2hhbm5lbClgKX0gLyAke3l9YCl9O1xuICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWVbJHtwZX1dICogd1ZhbHVlJHtwZX07YDtyZXR1cm4gWn0sbGU9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1Eub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtofWApfTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7US5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcbiAgICAgICAgICAgIGxldCBkMSA9ICR7US5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLG5lKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7US5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEYpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtRLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsail9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtRLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICB2YXIgd1I6IHUzMiA9IDA7XG4gICAgICAgICAgICBpZiAodW5pZm9ybXMuZGlsYXRpb25zLnggPT0gMSkge1xuICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdSID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5UkNvcm5lciArIHdSKSAlICh1bmlmb3Jtcy5zdHJpZGVzLngpID09IDBcbiAgICAgICAgICAgICAgd1IgPSB1MzIoKChkeVJDb3JuZXIgKyBpMzIodW5pZm9ybXMuc3RyaWRlcy54KSAtIDEpIC8gaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkpICogaTMyKHVuaWZvcm1zLnN0cmlkZXMueCkgLSBkeVJDb3JuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7IHdSIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLng7IHdSID0gd1IgKyAxKSB7XG4gICAgICAgICAgICAgIGlmICh3UiAlIHVuaWZvcm1zLmRpbGF0aW9ucy54ICE9IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZHlSID0gKCR7Vn0oZHlSQ29ybmVyKSArICR7Vn0od1IpKSAvICR7Vn0odW5pZm9ybXMuc3RyaWRlc1swXSk7XG4gICAgICAgICAgICAgIGxldCB3UlBlcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy54IC0gMSAtIHdSIC8gdW5pZm9ybXMuZGlsYXRpb25zLng7XG4gICAgICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49ICR7Vn0odW5pZm9ybXMuRHlfc2hhcGVbJHtGfV0pIHx8IGZyYWN0KGR5UikgPiAwLjAgfHxcbiAgICAgICAgICAgICAgICAgIHdSUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG4gICAgICAgICAgICAgIHZhciB3QzogdTMyID0gMDtcbiAgICAgICAgICAgICAgaWYgKHVuaWZvcm1zLmRpbGF0aW9ucy55ID09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBNaW5pbXVtIHdDID49IDAgdGhhdCBzYXRpc2ZpZXMgKGR5Q0Nvcm5lciArIHdDKSAlICh1bmlmb3Jtcy5zdHJpZGVzLnkpID09IDBcbiAgICAgICAgICAgICAgICB3QyA9IHUzMigoKGR5Q0Nvcm5lciArIGkzMih1bmlmb3Jtcy5zdHJpZGVzLnkpIC0gMSkgLyBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSkgKiBpMzIodW5pZm9ybXMuc3RyaWRlcy55KSAtIGR5Q0Nvcm5lcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmb3IgKDsgd0MgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueTsgd0MgPSB3QyArIDEpIHtcbiAgICAgICAgICAgICAgICBpZiAod0MgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGR5QyA9ICgke1Z9KGR5Q0Nvcm5lcikgKyAke1Z9KHdDKSkgLyAke1Z9KHVuaWZvcm1zLnN0cmlkZXMueSk7XG4gICAgICAgICAgICAgICAgbGV0IHdDUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnkgLSAxIC0gd0MgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueTtcbiAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMC4wIHx8IGR5QyA+PSAke1Z9KHVuaWZvcm1zLkR5X3NoYXBlWyR7an1dKSB8fFxuICAgICAgICAgICAgICAgICAgICBmcmFjdChkeUMpID4gMC4wIHx8IHdDUGVybSA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaWR5QzogdTMyID0gdTMyKGR5Qyk7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0Q2hhbm5lbCA9IGdyb3VwSWQgKiB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZDI6IHUzMiA9IDA7IGQyIDwgdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwOyBkMiA9IGQyICsgJHtmfSkge1xuICAgICAgICAgICAgICAgICAgbGV0IHhWYWx1ZSA9ICR7YT9KLmdldEJ5T2Zmc2V0KGAke0ouaW5kaWNlc1RvT2Zmc2V0KGAke0oudHlwZS5pbmRpY2VzfShiYXRjaCwgaWR5UiwgaWR5QywgaW5wdXRDaGFubmVsKWApfSAvICR7Zn1gKTpKLmdldChcImJhdGNoXCIsXCJpbnB1dENoYW5uZWxcIixcImlkeVJcIixcImlkeUNcIil9O1xuICAgICAgICAgICAgICAgICAgJHtlZSgpfVxuICAgICAgICAgICAgICAgICAgaW5wdXRDaGFubmVsID0gaW5wdXRDaGFubmVsICsgJHtmfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd1IgPSB3UiArIHVuaWZvcm1zLnN0cmlkZXNbMF0gLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7cj9gICsgYmlhc1tkMSAvICR7aH1dYDpcIlwifTtcbiAgICAgICAgICAgICR7US5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke08ucmVnaXN0ZXJVbmlmb3JtcyhNKS5kZWNsYXJlVmFyaWFibGVzKC4uLnZlLFEpfVxuICAgICAgJHtPLm1haW5TdGFydCgpfVxuICAgICAgJHtPLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX07XG4gICAgJHtsZX19YH07cmV0dXJue25hbWU6XCJDb252VHJhbnNwb3NlMkRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2Z9JHt5fSR7aH0ke3A9PT0xfWAsaW5wdXREZXBlbmRlbmNpZXM6d30sZ2V0UnVuRGF0YTooKT0+KHtkaXNwYXRjaEdyb3VwOnt4OmJbMF0seTpiWzFdLHo6YlsyXX0sb3V0cHV0czpbe2RpbXM6bj9uKG8pOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3JtczpBfSksZ2V0U2hhZGVyU291cmNlOmt9fX0pO3ZhciBpZyxhZyxzZyxMZCxHZCx1ZyxIZCxkZyxGZCxxZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2QoKTt2dCgpO2N0KCk7aWc9KGUsdCxuLHIsbyxhKT0+KGUtMSkqdCtuKyhyLTEpKm8rMS1hLGFnPShlLHQsbixyLG8pPT57bGV0IGE9TWF0aC5mbG9vcihlLzIpO3Q9PT1cIlNBTUVfVVBQRVJcIj8obltyXT1hLG5bb109ZS1hKTp0PT09XCJTQU1FX0xPV0VSXCImJihuW3JdPWUtYSxuW29dPWEpfSxzZz0oZSx0LG4scixvLGEscyxkLGwscCk9PntsZXQgZj1lLmxlbmd0aC0yLGg9cC5sZW5ndGg9PT0wO2wubGVuZ3RoPGYmJmwucHVzaCguLi5BcnJheShmLWwubGVuZ3RoKS5maWxsKDApKTtsZXQgeT1lWzBdLF89dFtkPzM6MV0qbztmb3IobGV0IGI9MCx3PWUubGVuZ3RoLWYtKGQ/MTowKTtiPGY7KytiLCsrdyl7bGV0IFM9ZVt3XSwkPWg/UypzW2JdOnBbYl0sdj1pZyhTLHNbYl0sYVtiXSx0W3ddLG5bYl0sJCk7YWcodixyLGEsYixiK2YpLGgmJnAucHVzaChzW2JdKihTLTEpK2xbYl0rKHRbd10tMSkqbltiXSsxLWFbYl0tYVtiK2ZdKX1wLnNwbGljZSgwLDAseSkscC5zcGxpY2UoZD8zOjEsMCxfKX0sTGQ9KGUsdCk9PntsZXQgbj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7aWYoZS5rZXJuZWxTaGFwZS5sZW5ndGg9PT0wfHxlLmtlcm5lbFNoYXBlLnJlZHVjZSgoaCx5KT0+aCp5LDEpPT09MCl7bi5sZW5ndGg9MDtmb3IobGV0IGg9MjtoPHRbMV0uZGltcy5sZW5ndGg7KytoKW4ucHVzaCh0WzFdLmRpbXNbaF0pfWxldCByPWUuZm9ybWF0PT09XCJOSFdDXCI7bi5zcGxpY2UoMCwwLHRbMV0uZGltc1swXSksbi5zcGxpY2Uocj8zOjEsMCx0WzFdLmRpbXNbMV0pO2xldCBvPWUucGFkcy5zbGljZSgpLGE9ZS5vdXRwdXRTaGFwZS5zbGljZSgpLHM9ZS5vdXRwdXRQYWRkaW5nLnNsaWNlKCksZD10WzBdLmRpbXMsbD1lLmRpbGF0aW9ucy5zbGljZSgpO2lmKGwucmVkdWNlKChoLHkpPT5oK3ksMCk9PT0wKXtsZXQgaD10WzBdLmRpbXMubGVuZ3RoLTI7bD1uZXcgQXJyYXkoaCkuZmlsbCgxKX1sZXQgcD1lLnN0cmlkZXMuc2xpY2UoKTtpZihwLnJlZHVjZSgoaCx5KT0+aCt5LDApPT09MCl7bGV0IGg9dFswXS5kaW1zLmxlbmd0aC0yO3A9bmV3IEFycmF5KGgpLmZpbGwoMSl9c2coZCxuLGwsZS5hdXRvUGFkLGUuZ3JvdXAsbyxwLHIscyxhKTtsZXQgZj1PYmplY3QuYXNzaWduKHt9LGUpO3JldHVybiBPYmplY3QuYXNzaWduKGYse2tlcm5lbFNoYXBlOm4scGFkczpvLG91dHB1dFBhZGRpbmc6cyxvdXRwdXRTaGFwZTphLGRpbGF0aW9uczpsLHN0cmlkZXM6cH0pLGZ9LEdkPWU9PntsZXQgdD1acihlKSxuPWUuZm9ybWF0LHI9W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVt0eXBlb2YgZS5hdXRvUGFkPlwidVwiPzA6ZS5hdXRvUGFkXSxvPWUuZGlsYXRpb25zLGE9ZS5ncm91cCxzPWUua2VybmVsU2hhcGUsZD1lLnBhZHMsbD1lLnN0cmlkZXMscD1lLndJc0NvbnN0KCksZj1lLm91dHB1dFBhZGRpbmcsaD1lLm91dHB1dFNoYXBlO3JldHVybnthdXRvUGFkOnIsZm9ybWF0Om4sZGlsYXRpb25zOm8sZ3JvdXA6YSxrZXJuZWxTaGFwZTpzLG91dHB1dFBhZGRpbmc6ZixvdXRwdXRTaGFwZTpoLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LHVnPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCYmZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG9ubHkgc3VwcG9ydCAyLWRpbWVuc2lvbmFsIGNvbnZcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IG49ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLHI9ZVsxXS5kaW1zWzBdO2lmKG4hPT1yKXRocm93IG5ldyBFcnJvcihcIkZJTFRFUl9JTl9DSEFOTkVMIHNob3VsZCBiZSBlcXVhbCB0byBEQVRBX0NIQU5ORUxcIik7bGV0IG89ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYoZS5sZW5ndGg9PT0zJiYoZVsyXS5kaW1zLmxlbmd0aCE9PTF8fGVbMl0uZGltc1swXSE9PW8pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgYT1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMucmVkdWNlKChmLGgpPT5mK2gsMCk+MCYmdC5kaWxhdGlvbnMubGVuZ3RoIT09YSl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHthfURgKTtpZih0LnN0cmlkZXMucmVkdWNlKChmLGgpPT5mK2gsMCk+MCYmdC5zdHJpZGVzLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke2F9RGApO2lmKHQucGFkcy5yZWR1Y2UoKGYsaCk9PmYraCwwKT4wJiZ0LnBhZHMubGVuZ3RoIT09YSoyKXRocm93IG5ldyBFcnJvcihgcGFkcyBzaG91bGQgYmUgJHthKjJ9RGApO2lmKHQub3V0cHV0UGFkZGluZy5sZW5ndGghPT1hJiZ0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09MCl0aHJvdyBuZXcgRXJyb3IoYG91dHB1dF9wYWRkaW5nIHNob3VsZCBiZSAke2F9RGApO2lmKHQua2VybmVsU2hhcGUucmVkdWNlKChmLGgpPT5mK2gsMCk+MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKTtpZih0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PTAmJnQub3V0cHV0U2hhcGUubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgb3V0cHV0IHNoYXBlXCIpfSxIZD0oZSx0LG4scik9PntsZXQgbz1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShPZSh0WzFdLFsyLDMsMCwxXSkse2lucHV0czpbMV0sb3V0cHV0czpbbi53SXNDb25zdD8tMjotMV19KVswXTtuLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPW8pO2xldCBhPVt0WzBdLG9dO3QubGVuZ3RoPT09MyYmYS5wdXNoKHRbMl0pLGUuY29tcHV0ZShWZChhLG4scikse2lucHV0czphfSl9LGRnPShlLHQpPT57bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIixyPVtlLmlucHV0c1swXS5yZXNoYXBlKG4/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZyLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPXQua2VybmVsU2hhcGU7KG8ubGVuZ3RoPT09MHx8b1swXT09PTApJiYobz1bZS5pbnB1dHNbMV0uZGltc1syXV0pO2xldCBhPXQuZGlsYXRpb25zOyhhLmxlbmd0aD09PTB8fGFbMF09PT0wKSYmKGE9WzFdKTtsZXQgcz10LnN0cmlkZXM7KHMubGVuZ3RoPT09MHx8c1swXT09PTApJiYocz1bMV0pO2xldCBkPXQucGFkcztkLmxlbmd0aD09PTAmJihkPVswLDBdKSxkPVswLGRbMF0sMCxkWzFdXSxzPVsxXS5jb25jYXQocyksYT1bMV0uY29uY2F0KGEpLG89WzFdLmNvbmNhdChvKTtsZXQgbD10Lm91dHB1dFBhZGRpbmc7bD1bMF0uY29uY2F0KGwpO2xldCBwPUxkKHsuLi50LHBhZHM6ZCxzdHJpZGVzOnMsZGlsYXRpb25zOmEsa2VybmVsU2hhcGU6byxvdXRwdXRQYWRkaW5nOmx9LHIpO0hkKGUscixwLGY9Pm4/W2ZbMF0sZlsyXSxmWzNdXTpbZlswXSxmWzFdLGZbM11dKX0sRmQ9KGUsdCk9PntpZih1ZyhlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpZGcoZSx0KTtlbHNle2xldCBuPUxkKHQsZS5pbnB1dHMpO0hkKGUsZS5pbnB1dHMsbil9fX0pO3ZhciBsZyxLZCxqZCxaZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtsZz0oZSx0LG4scik9PntsZXQgbz1FLnNpemUodCksYT10Lmxlbmd0aCxzPVAoXCJpbnB1dFwiLGUsYSksZD1OKFwib3V0cHV0XCIsZSxhKSxsPW4uZGF0YVR5cGU9PT02P24uZ2V0SW50MzJBcnJheSgpWzBdOk51bWJlcihuLmdldEJpZ0ludDY0QXJyYXkoKVswXSkscD1FLm5vcm1hbGl6ZUF4aXMobCxhKSxmPWg9PntsZXQgeT1gIGkzMigke3MuaW5kaWNlc0dldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX0pIGAsXz1LKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcInVuaWZvcm1zLmF4aXNcIixhKSxiPXIucmV2ZXJzZT95KyhyLmV4Y2x1c2l2ZT9cIiArIDFcIjpcIlwiKTpcIjBcIix3PXIucmV2ZXJzZT9fOnkrKHIuZXhjbHVzaXZlP1wiXCI6XCIgKyAxXCIpO3JldHVybmBcbiAgICAgICAgICAgICAgICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHMsZCl9XG4gICAgICAgICAgICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAgICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSAke2QudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgOiBpMzIgPSAke2J9O1xuICAgICAgICAgICAgICAgICAgbGV0IGxhc3QgOiBpMzIgPSAke3d9O1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA6IGkzMiA9IGZpcnN0OyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICR7cy5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJ1MzIoaSlcIil9O1xuICAgICAgICAgICAgICAgICAgICBzdW0gPSBzdW0gKyAke3MuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICR7ZC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInN1bVwiKX07XG4gICAgICAgICAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQ3VtU3VtXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6ci5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpwfSwuLi5IKHQsdCldfSksZ2V0U2hhZGVyU291cmNlOmZ9fSxLZD0oZSx0KT0+e2xldCBuPWUuaW5wdXRzWzBdLmRpbXMscj1lLmlucHV0c1swXS5kYXRhVHlwZSxvPWUuaW5wdXRzWzFdO2UuY29tcHV0ZShsZyhyLG4sbyx0KSx7aW5wdXRzOlswXX0pfSxqZD1lPT57bGV0IHQ9ZS5leGNsdXNpdmU9PT0xLG49ZS5yZXZlcnNlPT09MTtyZXR1cm4gcmUoe2V4Y2x1c2l2ZTp0LHJldmVyc2U6bn0pfX0pO3ZhciBjZyxwZyxtZyxRZCxZZCxYZD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtjZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgMSBpbnB1dC5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDREIGlucHV0LlwiKX0scGc9KGUsdCxuLHIpPT57bGV0IG89W107by5wdXNoKGBmbiBwZXJtKGk6ICR7ci50eXBlLmluZGljZXN9KSAtPiAke24udHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7bi50eXBlLmluZGljZXN9O2ApO2ZvcihsZXQgYT0wO2E8dDsrK2Epby5wdXNoKG4uaW5kaWNlc1NldChcImFcIixlW2FdLGBpWyR7YX1dYCkpO3JldHVybiBvLnB1c2goXCJyZXR1cm4gYTt9XCIpLG8uam9pbihgXG5gKX0sbWc9KGUsdCk9PntsZXQgbixyLG8sYSxzLGQsbD10LmZvcm1hdD09PVwiTkhXQ1wiLHA9dC5ibG9ja3NpemUsZj10Lm1vZGU9PT1cIkRDUlwiO2w/KFtuLHIsbyxhXT1lLmRpbXMscz1mP1tuLHIsbyxwLHAsYS9wKioyXTpbbixyLG8sYS9wKioyLHAscF0sZD1mP1swLDEsMywyLDQsNV06WzAsMSw0LDIsNSwzXSk6KFtuLHIsbyxhXT1bZS5kaW1zWzBdLGUuZGltc1syXSxlLmRpbXNbM10sZS5kaW1zWzFdXSxzPWY/W24scCxwLGEvcCoqMixyLG9dOltuLGEvcCoqMixwLHAscixvXSxkPWY/WzAsMyw0LDEsNSwyXTpbMCwxLDQsMiw1LDNdKTtsZXQgaD1lLnJlc2hhcGUocykseT1oLmRpbXMubGVuZ3RoLF89ZS5kYXRhVHlwZSxiPVAoXCJhXCIsXyx5KSx3PU4oXCJvdXRwdXRcIixfLHkpLFM9JD0+YFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGIsdyl9XG5cbiAgJHtwZyhkLHksYix3KX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBpbmRpY2VzID0gJHt3Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCBhSW5kaWNlcyA9IHBlcm0oaW5kaWNlcyk7XG5cbiAgICAke3cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYi5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKSl9XG4gIH1gO3JldHVybntuYW1lOlwiRGVwdGhUb1NwYWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ZS5kaW1zfTske3QuYmxvY2tzaXplfTske3QubW9kZX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6JD0+e2xldCB2PWw/W24scipwLG8qcCxhL3AqKjJdOltuLGEvcCoqMixyKnAsbypwXSxUPUUuc2l6ZSh2KSxDPWguZGltcyxBPUUuc29ydEJhc2VkT25QZXJtKEMsZCk7cmV0dXJue291dHB1dHM6W3tkaW1zOnYsZGF0YVR5cGU6JFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKFQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6VH0sLi4uSChDLEEpXX19LGdldFNoYWRlclNvdXJjZTpTfX0sUWQ9KGUsdCk9PntjZyhlLmlucHV0cyksZS5jb21wdXRlKG1nKGUuaW5wdXRzWzBdLHQpKX0sWWQ9ZT0+cmUoe2Jsb2Nrc2l6ZTplLmJsb2Nrc2l6ZSxtb2RlOmUubW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciB2byx0bixKZCxmZyxoZywkbyx4byxlbCxnZyx0bCxybCxubD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTt2bz1cIlthLXpBLVpdfFxcXFwuXFxcXC5cXFxcLlwiLHRuPVwiKFwiK3ZvK1wiKStcIixKZD1cIl5cIit0bitcIiRcIixmZz1cIihcIit0bitcIiwpKlwiK3RuLGhnPVwiXlwiK2ZnK1wiJFwiLCRvPWNsYXNze2NvbnN0cnVjdG9yKHQ9LTEpe3RoaXMuc3ltYm9sVG9JbmRpY2VzPW5ldyBNYXAsdGhpcy5pbnB1dEluZGV4PXR9YWRkU3ltYm9sKHQsbil7bGV0IHI9dGhpcy5zeW1ib2xUb0luZGljZXMuZ2V0KHQpO3I9PT12b2lkIDA/cj1bbl06ci5wdXNoKG4pLHRoaXMuc3ltYm9sVG9JbmRpY2VzLnNldCh0LHIpfX0seG89Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLmVxdWF0aW9uPW47dGhpcy5oYXNFbGxpcHNpcz0hMSx0aGlzLnN5bWJvbFRvSW5mbz1uZXcgTWFwLHRoaXMubGhzPW5ldyBBcnJheSx0aGlzLm91dHB1dERpbXM9W107bGV0W3Isb109bi5pbmNsdWRlcyhcIi0+XCIpP24uc3BsaXQoXCItPlwiLDIpOltuLFwiXCJdO2lmKCFyLm1hdGNoKFJlZ0V4cChoZykpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7aWYoci5zcGxpdChcIixcIikuZm9yRWFjaCgoZCxsKT0+e2xldCBwPXRbbF0uZGltcy5zbGljZSgpO2lmKCFkLm1hdGNoKFJlZ0V4cChKZCkpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IGY9dGhpcy5wcm9jZXNzVGVybShkLCEwLHAsbCk7dGhpcy5saHMucHVzaChmKX0pLG89PT1cIlwiKW8rPVsuLi50aGlzLnN5bWJvbFRvSW5mby5lbnRyaWVzKCldLmZpbHRlcigoW2QsbF0pPT5sLmNvdW50PT09MXx8ZD09PVwiLi4uXCIpLm1hcCgoW2RdKT0+ZCkuam9pbihcIlwiKTtlbHNlIGlmKCFvLm1hdGNoKFJlZ0V4cCh0bikpKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTXCIpO28ubWF0Y2goUmVnRXhwKHZvLFwiZ1wiKSk/LmZvckVhY2goZD0+e2lmKGQ9PT1cIi4uLlwiKXRoaXMub3V0cHV0RGltcz10aGlzLm91dHB1dERpbXMuY29uY2F0KHRoaXMuZWxsaXBzaXNEaW1zKTtlbHNle2xldCBsPXRoaXMuc3ltYm9sVG9JbmZvLmdldChkKTtpZihsPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgUkhTIHN5bWJvbFwiKTt0aGlzLm91dHB1dERpbXMucHVzaChsLmRpbVZhbHVlKX19KSx0aGlzLnJocz10aGlzLnByb2Nlc3NUZXJtKG8sITEsdGhpcy5vdXRwdXREaW1zKX1hZGRTeW1ib2wodCxuLHIpe2xldCBvPXRoaXMuc3ltYm9sVG9JbmZvLmdldCh0KTtpZihvIT09dm9pZCAwKXtpZihvLmRpbVZhbHVlIT09biYmby5jb3VudCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGltZW5zaW9uIG1pc21hdGNoXCIpO28uY291bnQrKyxvLmlucHV0SW5kaWNlcy5wdXNoKHIpfWVsc2Ugbz17Y291bnQ6MSxkaW1WYWx1ZTpuLGlucHV0SW5kaWNlczpbcl19O3RoaXMuc3ltYm9sVG9JbmZvLnNldCh0LG8pfXByb2Nlc3NUZXJtKHQsbixyLG89LTEpe2xldCBhPXIubGVuZ3RoLHM9ITEsZD1bXSxsPTA7aWYoIXQubWF0Y2goUmVnRXhwKEpkKSkmJiFuJiZ0IT09XCJcIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBwPXQubWF0Y2goUmVnRXhwKHZvLFwiZ1wiKSksZj1uZXcgJG8obyk7cmV0dXJuIHA/LmZvckVhY2goKGgseSk9PntpZihoPT09XCIuLi5cIil7aWYocyl0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBlbGxpcHNpcyBpcyBhbGxvd2VkIHBlciBpbnB1dCB0ZXJtXCIpO3M9ITA7bGV0IF89YS1wLmxlbmd0aCsxO2lmKF88MCl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBvdXQgb2YgYm91bmRzXCIpO2lmKGQ9ci5zbGljZShsLGwrXyksdGhpcy5oYXNFbGxpcHNpcyl7aWYodGhpcy5lbGxpcHNpc0RpbXMubGVuZ3RoIT09ZC5sZW5ndGh8fHRoaXMuZWxsaXBzaXNEaW1zLnRvU3RyaW5nKCkhPT1kLnRvU3RyaW5nKCkpdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgZGltZW5zaW9ucyBtaXNtYXRjaFwiKX1lbHNlIGlmKG4pdGhpcy5oYXNFbGxpcHNpcz0hMCx0aGlzLmVsbGlwc2lzRGltcz1kO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIExIU1wiKTtmb3IobGV0IGI9MDtiPGQubGVuZ3RoO2IrKyl7bGV0IHc9U3RyaW5nLmZyb21DaGFyQ29kZSg0OCtiKTtmLmFkZFN5bWJvbCh3LHkrYiksdGhpcy5hZGRTeW1ib2wodyxyW2wrK10sbyl9fWVsc2UgZi5hZGRTeW1ib2woaCx5Kyh0aGlzLmhhc0VsbGlwc2lzP3RoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aC0xOjApKSx0aGlzLmFkZFN5bWJvbChoLHJbbCsrXSxvKX0pLGZ9fSxlbD1lPT5lK1wiX21heFwiLGdnPShlLHQsbixyKT0+e2xldCBhPWUubWFwKGY9PmYubGVuZ3RoKS5tYXAoKGYsaCk9PlAoYGlucHV0JHtofWAsdCxmKSkscz1FLnNpemUociksZD1OKFwib3V0cHV0XCIsdCxyLmxlbmd0aCksbD1bLi4ubi5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIoZj0+IW4ucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoZikpLHA9Zj0+e2xldCBoPVtdLHk9XCJ2YXIgcHJvZCA9IDEuMDtcIixfPVwidmFyIHN1bSA9IDAuMDtcIixiPVwic3VtICs9IHByb2Q7XCIsdz1bXSxTPVtdLCQ9W10sdj1bXSxUPW4uc3ltYm9sVG9JbmZvLnNpemU9PT1uLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtuLnN5bWJvbFRvSW5mby5mb3JFYWNoKChBLGspPT57aWYobi5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhrKSl7bGV0IE89bi5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChrKT8uWzBdO08hPT12b2lkIDAmJm4ubGhzLmZvckVhY2goKE0sVik9PntpZihBLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhWKSl7bGV0IEY9TS5zeW1ib2xUb0luZGljZXMuZ2V0KGspO2lmKEY9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Ri5mb3JFYWNoKGo9PntoLnB1c2goYCR7YVtWXS5pbmRpY2VzU2V0KGBpbnB1dCR7Vn1JbmRpY2VzYCxqLGQuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixPKSl9YCl9KX19KX1lbHNlIG4ubGhzLmZvckVhY2goKE8sTSk9PntpZihBLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhNKSl7bGV0IFY9Ty5zeW1ib2xUb0luZGljZXMuZ2V0KGspO2lmKFY9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Vi5mb3JFYWNoKEY9Pnt3LnB1c2goYCR7YVtNXS5pbmRpY2VzU2V0KGBpbnB1dCR7TX1JbmRpY2VzYCxGLGAke2t9YCl9YCl9KSx2LnB1c2goYHByb2QgKj0gJHthW01dLmdldEJ5SW5kaWNlcyhgaW5wdXQke019SW5kaWNlc2ApfTtgKX19KSxTLnB1c2goYGZvcih2YXIgJHtrfTogdTMyID0gMDsgJHtrfSA8IHVuaWZvcm1zLiR7ZWwoayl9OyAke2t9KyspIHtgKSwkLnB1c2goXCJ9XCIpfSk7bGV0IEM9VD9bLi4uaCxgbGV0IHN1bSA9ICR7YS5tYXAoKEEsayk9PkEuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7a31JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi5oLF8sLi4uUywuLi53LHksLi4udixiLC4uLiRdO3JldHVybmBcbiAgICAgICAgICAgICR7Zi5yZWdpc3RlclVuaWZvcm1zKGwubWFwKEE9Pih7bmFtZTpgJHtlbChBKX1gLHR5cGU6XCJ1MzJcIn0pKSkucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uYSxkKX1cblxuICAgICAgICAgICAgJHtmLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtmLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAke2EubWFwKChBLGspPT5gdmFyIGlucHV0JHtrfUluZGljZXM6ICR7YVtrXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxuYCl9XG4gICAgICAgICAgICAke0Muam9pbihgXG5gKX07XG4gICAgICAgICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkVpbnN1bVwiLHNoYWRlckNhY2hlOntoaW50Om4uZXF1YXRpb24saW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKCk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+e2xldCBmPWwuZmlsdGVyKHk9Pm4uc3ltYm9sVG9JbmZvLmhhcyh5KSkubWFwKHk9Pih7dHlwZToxMixkYXRhOm4uc3ltYm9sVG9JbmZvLmdldCh5KT8uZGltVmFsdWV8fDB9KSk7Zi5wdXNoKHt0eXBlOjEyLGRhdGE6c30pO2xldCBoPWUubWFwKCh5LF8pPT5bLi4uSCh5KV0pLnJlZHVjZSgoeSxfKT0+eS5jb25jYXQoXyksZik7cmV0dXJuIGgucHVzaCguLi5IKHIpKSx7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTp0fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczpofX0sZ2V0U2hhZGVyU291cmNlOnB9fSx0bD0oZSx0KT0+e2xldCBuPW5ldyB4byhlLmlucHV0cyx0LmVxdWF0aW9uKSxyPW4ub3V0cHV0RGltcyxvPWUuaW5wdXRzLm1hcCgoYSxzKT0+YS5kaW1zKTtlLmNvbXB1dGUoZ2cobyxlLmlucHV0c1swXS5kYXRhVHlwZSxuLHIpKX0scmw9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3JldHVybiByZSh7ZXF1YXRpb246dH0pfX0pO3ZhciB5ZyxvbCxiZyxfZyxpbCxhbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7eWc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxuPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxyPW4ubGVuZ3RoPHQubGVuZ3RoPzA6bi5sZW5ndGgtdC5sZW5ndGgsbz10Lmxlbmd0aDxuLmxlbmd0aD8wOnQubGVuZ3RoLW4ubGVuZ3RoO2Zvcig7cjxuLmxlbmd0aCYmbzx0Lmxlbmd0aDsrK3IsKytvKWlmKG5bcl0hPT10W29dJiZuW3JdIT09MSYmdFtvXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LG9sPShlLHQpPT57bGV0IG49ZS5sZW5ndGgtdC5sZW5ndGgscj1bXTtmb3IobGV0IG89MDtvPG47KytvKXIucHVzaChlW29dKTtmb3IobGV0IG89MDtvPHQubGVuZ3RoOysrbylyLnB1c2godFtvXT09PTE/ZVtvK25dOnRbb10pO3JldHVybiByfSxiZz0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/b2woZSx0KTpvbCh0LGUpLF9nPWU9PntsZXQgdD1lWzBdLmRpbXMsbj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlcikscj1iZyh0LG4pLG89ZVswXS5kYXRhVHlwZSxhPW89PT05fHxFLnNpemUodCk9PT0xLHM9bz09PTl8fHQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTA/NDoxLGQ9YXx8ci5sZW5ndGg+MCYmcltyLmxlbmd0aC0xXSU0PT09MD80OjEsbD1NYXRoLmNlaWwoRS5zaXplKHIpL2QpLHA9aD0+e2xldCB5PVAoXCJpbnB1dFwiLG8sdC5sZW5ndGgscyksXz1OKFwib3V0cHV0XCIsbyxyLmxlbmd0aCxkKSxiO2lmKG89PT05KXtsZXQgdz0oUywkLHY9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7JH0gPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAkeyR9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHskfSA9ICR7eS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7JH1gLF8pfTtcbiAgICAgICAgICBsZXQgaW5kZXgkeyR9ID0gb2Zmc2V0JHskfSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQkeyR9ID0gb2Zmc2V0JHskfSAlIDR1O1xuICAgICAgICAgICR7U31bJHskfV0gPSAke3Z9KCR7eS5nZXRCeU9mZnNldChgaW5kZXgkeyR9YCl9W2NvbXBvbmVudCR7JH1dKTtcbiAgICAgICAgYDtiPWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2R9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt3KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICR7dyhcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAke3coXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt3KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YH1lbHNlIGI9YFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2R9YCl9O1xuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke3kuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsXyl9O1xuICAgICAgICBsZXQgZGF0YSA9ICR7Xy50eXBlLnZhbHVlfSgke3kuZ2V0QnlPZmZzZXQoYGlucHV0T2Zmc2V0IC8gJHtzfWApfSk7XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YDtyZXR1cm5gXG4gICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LF8pfVxuICAgICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICR7Yn1gfSxmPVt7dHlwZToxMixkYXRhOmx9LC4uLkgodCxyKV07cmV0dXJue25hbWU6XCJFeHBhbmRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyLmxlbmd0aH07JHtzfSR7ZH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSl9fSxpbD1lPT57eWcoZS5pbnB1dHMpLGUuY29tcHV0ZShfZyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgd2csc2wsdWw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO2pyKCk7d2c9ZT0+e2xldCB0PWVbMF0uZGF0YVR5cGUsbj1FLnNpemUoZVswXS5kaW1zKSxyPUUuc2l6ZShlWzFdLmRpbXMpLG89ciU0PT09MCxhPXM9PntsZXQgZD1QKFwieFwiLHQsWzFdLDQpLGw9UChcImJpYXNcIix0LFsxXSw0KSxwPU4oXCJ5XCIsdCxbMV0sNCksZj1be25hbWU6XCJvdXRwdXRfdmVjX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19zaXplXCIsdHlwZTpcInUzMlwifV0saD1fPT5gXG4gICAgICBsZXQgYmlhcyR7X31fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke199KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtffSA9ICR7bC5nZXRCeU9mZnNldChgYmlhcyR7X31fb2Zmc2V0IC8gNGApfVtiaWFzJHtffV9vZmZzZXQgJSA0XTtgLHk9bz9gXG4gICAgICBsZXQgYmlhcyA9ICR7bC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSAodW5pZm9ybXMuYmlhc19zaXplIC8gNClcIil9O2A6YCR7aCgwKX0ke2goMSl9JHtoKDIpfSR7aCgzKX1cbiAgICAgIGxldCBiaWFzID0gJHtkLnR5cGUudmFsdWV9KGJpYXMwLCBiaWFzMSwgYmlhczIsIGJpYXMzKTtgO3JldHVybmAke3MucmVnaXN0ZXJVbmlmb3JtcyhmKS5kZWNsYXJlVmFyaWFibGVzKGQsbCxwKX1cblxuICAgICR7bW8oemUodCkpfVxuXG4gICAgJHtzLm1haW5TdGFydChFdCl9XG4gICAgICAke3MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZVwiKX1cblxuICAgICAgbGV0IHggPSAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7eX1cbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XG4gICAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZm8oXCJ4X2luXCIpKX1cbiAgICB9YH07cmV0dXJue25hbWU6XCJGYXN0R2VsdVdpdGhCaWFzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7b31gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTphLGdldFJ1bkRhdGE6cz0+KHtvdXRwdXRzOlt7ZGltczpzWzBdLmRpbXMsZGF0YVR5cGU6c1swXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwobi80KX0se3R5cGU6MTIsZGF0YTpyfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi9FdC80KX19KX19LHNsPWU9PntlLmlucHV0cy5sZW5ndGg8Mnx8RS5zaXplKGUuaW5wdXRzWzFdLmRpbXMpPT09MD9uZChlKTplLmNvbXB1dGUod2coZS5pbnB1dHMpKX19KTt2YXIgdmcsJGcsZGwsbGwsY2w9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7dmc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLlwiKX0sJGc9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzFdLmRpbXMsbz1uLmxlbmd0aCxhPUUubm9ybWFsaXplQXhpcyh0LmF4aXMsbykscz1uLnNsaWNlKDApO3Muc3BsaWNlKGEsMSwuLi5yKTtsZXQgZD1uW2FdLGw9ZVswXS5kYXRhVHlwZT09PTk/NDoxLHA9TWF0aC5jZWlsKEUuc2l6ZShzKS9sKSxmPVt7dHlwZToxMixkYXRhOnB9LHt0eXBlOjYsZGF0YTpkfSx7dHlwZToxMixkYXRhOmF9LC4uLkgoZVswXS5kaW1zLGVbMV0uZGltcyxzKV0saD15PT57bGV0IF89UChcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsbCksYj1QKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSx3PU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHMubGVuZ3RoLGwpLFM9dj0+e2xldCBUPXIubGVuZ3RoLEM9YHZhciBpbmRpY2VzSW5kaWNlcyR7dn0gID0gJHtiLnR5cGUuaW5kaWNlc30oMCk7YDtmb3IobGV0IEE9MDtBPFQ7QSsrKUMrPWAke1Q+MT9gaW5kaWNlc0luZGljZXMke3Z9WyR7QX1dYDpgaW5kaWNlc0luZGljZXMke3Z9YH0gPSAke3MubGVuZ3RoPjE/YG91dHB1dEluZGljZXMke3Z9W3VuaWZvcm1zLmF4aXMgKyAke0F9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YDtDKz1gXG4gICAgICAgICAgdmFyIGlkeCR7dn0gPSAke2IuZ2V0QnlJbmRpY2VzKGBpbmRpY2VzSW5kaWNlcyR7dn1gKX07XG4gICAgICAgICAgaWYgKGlkeCR7dn0gPCAwKSB7XG4gICAgICAgICAgICBpZHgke3Z9ID0gaWR4JHt2fSArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHt2fSA6ICR7Xy50eXBlLmluZGljZXN9O1xuICAgICAgICBgO2ZvcihsZXQgQT0wLGs9MDtBPG87QSsrKUE9PT1hPyhDKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gdTMyKGlkeCR7dn0pO2Asays9VCk6KEMrPWAke28+MT9gZGF0YUluZGljZXMke3Z9WyR7QX1dYDpgZGF0YUluZGljZXMke3Z9YH0gPSAke3MubGVuZ3RoPjE/YG91dHB1dEluZGljZXMke3Z9WyR7a31dYDpgb3V0cHV0SW5kaWNlcyR7dn1gfTtgLGsrKyk7cmV0dXJuIEN9LCQ7aWYoZVswXS5kYXRhVHlwZT09PTkpe2xldCB2PShULEMsQT1cIlwiKT0+YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtDfSA9ICR7dy5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7Q311YCl9O1xuICAgICAgICAgICR7UyhDKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7Q30gPSAke18uaW5kaWNlc1RvT2Zmc2V0KGBkYXRhSW5kaWNlcyR7Q31gKX07XG4gICAgICAgICAgbGV0IGluZGV4JHtDfSA9IG9mZnNldCR7Q30gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHtDfSA9IG9mZnNldCR7Q30gJSA0dTtcbiAgICAgICAgICAke1R9WyR7Q31dID0gJHtBfSgke18uZ2V0QnlPZmZzZXQoYGluZGV4JHtDfWApfVtjb21wb25lbnQke0N9XSk7XG4gICAgICAgIGA7JD1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtsfTtcbiAgICAgICAgdmFyIHZhbHVlID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3YoXCJ2YWx1ZVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwyLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICR7dy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICAgICAgYH1lbHNlICQ9YFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke1MoXCJcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHtfLmdldEJ5SW5kaWNlcyhcImRhdGFJbmRpY2VzXCIpfTtcbiAgICAgICR7dy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgIGA7cmV0dXJuYFxuICAgICAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhfLGIsdyl9XG4gICAgICAke3kubWFpblN0YXJ0KCl9XG4gICAgICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgJHskfVxuICAgICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6Zn0pLGdldFNoYWRlclNvdXJjZTpofX0sZGw9ZT0+cmUoe2F4aXM6ZS5heGlzfSksbGw9KGUsdCk9PntsZXQgbj1lLmlucHV0czt2ZyhuKSxlLmNvbXB1dGUoJGcoZS5pbnB1dHMsdCkpfX0pO3ZhciB4ZyxwbCxtbCxmbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7eGc9KGUsdCxuLHIsbyxhLHMsZCxsKT0+e2xldCBwPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9XSxmPVthXTtwLnB1c2goLi4uSCh0LmRpbXMsZikpO2xldCBoPXk9PntsZXQgXz1QKFwiaW5kaWNlc19kYXRhXCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxiPU4oXCJpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFcIiwxMiwxLDEpLHc9W18sYl0sUz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiYXRjaF9kaW1zXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpuLmxlbmd0aH0se25hbWU6XCJudW1fc2xpY2VzX3Blcl9iYXRjaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9iYXRjaF9zdHJpZGVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX3NsaWNlX2RpbXNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7eS5yZWdpc3RlclVuaWZvcm1zKFMpLmRlY2xhcmVWYXJpYWJsZXMoLi4udyl9XG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XG4gICAgbGV0IGJhc2Vfb2Zmc2V0ID0gYmF0Y2hfaWR4ICogdW5pZm9ybXMuaW5wdXRfYmF0Y2hfc3RyaWRlO1xuXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XG4gICAgdmFyIHJlbGF0aXZlX3NsaWNlX29mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xuICAgICAgbGV0IGlucHV0X2RpbV9pZHggPSB1bmlmb3Jtcy5iYXRjaF9kaW1zICsgZGltX2lkeDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgJHtvLmxlbmd0aD09PTE/XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7XCI6XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltc1tpbnB1dF9kaW1faWR4XSk7XCJ9XG4gICAgICB9XG4gICAgICAke24ubGVuZ3RoPT09MT9cInJlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YSk7XCI6XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pO1wifVxuICAgIH1cblxuICAgIGlucHV0X3NsaWNlX29mZnNldHNfZGF0YVtnbG9iYWxfaWR4XSA9ICBiYXNlX29mZnNldCArIHUzMihyZWxhdGl2ZV9zbGljZV9vZmZzZXQpO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcImNvbXB1dGVTbGljZU9mZnNldHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvLmxlbmd0aH1fJHtuLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZixkYXRhVHlwZTplLmlucHV0c1sxXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTpofSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXX0scGw9KGUsdCk9PntsZXQgbj1lLmlucHV0cyxyPW5bMF0uZGltcyxvPW5bMF0uZGF0YVR5cGUsYT1uWzFdLmRpbXMscz1hW2EubGVuZ3RoLTFdLGQ9RS5zaXplVG9EaW1lbnNpb24oYSxhLmxlbmd0aC0xKSxsPUUuc2l6ZUZyb21EaW1lbnNpb24ocix0LmJhdGNoRGltcytzKSxwPUUuc2l6ZVRvRGltZW5zaW9uKHIsdC5iYXRjaERpbXMpLGY9RS5zaXplRnJvbURpbWVuc2lvbihyLHQuYmF0Y2hEaW1zKSxoPWQvcCx5PW5ldyBBcnJheShzKSxfPWw7Zm9yKGxldCBDPTA7QzxzOysrQyl5W3MtMS1DXT1fLF8qPXJbdC5iYXRjaERpbXMrcy0xLUNdO2xldCBiPXhnKGUsblsxXSx5LHQuYmF0Y2hEaW1zLHIsZCxoLGYscyksdz10LmJhdGNoRGltcytzO2lmKHc+ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiByYW5rIG9mIGlucHV0IHRlbnNvclwiKTtsZXQgUz1hLnNsaWNlKDAsLTEpLmNvbmNhdChyLnNsaWNlKHcpKSwkPUUuc2l6ZShTKSx2PVt7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6bH0sLi4uSChuWzBdLmRpbXMsYi5kaW1zLFMpXSxUPUM9PntsZXQgQT1QKFwiZGF0YVwiLG5bMF0uZGF0YVR5cGUsblswXS5kaW1zLmxlbmd0aCksaz1QKFwic2xpY2Vfb2Zmc2V0c1wiLDEyLGIuZGltcy5sZW5ndGgpLE89TihcIm91dHB1dFwiLG5bMF0uZGF0YVR5cGUsUy5sZW5ndGgpO3JldHVybmBcbiAgICAgICAgICAke0MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzbGljZV9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhBLGssTyl9XG4gICAgICAgICAgICAke0MubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke0MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBzbGljZV9vZmZzZXQgPSBzbGljZV9vZmZzZXRzW2dsb2JhbF9pZHggLyB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBkYXRhW3UzMihzbGljZV9vZmZzZXQpICsgZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiR2F0aGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6UyxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoJC82NCl9LHByb2dyYW1Vbmlmb3Jtczp2fSksZ2V0U2hhZGVyU291cmNlOlR9LHtpbnB1dHM6W25bMF0sYl19KX0sbWw9ZT0+KHtiYXRjaERpbXM6ZS5iYXRjaF9kaW1zLGNhY2hlS2V5OlwiXCJ9KX0pO3ZhciBTZyxUZyxobCxnbCx5bD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtTZz0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy5cIik7bGV0IG49RS5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLGVbMF0uZGltcy5sZW5ndGgpLHI9dC5ibG9ja1NpemUsbz1lWzBdLGE9ZVsyXSxzPWUubGVuZ3RoPT09ND9lWzNdOnZvaWQgMDtpZihhLmRpbXMubGVuZ3RoIT09by5kaW1zLmxlbmd0aHx8IW8uZGltcy5tYXAoKGQsbCk9Pmw9PT1uP01hdGguY2VpbChkL3IpPT09YS5kaW1zW2xdOmQ9PT1hLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy5cIik7aWYocyl7aWYocy5kYXRhVHlwZSE9PW8uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKHMuZGltcy5sZW5ndGghPT1hLmRpbXMubGVuZ3RofHwhcy5kaW1zLm1hcCgoZCxsKT0+ZD09PWEuZGltc1tsXSkucmVkdWNlKChkLGwpPT5kJiZsLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLlwiKX19LFRnPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9ZVsxXS5kaW1zLG89bi5sZW5ndGgsYT1FLm5vcm1hbGl6ZUF4aXModC5nYXRoZXJBeGlzLG8pLHM9RS5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLG8pLGQ9bi5zbGljZSgwKTtkLnNwbGljZShhLDEsLi4ucik7bGV0IGw9RS5zaXplKGQpLHA9ZVsyXS5kYXRhVHlwZSxoPWVbMF0uZGF0YVR5cGU9PT0yMix5PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5IKC4uLmUubWFwKChiLHcpPT5iLmRpbXMpLGQpXSxfPWI9PntsZXQgdz1QKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksUz1QKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSwkPVAoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLHY9ZS5sZW5ndGg+Mz9QKFwiemVyb1BvaW50XCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDAsVD1OKFwib3V0cHV0XCIscCxkLmxlbmd0aCksQz1bdyxTLCRdO3YmJkMucHVzaCh2KTtsZXQgQT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJxdWFudGl6ZV9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImdhdGhlcl9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAgICR7Yi5yZWdpc3RlclVuaWZvcm1zKEEpLmRlY2xhcmVWYXJpYWJsZXMoLi4uQyxUKX1cbiAgICAgICAgJHtiLm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke1MudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgJHtyLmxlbmd0aD4xP2BcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpXCIpfTtcbiAgICAgICAgICAgICR7Uy5pbmRpY2VzU2V0KFwiaW5kaWNlc19pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgfWA6YGluZGljZXNfaW5kaWNlcyA9ICR7VC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIpfTtgfTtcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7dy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZ2F0aGVyX2F4aXM7IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7VC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICR7dy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7Uy5nZXRCeUluZGljZXMoXCJpbmRpY2VzX2luZGljZXNcIil9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke25bYV19O1xuICAgICAgICB9XG4gICAgICAgICR7dy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiLFwidTMyKGluZGV4X2Zyb21faW5kaWNlcylcIil9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtkLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7VC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixgaSArICR7ci5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke3cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7dy5pbmRpY2VzVG9PZmZzZXQoXCJkYXRhX2luZGljZXNcIil9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHt3LmdldEJ5T2Zmc2V0KFwiZGF0YV9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhX3ZlYyA9ICR7aD9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICR7JC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiLFwicXVhbnRpemVfYXhpc19pbmRleFwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7JC5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgJHt2P2BcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kaWNlcyA9IHNjYWxlX2luZGljZXM7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7di5pbmRpY2VzVG9PZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGljZXNcIil9O1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9IHplcm9fcG9pbnRfb2Zmc2V0ICUgODtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID0gJHt2LmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgICAgICAgbGV0IHBhY2tlZF84Yml0X3plcm9fcG9pbnRzID0gKHBhY2tlZF80Yml0X3plcm9fcG9pbnRzID4+ICg0ICogKHplcm9fcG9pbnRfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtoP1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfemVyb19wb2ludHMpKTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4IC8gMl07YDpcInZhciB6ZXJvX3BvaW50ID0gMFwifTtcbiAgICAgICAgbGV0IGRlcXVhbnRpemVkX2RhdGEgPSAke3plKHApfShxdWFudGl6ZWRfZGF0YSAtIHplcm9fcG9pbnQpICogc2NhbGU7XG4gICAgICAgICR7VC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRlcXVhbnRpemVkX2RhdGFcIil9O1xuICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlckJsb2NrUXVhbnRpemVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtlLmZpbHRlcigoYix3KT0+dyE9PTEpLm1hcChiPT5iLmRpbXMuam9pbihcIl9cIikpLmpvaW4oXCI7XCIpfWAsaW5wdXREZXBlbmRlbmNpZXM6QXJyYXkuZnJvbSh7bGVuZ3RoOmUubGVuZ3RofSwoYix3KT0+XCJyYW5rXCIpfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6cH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTpffX0saGw9KGUsdCk9PntsZXQgbj1lLmlucHV0cztTZyhuLHQpLGUuY29tcHV0ZShUZyhlLmlucHV0cyx0KSl9LGdsPWU9PnJlKHtibG9ja1NpemU6ZS5ibG9ja1NpemUsZ2F0aGVyQXhpczplLmdhdGhlckF4aXMscXVhbnRpemVBeGlzOmUucXVhbnRpemVBeGlzfSl9KTt2YXIgQ2csSWcsYmwsX2wsd2w9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7Q2c9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGJlIHJhbmsgPj0gMS5cIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBHYXRoZXJFbGVtZW50cyByZXF1aXJlcyB0aGF0IHRoZSBkYXRhIGlucHV0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcyBpbnB1dCB0ZW5zb3JzIGJlIG9mIHNhbWUgcmFuay5gKX0sSWc9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1lWzBdLmRhdGFUeXBlLG89bi5sZW5ndGgsYT1lWzFdLmRpbXMscz1lWzFdLmRhdGFUeXBlLGQ9RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxvKSxsPW5bZF0scD1hLnNsaWNlKDApLGY9RS5zaXplKHApLGg9UChcImlucHV0XCIscixvKSx5PVAoXCJpbmRpY2VzSW5wdXRcIixzLGEubGVuZ3RoKSxfPU4oXCJvdXRwdXRcIixyLHAubGVuZ3RoKSxiPVt7dHlwZToxMixkYXRhOmZ9LHt0eXBlOjYsZGF0YTpsfSx7dHlwZToxMixkYXRhOmR9XTtyZXR1cm4gYi5wdXNoKC4uLkgobixhLHApKSx7bmFtZTpcIkdhdGhlckVsZW1lbnRzXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZi82NCl9LHByb2dyYW1Vbmlmb3JtczpifSksZ2V0U2hhZGVyU291cmNlOiQ9PmBcbiAgICAgICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCx5LF8pfVxuICAgICAgJHskLm1haW5TdGFydCgpfVxuICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgdmFyIGlkeCA9ICR7eS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgaWR4ID0gaWR4ICsgdW5pZm9ybXMuYXhpc0RpbUxpbWl0O1xuICAgICAgfVxuICAgICAgdmFyIGlucHV0SW5kaWNlcyA9ICR7aC50eXBlLmluZGljZXN9KG91dHB1dEluZGljZXMpO1xuICAgICAgJHtoLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpZHgpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7aC5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuXG4gICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gIH1gfX0sYmw9ZT0+cmUoe2F4aXM6ZS5heGlzfSksX2w9KGUsdCk9PntsZXQgbj1lLmlucHV0cztDZyhuKSxlLmNvbXB1dGUoSWcoZS5pbnB1dHMsdCkpfX0pO3ZhciBBZyxrZyx2bCwkbCx4bD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7QWc9ZT0+e2lmKCFlKXRocm93IG5ldyBFcnJvcihcIklucHV0IGlzIG1pc3NpbmdcIik7aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhaWQgaW5wdXQgbnVtYmVyLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMl0uZGltcy5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHNoYXBlIG9mIENcIik7aWYoZVswXS5kYXRhVHlwZSE9PWVbMV0uZGF0YVR5cGV8fGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgdHlwZXMgYXJlIG1pc21hdGNoZWRcIil9LGtnPShlLHQpPT57bGV0IG49ZVswXS5kaW1zLnNsaWNlKCkscj1lWzFdLmRpbXMuc2xpY2UoKSxbbyxhLHNdPVdyLmdldFNoYXBlT2ZHZW1tUmVzdWx0KG4sdC50cmFuc0Escix0LnRyYW5zQixlLmxlbmd0aD09PTM/ZVsyXS5kaW1zOnZvaWQgMCksZD1bbyxhXTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgZ2VtbSBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtsZXQgbD0xNixwPU1hdGguY2VpbChhL2wpLGY9TWF0aC5jZWlsKG8vbCksaD0hMCx5PUUuc2l6ZShkKSxfPVt7dHlwZToxMixkYXRhOmg/cDp5fSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxLGRhdGE6dC5hbHBoYX0se3R5cGU6MSxkYXRhOnQuYmV0YX1dLGI9W1widHlwZVwiLFwidHlwZVwiXTtlLmxlbmd0aD09PTMmJihfLnB1c2goLi4uSChlWzJdLmRpbXMpKSxiLnB1c2goXCJyYW5rXCIpKSxfLnB1c2goLi4uSChkKSk7bGV0IHc9JD0+e2xldCB2PVwiXCI7dC50cmFuc0EmJnQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6dC50cmFuc0EmJiF0LnRyYW5zQj92PVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiOiF0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjohdC50cmFuc0EmJiF0LnRyYW5zQiYmKHY9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCIpO2xldCBUPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIixDPVAoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLEE9UChcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksaz1DLnR5cGUudmFsdWUsTz1udWxsLE09W0MsQV07ZS5sZW5ndGg9PT0zJiYoTz1QKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksTS5wdXNoKE8pKTtsZXQgVj1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7TS5wdXNoKFYpO2xldCBGPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9XTtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKEYpLmRlY2xhcmVWYXJpYWJsZXMoLi4uTSl9XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgbSA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5OO1xuICAgIGxldCBuID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLk47XG5cbiAgICB2YXIgdmFsdWUgPSAke2t9KDApO1xuICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAke3Z9XG4gICAgfVxuXG4gICAgJHtUfVxuICAgICR7TyE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke08uYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsVil9OyB2YWx1ZSArPSAke2t9KHVuaWZvcm1zLmJldGEpICogJHtPLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwifVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YH0sUz0kPT57bGV0IHY9UChcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksVD1QKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxDPW51bGwsQT1bdixUXTtlLmxlbmd0aD09PTMmJihDPVAoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxBLnB1c2goQykpO2xldCBrPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtBLnB1c2goayk7bGV0IE89W3tuYW1lOlwibnVtX3RpbGVfblwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV0sTT1cIlwiLFY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/KFY9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1QudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLE09XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOnQudHJhbnNBJiYhdC50cmFuc0I/KFY9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1QudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLE09XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpOiF0LnRyYW5zQSYmdC50cmFuc0I/KFY9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1QudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLE09XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYoVj1gXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7VC50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsTT1cInZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtcIik7bGV0IEY9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoTykuZGVjbGFyZVZhcmlhYmxlcyguLi5BKX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZV9hOiBhcnJheTxhcnJheTwke3YudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlX2I6IGFycmF5PGFycmF5PCR7VC50eXBlLnN0b3JhZ2V9LCAke2x9PiwgJHtsfT47XG4gICR7JC5tYWluU3RhcnQoW2wsbCwxXSl9XG4gICAgbGV0IHRpbGVfY29sX3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgdGlsZV9yb3dfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke2x9O1xuICAgIGxldCBudW1fdGlsZXMgPSAodW5pZm9ybXMuSyAtIDEpIC8gJHtsfSArIDE7XG4gICAgdmFyIGtfc3RhcnQgPSAwdTtcbiAgICB2YXIgdmFsdWUgPSAke2sudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgdDogdTMyID0gMHU7IHQgPCBudW1fdGlsZXM7IHQrKykge1xuICAgICAgJHtWfVxuICAgICAga19zdGFydCA9IGtfc3RhcnQgKyAke2x9O1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8ICR7bH07IGsrKykge1xuICAgICAgICAke019XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgJHtGfVxuICAgIGxldCBtID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgIGxldCBuID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICR7QyE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke0MuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsayl9OyB2YWx1ZSArPSAke2sudHlwZS52YWx1ZX0odW5pZm9ybXMuYmV0YSkgKiAke0MuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCJ9XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBvdXRwdXRbbSAqIHVuaWZvcm1zLk4gKyBuXSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9O3JldHVybiBoP3tuYW1lOlwiR2VtbVNoYXJlZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczpifSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cCpmfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpTfTp7bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6Yn0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6d319LHZsPWU9PntsZXQgdD1lLnRyYW5zQSxuPWUudHJhbnNCLHI9ZS5hbHBoYSxvPWUuYmV0YTtyZXR1cm57dHJhbnNBOnQsdHJhbnNCOm4sYWxwaGE6cixiZXRhOm8sY2FjaGVLZXk6YCR7ZS50cmFuc0F9OyR7ZS50cmFuc0J9OyR7ZS5hbHBoYT09PTF9YH19LCRsPShlLHQpPT57QWcoZS5pbnB1dHMpLGUuY29tcHV0ZShrZyhlLmlucHV0cyx0KSl9fSk7dmFyIHB0LCR0LE50LFZ0LEVnLFBnLHpnLE9nLERnLEJnLE1nLFJnLFNsLFRsLENsPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO1twdCwkdCxOdCxWdF09WzAsMSwyLDNdLEVnPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IDQtRCB0ZW5zb3IgaXMgc3VwcG9ydGVkLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltcy5sZW5ndGgtMiE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTFdKXRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7ZVswXS5kaW1zLmxlbmd0aC0yfWApO2lmKGVbMF0uZGltc1swXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplXCIpfSxQZz1gXG4gIGZuIGdzX2dldF9jdWJpY19jb2VmZnMoeDogZjMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XG4gICAgdmFyIGNvZWZmczogdmVjNDxmMzI+O1xuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcbiAgICBjb2VmZnNbMl0gPSAoKChjdWJpY19hbHBoYSArIDIpICogKDEgLSB4X2FicykgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiAoMSAtIHhfYWJzKSAqICgxIC0geF9hYnMpICsgMSk7XG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuYCx6Zz1lPT5gXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZX0+LCB4OiBmMzIsIHk6IGYzMikgLT4gJHtlfSB7XG4gICAgdmFyIHY6IHZlYzQ8ZjMyPjtcbiAgICB2YXIgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdltpXSA9IGNvZWZmc1swXSAqIHBbaV1bMF0gKyBjb2VmZnNbMV0gKiBwW2ldWzFdICsgY29lZmZzWzJdICogcFtpXVsyXSArIGNvZWZmc1szXSAqIHBbaV1bM107XG4gICAgfVxuICAgIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeSk7XG4gICAgbGV0IHBpeGVsID0gJHtlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcbiAgICByZXR1cm4gcGl4ZWw7XG4gIH1cbmAsT2c9ZT0+YFxuICBmbiBnc19kZW5vcm1hbGl6ZShuOiBmMzIsIGxlbmd0aDogaTMyKSAtPiBmMzIge1xuICAgICR7ZS5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAvLyBhbGlnbkNvcm5lcnM6IGZhbHNlID0+IFstMSwgMV0gdG8gWy0wLjUsIGxlbmd0aCAtIDAuNV1cbiAgICByZXR1cm4gKChuICsgMS4wKSAqIGYzMihsZW5ndGgpIC0gMS4wKSAvIDIuMDtcbiAgICBgOmBcbiAgICAvLyBhbGlnbkNvcm5lcnM6IHRydWUgPT4gWy0xLCAxXSB0byBbMCwgbGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XG4gICAgYH1cbiAgfVxuYCxEZz1lPT5gXG4gICR7ZS5wYWRkaW5nTW9kZT09PVwicmVmbGVjdGlvblwiP2BcbiAgICAgIGZuIGdzX3JlZmxlY3QoeDogaTMyLCB4X21pbjogZjMyLCB4X21heDogZjMyKSAtPiB1MzIge1xuICAgICAgICB2YXIgZHggPSAwLjA7XG4gICAgICAgIHZhciBmeCA9IGYzMih4KTtcbiAgICAgICAgbGV0IHJhbmdlID0geF9tYXggLSB4X21pbjtcbiAgICAgICAgaWYgKGZ4IDwgeF9taW4pIHtcbiAgICAgICAgICBkeCA9IHhfbWluIC0gZng7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZ4ID4geF9tYXgpIHtcbiAgICAgICAgICBkeCA9IGZ4IC0geF9tYXg7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1MzIoZngpO1xuICAgICAgfWA6XCJcIn1cbmAsQmc9KGUsdCxuKT0+YFxuICBmbiBwaXhlbF9hdF9ncmlkKHI6IGkzMiwgYzogaTMyLCBIOiBpMzIsIFc6IGkzMiwgYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBib3JkZXI6IHZlYzQ8ZjMyPikgLT4gJHt0fSB7XG4gICAgIHZhciBwaXhlbCA9ICR7dH0oMCk7XG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xuICAgICBpbmRpY2VzWyR7cHR9XSA9IGJhdGNoO1xuICAgICBpbmRpY2VzWyR7JHR9XSA9IGNoYW5uZWw7YCsoKCk9Pntzd2l0Y2gobi5wYWRkaW5nTW9kZSl7Y2FzZVwiemVyb3NcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgSCAmJiBjID49MCAmJiBjIDwgVykge1xuICAgICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIocik7XG4gICAgICAgICAgICBpbmRpY2VzWyR7VnR9XSA9IHUzMihjKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwiYm9yZGVyXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtOdH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske1Z0fV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtjYXNlXCJyZWZsZWN0aW9uXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtOdH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XG4gICAgICAgICAgaW5kaWNlc1ske1Z0fV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7bi5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYFxuICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKX07XG4gIH1cbmAsTWc9KGUsdCxuKT0+KCgpPT57c3dpdGNoKG4ubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcGl4ZWxfYXRfZ3JpZChpMzIocm91bmQoeSkpLCBpMzIocm91bmQoeCkpLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG4gICAgICAgIGA7Y2FzZVwiYmlsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtwdH1dLCBpbmRpY2VzWyR7JHR9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke3R9KGYzMih4MikgLSB4KTtcbiAgICAgICAgICBsZXQgZHgxID0gJHt0fSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7dH0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke3R9KHkgLSBmMzIoeTEpKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZHkyICogKGR4MiAqIHAxMSArIGR4MSAqIHAxMikgKyBkeTEgKiAoZHgyICogcDIxICsgZHgxICogcDIyKTtcbiAgICAgICAgYDtjYXNlXCJiaWN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xuICAgICAgICAgIHZhciBwOiBtYXQ0eDQ8JHt0fT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7cHR9XSwgaW5kaWNlc1skeyR0fV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBtb2RlICR7bi5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgJHtlLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicmVzdWx0XCIpfWAsUmc9KGUsdCk9PntsZXQgbj1QKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCkscj1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dLG89UChcImdyaWRcIixlWzFdLmRhdGFUeXBlLHIubGVuZ3RoLDIpLGE9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV07dC5mb3JtYXQ9PT1cIk5IV0NcIiYmKGE9W2VbMF0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMF0uZGltc1szXV0sW3B0LCR0LE50LFZ0XT1bMCwzLDEsMl0pO2xldCBzPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoKSxkPW4udHlwZS52YWx1ZSxsPUUuc2l6ZShhKSxwPVt7dHlwZToxMixkYXRhOmx9LC4uLkgoZVswXS5kaW1zLHIsYSldLGY9aD0+YFxuICAke2gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG4sbyxzKX1cbiAgJHtQZ31cbiAgJHt6ZyhkKX1cbiAgJHtPZyh0KX1cbiAgJHtEZyh0KX1cbiAgJHtCZyhuLGQsdCl9XG5cbiAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7TnR9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7VnR9XSk7XG5cbiAgICAgICR7dC5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYDpgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7cy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske3B0fV0sIGluZGljZXNbJHtOdH1dLCBpbmRpY2VzWyR7VnR9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtvLmdldEJ5SW5kaWNlcyhcImdyaWRfaW5kaWNlc1wiKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke01nKHMsZCx0KX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcmlkU2FtcGxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6aD0+e2xldCB5PUUuc2l6ZShhKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpoWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoeS82NCl9LHByb2dyYW1Vbmlmb3JtczpwfX0sZ2V0U2hhZGVyU291cmNlOmZ9fSxTbD0oZSx0KT0+e0VnKGUuaW5wdXRzKSxlLmNvbXB1dGUoUmcoZS5pbnB1dHMsdCkpfSxUbD1lPT5yZSh7YWxpZ25Db3JuZXJzOmUuYWxpZ25fY29ybmVycyxtb2RlOmUubW9kZSxwYWRkaW5nTW9kZTplLnBhZGRpbmdfbW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciBNZSxWZyxBbCxJbCxXZyxvcixrbCxTbz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7VnIoKTtxcigpO2NlKCk7Y3QoKTtNZT0oZSx0KT0+ZS5sZW5ndGg+dCYmZVt0XS5kaW1zLmxlbmd0aD4wP2VbdF06dm9pZCAwLFZnPShlLHQpPT57bGV0IG49ZVswXSxyPU1lKGUsMSksbz1NZShlLDIpLGE9TWUoZSwzKSxzPU1lKGUsNCksZD1NZShlLDUpLGw9TWUoZSw2KSxwPU1lKGUsNyk7aWYobi5kaW1zLmxlbmd0aCE9PTMmJm4uZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IGY9bi5kaW1zWzBdLGg9bi5kaW1zWzFdLHk9bi5kaW1zLmxlbmd0aD09PTM/bi5kaW1zWzJdOnQubnVtSGVhZHMqbi5kaW1zWzRdLF89aCxiPTAsdz0wLFM9TWF0aC5mbG9vcih5L3QubnVtSGVhZHMpO2lmKGwmJnAmJkUuc2l6ZShsLmRpbXMpJiZFLnNpemUocC5kaW1zKSl7aWYobC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihsLmRpbXNbMF0hPT1mfHxsLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxsLmRpbXNbM10hPT1TKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYocC5kaW1zWzBdIT09Znx8cC5kaW1zWzFdIT09dC5udW1IZWFkc3x8cC5kaW1zWzNdIT09Uyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYobC5kaW1zWzJdIT09cC5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO2lmKHAuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtiPWwuZGltc1syXSx3PWwuZGltc1syXX1lbHNlIGlmKGwmJkUuc2l6ZShsLmRpbXMpfHxwJiZFLnNpemUocC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0ICQ7aWYociYmRS5zaXplKHIuZGltcyk+MCl7aWYobi5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihyLmRpbXMubGVuZ3RoPDN8fHIuZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1yLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKHIuZGltcy5sZW5ndGg9PT0zKXtpZihyLmRpbXNbMl0hPT1uLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTskPTIsXz1yLmRpbXNbMV19ZWxzZSBpZihyLmRpbXMubGVuZ3RoPT09NSl7aWYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09Mnx8ci5kaW1zWzRdIT09Uyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7JD01LF89ci5kaW1zWzFdfWVsc2V7aWYoci5kaW1zWzFdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09Uyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTskPTAsXz1yLmRpbXNbMl19fWVsc2V7aWYobi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihuLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT0zKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpOyQ9M31pZihhJiZFLnNpemUoYS5kaW1zKT4wKXtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtpZihyJiZyLmRpbXMubGVuZ3RoPT09NSYmci5kaW1zWzNdPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuXCIpfWxldCB2PWIrXyxUPTA7aWYocyYmRS5zaXplKHMuZGltcyk+MCl7VD04O2xldCBPPXMuZGltczt0aHJvdyBPLmxlbmd0aD09PTE/T1swXT09PWY/VD0xOk9bMF09PT0zKmYrMiYmKFQ9Myk6Ty5sZW5ndGg9PT0yJiZPWzBdPT09ZiYmT1sxXT09PXYmJihUPTUpLFQ9PT04P25ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk6bmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpfWxldCBDPSExLEE9eTtpZihvJiZFLnNpemUoby5kaW1zKT4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoXyE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihfIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sQz0hMH19bGV0IGs9ITE7aWYocyYmRS5zaXplKHMuZGltcyk+MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCYmRS5zaXplKGQuZGltcyk+MCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1mfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT1ofHxkLmRpbXNbM10hPT12KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOmYsc2VxdWVuY2VMZW5ndGg6aCxwYXN0U2VxdWVuY2VMZW5ndGg6YixrdlNlcXVlbmNlTGVuZ3RoOl8sdG90YWxTZXF1ZW5jZUxlbmd0aDp2LG1heFNlcXVlbmNlTGVuZ3RoOncsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTp5LHZIaWRkZW5TaXplOkEsaGVhZFNpemU6Uyx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpULHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczprLHBhc3NQYXN0SW5LdjpDLHFrdkZvcm1hdDokfX0sQWw9ZT0+cmUoey4uLmV9KSxJbD1yZSh7cGVybTpbMCwyLDEsM119KSxXZz0oZSx0LG4scixvLGEscyk9PntsZXQgZD1bcixvLGFdLGw9RS5zaXplKGQpLHA9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmF9XSxmPWg9PntsZXQgeT1OKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsZCksXz1QKFwicWt2XCIsdC5kYXRhVHlwZSxkKSxiPVAoXCJiaWFzXCIsbi5kYXRhVHlwZSxkKSx3PVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3Jtcyh3KS5kZWNsYXJlVmFyaWFibGVzKF8sYix5KX1cbiAgJHtoLm1haW5TdGFydCgpfVxuICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTpmfSx7aW5wdXRzOlt0LG5dLG91dHB1dHM6Wy0xXX0pWzBdfSxvcj0oZSx0LG4scixvLGEscyxkKT0+e2xldCBsPWE7aWYocyYmRS5zaXplKHMuZGltcyk+MCl7aWYocj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBsPVdnKGUsYSxzLHQscixuKm8sZCksbD1sLnJlc2hhcGUoW3QscixuLG9dKSxuPT09MXx8cj09PTE/bDplLmNvbXB1dGUoT2UobCxJbC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBhLmRpbXMubGVuZ3RoPT09MyYmKGw9YS5yZXNoYXBlKFt0LHIsbixvXSkpLG49PT0xfHxyPT09MT9sOmUuY29tcHV0ZShPZShsLElsLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfSxrbD0oZSx0KT0+e2xldCBuPVZnKGUuaW5wdXRzLHQpLHI9ZS5pbnB1dHNbMF0sbz1NZShlLmlucHV0cywxKSxhPU1lKGUuaW5wdXRzLDIpLHM9TWUoZS5pbnB1dHMsMyksZD1NZShlLmlucHV0cyw0KSxsPU1lKGUuaW5wdXRzLDUpLHA9TWUoZS5pbnB1dHMsNiksZj1NZShlLmlucHV0cyw3KTtpZihyLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgaD1vJiZhJiZvLmRpbXMubGVuZ3RoPT09NCYmYS5kaW1zLmxlbmd0aD09PTQseT1vcihlLG4uYmF0Y2hTaXplLG4ubnVtSGVhZHMsbi5zZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLHIscywwKTtpZihoKXJldHVybiBVdChlLHksbyxhLGQsdm9pZCAwLHAsZixsLG4pO2lmKCFvfHwhYSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IF89b3IoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4ua3ZTZXF1ZW5jZUxlbmd0aCxuLmhlYWRTaXplLG8scyxuLmhpZGRlblNpemUpLGI9b3IoZSxuLmJhdGNoU2l6ZSxuLm51bUhlYWRzLG4ua3ZTZXF1ZW5jZUxlbmd0aCxuLnZIZWFkU2l6ZSxhLHMsMipuLmhpZGRlblNpemUpO1V0KGUseSxfLGIsZCx2b2lkIDAscCxmLGwsbil9fSk7dmFyIExnLEdnLEhnLEZnLFRvLEVsLFBsLENvPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO0xnPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sR2c9KGUsdCk9PntsZXQgbj1bXSxyPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89Pm4ucHVzaChOdW1iZXIobykpKSxyPW4ubGVuZ3RoKSxyZSh7bnVtT3V0cHV0czpyLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6bn0pfSxIZz1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtLKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsRmc9ZT0+e2xldCB0PWUubGVuZ3RoLG49W107Zm9yKGxldCByPTA7cjx0Oysrcil7bGV0IG89ZVtyXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9uLnB1c2gobyk6cj09PTA/bi5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke3J9dSkgeyAke299IH1gKTpyPT09dC0xP24ucHVzaChgZWxzZSB7ICR7b30gfWApOm4ucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke3J9KSB7ICR7b30gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtuLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sVG89KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1FLnNpemUobiksbz1lWzBdLmRhdGFUeXBlLGE9RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxuLmxlbmd0aCkscz1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPVAoXCJpbnB1dFwiLG8sbi5sZW5ndGgpLGw9bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1bXSxmPVtdLGg9MCx5PVt7dHlwZToxMixkYXRhOnJ9XTtmb3IobGV0IGI9MDtiPHQubnVtT3V0cHV0cztiKyspe2grPXQuc3BsaXRTaXplc1tiXSxsW2JdPWg7bGV0IHc9bi5zbGljZSgpO3dbYV09dC5zcGxpdFNpemVzW2JdLGYucHVzaCh3KSxzW2JdPU4oYG91dHB1dCR7Yn1gLG8sdy5sZW5ndGgpLHAucHVzaCh7ZGltczpmW2JdLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX15LnB1c2goe3R5cGU6MTIsZGF0YTpsfSwuLi5IKG4sLi4uZikpO2xldCBfPWI9PmBcbiAgJHtiLnJlZ2lzdGVyVW5pZm9ybShcImlucHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzaXplX2luX3NwbGl0X2F4aXNcIixcInUzMlwiLGwubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGQsLi4ucyl9XG4gICR7SGcobC5sZW5ndGgpfVxuICAke0ZnKHMpfVxuXG4gICR7Yi5tYWluU3RhcnQoKX1cbiAgICAke2IuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLmlucHV0X3NpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5kZXggPSAke2QuaW5kaWNlc0dldChcImluZGljZXNcIixhKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtLKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixsLmxlbmd0aCl9O1xuICAgICAgJHtkLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsYSxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KX19LEVsPShlLHQpPT57TGcoZS5pbnB1dHMpO2xldCBuPWUuaW5wdXRzLmxlbmd0aD09PTE/dDpHZyhlLmlucHV0cyx0KTtlLmNvbXB1dGUoVG8oZS5pbnB1dHMsbikse2lucHV0czpbMF19KX0sUGw9ZT0+e2xldCB0PWUuYXhpcyxuPWUuc3BsaXRTaXplcyxyPWUubnVtT3V0cHV0czwwP24ubGVuZ3RoOmUubnVtT3V0cHV0cztpZihyIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiByZSh7YXhpczp0LG51bU91dHB1dHM6cixzcGxpdFNpemVzOm59KX19KTt2YXIgcWcsS2csemwsT2wsRGw9RygoKT0+e1widXNlIHN0cmljdFwiO0NlKCk7cXIoKTtTbygpO0NvKCk7Y3QoKTtxZz0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkpdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBRdWVycnlBdHRlbnRpb24gZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgbj1lWzBdLHI9ZVsxXSxvPWVbMl0sYT1lWzNdLHM9ZVs0XTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBkPSExLGw9bi5kaW1zWzBdLHA9bi5kaW1zWzFdLGY9bi5kaW1zLmxlbmd0aD09PTM/ZD9uLmRpbXNbMl0vMzpuLmRpbXNbMl06dC5udW1IZWFkcypuLmRpbXNbNF0saD1wLHk9MCxfPSFyfHxyLmRpbXMubGVuZ3RoPT09MCxiPU1hdGguZmxvb3IoXz9mLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTpmL3QubnVtSGVhZHMpO18mJihmPWIqdC5udW1IZWFkcyk7bGV0IHc9YSYmYS5kaW1zLmxlbmd0aCE9PTAsUz1zJiZzLmRpbXMubGVuZ3RoIT09MDtpZih3JiZhLmRpbXMubGVuZ3RoPT09NCYmYS5kaW1zWzBdPT09bCYmYS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZhLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmEuZGltc1szXT09PWIpdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHcmJlMpe2lmKGEuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYocy5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO3k9YS5kaW1zWzJdfWVsc2UgaWYod3x8Uyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IHY9MTtpZihyJiZyLmRpbXMubGVuZ3RoPjApe2lmKG4uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYoci5kaW1zLmxlbmd0aDwzfHxyLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYobi5kaW1zWzBdIT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihyLmRpbXMubGVuZ3RoPT09Myl7aWYobi5kaW1zWzJdJXIuZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO2g9ci5kaW1zWzFdfWVsc2UgaWYoci5kaW1zLmxlbmd0aD09PTUpe2lmKHIuZGltc1syXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PTJ8fHIuZGltc1s0XSE9PWIpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO2g9ci5kaW1zWzFdfWVsc2V7aWYoci5kaW1zWzFdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09Yil0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTtoPXIuZGltc1syXX19ZWxzZXtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKG4uZGltcy5sZW5ndGg9PT01JiYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7dj0zfWxldCBUPTAsQz0hMSxBPXQua3ZOdW1IZWFkcz9iKnQua3ZOdW1IZWFkczpmO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKGghPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYoaCE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxDPSEwfX1sZXQgaz1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKGsmJmsuZGltcy5sZW5ndGghPT0xJiZrLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO3JldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpwLHBhc3RTZXF1ZW5jZUxlbmd0aDp5LGt2U2VxdWVuY2VMZW5ndGg6aCx0b3RhbFNlcXVlbmNlTGVuZ3RoOi0xLG1heFNlcXVlbmNlTGVuZ3RoOi0xLGlucHV0SGlkZGVuU2l6ZTowLGhpZGRlblNpemU6Zix2SGlkZGVuU2l6ZTpBLGhlYWRTaXplOmIsdkhlYWRTaXplOk1hdGguZmxvb3IoQS90Lmt2TnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsa3ZOdW1IZWFkczp0Lmt2TnVtSGVhZHMsblJlcHM6dC5udW1IZWFkcy90Lmt2TnVtSGVhZHMscGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohMSxtYXNrVHlwZTpULHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6Qyxxa3ZGb3JtYXQ6dn19LEtnPXJlKHtwZXJtOlswLDIsMSwzXX0pLHpsPShlLHQsbik9PntsZXQgcj10LG89bi5rdk51bUhlYWRzO3JldHVybiB0LmRpbXMubGVuZ3RoPT09MyYmbi5rdlNlcXVlbmNlTGVuZ3RoIT09MCYmKHI9dC5yZXNoYXBlKFtuLmJhdGNoU2l6ZSxuLmt2U2VxdWVuY2VMZW5ndGgsbyxuLmhlYWRTaXplXSkscj1lLmNvbXB1dGUoT2UocixLZy5wZXJtKSx7aW5wdXRzOltyXSxvdXRwdXRzOlstMV19KVswXSkscn0sT2w9KGUsdCk9PntsZXQgbj1xZyhlLmlucHV0cyx0KTtpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7aWYoZS5pbnB1dHNbMV0/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCByPWUuaW5wdXRzWzBdLG89ZS5pbnB1dHNbMV0mJmUuaW5wdXRzWzFdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMV06dm9pZCAwLGE9ZS5pbnB1dHNbMl0mJmUuaW5wdXRzWzJdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMl06dm9pZCAwLHM9ZS5pbnB1dHNbM10mJmUuaW5wdXRzWzNdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1szXTp2b2lkIDAsZD1lLmlucHV0c1s0XSYmZS5pbnB1dHNbNF0uZGltcy5sZW5ndGghPT0wP2UuaW5wdXRzWzRdOnZvaWQgMCxsPWUuaW5wdXRzLmxlbmd0aD40P2UuaW5wdXRzWzVdOnZvaWQgMCxwPWUuaW5wdXRzLmxlbmd0aD41P2UuaW5wdXRzWzZdOnZvaWQgMCxmPW4ua3ZOdW1IZWFkcz9uLmt2TnVtSGVhZHM6bi5udW1IZWFkcyxoPXJlKHtheGlzOjIsbnVtT3V0cHV0czozLHNwbGl0U2l6ZXM6W24ubnVtSGVhZHMqbi5oZWFkU2l6ZSxmKm4uaGVhZFNpemUsZipuLmhlYWRTaXplXX0pLFt5LF8sYl09IW8mJiFhP2UuY29tcHV0ZShUbyhbcl0saCkse2lucHV0czpbcl0sb3V0cHV0czpbLTEsLTEsLTFdfSk6W3IsbyxhXSx3PW9yKGUsbi5iYXRjaFNpemUsbi5udW1IZWFkcyxuLnNlcXVlbmNlTGVuZ3RoLG4uaGVhZFNpemUseSx2b2lkIDAsMCk7VXQoZSx3LHpsKGUsXyxuKSx6bChlLGIsbiksdm9pZCAwLHZvaWQgMCxzLGQsdm9pZCAwLG4sbCxwKX19KTt2YXIgQmwsamcsWmcsTWwsUmw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjdCgpO2NlKCk7Qmw9KGUsdCxuLHIsbyxhLHMsZCk9PntsZXQgbD1nZShhKSxwPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYCxmPWw9PT0xP1widmVjMmZcIjpgbWF0Mngke2x9ZmAsaD1vKnMseT02NDtoPT09MSYmKHk9MjU2KTtsZXQgXz1bbyxzLGEvbF0sYj1bbyxzLDJdLHc9W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiXSxTPVtdO1MucHVzaCguLi5IKF8sYikpO2xldCAkPXY9PntsZXQgVD1QKFwieFwiLHQuZGF0YVR5cGUsMyxsKSxDPVAoXCJzY2FsZVwiLG4uZGF0YVR5cGUsbi5kaW1zKSxBPVAoXCJiaWFzXCIsci5kYXRhVHlwZSxyLmRpbXMpLGs9TihcIm91dHB1dFwiLDEsMywyKSxPPVtULEMsQSxrXTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQgOiBhcnJheTwke2Z9LCAke3l9PjtcbiAgY29uc3Qgd29ya2dyb3VwX3NpemUgPSAke3l9dTtcbiAgJHt2LmRlY2xhcmVWYXJpYWJsZXMoLi4uTyl9XG4gICR7di5tYWluU3RhcnQoeSl9XG4gICAgbGV0IGJhdGNoID0gd29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgY2hhbm5lbCA9IHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGhpZ2h0ID0gdW5pZm9ybXMueF9zaGFwZVsyXTtcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgc3VtID0gJHtwfSgwKTtcbiAgICB2YXIgc3F1YXJlZF9zdW0gPSAke3B9KDApO1xuICAgIGZvciAodmFyIGggPSBsb2NhbF9pZHg7IGggPCBoaWdodDsgaCArPSB3b3JrZ3JvdXBfc2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHtwfSgke1QuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9KTtcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIHNxdWFyZWRfc3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9ICR7Zn0oc3VtLCBzcXVhcmVkX3N1bSk7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBfc2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsX2lkeCA9PSAwKSB7XG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtLZShcIndvcmtncm91cF9zaGFyZWRbMF1bMF1cIixsKX0gLyBmMzIoaGlnaHQgKiAke2x9KTtcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7S2UoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG5cbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZH0pKTtcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xuICAgICAgbGV0IGNoYW5uZWxfc2hpZnQgPSBmMzIoYmlhc1tjaGFubmVsXSkgLSBzdW1fZmluYWwgKiBjaGFubmVsX3NjYWxlO1xuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH07JHtkfTske3l9YCxpbnB1dERlcGVuZGVuY2llczp3fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmIsZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6aH0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6JH0se2lucHV0czpbdCxuLHJdLG91dHB1dHM6Wy0xXX0pWzBdfSxqZz0oZSx0LG4pPT57bGV0IHI9dFswXS5kaW1zLG89cixhPTIscz1yWzBdLGQ9clsxXSxsPUUuc2l6ZUZyb21EaW1lbnNpb24ocixhKSxwPWdlKGwpLGY9RS5zaXplKG8pL3AsaD1CbChlLHRbMF0sdFsxXSx0WzJdLHMsbCxkLG4uZXBzaWxvbikseT1bcyxkLGwvcF0sXz1bcyxkXSxiPVtcInR5cGVcIixcIm5vbmVcIl0sdz1TPT57bGV0ICQ9UChcInhcIix0WzBdLmRhdGFUeXBlLHkubGVuZ3RoLHApLHY9UChcInNjYWxlX3NoaWZ0XCIsMSxfLmxlbmd0aCwyKSxUPU4oXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLHkubGVuZ3RoLHApLEM9WyQsdixUXTtyZXR1cm5gXG4gICR7Uy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uQyl9XG4gICR7Uy5tYWluU3RhcnQoKX1cbiAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtULm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgbGV0IGJhdGNoID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICAgIGxldCBjaGFubmVsID0gb3V0cHV0SW5kaWNlc1sxXTtcbiAgICAgIGxldCBzY2FsZV9zaGlmdCA9ICR7di5nZXRCeUluZGljZXMoXCJ2ZWMyPHUzMj4oYmF0Y2gsIGNoYW5uZWwpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7JC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9ICogJHtULnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtULnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtULnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOmJ9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZi82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpmfSwuLi5IKHksXyx5KV19KSxnZXRTaGFkZXJTb3VyY2U6d30se2lucHV0czpbdFswXSxoXX0pfSxaZz0oZSx0LG4pPT57bGV0IHI9dFswXS5kaW1zLG89cixhPXJbMF0scz1yW3IubGVuZ3RoLTFdLGQ9RS5zaXplRnJvbURpbWVuc2lvbihyLDEpL3MsbD1nZShzKSxwPUUuc2l6ZShvKS9sLGY9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKHMvbCl9XSxoPVtcInR5cGVcIixcInR5cGVcIl0seT0hMSxfPVswLHIubGVuZ3RoLTFdO2ZvcihsZXQgJD0wOyQ8ci5sZW5ndGgtMjskKyspeT15fHxyWyQrMV0hPT0xLF8ucHVzaCgkKzEpO3k9eSYmcltyLmxlbmd0aC0xXSE9PTE7bGV0IGI9eT9lLmNvbXB1dGUoT2UoZS5pbnB1dHNbMF0sXykse2lucHV0czpbZS5pbnB1dHNbMF1dLG91dHB1dHM6Wy0xXX0pWzBdOmUuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7bGVuZ3RoOnIubGVuZ3RofSwoJCx2KT0+cltfW3ZdXSkpLHc9QmwoZSxiLHRbMV0sdFsyXSxhLGQscyxuLmVwc2lsb24pLFM9JD0+e2xldCB2PV9lKHRbMF0uZGF0YVR5cGUpLFQ9bD09PTE/XCJ2ZWMyZlwiOmBtYXQke2x9eDJmYCxDPU89PntsZXQgTT1PPT09MD9cInhcIjpcInlcIixWPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYDtzd2l0Y2gobCl7Y2FzZSAxOnJldHVybmAke3Z9KCR7Vn0oc2NhbGUuJHtNfSkpYDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt2fT4oJHtWfShzY2FsZVswXS4ke019LCBzY2FsZVsxXS4ke019KSlgO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3Z9Pigke1Z9KHNjYWxlWzBdLiR7TX0sIHNjYWxlWzFdLiR7TX0sIHNjYWxlWzJdLiR7TX0sIHNjYWxlWzNdLiR7TX0pKWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7bH1gKX19LEE9UChcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsbCksaz1OKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxvLGwpO3JldHVybmBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7QS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7VH0+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7ay50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke0MoMCl9LCAke0MoMSl9KTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbk5IV0NcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6aH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6U30se2lucHV0czpbdFswXSx3XX0pfSxNbD0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/WmcoZSxlLmlucHV0cyx0KTpqZyhlLGUuaW5wdXRzLHQpfX0pO3ZhciBRZyxZZyxVbCxObD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO2NlKCk7UWc9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LFlnPShlLHQsbik9PntsZXQgcj10LnNpbXBsaWZpZWQsbz1lWzBdLmRpbXMsYT1lWzFdLHM9IXImJmVbMl0sZD1vLGw9RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxvLmxlbmd0aCkscD1FLnNpemVUb0RpbWVuc2lvbihvLGwpLGY9RS5zaXplRnJvbURpbWVuc2lvbihvLGwpLGg9RS5zaXplKGEuZGltcykseT1zP0Uuc2l6ZShzLmRpbXMpOjA7aWYoaCE9PWZ8fHMmJnkhPT1mKXRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7Zn0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke2h9IGFuZCBiaWFzIHNpemUgb2YgJHt5fWApO2xldCBfPVtdO2ZvcihsZXQgQT0wO0E8by5sZW5ndGg7KytBKUE8bD9fLnB1c2gob1tBXSk6Xy5wdXNoKDEpO2xldCBiPWdlKGYpLHc9W1widHlwZVwiLFwidHlwZVwiXSxTPVt7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEsZGF0YTpmfSx7dHlwZToxMixkYXRhOk1hdGguZmxvb3IoZi9iKX0se3R5cGU6MSxkYXRhOnQuZXBzaWxvbn1dO3MmJncucHVzaChcInR5cGVcIik7bGV0ICQ9bj4xLHY9bj4yLFQ9QT0+e2xldCBrPV9lKGVbMF0uZGF0YVR5cGUpLE89W1AoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsYiksUChcInNjYWxlXCIsYS5kYXRhVHlwZSxhLmRpbXMsYildO3MmJk8ucHVzaChQKFwiYmlhc1wiLHMuZGF0YVR5cGUscy5kaW1zLGIpKSxPLnB1c2goTihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZCxiKSksJCYmTy5wdXNoKE4oXCJtZWFuX2RhdGFfb3V0cHV0XCIsMSxfKSksdiYmTy5wdXNoKE4oXCJpbnZfc3RkX291dHB1dFwiLDEsXykpO2xldCBNPVt7bmFtZTpcIm5vcm1fY291bnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibm9ybV9zaXplXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZV92ZWN0b3JpemVkXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XTtyZXR1cm5gXG4gICR7QS5yZWdpc3RlclVuaWZvcm1zKE0pLmRlY2xhcmVWYXJpYWJsZXMoLi4uTyl9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm5vcm1fY291bnRcIil9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhbl92ZWN0b3IgPSAke3VvKFwiZjMyXCIsYil9O1xuICAgIHZhciBtZWFuX3NxdWFyZV92ZWN0b3IgPSAke3VvKFwiZjMyXCIsYil9O1xuXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaCsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke1B0KGssYixcInhbaCArIG9mZnNldF1cIil9O1xuICAgICAgbWVhbl92ZWN0b3IgKz0gdmFsdWU7XG4gICAgICBtZWFuX3NxdWFyZV92ZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IG1lYW4gPSAke0tlKFwibWVhbl92ZWN0b3JcIixiKX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XG4gICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtLZShcIm1lYW5fc3F1YXJlX3ZlY3RvclwiLGIpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZSAke3I/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke1B0KGssYixcInhbaiArIG9mZnNldF1cIil9O1xuICAgICAgbGV0IGYzMnNjYWxlID0gJHtQdChrLGIsXCJzY2FsZVtqXVwiKX07XG4gICAgICBvdXRwdXRbaiArIG9mZnNldF0gPSAke09bMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7cj9cIlwiOlwiLSBtZWFuXCJ9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHtzP2ArICR7UHQoayxiLFwiYmlhc1tqXVwiKX1gOlwiXCJ9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7JD9cIm1lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuXCI6XCJcIn07XG4gICAgJHt2P1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldlwiOlwiXCJ9O1xuICB9YH0sQz1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuICQmJkMucHVzaCh7ZGltczpfLGRhdGFUeXBlOjF9KSx2JiZDLnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSkse25hbWU6XCJMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHtifTske259OyR7cn1gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpDLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpUfX0sVWw9KGUsdCk9PntRZyhlLmlucHV0cyksZS5jb21wdXRlKFlnKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCkpfX0pO3ZhciBYZyxWbCxXbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7YWUoKTtYcigpO0pyKCk7WGc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSxWbD1lPT57WGcoZS5pbnB1dHMpO2xldCB0PXJ0LmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IG49dFt0Lmxlbmd0aC0xXSxyPWUuaW5wdXRzWzBdLmRpbXNbZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgtMV07aWYobjw4JiZyPDgpZS5jb21wdXRlKFlyKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKTtlbHNle2xldCBvPXRbdC5sZW5ndGgtMl0sYT1FLnNpemUoZS5pbnB1dHNbMF0uZGltcy5zbGljZSgwLC0yKSkscz1FLnNpemUoZS5pbnB1dHNbMV0uZGltcy5zbGljZSgwLC0yKSk7aWYoYSE9PTEmJm89PT0xJiZzPT09MSl7bGV0IGQ9ZS5pbnB1dHNbMF0ucmVzaGFwZShbMSxhLHJdKSxsPWUuaW5wdXRzWzFdLnJlc2hhcGUoWzEscixuXSkscD1bMSxhLG5dLGY9W2QsbF07ZS5jb21wdXRlKG5yKGYse2FjdGl2YXRpb246XCJcIn0sdCxwKSx7aW5wdXRzOmZ9KX1lbHNlIGUuY29tcHV0ZShucihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSl9fX0pO3ZhciBKZyxleSx0eSxMbCxHbCxIbD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtKZz0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0c1wiKTtsZXQgbj1lWzBdLHI9bi5kaW1zLmxlbmd0aDtpZihuLmRpbXNbci0xXSE9PXQuayl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWVcIik7bGV0IG89TWF0aC5mbG9vcigodC5rK3QuYmxvY2tTaXplLTEpL3QuYmxvY2tTaXplKSxhPXQuYmxvY2tTaXplLzgqdC5iaXRzLHM9ZVsxXTtpZighRS5hcmVFcXVhbChzLmRpbXMsW3QubixvLGFdKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemVcIik7bGV0IGw9ZVsyXS5kaW1zO2lmKEUuc2l6ZShsKSE9PXQubipvKXRocm93IG5ldyBFcnJvcihcInNjYWxlcyBpbnB1dCBzaXplIGVycm9yLlwiKTtpZihlLmxlbmd0aD09PTQpe2xldCBmPWVbM10uZGltcyxoPXQuYml0cz40P3QubipvOnQubipNYXRoLmZsb29yKChvKzEpLzIpO2lmKEUuc2l6ZShmKSE9PWgpdGhyb3cgbmV3IEVycm9yKFwiemVyb1BvaW50cyBpbnB1dCBzaXplIGVycm9yLlwiKX19LGV5PShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9bi5sZW5ndGgsbz1uW3ItMl0sYT10Lmsscz10Lm4sZD1uLnNsaWNlKDAsci0yKSxsPUUuc2l6ZShkKSxmPWVbMV0uZGltc1syXS80LGg9ZVswXS5kYXRhVHlwZSx5PWdlKHQuayksXz1nZShmKSxiPWdlKHMpLHc9ZC5jb25jYXQoW28sc10pLFM9bz4xJiZzL2IlMj09PTA/MjoxLCQ9RS5zaXplKHcpL2IvUyx2PTY0LFQ9W10sQz1bbCxvLGEveV0sQT1FLmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7QS5zcGxpY2UoLTEsMSxmL18pLFQucHVzaCguLi5IKEMpKSxULnB1c2goLi4uSChBKSksVC5wdXNoKC4uLkgoZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiZULnB1c2goLi4uSChFLmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IGs9W2wsbyxzL2JdO1QucHVzaCguLi5IKGspKTtsZXQgTz1NPT57bGV0IFY9Qy5sZW5ndGgsRj1QKFwiYVwiLGVbMF0uZGF0YVR5cGUsVix5KSxqPVAoXCJiXCIsMTIsQS5sZW5ndGgsXyksbmU9UChcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVz1bRixqLG5lXSxKPWUubGVuZ3RoPT09ND9QKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7SiYmVy5wdXNoKEopO2xldCB2ZT1rLmxlbmd0aCxRPU4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHZlLGIpLGVlPV9lKGVbMF0uZGF0YVR5cGUpLGxlPSgoKT0+e3N3aXRjaCh5KXtjYXNlIDE6cmV0dXJuYGFycmF5PCR7ZWV9LCA4PmA7Y2FzZSAyOnJldHVybmBtYXQ0eDI8JHtlZX0+YDtjYXNlIDQ6cmV0dXJuYG1hdDJ4NDwke2VlfT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke3l9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0pKCksWj0oKT0+e2xldCBTZT1gXG4gICAgICAgICAgLy8gcmV1c2UgYSBkYXRhXG4gICAgICAgICAgICB2YXIgaW5wdXRfb2Zmc2V0ID0gJHtGLmluZGljZXNUb09mZnNldChgJHtGLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgd29yZF9vZmZzZXQpYCl9O1xuICAgICAgICAgICAgdmFyIGFfZGF0YTogJHtsZX07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4L3l9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHtGLmdldEJ5T2Zmc2V0KFwiaW5wdXRfb2Zmc2V0XCIpfTtcbiAgICAgICAgICAgICAgaW5wdXRfb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtmb3IobGV0IEQ9MDtEPGIqUztEKyspU2UrPWBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke189PT0xP2BiJHtEfV9kYXRhYDpgYiR7RH1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke2xlfSgke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoUixZKT0+YCR7ZWV9KGJfdmFsdWVfbG93ZXJbJHtZfV0pLCAke2VlfShiX3ZhbHVlX3VwcGVyWyR7WX1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAke3k9PT0xP2Ake2xlfSgke0FycmF5LmZyb20oe2xlbmd0aDo4fSwoUixZKT0+YChiX3F1YW50aXplZF92YWx1ZXNbJHtZfV0gLSAke0o/YHplcm9fcG9pbnQke0R9YDpcInplcm9fcG9pbnRcIn0pICogc2NhbGUke0R9YCkuam9pbihcIiwgXCIpfSk7YDpgKGJfcXVhbnRpemVkX3ZhbHVlcyAtICR7bGV9KCR7QXJyYXkoOCkuZmlsbChgJHtKP2B6ZXJvX3BvaW50JHtEfWA6XCJ6ZXJvX3BvaW50XCJ9YCkuam9pbihcIixcIil9KSkgKiBzY2FsZSR7RH07YH07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke1N9ICsgJHtNYXRoLmZsb29yKEQvYil9XSR7Yj4xP2BbJHtEJWJ9XWA6XCJcIn0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6OC95fSwoUixZKT0+YCR7eT09PTE/YGFfZGF0YVske1l9XSAqIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7WX1dYDpgZG90KGFfZGF0YVske1l9XSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtZfV0pYH1gKS5qb2luKFwiICsgXCIpfTtcbiAgICAgICAgICBgO3JldHVybiBTZX0scGU9KCk9PntsZXQgU2U9YFxuICAgICAgICAgICAgdmFyIGNvbF9pbmRleCA9IGNvbCAqICR7Yn07XG4gICAgICAgICAgICAke0o/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuQmxvY2tzUGVyQ29sICsgMSkgLyAyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9jb3VudDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZF9pbmRleDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkOiB1MzI7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtlZX0oOCk7YH1cbiAgICAgICAgICAgIGA7Zm9yKGxldCBEPTA7RDxiKlM7RCsrKVNlKz1gXG4gICAgICAgICAgICBsZXQgc2NhbGUke0R9ID0gJHtuZS5nZXRCeU9mZnNldChcImNvbF9pbmRleCAqIG5CbG9ja3NQZXJDb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICAke0o/YFxuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX2NvdW50ID0gY29sX2luZGV4ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkX2luZGV4ID0gemVyb19wb2ludF9ieXRlX2NvdW50ID4+IDB4MnU7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmQgPSAke0ouZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCR7RH0gPSAke2VlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIFNlfSxrZT0oKT0+e2xldCBTZT1gY29sX2luZGV4ID0gY29sICogJHtifTtgO2ZvcihsZXQgRD0wO0Q8YipTO0QrKylTZSs9YFxuICAgICAgICAgICAgbGV0IGIke0R9X2RhdGEgPSAke2ouZ2V0QnlJbmRpY2VzKGAke2oudHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuIFNlKz1gXG4gICAgICAgICAgICB2YXIgYl92YWx1ZTogdTMyO1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfdXBwZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7bGV9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke2xlfTtgLFNlfTtyZXR1cm5gXG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQ6IGFycmF5PCR7US50eXBlLnZhbHVlfSwgJHtTKnZ9PjtcbiAgICAgICAgJHtNLmRlY2xhcmVWYXJpYWJsZXMoLi4uVyxRKX1cbiAgICAgICAgJHtNLm1haW5TdGFydChbdiwxLDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Eub2Zmc2V0VG9JbmRpY2VzKGAoZ2xvYmFsX2lkeCAvICR7dn0pICogJHtTfWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuQmxvY2tzUGVyQ29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcblxuICAgICAgICAgIGZvciAodmFyIGJsb2NrID0gbG9jYWxfaWQueDsgYmxvY2sgPCBuQmxvY2tzUGVyQ29sOyBibG9jayArPSAke3Z9KSB7XG4gICAgICAgICAgICAvL3Byb2Nlc3Mgb25lIGJsb2NrXG4gICAgICAgICAgICB2YXIgd29yZF9vZmZzZXQ6IHUzMiA9IGJsb2NrICogJHt0LmJsb2NrU2l6ZS95fTtcbiAgICAgICAgICAgICR7cGUoKX1cbiAgICAgICAgICAgIGZvciAodmFyIHdvcmQ6IHUzMiA9IDA7IHdvcmQgPCAke2Z9OyB3b3JkICs9ICR7X30pIHtcbiAgICAgICAgICAgICAgJHtrZSgpfVxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtffTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgJHtaKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L3l9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHtTfSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtRLnR5cGUudmFsdWV9ID0gJHtRLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3Z9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHtTfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7US5zZXRCeUluZGljZXMoYCR7US50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCxcIm91dHB1dF92YWx1ZVwiKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJNYXRNdWxOQml0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3QuYml0c307JHt5fTske199OyR7Yn07JHtTfTske3Z9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dyxkYXRhVHlwZTpofV0sZGlzcGF0Y2hHcm91cDp7eDokfSxwcm9ncmFtVW5pZm9ybXM6VH0pLGdldFNoYWRlclNvdXJjZTpPfX0sdHk9KGUsdCk9PntsZXQgbj1lWzBdLmRpbXMscj1uLmxlbmd0aCxvPW5bci0yXSxhPXQuayxzPXQubixkPW4uc2xpY2UoMCxyLTIpLGw9RS5zaXplKGQpLGY9ZVsxXS5kaW1zWzJdLzQsaD1lWzBdLmRhdGFUeXBlLHk9Z2UodC5rKSxfPWdlKGYpLGI9ZC5jb25jYXQoW28sc10pLHc9MTI4LFM9cyU4PT09MD84OnMlND09PTA/NDoxLCQ9dy9TLHY9JCpfKjgsVD12L3ksQz12L3QuYmxvY2tTaXplLEE9RS5zaXplKGIpL1Msaz1bXSxPPVtsLG8sYS95XSxNPUUuY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtNLnNwbGljZSgtMSwxLGYvXyksay5wdXNoKC4uLkgoTykpLGsucHVzaCguLi5IKE0pKSxrLnB1c2goLi4uSChlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJmsucHVzaCguLi5IKEUuY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgVj1bbCxvLHNdO2sucHVzaCguLi5IKFYpKTtsZXQgRj1qPT57bGV0IG5lPU8ubGVuZ3RoLFc9UChcImFcIixlWzBdLmRhdGFUeXBlLG5lLHkpLEo9UChcImJcIiwxMixNLmxlbmd0aCxfKSx2ZT1QKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxRPVtXLEosdmVdLGVlPWUubGVuZ3RoPT09ND9QKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7ZWUmJlEucHVzaChlZSk7bGV0IGxlPVYubGVuZ3RoLFo9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbGUpLHBlPV9lKGVbMF0uZGF0YVR5cGUpLGtlPSgpPT57c3dpdGNoKHkpe2Nhc2UgMTpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7cGV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke3BlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke3BlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtwZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHt5fS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Vy50eXBlLnZhbHVlfSwgJHtUfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7Wi50eXBlLnZhbHVlfSwgJHskfT4sICR7U30+O1xuICAgICAgICAke2ouZGVjbGFyZVZhcmlhYmxlcyguLi5RLFopfVxuICAgICAgICAke2oubWFpblN0YXJ0KFskLFMsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7Wi5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7U31gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtDfSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke1R9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtUfTsgYV9vZmZzZXQgKz0gJHt3fSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vy5nZXRCeUluZGljZXMoYCR7Vy50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1cudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtDfSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke2VlP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBiX3JvdyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7ZWUuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7cGV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtwZX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7dmUuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtKLmdldEJ5SW5kaWNlcyhgJHtKLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL3l9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAke2tlKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtfPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7cGV9Pigke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoU2UsRCk9PmAke3BlfShiX3ZhbHVlX2xvd2VyWyR7RH1dKSwgJHtwZX0oYl92YWx1ZV91cHBlclske0R9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke3BlfT4oJHtBcnJheSg4KS5maWxsKFwiemVyb19wb2ludFwiKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjJ9LChTZSxEKT0+YCR7YGRvdChhX2RhdGEke0R9LCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske0R9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgveX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7U30pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7Wi50eXBlLnZhbHVlfSA9ICR7Wi50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwdTsgYiA8ICR7JH07IGIrKykge1xuICAgICAgICAgICAgICBvdXRwdXRfdmFsdWUgKz0gaW50ZXJfcmVzdWx0c1tsb2NhbF9pZHhdW2JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbCArIGxvY2FsX2lkeCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsyXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJHtaLnNldEJ5SW5kaWNlcyhgJHtaLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWR4KWAsXCJvdXRwdXRfdmFsdWVcIil9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJCbG9ja3dpc2VNYXRNdWxOQml0czMyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7eX07JHtffTskeyR9OyR7U31gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpiLGRhdGFUeXBlOmh9XSxkaXNwYXRjaEdyb3VwOnt4OkF9LHByb2dyYW1Vbmlmb3JtczprfSksZ2V0U2hhZGVyU291cmNlOkZ9fSxMbD0oZSx0KT0+e0pnKGUuaW5wdXRzLHQpLHQuYmxvY2tTaXplPT09MzImJmUuYWRhcHRlckluZm8uaXNWZW5kb3IoXCJpbnRlbFwiKSYmZS5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZShcImdlbi0xMmxwXCIpP2UuY29tcHV0ZSh0eShlLmlucHV0cyx0KSk6ZS5jb21wdXRlKGV5KGUuaW5wdXRzLHQpKX0sR2w9ZT0+cmUoZSl9KTt2YXIgcnksbnksb3ksaXksYXksc3ksdXksZHksRmwscWw9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtjZSgpO3J5PWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LG55PShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtLKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0soXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgIHZhbHVlID0gJHtlLnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke3J9XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgfSxveT0oZSx0LG4pPT57bGV0IHI9XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKXIrPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0soXCJ1bmlmb3Jtcy5wYWRzXCIsbyxuKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkgLSAxKTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7SyhcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke3J9XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LGl5PShlLHQsbik9PntsZXQgcj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pcis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7SyhcInVuaWZvcm1zLnBhZHNcIixvLG4pfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayA9IGkzMigke0soXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtLKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sYXk9KGUsdCxuKT0+e2xldCByPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbylyKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtLKFwidW5pZm9ybXMucGFkc1wiLG8sbil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7SyhcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtLKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtLKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7cn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sc3k9KGUsdCxuKT0+e3N3aXRjaChuLm1vZGUpe2Nhc2UgMDpyZXR1cm4gbnkoZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMTpyZXR1cm4gb3koZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMjpyZXR1cm4gaXkoZSx0LG4ucGFkcy5sZW5ndGgpO2Nhc2UgMzpyZXR1cm4gYXkoZSx0LG4ucGFkcy5sZW5ndGgpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sdXk9KGUsdCk9PntsZXQgbj1FLnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcykscj1lWzBdLmRpbXMsbz1FLnNpemUobiksYT1be3R5cGU6MTIsZGF0YTpvfSx7dHlwZTo2LGRhdGE6dC5wYWRzfV0scz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhO3QubW9kZT09PTAmJmEucHVzaCh7dHlwZTpzP2VbMl0uZGF0YVR5cGU6MSxkYXRhOnQudmFsdWV9KSxhLnB1c2goLi4uSChlWzBdLmRpbXMsbikpO2xldCBkPVtcInJhbmtcIl0sbD1wPT57bGV0IGY9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbi5sZW5ndGgpLGg9UChcInhcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSx5PWgudHlwZS52YWx1ZSxfPXN5KGYsci5sZW5ndGgsdCksYj1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofV07cmV0dXJuIHQubW9kZT09PTAmJmIucHVzaCh7bmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsdHlwZTpzP3k6XCJmMzJcIn0pLGBcbiAgICAgICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKGIpLmRlY2xhcmVWYXJpYWJsZXMoaCxmKX1cbiAgICAgICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHtmLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke3l9KDApO1xuICAgICAgICAgICAgJHtffVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QubW9kZX0ke3N9YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEUuc2l6ZShuKS82NCl9LHByb2dyYW1Vbmlmb3JtczphfSksZ2V0U2hhZGVyU291cmNlOmx9fSxkeT0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCBuPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLHI9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmRhdGFUeXBlPT09MTA/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOmVbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxvPWVbMF0uZGltcy5sZW5ndGgsYT1uZXcgSW50MzJBcnJheSgyKm8pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBkPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgbD0wO2w8ZC5sZW5ndGg7bCsrKWFbTnVtYmVyKGRbbF0pXT1OdW1iZXIobltsXSksYVtOdW1iZXIoZFtsXSkrb109TnVtYmVyKG5bbCtkLmxlbmd0aF0pfWVsc2Ugbi5mb3JFYWNoKChkLGwpPT5hW051bWJlcihsKV09TnVtYmVyKGQpKTtsZXQgcz1bXTtyZXR1cm4gYS5mb3JFYWNoKGQ9PnMucHVzaChkKSkse21vZGU6dC5tb2RlLHZhbHVlOnIscGFkczpzfX1lbHNlIHJldHVybiB0fSxGbD0oZSx0KT0+e3J5KGUuaW5wdXRzKTtsZXQgbj1keShlLmlucHV0cyx0KTtlLmNvbXB1dGUodXkoZS5pbnB1dHMsbikse2lucHV0czpbMF19KX19KTt2YXIgcm4sS2wsamwsWmwsUWwsbHksY3ksWWwsWGwsSmwsZWMsdGMscmMsbmMsb2MsaWMsYWMsc2MsdWMsZGM9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7dGUoKTthZSgpO2NlKCk7cm49ZT0+e2lmKHdlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmKCFlfHxlLmxlbmd0aCE9PTEpKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxLbD0oZSx0LG4pPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixvPWUuZGltcy5zbGljZSgpO3ImJm8uc3BsaWNlKDEsMCxvLnBvcCgpKTtsZXQgYT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLHM9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGQ9dC5zdHJpZGVzLnNsaWNlKCksbD1hP3QuZGlsYXRpb25zLnNsaWNlKCk6W10scD10LnBhZHMuc2xpY2UoKTtrdC5hZGp1c3RQb29sQXR0cmlidXRlcyhuLG8scyxkLGwscCk7bGV0IGY9a3QuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShuLG8sZCxsLHMscCx0LmF1dG9QYWQpLGg9T2JqZWN0LmFzc2lnbih7fSx0KTthP09iamVjdC5hc3NpZ24oaCx7a2VybmVsU2hhcGU6cyxzdHJpZGVzOmQscGFkczpwLGRpbGF0aW9uczpsLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKGgse2tlcm5lbFNoYXBlOnMsc3RyaWRlczpkLHBhZHM6cCxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IHk9Zi5zbGljZSgpO3JldHVybiB5LnB1c2goeS5zcGxpY2UoMSwxKVswXSksW2gscj95OmZdfSxqbD0oZSx0KT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIscj1FLnNpemUoZSksbz1FLnNpemUodC5rZXJuZWxTaGFwZSksYT1be3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm99XSxzPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZD10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLGw9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0scD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLGY9dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0saD0hIShwK2YpO2EucHVzaCh7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOmZ9KSxzLnB1c2goe25hbWU6XCJrd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd1N0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3RW5kXCIsdHlwZTpcInUzMlwifSk7bGV0IHk9ITE7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgXz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTJdLGI9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMl0sdz10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTJdLFM9dC5wYWRzW3QucGFkcy5sZW5ndGgtMl07eT0hISh3K1MpLGEucHVzaCh7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6Yn0se3R5cGU6MTIsZGF0YTp3fSx7dHlwZToxMixkYXRhOlN9KSxzLnB1c2goe25hbWU6XCJraFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaFN0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoRW5kXCIsdHlwZTpcInUzMlwifSl9cmV0dXJuW2EscywhMCxoLHldfWVsc2V7aWYobil0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IGQ9RS5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKTthLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOnQucGFkc30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9KSxzLnB1c2goe25hbWU6XCJrZXJuZWxTdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpkLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9KTtsZXQgbD10LnBhZHMucmVkdWNlKChwLGYpPT5wK2YpO3JldHVyblthLHMsISFsLCExLCExXX19LFpsPShlLHQsbixyLG8sYSxzLGQsbCxwLGYsaCk9PntsZXQgeT1vLmZvcm1hdD09PVwiTkhXQ1wiLF89dC50eXBlLnZhbHVlLGI9TihcIm91dHB1dFwiLHQudHlwZS50ZW5zb3Iscik7aWYoby5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCB3PVwiXCIsUz1cIlwiLCQ9XCJcIix2PW4tKHk/MjoxKTtpZihmP3c9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske3Z9XSA8IDAgfHwgeEluZGljZXNbJHt2fV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7dn1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2F9XG4gICAgICAgICAgICAgICAgfWA6dz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3Z9XSA9IGluZGljZXNbJHt2fV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgICAgICB9YCxvLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBDPW4tKHk/MzoyKTtoP1M9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtDfV0gPSBpbmRpY2VzWyR7Q31dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske0N9XSA8IDAgfHwgeEluZGljZXNbJHtDfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske0N9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA6Uz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske0N9XSA9IGluZGljZXNbJHtDfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGAsJD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LGIpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtiLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke1N9XG4gICAgICAgICAgICAgICR7d31cbiAgICAgICAgICAgICAgJHskfVxuICAgICAgICAgICAgICAke3N9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH1lbHNle2lmKHkpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCB3PW8ua2VybmVsU2hhcGUubGVuZ3RoLFM9by5wYWRzLmxlbmd0aCwkPVwiXCI7cmV0dXJuIHA/JD1gXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IHVuaWZvcm1zLnhfc2hhcGVbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICR7YX1cbiAgICAgICAgICAgICAgfWA6JD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgJHthfVxuICAgICAgICAgICAgYCxgXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhsKS5kZWNsYXJlVmFyaWFibGVzKHQsYil9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7Yi5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHtiLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7d30+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7dy0xfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7SyhcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIix3KX07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7SyhcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIix3KX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHt3LTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7bi13fXU7IGogPCAke259dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke0soXCJ1bmlmb3Jtcy5zdHJpZGVzXCIsYGogLSAke24td311YCx3KX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke24td311XSAtICR7SyhcInVuaWZvcm1zLnBhZHNcIixcImogLSAydVwiLFMpfTtcbiAgICAgICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3N9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH19LFFsPWU9PmAke2UuZm9ybWF0fTske2UuY2VpbE1vZGV9OyR7ZS5hdXRvUGFkfTske2Uua2VybmVsU2hhcGUubGVuZ3RofWAsbHk9ZT0+YCR7UWwoZSl9OyR7ZS5jb3VudEluY2x1ZGVQYWR9YCxjeT1lPT5gJHtRbChlKX07JHtlLnN0b3JhZ2VPcmRlcn07JHtlLmRpbGF0aW9uc31gLFlsPWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLFhsPShlLHQsbixyKT0+e2xldFtvLGFdPUtsKHQscixuKSxzPVAoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxkPXMudHlwZS52YWx1ZSxsPVwidmFsdWUgKz0geF92YWw7XCIscD1cIlwiO28uY291bnRJbmNsdWRlUGFkP3ArPWB2YWx1ZSAvPSAke2R9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A6cCs9YHZhbHVlIC89ICR7ZH0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO2xldFtmLGgseSxfLGJdPWpsKGEsbyk7Zi5wdXNoKC4uLkgodC5kaW1zLGEpKTtsZXQgdz1bXCJyYW5rXCJdO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7ci5jYWNoZUtleX07JHt5fTske199OyR7Yn1gLGlucHV0RGVwZW5kZW5jaWVzOnd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoRS5zaXplKGEpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmZ9KSxnZXRTaGFkZXJTb3VyY2U6Uz0+WmwoUyxzLHQuZGltcy5sZW5ndGgsYS5sZW5ndGgsbyxsLHAsMCxoLHksXyxiKX19LEpsPWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxuPVlsKGUpO2lmKG4uY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7bGV0IHI9e2NvdW50SW5jbHVkZVBhZDp0LC4uLm4sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLnIsY2FjaGVLZXk6bHkocil9fSxlYz0oZSx0KT0+e3JuKGUuaW5wdXRzKSxlLmNvbXB1dGUoWGwoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sdGM9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdfSxyYz1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLnRjLGNhY2hlS2V5OnR9fSxuYz0oZSx0KT0+e3JuKGUuaW5wdXRzKSxlLmNvbXB1dGUoWGwoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0sb2M9KGUsdCxuLHIpPT57bGV0W28sYV09S2wodCxyLG4pLHM9YFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgLGQ9XCJcIixsPVAoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxwPVtcInJhbmtcIl0sW2YsaCx5LF8sYl09amwoYSxvKTtyZXR1cm4gZi5wdXNoKC4uLkgodC5kaW1zLGEpKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke3IuY2FjaGVLZXl9OyR7eX07JHtffTske2J9YCxpbnB1dERlcGVuZGVuY2llczpwfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEUuc2l6ZShhKS82NCl9LHByb2dyYW1Vbmlmb3JtczpmfSksZ2V0U2hhZGVyU291cmNlOnc9PlpsKHcsbCx0LmRpbXMubGVuZ3RoLGEubGVuZ3RoLG8scyxkLHQuZGF0YVR5cGU9PT0xMD8tNjU1MDQ6LTFlNSxoLHksXyxiKX19LGljPShlLHQpPT57cm4oZS5pbnB1dHMpLGUuY29tcHV0ZShvYyhcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LGFjPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIsbj1lLmRpbGF0aW9ucyxyPVlsKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtsZXQgbz17c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOm4sLi4ucixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ubyxjYWNoZUtleTpjeShvKX19LHNjPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4udGMsY2FjaGVLZXk6dH19LHVjPShlLHQpPT57cm4oZS5pbnB1dHMpLGUuY29tcHV0ZShvYyhcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIG15LGZ5LGxjLGNjLHBjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO215PShlLHQpPT57aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJEZXF1YW50aXplTGluZWFyIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsxXS5kaW1zPT09ZVsyXS5kaW1zKXRocm93IG5ldyBFcnJvcihcIngtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMF0uZGF0YVR5cGU9PT02JiZlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkluIHRoZSBjYXNlIG9mIGRlcXVhbnRpemluZyBpbnQzMiB0aGVyZSBpcyBubyB6ZXJvIHBvaW50LlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MCYmZVsxXS5kaW1zLmxlbmd0aCE9PTEmJmVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGlucHV0IG11c3QgYmUgYSBzY2FsYXIsIGEgMUQgdGVuc29yLCBvciBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvci5cIik7aWYoZS5sZW5ndGg+Mil7aWYoZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuay5cIik7aWYoIWVbMV0uZGltcy5tYXAoKG4scik9Pm49PT1lWzJdLmRpbXNbcl0pLnJlZHVjZSgobixyKT0+biYmciwhMCkpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS5cIil9aWYodC5ibG9ja1NpemU+MCl7aWYoZVsxXS5kaW1zLmxlbmd0aD09PTB8fGVbMV0uZGltcy5sZW5ndGg9PT0xJiZlWzFdLmRpbXNbMF09PT0xKXRocm93IG5ldyBFcnJvcihcImJsb2NrU2l6ZSBtdXN0IGJlIHNldCBvbmx5IGZvciBibG9jayBxdWFudGl6YXRpb24uXCIpO2lmKCFlWzFdLmRpbXMubWFwKChvLGEpPT5hPT09dC5heGlzfHxvPT09ZVswXS5kaW1zW2FdKS5yZWR1Y2UoKG8sYSk9Pm8mJmEsITApKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24sIHNjYWxlIGlucHV0IHNoYXBlIHRvIG1hdGNoIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgZm9yIHRoZSBheGlzXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24gdGhlIHNjYWxlIGlucHV0IHJhbmsgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgeCByYW5rLlwiKTtsZXQgbj1lWzBdLmRpbXNbdC5heGlzXSxyPWVbMV0uZGltc1t0LmF4aXNdO2lmKHQuYmxvY2tTaXplPE1hdGguY2VpbChuL3IpfHx0LmJsb2NrU2l6ZT5NYXRoLmNlaWwobi8oci0xKS0xKSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSB3aXRoIGluIHRoZSByYW5nZSBbY2VpbChkSSAvIFNpKSwgY2VpbChkSSAvIChTaSAtIDEpIC0gMSldLlwiKX19LGZ5PShlLHQpPT57bGV0IG49RS5ub3JtYWxpemVBeGlzKHQuYXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxyPWVbMF0uZGF0YVR5cGUsbz1yPT09MyxhPWVbMF0uZGltcyxzPWVbMV0uZGF0YVR5cGUsZD1FLnNpemUoYSksbD1yPT09M3x8cj09PTIscD1sP1tNYXRoLmNlaWwoRS5zaXplKGVbMF0uZGltcykvNCldOmVbMF0uZGltcyxmPWVbMV0uZGltcyxoPWUubGVuZ3RoPjI/ZVsyXTp2b2lkIDAseT1oP2w/W01hdGguY2VpbChFLnNpemUoaC5kaW1zKS80KV06aC5kaW1zOnZvaWQgMCxfPWYubGVuZ3RoPT09MHx8Zi5sZW5ndGg9PT0xJiZmWzBdPT09MSxiPV89PT0hMSYmZi5sZW5ndGg9PT0xLHc9Z2UoZCksUz1fJiYoIWx8fHc9PT00KSwkPVM/dzoxLHY9UyYmIWw/dzoxLFQ9UChcImlucHV0XCIsbD8xMjpyLHAubGVuZ3RoLHYpLEM9UChcInNjYWxlXCIscyxmLmxlbmd0aCksQT1oP1AoXCJ6ZXJvX3BvaW50XCIsbD8xMjpyLHkubGVuZ3RoKTp2b2lkIDAsaz1OKFwib3V0cHV0XCIscyxhLmxlbmd0aCwkKSxPPVtULENdO0EmJk8ucHVzaChBKTtsZXQgTT1bcCxmXTtoJiZNLnB1c2goeSk7bGV0IFY9W3t0eXBlOjEyLGRhdGE6ZC8kfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6dC5ibG9ja1NpemV9LC4uLkgoLi4uTSxhKV0sRj1qPT57bGV0IG5lPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImF4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICR7ai5yZWdpc3RlclVuaWZvcm1zKG5lKS5kZWNsYXJlVmFyaWFibGVzKC4uLk8sayl9XG4gICAgICAke2oubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHtqLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2sub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAvLyBTZXQgaW5wdXQgeFxuICAgICAgICAgICR7bD9gXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke1QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4IC8gNFwiKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KGlucHV0KVwiOlwidW5wYWNrNHhVOChpbnB1dClcIn07XG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7JD09PTE/XCJ4X3ZlY1tnbG9iYWxfaWR4ICUgNF1cIjpcInhfdmVjXCJ9O2A6YGxldCB4X3ZhbHVlID0gJHtULmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07YH07XG5cbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcbiAgICAgICAgICAke18/YGxldCBzY2FsZV92YWx1ZT0gJHtDLmdldEJ5T2Zmc2V0KFwiMFwiKX1gOmI/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7Qy5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke0MudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtDLmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke0MuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtDLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2B9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAke0E/Xz9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7QS5nZXRCeU9mZnNldChcIjBcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlPSB6ZXJvX3BvaW50X3ZlY1swXWA6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX1gOmI/bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXggLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggJSA0XWA6YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4XCIpfTtgOmw/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X29mZnNldCA9ICR7Qy5pbmRpY2VzVG9PZmZzZXQoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbnB1dCA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfb2Zmc2V0ICUgNF07YDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07YDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke2w/bz9cImkzMlwiOlwidTMyXCI6VC50eXBlLnZhbHVlfSgwKTtgfTtcbiAgICAgIC8vIENvbXB1dGUgYW5kIHdyaXRlIG91dHB1dFxuICAgICAgJHtrLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGAke2sudHlwZS52YWx1ZX0oeF92YWx1ZSAtIHplcm9fcG9pbnRfdmFsdWUpICogc2NhbGVfdmFsdWVgKX07XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJEZXF1YW50aXplTGluZWFyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpBP1tcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOkYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOnN9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLyQvNjQpLHk6MSx6OjF9LHByb2dyYW1Vbmlmb3JtczpWfSl9fSxsYz0oZSx0KT0+e215KGUuaW5wdXRzLHQpLGUuY29tcHV0ZShmeShlLmlucHV0cyx0KSl9LGNjPWU9PnJlKHtheGlzOmUuYXhpcyxibG9ja1NpemU6ZS5ibG9ja1NpemV9KX0pO3ZhciBoeSxneSxtYyxmYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTt0ZSgpO2NlKCk7aHk9KGUsdCxuKT0+e2xldCByPWU9PT10LG89ZTx0JiZuPDAsYT1lPnQmJm4+MDtpZihyfHxvfHxhKXRocm93IG5ldyBFcnJvcihcIlJhbmdlIHRoZXNlIGlucHV0cycgY29udGVudHMgYXJlIGludmFsaWQuXCIpfSxneT0oZSx0LG4scik9PntsZXQgbz1NYXRoLmFicyhNYXRoLmNlaWwoKHQtZSkvbikpLGE9W29dLHM9byxkPVt7dHlwZToxMixkYXRhOnN9LHt0eXBlOnIsZGF0YTplfSx7dHlwZTpyLGRhdGE6bn0sLi4uSChhKV0sbD1wPT57bGV0IGY9TihcIm91dHB1dFwiLHIsYS5sZW5ndGgpLGg9Zi50eXBlLnZhbHVlLHk9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydFwiLHR5cGU6aH0se25hbWU6XCJkZWx0YVwiLHR5cGU6aH1dO3JldHVybmBcbiAgICAgICAgJHtwLnJlZ2lzdGVyVW5pZm9ybXMoeSkuZGVjbGFyZVZhcmlhYmxlcyhmKX1cbiAgICAgICAgJHtwLm1haW5TdGFydCgpfVxuICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHVuaWZvcm1zLnN0YXJ0ICsgJHtofShnbG9iYWxfaWR4KSAqIHVuaWZvcm1zLmRlbHRhO1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiUmFuZ2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyfWB9LGdldFNoYWRlclNvdXJjZTpsLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpyfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocy82NCl9LHByb2dyYW1Vbmlmb3JtczpkfSl9fSxtYz1lPT57bGV0IHQ9MCxuPTAscj0wO2UuaW5wdXRzWzBdLmRhdGFUeXBlPT09Nj8odD1lLmlucHV0c1swXS5nZXRJbnQzMkFycmF5KClbMF0sbj1lLmlucHV0c1sxXS5nZXRJbnQzMkFycmF5KClbMF0scj1lLmlucHV0c1syXS5nZXRJbnQzMkFycmF5KClbMF0pOmUuaW5wdXRzWzBdLmRhdGFUeXBlPT09MSYmKHQ9ZS5pbnB1dHNbMF0uZ2V0RmxvYXQzMkFycmF5KClbMF0sbj1lLmlucHV0c1sxXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdKSx3ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJmh5KHQsbixyKSxlLmNvbXB1dGUoZ3kodCxuLHIsZS5pbnB1dHNbMF0uZGF0YVR5cGUpLHtpbnB1dHM6W119KX19KTt2YXIgeXksYnksaGMsZ2MseWM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7eXk9KGUsdCxuLHIpPT57aWYoZSE9PVwibm9uZVwiJiZyIT09XCJpMzJcIiYmciE9PVwidTMyXCImJnIhPT1cImYzMlwiKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtyfSBpcyBub3Qgc3VwcG9ydGVkIHdpdGggcmVkdWN0aW9uICR7ZX0uYCk7bGV0IG89YHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSAwO1xuICAgICAgICAgICAgICAgIGxvb3Age1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlRjMyID1gLGE9YDtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGJpdGNhc3Q8aTMyPihuZXdWYWx1ZUYzMik7XG4gICAgICAgICAgICAgICAgICBsZXQgcmVzID0gYXRvbWljQ29tcGFyZUV4Y2hhbmdlV2VhaygmJHt0fSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIGlmIHJlcy5leGNoYW5nZWQge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gcmVzLm9sZF92YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1gO3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuYCR7dH09JHtufTtgO2Nhc2VcImFkZFwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY0FkZCgmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgXG4gICAgICAgICAgICAgICR7b31iaXRjYXN0PCR7cn0+KG9sZFZhbHVlKSArICgke259KSR7YX1gO2Nhc2VcIm1heFwiOnJldHVybiByPT09XCJpMzJcInx8cj09PVwidTMyXCI/YGF0b21pY01heCgmJHt0fSwgYml0Y2FzdDwke3J9Pigke259KSk7YDpgXG4gICAgICAgICAgICAgICAgJHtvfW1heChiaXRjYXN0PGYzMj4ob2xkVmFsdWUpLCAoJHtufSkpJHthfWA7Y2FzZVwibWluXCI6cmV0dXJuIHI9PT1cImkzMlwifHxyPT09XCJ1MzJcIj9gYXRvbWljTWluKCYke3R9LCBiaXRjYXN0PCR7cn0+KCR7bn0pKTtgOmAke299bWluKGJpdGNhc3Q8JHtyfT4ob2xkVmFsdWUpLCAoJHtufSkpJHthfWA7Y2FzZVwibXVsXCI6cmV0dXJuYCR7b30oYml0Y2FzdDwke3J9PihvbGRWYWx1ZSkgKiAoJHtufSkpJHthfWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFJlZHVjdGlvbiAke2V9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxieT0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPWVbMV0uZGltcyxvPW4sYT0xLHM9TWF0aC5jZWlsKEUuc2l6ZShyKS9hKSxkPXJbci5sZW5ndGgtMV0sbD1FLnNpemVGcm9tRGltZW5zaW9uKG4sZCkscD1be3R5cGU6MTIsZGF0YTpzfSx7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH0sLi4uSChlWzFdLmRpbXMsZVsyXS5kaW1zLG8pXSxmPWg9PntsZXQgeT1QKFwiaW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksXz1QKFwidXBkYXRlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxhKSxiPXQucmVkdWN0aW9uIT09XCJub25lXCImJnQucmVkdWN0aW9uIT09XCJcIj9IcyhcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgpOk4oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLGEpO3JldHVybmBcbiAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImxhc3RfaW5kZXhfZGltZW5zaW9uXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibnVtX3VwZGF0ZXNfZWxlbWVudHNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHksXyxiKX1cbiAgICAgICR7aC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgdmFyIGhhc0R1cGxpY2F0ZXMgPSBmYWxzZTtcbiAgaWYgKCR7dC5yZWR1Y3Rpb249PT1cIm5vbmVcIn0pIHtcbiAgICBsZXQgbiA9ICR7RS5zaXplKHIpfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkgPSBpICsgMSkge1xuICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbjsgaiA9IGogKyAxKSB7XG4gICAgICAgIHZhciBpbmRleF9pID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgICAgIHZhciBpbmRleF9qID0gaTMyKGluZGljZXNbal0ueCk7XG4gICAgICAgIGlmIChpbmRleF9pID09IGluZGV4X2opIHtcbiAgICAgICAgICBoYXNEdXBsaWNhdGVzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc0R1cGxpY2F0ZXMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRhdGFfb2Zmc2V0ID0gMHU7XG4gIHZhciBpbmRpY2VzX3N0YXJ0ID0gdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb24gKiBnbG9iYWxfaWR4O1xuICBpZiAoJHt0LnJlZHVjdGlvbj09PVwibm9uZVwifSAmJiBoYXNEdXBsaWNhdGVzKSB7XG4gICAgaWYgKGdsb2JhbF9pZHggIT0gMHUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5kaWNlc19zdGFydCA9IDB1O1xuICB9XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uXTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7eXkodC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIixiLnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHMvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTpmfX0saGM9ZT0+cmUoe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLGdjPShlLHQpPT57ZS5jb21wdXRlKGJ5KGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIF95LHd5LHZ5LGJjLCR5LHh5LFN5LFR5LEN5LEl5LEF5LGt5LF9jLEV5LFB5LHp5LE95LER5LHdjLHZjLCRjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Q2UoKTtjZSgpO195PShlLHQpPT57aWYoZS5ldmVyeShuPT5uPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSx3eT0oZSx0LG4pPT57dC5ldmVyeShvPT5vPj0wJiZvPG58fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IHI9bmV3IEFycmF5KG4pLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxhKT0+cltvXT1lW2FdKSxyfSx2eT0oZSx0LG4scixvLGEpPT57bGV0W3MsZCxsXT1uPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKHM+MCYmZS5sZW5ndGg+cyYmZVtzXS5kaW1zLmxlbmd0aD4wKWVbc10uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChmPT5hLnB1c2goZikpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPT09MSYmZVtkXS5kaW1zWzBdPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChmPT5yLnB1c2goZikpLHIubGVuZ3RoIT09MCYmci5sZW5ndGghPT1wJiZuPj0xOCYmci5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7X3kocix0KSx0LmF4ZXMubGVuZ3RoPjAmJnd5KHIsdC5heGVzLHApLmZvckVhY2goKGYsaCk9PnJbaF09Zil9aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPT09MSYmZVtsXS5kaW1zWzBdPjAmJihlW2xdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKGY9Pm8ucHVzaChOdW1iZXIoZikpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09cCYmbj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYoci5sZW5ndGghPT0wJiZyLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgcjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJnIubGVuZ3RoPjAmJm8ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sYmM9KGUsdCxuLHIpPT5gXG4gIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgbGV0IGJpZyA9ICgke2V9KSAqICgke3R9KTtcbiAgbGV0IHdob2xlID0gJHtyfShiaWcgLyAoJHtufSkpO1xuICBsZXQgZnJhY3QgPSAke3J9KGJpZyAlICgke259KSkgLyAke3J9KCR7bn0pO1xuICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbmAsJHk9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYFxuICAgICAgICAgIGlmICh4U2NhbGUgPCAxLjAgfHwgZmxvb3IoeFNjYWxlKSAhPSB4U2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHtiYyhcInhSZXNpemVkXCIsXCJsZW5ndGhPcmlnaW5hbFwiLFwibGVuZ3RoUmVzaXplZFwiLHQpfVxuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJweXRvcmNoX2hhbGZfcGl4ZWxcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpIC0gMC41O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2hhbGZfcGl4ZWxfZm9yX25uXCI6cmV0dXJuYHJldHVybiAoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpO2A7Y2FzZVwiYWxpZ25fY29ybmVyc1wiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAke2JjKFwieFJlc2l6ZWRcIixcImxlbmd0aE9yaWdpbmFsIC0gMVwiLFwibGVuZ3RoUmVzaXplZCAtIDFcIix0KX1cbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLHh5PShlLHQsbik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke259LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7bn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsU3k9KGUsdCxuKT0+e2xldCByPW5ldyBBcnJheShuKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkobikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/cjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoYSxzKT0+e3JbYV09b1tzXSxyW3Mrbl09b1t0Lmxlbmd0aCtzXX0pLHIpOm99LFR5PShlLHQsbixyKT0+e2xldCBvPVtdO2lmKG4ubGVuZ3RoPjApaWYoci5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGE9Pm8ucHVzaChhKSksTWF0aC5tYXgoLi4ucik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7ci5mb3JFYWNoKChhLHMpPT5vW2FdPW5bc10pfWVsc2Ugbi5mb3JFYWNoKGE9Pm8ucHVzaChhKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGEscyk9Pk1hdGgucm91bmQoYSp0W3NdKSl9cmV0dXJuIG99LEN5PShlLHQsbik9PntsZXQgcj0oKCk9Pntzd2l0Y2gobi5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gbi5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLm4uYXhlcy5tYXAoYT0+dFthXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiBuLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4ubi5heGVzLm1hcChhPT50W2FdKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtuLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiBuLmF4ZXMubGVuZ3RoPjA/KG4uYXhlcy5mb3JFYWNoKGE9PnRbYV09ciksbi5heGVzLmZvckVhY2goYT0+b1thXT1NYXRoLnJvdW5kKGVbYV0qdFthXSkpKToodC5maWxsKHIsMCx0Lmxlbmd0aCksby5mb3JFYWNoKChhLHMpPT5vW3NdPU1hdGgucm91bmQoYSp0W3NdKSkpLG99LEl5PShlLHQsbixyLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7bi5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke24ubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke24ubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtLKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIscil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7SyhcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7SyhcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7SyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0soXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxBeT0oZSx0LG4scixvLGEscyk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtLKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke0soXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixhKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7SyhcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtuLmxlbmd0aH1gLGEpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7SyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0soXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHtzfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gLGt5PShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcImlucHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7SyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWAsX2M9KGUsdCxuLHIpPT5lLnJhbms+cj9gXG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdCxcImNoYW5uZWxcIil9O1xuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLG4sXCJiYXRjaFwiKX07XG5gOlwiXCIsRXk9KGUsdCxuLHIsbyk9PntsZXRbcyxkLGwscF09bi5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOlswLDIsMywxXSxmPWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHtmfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKHJvdywgJHtuW2RdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGwsYG1heCgwLCBtaW4oY29sLCAke25bbF19IC0gMSkpYCl9O1xuICAgICAgJHtfYyhlLHAscywyKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtmfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIHJvdzoke2Z9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGNvbDoke2Z9ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgJHtyP2BpZiAocm93IDwgMCB8fCByb3cgPiAoJHtuW2RdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7bltsXX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgIH1gOlwiXCJ9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7bltkXX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtuW2xdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7bi5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3B9XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7bi5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3N9XSlgOlwiMFwifTtcbiAgICAgIHZhciB4MTE6ICR7Zn0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7Zn0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7Zn0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7Zn0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7Zn0gPSBhYnMocm93IC0gJHtmfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke2Z9ID0gYWJzKCR7Zn0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHtmfSA9IGFicyhjb2wgLSAke2Z9KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7Zn0gPSBhYnMoJHtmfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YH0sUHk9KGUsdCxuLHIsbyxhLHMsZCxsLHApPT57bGV0IGY9bi5sZW5ndGg9PT0yLGg9ITAsW3ksX109Zj9bMCwxXTpoP1syLDNdOlsxLDJdLGI9ZS50eXBlLnZhbHVlLHc9Uz0+e2xldCAkPVM9PT15P1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXG4gICAgICBmbiAkeyR9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7Yn0ge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFMpfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke2J9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtvW1NdfSxcbiAgICAgICAgJHtyW1NdfSwgJHtuW1NdfSwgJHthW1NdfSwgJHthW1NdfSArICR7bi5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7Yn0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7ZH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke25bU119IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7bH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7Yn0sIDQ+ID0gYXJyYXk8JHtifSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHskfTogJHtifSA9IG9yaWdpbmFsSWR4ICsgJHtifShpKTtcbiAgICAgICAgICBpZiAoJHskfSA8IDAgfHwgJHskfSA+PSAke25bU119KSB7XG4gICAgICAgICAgICAke3A/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6ZD9gcmV0dXJuICR7bH07YDpgJHskfSA9IG1heCgwLCBtaW4oJHskfSwgJHtuW1NdfSAtIDEpKTtgfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLFMsYHUzMigkeyR9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7Uz09PXk/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHt3KHkpfTtcbiAgICAke3coXyl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke2J9KSAtPiBhcnJheTwke2J9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHtifSwgND4gPSBhcnJheTwke2J9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7Yn0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7Yn0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHtifSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke3N9ICogb25lUGx1c0Fic1MgLSA1ICogJHtzfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke3N9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7c307XG4gICAgY29lZmZzWzFdID0gKCgke3N9ICsgMikgKiBhYnNTIC0gKCR7c30gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke3N9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHtzfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke3N9ICogdHdvTWludXNBYnNTIC0gNSAqICR7c30pICogdHdvTWludXNBYnNTICsgOCAqICR7c30pICogdHdvTWludXNBYnNTIC0gNCAqICR7c307XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7Yn0sIDQ+LCBjb2VmczogYXJyYXk8JHtifSwgND4pIC0+ICR7Yn0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHtifSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtifSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSx6eT0oZSx0LG4scixvKT0+e2xldFtzLGQsbCxwLGZdPW4ubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLGg9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHtofSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKGRlcHRoLCAke25bZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihoZWlnaHQsICR7bltsXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKHdpZHRoLCAke25bcF19IC0gMSkpYCl9O1xuICAgICAgJHtfYyhlLGYscywzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7aH0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke2h9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGhlaWdodDoke2h9ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgdmFyIHdpZHRoOiR7aH0gPSBvcmlnaW5hbEluZGljZXNbJHtwfV07XG4gICAgICAke3I/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtuW2RdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7bltsXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtuW3BdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7bltkXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtuW2xdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtuW3BdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtuLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7Zn1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtuLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7c31dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7aH0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHtofSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke2h9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHtofSA9IGFicyhkZXB0aCAtICR7aH0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke2h9ID0gYWJzKCR7aH0oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7aH0gPSBhYnMoaGVpZ2h0IC0gJHtofShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke2h9ID0gYWJzKCR7aH0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHtofSA9IGFicyh3aWR0aCAtICR7aH0od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke2h9ID0gYWJzKCR7aH0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxPeT0oZSx0LG4scixvLGEpPT57bGV0IHM9ZS5kaW1zLGQ9U3koYSx0LmF4ZXMscy5sZW5ndGgpLGw9VHkocyxyLG8sdC5heGVzKSxwPXIuc2xpY2UoKTtyLmxlbmd0aD09PTAmJihwPXMubWFwKCh2LFQpPT52PT09MD8xOmxbVF0vdiksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKGw9Q3kocyxwLHQpKSk7bGV0IGY9TihcIm91dHB1dFwiLGUuZGF0YVR5cGUsbC5sZW5ndGgpLGg9UChcImlucHV0XCIsZS5kYXRhVHlwZSxzLmxlbmd0aCkseT1FLnNpemUobCksXz1zLmxlbmd0aD09PWwubGVuZ3RoJiZzLmV2ZXJ5KCh2LFQpPT52PT09bFtUXSksYj10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIix3PXQuZXh0cmFwb2xhdGlvblZhbHVlLFM9aC50eXBlLnZhbHVlLCQ9dj0+YFxuICAgICAgJHtfP1wiXCI6YFxuICAgICAgJHskeSh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLFMpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtreShoLHMpfTtcbiAgICAgICAgICAgICAgJHt4eSh0Lm5lYXJlc3RNb2RlLG4sUyl9O1xuICAgICAgICAgICAgICAke0F5KGgsZixzLGwscC5sZW5ndGgsZC5sZW5ndGgsYil9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtJeShmLHMsbCxwLmxlbmd0aCxkLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKHMubGVuZ3RoPT09Mnx8cy5sZW5ndGg9PT00KXJldHVybmAke0V5KGgsZixzLGIsdyl9YDtpZihzLmxlbmd0aD09PTN8fHMubGVuZ3RoPT09NSlyZXR1cm5gJHt6eShoLGYscyxiLHcpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYocy5sZW5ndGg9PT0yfHxzLmxlbmd0aD09PTQpcmV0dXJuYCR7UHkoaCxmLHMsbCxwLGQsdC5jdWJpY0NvZWZmQSxiLHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7di5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIscC5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsZC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoaCxmKX1cbiAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHtfP1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2Yub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2gudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2guZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3MubGVuZ3RoPT09Mnx8cy5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtufXwke3AubGVuZ3RoPjA/dC5tb2RlPT09XCJjdWJpY1wiP3A6cC5sZW5ndGg6XCJcIn18JHtvLmxlbmd0aD4wP286XCJcIn18JHtkLmxlbmd0aD4wP2Q6XCJcIn18JHtffXwke3QubW9kZT09PVwibmVhcmVzdFwiP3MubGVuZ3RoOnN9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6JCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MSxkYXRhOnB9LHt0eXBlOjEsZGF0YTpkfSwuLi5IKHMsbCldfSl9fSxEeT1lPT57bGV0IHQ9ZS5jdXN0b21EYXRhQnVmZmVyO3JldHVybiBuZXcgVWludDMyQXJyYXkodCx0LmJ5dGVPZmZzZXQsMSlbMF19LHdjPShlLHQpPT57bGV0IG49W10scj1bXSxvPVtdLGE9RHkoZSk7aWYodC5hbnRpYWxpYXMhPT0wKXRocm93IEVycm9yKFwiT25seSBkZWZhdWx0IHZhbHVlICgwKSBmb3IgQW50aWFsaWFzIGF0dHJpYnV0ZSBpcyBzdXBwb3J0ZWRcIik7dnkoZS5pbnB1dHMsdCxhLG4scixvKSxlLmNvbXB1dGUoT3koZS5pbnB1dHNbMF0sdCxhLG4scixvKSx7aW5wdXRzOlswXX0pfSx2Yz1lPT57bGV0IHQ9ZS5hbnRpYWxpYXMsbj1lLmF4ZXMscj1lLmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLG89ZS5jdWJpY0NvZWZmQSxhPWUuZXhjbHVkZU91dHNpZGUhPT0wLHM9ZS5leHRyYXBvbGF0aW9uVmFsdWUsZD1lLmtlZXBBc3BlY3RSYXRpb1BvbGljeSxsPWUubW9kZSxwPWUubmVhcmVzdE1vZGU9PT1cIlwiP1wic2ltcGxlXCI6ZS5uZWFyZXN0TW9kZTtyZXR1cm4gcmUoe2FudGlhbGlhczp0LGF4ZXM6bixjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpyLGN1YmljQ29lZmZBOm8sZXhjbHVkZU91dHNpZGU6YSxleHRyYXBvbGF0aW9uVmFsdWU6cyxrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6ZCxtb2RlOmwsbmVhcmVzdE1vZGU6cH0pfX0pO3ZhciBCeSxNeSx4YyxTYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTthZSgpO0NlKCk7Y2UoKTtCeT0oZSx0KT0+e2xldFtuLHIsbyxhXT1lLHtudW1IZWFkczpzLHJvdGFyeUVtYmVkZGluZ0RpbTpkfT10O2lmKG4uZGltcy5sZW5ndGghPT0zJiZuLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICd4JyBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zLCBnb3QgJHtuLmRpbXMubGVuZ3RofWApO2lmKCFFLmFyZUVxdWFsKHIuZGltcyxbXSkmJiFFLmFyZUVxdWFsKHIuZGltcyxbMV0pJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMCwgMSwgb3IgMiBkaW1lbnNpb25zLCBnb3QgJHtyLmRpbXMubGVuZ3RofWApO2lmKG8uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke28uZGltcy5sZW5ndGh9YCk7aWYoYS5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnc2luX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7YS5kaW1zLmxlbmd0aH1gKTtpZighRS5hcmVFcXVhbChvLmRpbXMsYS5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dHMgJ2Nvc19jYWNoZScgYW5kICdzaW5fY2FjaGUnIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2lmKGQ+MCYmcz09PTApdGhyb3cgbmV3IEVycm9yKFwibnVtX2hlYWRzIG11c3QgYmUgcHJvdmlkZWQgaWYgcm90YXJ5X2VtYmVkZGluZ19kaW0gaXMgc3BlY2lmaWVkXCIpO2xldCBsPW4uZGltc1swXSxwPW4uZGltc1tuLmRpbXMubGVuZ3RoLTJdLGY9by5kaW1zWzBdLGg9RS5zaXplRnJvbURpbWVuc2lvbihuLmRpbXMsMSkvcCx5PWQ9PT0wP28uZGltc1sxXSoyOmgvcztpZihkPnkpdGhyb3cgbmV3IEVycm9yKFwicm90YXJ5X2VtYmVkZGluZ19kaW0gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGVhZF9zaXplXCIpO2lmKHIuZGltcy5sZW5ndGg9PT0yKXtpZihsIT09ci5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDAgc2hvdWxkIGJlIG9mIHNpemUgYmF0Y2hfc2l6ZSwgZ290ICR7ci5kaW1zWzBdfWApO2lmKHAhPT1yLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgb2Ygc2l6ZSBzZXF1ZW5jZV9sZW5ndGgsIGdvdCAke3IuZGltc1sxXX1gKX1pZih5LzIhPT1vLmRpbXNbMV0mJmQvMiE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBzYW1lIGFzIGhlYWRfc2l6ZSAvIDIgb3Igcm90YXJ5X2VtYmVkZGluZ19kaW0gLyAyLCBnb3QgJHtvLmRpbXNbMV19YCk7aWYocD5mKXRocm93IG5ldyBFcnJvcihcIlVwZGF0aW5nIGNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGluIFJvdGFyeUVtYmVkZGluZyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiKX0sTXk9KGUsdCk9PntsZXR7aW50ZXJsZWF2ZWQ6bixudW1IZWFkczpyLHJvdGFyeUVtYmVkZGluZ0RpbTpvLHNjYWxlOmF9PXQscz1lWzBdLmRpbXNbMF0sZD1FLnNpemVGcm9tRGltZW5zaW9uKGVbMF0uZGltcywxKSxsPWVbMF0uZGltc1tlWzBdLmRpbXMubGVuZ3RoLTJdLHA9ZC9sLGY9ZVsyXS5kaW1zWzFdLGg9bz09PTA/ZioyOnAvcix5PW5ldyBBcnJheShzLGwscC9oLGgtZiksXz1FLmNvbXB1dGVTdHJpZGVzKHkpLGI9W3t0eXBlOjEsZGF0YTphfSx7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6X30sLi4uZVswXS5kaW1zLmxlbmd0aD09PTM/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2QscCxoLDFdfSk6W10sLi4uZVswXS5kaW1zLmxlbmd0aD09PTQ/bmV3IEFycmF5KHt0eXBlOjEyLGRhdGE6W2QsaCxsKmgsMV19KTpbXSwuLi5IKGVbMF0uZGltcyxlWzFdLmRpbXMsZVsyXS5kaW1zLGVbM10uZGltcyxlWzBdLmRpbXMpXSx3PVM9PntsZXQgJD1QKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHY9UChcInBvc2l0aW9uX2lkc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksVD1QKFwiY29zX2NhY2hlXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxDPVAoXCJzaW5fY2FjaGVcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcy5sZW5ndGgpLEE9TihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCk7cmV0dXJuIFMucmVnaXN0ZXJVbmlmb3Jtcyhbe25hbWU6XCJzY2FsZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJnbG9iYWxfc2hhcGVcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnkubGVuZ3RofSx7bmFtZTpcImdsb2JhbF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH0se25hbWU6XCJpbnB1dF9vdXRwdXRfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9XSksYFxuICAgICAgICAke1MuZGVjbGFyZVZhcmlhYmxlcygkLHYsVCxDLEEpfVxuXG4gICAgICAgICR7Uy5tYWluU3RhcnQoRXQpfVxuICAgICAgICAgIGxldCBoYWxmX3JvdGFyeV9lbWJfZGltID0gdW5pZm9ybXMuJHtULm5hbWV9X3NoYXBlWzFdO1xuICAgICAgICAgIGxldCBic25oID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzICUgdW5pZm9ybXMuZ2xvYmFsX3NoYXBlO1xuICAgICAgICAgIGxldCBzaXplID0gdW5pZm9ybXMuZ2xvYmFsX3NoYXBlWzBdICogdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXNbMF07XG4gICAgICAgICAgJHtTLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJzaXplXCIpfVxuXG4gICAgICAgICAgaWYgKGJzbmhbM10gPCBoYWxmX3JvdGFyeV9lbWJfZGltKSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWRzX2lkeCA9XG4gICAgICAgICAgICAgICAgJHt2LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwiYnNuaC54eVwiLE4oXCJcIix2LnR5cGUudGVuc29yLDIpKX07XG4gICAgICAgICAgICBsZXQgcG9zaXRpb25faWQgPVxuICAgICAgICAgICAgICAgIHUzMigke3YuZ2V0QnlPZmZzZXQoXCJwb3NpdGlvbl9pZHNfaWR4XCIpfSkgKyBzZWxlY3QoMCwgYnNuaFsxXSwgcG9zaXRpb25faWRzX2lkeCA9PSAwKTtcbiAgICAgICAgICAgIGxldCBpID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIHNlbGVjdCgwLCBic25oWzNdLCAke259KTtcbiAgICAgICAgICAgIGxldCBqID0gaSArIHNlbGVjdChoYWxmX3JvdGFyeV9lbWJfZGltLCAxLCAke259KTtcbiAgICAgICAgICAgIGxldCByZSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSAtXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke0MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwiaVwiLFwicmVcIil9XG4gICAgICAgICAgICBsZXQgaW0gPSAkeyQuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7Qy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gK1xuICAgICAgICAgICAgICAgICR7JC5nZXRCeU9mZnNldChcImpcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImpcIixcImltXCIpfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgayA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBoYWxmX3JvdGFyeV9lbWJfZGltO1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwia1wiLCQuZ2V0QnlPZmZzZXQoXCJrXCIpKX1cbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJvdGFyeUVtYmVkZGluZ1wiLHNoYWRlckNhY2hlOntoaW50OnJlKHtpbnRlcmxlYXZlZDpufSkuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOncsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEUuc2l6ZSh5KS9FdCl9LHByb2dyYW1Vbmlmb3JtczpifSl9fSx4Yz0oZSx0KT0+e0J5KGUuaW5wdXRzLHQpLGUuY29tcHV0ZShNeShlLmlucHV0cyx0KSl9fSk7dmFyIFJ5LFV5LFRjLENjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtSeT1lPT57aWYoIWV8fGUubGVuZ3RoPDMpdGhyb3cgbmV3IEVycm9yKFwibGF5ZXJOb3JtIHJlcXVpcmVzIGF0IGxlYXN0IDMgaW5wdXRzLlwiKTtsZXQgdD1lWzBdLG49ZVsxXSxyPWVbMl07aWYodC5kYXRhVHlwZSE9PW4uZGF0YVR5cGV8fHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIkFsbCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZVwiKTtpZih0LmRpbXMubGVuZ3RoIT09MyYmdC5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSAyRCBvciAzRFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MyYmbi5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGJlIDJEIG9yIDNEXCIpO2xldCBvPXQuZGltc1t0LmRpbXMubGVuZ3RoLTFdLGE9dC5kaW1zW3QuZGltcy5sZW5ndGgtMl07aWYobi5kaW1zW24uZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTJdIT09YSl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBzZXF1ZW5jZSBsZW5ndGggYXMgaW5wdXRcIik7aWYoci5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBiZSAxRFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiR2FtbWEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpO2lmKGUubGVuZ3RoPjMpe2xldCBzPWVbM107aWYocy5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGJlIDFEXCIpO2lmKHMuZGltc1tzLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX1pZihlLmxlbmd0aD40KXtsZXQgcz1lWzRdO2lmKHMuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBiZSAxRFwiKTtpZihzLmRpbXNbcy5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9fSxVeT0oZSx0LG4scik9PntsZXQgbz10LnNpbXBsaWZpZWQsYT1lWzBdLmRpbXMscz1FLnNpemUoYSksZD1hLGw9cyxwPWEuc2xpY2UoLTEpWzBdLGY9cj9hLnNsaWNlKDAsLTEpLmNvbmNhdCgxKTpbXSxoPSFvJiZlLmxlbmd0aD4zLHk9ZS5sZW5ndGg+NCxfPXImJm4+MSxiPXImJm4+Mix3PW4+MyxTPTY0LCQ9Z2UocCksdj1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MSxkYXRhOnQuZXBzaWxvbn1dLFQ9QT0+e2xldCBrPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImNvbXBvbmVudHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZXBzaWxvblwiLHR5cGU6XCJmMzJcIn1dLE89W1AoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsJCksUChcInNraXBcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcywkKSxQKFwiZ2FtbWFcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcywkKV07aCYmTy5wdXNoKFAoXCJiZXRhXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMsJCkpLHkmJk8ucHVzaChQKFwiYmlhc1wiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLCQpKSxPLnB1c2goTihcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZCwkKSksXyYmTy5wdXNoKE4oXCJtZWFuX291dHB1dFwiLDEsZikpLGImJk8ucHVzaChOKFwiaW52X3N0ZF9vdXRwdXRcIiwxLGYpKSx3JiZPLnB1c2goTihcImlucHV0X3NraXBfYmlhc19zdW1cIixlWzBdLmRhdGFUeXBlLGQsJCkpO2xldCBNPV9lKGVbMF0uZGF0YVR5cGUpLFY9X2UoMSwkKTtyZXR1cm5gXG5cbiAgICAgICR7QS5yZWdpc3RlclVuaWZvcm1zKGspLmRlY2xhcmVWYXJpYWJsZXMoLi4uTyl9XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc2hhcmVkIDogYXJyYXk8JHtWfSwgJHtTfT47XG4gICAgICB2YXI8d29ya2dyb3VwPiBzdW1fc3F1YXJlZF9zaGFyZWQgOiBhcnJheTwke1Z9LCAke1N9PjtcblxuICAgICAgJHtBLm1haW5TdGFydChbUywxLDFdKX1cbiAgICAgICAgbGV0IGl4ID0gbG9jYWxfaWQueDtcbiAgICAgICAgbGV0IGl5ID0gZ2xvYmFsX2lkLnggLyAke1N9O1xuXG4gICAgICAgIGxldCBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkOiB1MzIgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSAvIHVuaWZvcm1zLmNvbXBvbmVudHM7XG4gICAgICAgIHZhciBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC8gJHtTfTtcbiAgICAgICAgbGV0IG9mZnNldCA9IGl4ICogc3RyaWRlICsgaXkgKiBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkO1xuICAgICAgICBsZXQgb2Zmc2V0MWQgPSBzdHJpZGUgKiBpeDtcbiAgICAgICAgaWYgKGl4ID09ICR7Uy0xfSkge1xuICAgICAgICAgIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLSBzdHJpZGUgKiBpeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBsZXQgc2tpcF92YWx1ZSA9IHNraXBbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IGJpYXNfdmFsdWUgPSAke3k/XCJiaWFzW29mZnNldDFkICsgaV1cIjpNK1wiKDAuMClcIn07XG4gICAgICAgICAgbGV0IGlucHV0X3ZhbHVlID0geFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbnB1dF92YWx1ZSArIHNraXBfdmFsdWUgKyBiaWFzX3ZhbHVlO1xuICAgICAgICAgICR7dz9cImlucHV0X3NraXBfYmlhc19zdW1bb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcIjpcIlwifVxuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHZhbHVlO1xuICAgICAgICAgIGxldCBmMzJfdmFsdWUgPSAke1B0KE0sJCxcInZhbHVlXCIpfTtcbiAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBmMzJfdmFsdWU7XG4gICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBmMzJfdmFsdWUgKiBmMzJfdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2Vfc2l6ZSA6IHUzMiA9ICR7U307XG4gICAgICAgIGZvciAodmFyIGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDE7ICBjdXJyX3NpemUgPiAwOyBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlX3NpemUgPSBjdXJyX3NpemUgKyAocmVkdWNlX3NpemUgJiAxKTtcbiAgICAgICAgICBpZiAoaXggPCBjdXJyX3NpemUpIHtcbiAgICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IHN1bV9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IHN1bV9zcXVhcmVkX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN1bSA9IHN1bV9zaGFyZWRbMF07XG4gICAgICAgIGxldCBzcXVhcmVfc3VtID0gc3VtX3NxdWFyZWRfc2hhcmVkWzBdO1xuICAgICAgICBsZXQgbWVhbiA9ICR7S2UoXCJzdW1cIiwkKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpO1xuICAgICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydCgke0tlKFwic3F1YXJlX3N1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgJHtvP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG4gICAgICAgICR7Xz9cIm1lYW5fb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhbjtcIjpcIlwifVxuICAgICAgICAke2I/XCJpbnZfc3RkX291dHB1dFtnbG9iYWxfaWR4XSA9IGludl9zdGRfZGV2O1wiOlwiXCJ9XG5cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gKG91dHB1dFtvZmZzZXQgKyBpXSAke28/XCJcIjpgLSAke019KG1lYW4pYH0pICpcbiAgICAgICAgICAgICR7TX0oaW52X3N0ZF9kZXYpICogZ2FtbWFbb2Zmc2V0MWQgKyBpXVxuICAgICAgICAgICAgJHtoP1wiKyBiZXRhW29mZnNldDFkICsgaV1cIjpcIlwifTtcbiAgICAgICAgfVxuICAgICAgfWB9LEM9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiBuPjEmJkMucHVzaCh7ZGltczpmLGRhdGFUeXBlOjF9KSxuPjImJkMucHVzaCh7ZGltczpmLGRhdGFUeXBlOjF9KSxuPjMmJkMucHVzaCh7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KSx7bmFtZTpcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHskfTske199OyR7Yn07JHt3fWAsaW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKEEsayk9PlwidHlwZVwiKX0sZ2V0U2hhZGVyU291cmNlOlQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOkMsZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC9wKX0scHJvZ3JhbVVuaWZvcm1zOnZ9KX19LFRjPShlLHQpPT57UnkoZS5pbnB1dHMpO2xldCByPVswXTtlLm91dHB1dENvdW50PjEmJnIucHVzaCgtMyksZS5vdXRwdXRDb3VudD4yJiZyLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MyYmci5wdXNoKDMpLGUuY29tcHV0ZShVeShlLmlucHV0cyx0LGUub3V0cHV0Q291bnQsITEpLHtvdXRwdXRzOnJ9KX19KTt2YXIgTnksbm4sVnksSWMsV3ksTHksQWMsa2MsRWM9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2NlKCk7Tnk9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtpZih0LmF4ZXMubGVuZ3RoIT09MCl7aWYodC5heGVzLmxlbmd0aCE9PXQuc3RhcnRzLmxlbmd0aHx8dC5heGVzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcywgc3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIil9ZWxzZSBpZih0LnN0YXJ0cy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpO2Uuc2xpY2UoMSkuZm9yRWFjaCgobixyKT0+e2lmKGVbcisxXS5kYXRhVHlwZSE9PTYmJmVbcisxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3J9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKX0pfSxubj0oZSx0KT0+e2xldCBuPVtdO2lmKGUubGVuZ3RoPnQpaWYoZVt0XS5kYXRhVHlwZT09PTcpZVt0XS5nZXRCaWdJbnQ2NEFycmF5KCkuZm9yRWFjaChyPT5uLnB1c2goTnVtYmVyKHIpKSk7ZWxzZSBpZihlW3RdLmRhdGFUeXBlPT09NillW3RdLmdldEludDMyQXJyYXkoKS5mb3JFYWNoKHI9Pm4ucHVzaChOdW1iZXIocikpKTtlbHNlIHRocm93IG5ldyBFcnJvcihgSW5wdXQgJHt0fSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCk7cmV0dXJuIG59LFZ5PShlLHQpPT57aWYoZS5sZW5ndGg+MSl7bGV0IG49bm4oZSwxKSxyPW5uKGUsMiksbz1ubihlLDMpO3JldHVybiBvLmxlbmd0aD09PTAmJihvPVsuLi5BcnJheShlWzBdLmRpbXMubGVuZ3RoKS5rZXlzKCldKSxyZSh7c3RhcnRzOm4sZW5kczpyLGF4ZXM6b30pfWVsc2UgcmV0dXJuIHR9LEljPShlLHQsbixyLG8pPT57bGV0IGE9ZTtyZXR1cm4gZTwwJiYoYSs9bltyW3RdXSksb1t0XTwwP01hdGgubWF4KDAsTWF0aC5taW4oYSxuW3JbdF1dLTEpKTpNYXRoLm1heCgwLE1hdGgubWluKGEsbltyW3RdXSkpfSxXeT0oZSx0LG4pPT5gZm4gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICB2YXIgY2FycnkgPSAwdTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gJHtuLmxlbmd0aH07IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgaW5wdXRfc2hhcGVfaSA9ICR7SyhcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsbi5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGVwc19pID0gJHtLKFwidW5pZm9ybXMuc3RlcHNcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHNpZ25zX2kgPSAke0soXCJ1bmlmb3Jtcy5zaWduc1wiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RhcnRzX2kgPSAke0soXCJ1bmlmb3Jtcy5zdGFydHNcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gb3V0cHV0X2luZGV4ICogc3RlcHNfaSArIHN0YXJ0c19pICsgY2Fycnk7XG4gICAgICAgICAgICBjYXJyeSA9IGlucHV0X2luZGV4IC8gaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfaW5kZXggJSBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaWYgKHNpZ25zX2kgPCAwKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIGlucHV0X2luZGV4IC0gMXUgKyBzdGFydHNfaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfaW5kZXhcIil9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICAgIH1gLEx5PShlLHQpPT57bGV0IG49ZVswXS5kaW1zLHI9RS5zaXplKG4pLG89dC5heGVzLmxlbmd0aD4wP0Uubm9ybWFsaXplQXhlcyh0LmF4ZXMsbi5sZW5ndGgpOlsuLi5BcnJheShuLmxlbmd0aCkua2V5cygpXSxhPW5uKGUsNCk7YS5mb3JFYWNoKCQ9PiQhPT0wfHwoKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJzdGVwIGNhbm5vdCBiZSAwXCIpfSkpLGEubGVuZ3RoPT09MCYmKGE9QXJyYXkoby5sZW5ndGgpLmZpbGwoMSkpO2xldCBzPXQuc3RhcnRzLm1hcCgoJCx2KT0+SWMoJCx2LG4sbyxhKSksZD10LmVuZHMubWFwKCgkLHYpPT5JYygkLHYsbixvLGEpKTtpZihvLmxlbmd0aCE9PXMubGVuZ3RofHxvLmxlbmd0aCE9PWQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInN0YXJ0LCBlbmRzIGFuZCBheGVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50c1wiKTtpZihvLmxlbmd0aCE9PW4ubGVuZ3RoKWZvcihsZXQgJD0wOyQ8bi5sZW5ndGg7KyskKW8uaW5jbHVkZXMoJCl8fChzLnNwbGljZSgkLDAsMCksZC5zcGxpY2UoJCwwLG5bJF0pLGEuc3BsaWNlKCQsMCwxKSk7bGV0IGw9YS5tYXAoJD0+TWF0aC5zaWduKCQpKTthLmZvckVhY2goKCQsdixUKT0+e2lmKCQ8MCl7bGV0IEM9KGRbdl0tc1t2XSkvJCxBPXNbdl0saz1BK0MqYVt2XTtzW3ZdPWssZFt2XT1BLFRbdl09LSR9fSk7bGV0IHA9bi5zbGljZSgwKTtvLmZvckVhY2goKCQsdik9PntwWyRdPU1hdGguY2VpbCgoZFskXS1zWyRdKS9hWyRdKX0pO2xldCBmPXtkaW1zOnAsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0saD1OKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxwLmxlbmd0aCkseT1QKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLF89RS5zaXplKHApLGI9W3tuYW1lOlwib3V0cHV0U2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdGFydHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnMubGVuZ3RofSx7bmFtZTpcInNpZ25zXCIsdHlwZTpcImkzMlwiLGxlbmd0aDpsLmxlbmd0aH0se25hbWU6XCJzdGVwc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9XSx3PVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6c30se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6YX0sLi4uSChlWzBdLmRpbXMscCldLFM9JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoYikuZGVjbGFyZVZhcmlhYmxlcyh5LGgpfVxuICAgICAgICAke1d5KHksaCxuKX1cbiAgICAgICAgJHskLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2gub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgbGV0IGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgICAgICR7aC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix5LmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJTbGljZVwiLHNoYWRlckNhY2hlOntoaW50OmAke2wubGVuZ3RofV8ke3MubGVuZ3RofV8ke2EubGVuZ3RofWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOlMsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltmXSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChyLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnd9KX19LEFjPShlLHQpPT57TnkoZS5pbnB1dHMsdCk7bGV0IG49VnkoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKEx5KGUuaW5wdXRzLG4pLHtpbnB1dHM6WzBdfSl9LGtjPWU9PntsZXQgdD1lLnN0YXJ0cyxuPWUuZW5kcyxyPWUuYXhlcztyZXR1cm4gcmUoe3N0YXJ0czp0LGVuZHM6bixheGVzOnJ9KX19KTt2YXIgR3ksSHksUGMsemMsT2M9RygoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7YWUoKTtDZSgpO2N0KCk7Y2UoKTtHeT1lPT57aWYoIWV8fGUubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0bWF4IG9wIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxIeT0oZSx0KT0+e2xldCBuPWUuaW5wdXRzWzBdLHI9bi5kaW1zLG89RS5zaXplKHIpLGE9ci5sZW5ndGgscz1FLm5vcm1hbGl6ZUF4aXModC5heGlzLGEpLGQ9czxyLmxlbmd0aC0xLGwscD1bXTtkPyhwPUFycmF5LmZyb20oe2xlbmd0aDphfSwoTyxNKT0+TSkscFtzXT1hLTEscFthLTFdPXMsbD1lLmNvbXB1dGUoT2UobixwKSx7aW5wdXRzOltuXSxvdXRwdXRzOlstMV19KVswXSk6bD1uO2xldCBmPWwuZGltcyxoPWZbYS0xXSx5PW8vaCxfPWdlKGgpLGI9aC9fLHc9NjQ7eT09PTEmJih3PTI1Nik7bGV0IFM9KE8sTSk9Pk09PT00P2BtYXgobWF4KCR7T30ueCwgJHtPfS55KSwgbWF4KCR7T30ueiwgJHtPfS53KSlgOk09PT0yP2BtYXgoJHtPfS54LCAke099LnkpYDpNPT09Mz9gbWF4KG1heCgke099LngsICR7T30ueSksICR7T30ueilgOk8sJD1QKFwieFwiLGwuZGF0YVR5cGUsbC5kaW1zLF8pLHY9TihcInJlc3VsdFwiLGwuZGF0YVR5cGUsbC5kaW1zLF8pLFQ9JC50eXBlLnZhbHVlLEM9X2UobC5kYXRhVHlwZSk9PT1cImYzMlwiP2B2YXIgdGhyZWFkTWF4ID0gJHtUfSgtMy40MDI4MjNlKzM4Zik7YDpgdmFyIHRocmVhZE1heCA9ICR7VH0oLTY1NTA0LjBoKTtgLEE9Tz0+YFxuICAgICAgdmFyPHdvcmtncm91cD4gcm93TWF4U2hhcmVkIDogJHtUfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd1N1bVNoYXJlZCA6ICR7VH07XG4gICAgICB2YXI8d29ya2dyb3VwPiB0aHJlYWRTaGFyZWQgOiBhcnJheTwke1R9LCAke3d9PjtcblxuICAgICAgZm4gZ2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIpIC0+ICR7VH0ge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXR1cm4geFtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZuIHNldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyLCB2YWx1ZTogJHtUfSkge1xuICAgICAgICBsZXQgaW5kZXggPSByb3cgKiByb3dfc3RyaWRlICsgY29sO1xuICAgICAgICByZXN1bHRbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICAke08ucmVnaXN0ZXJVbmlmb3JtKFwicGFja2VkQ29sc1wiLFwiaTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoJCx2KX1cbiAgICAgICR7Ty5tYWluU3RhcnQodyl9XG4gICAgICAgIGxldCBnaW5kZXggPSBpMzIoZ2xvYmFsX2lkeCk7XG4gICAgICAgIGxldCBsaW5kZXggPSBpMzIobG9jYWxfaWR4KTtcbiAgICAgICAgY29uc3Qgd2cgPSAke3d9O1xuICAgICAgICBsZXQgcm93ID0gZ2luZGV4IC8gd2c7XG4gICAgICAgIGxldCBjb2xzID0gdW5pZm9ybXMucGFja2VkQ29scztcbiAgICAgICAgbGV0IHJvd19zdHJpZGUgOiBpMzIgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3MgbWF4XG4gICAgICAgICR7Q31cbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSk7XG4gICAgICAgICAgdGhyZWFkTWF4ID0gbWF4KHRocmVhZE1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPCBjb2xzKSB7XG4gICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRNYXg7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKGNvbHMsIHdnKTtcbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgcmVkdWNlU2l6ZSA9IGN1cnJTaXplICsgKHJlZHVjZVNpemUgJiAxKTtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gbWF4KHRocmVhZFNoYXJlZFtsaW5kZXhdLCB0aHJlYWRTaGFyZWRbbGluZGV4ICsgcmVkdWNlU2l6ZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93TWF4U2hhcmVkID0gJHtUfSgke1MoXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIHN1bVxuICAgICAgICB2YXIgdGhyZWFkU3VtID0gJHtUfSgwLjApO1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCBzdWJFeHAgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKTtcbiAgICAgICAgICB0aHJlYWRTdW0gKz0gc3ViRXhwO1xuICAgICAgICB9XG4gICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU3VtO1xuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgZm9yICh2YXIgY3VyclNpemUgPSB3ZyA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgICAgICBpZiAobGluZGV4IDwgY3VyclNpemUpIHtcbiAgICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkU2hhcmVkW2xpbmRleF0gKyB0aHJlYWRTaGFyZWRbbGluZGV4ICsgY3VyclNpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA9PSAwKSB7XG4gICAgICAgICAgcm93U3VtU2hhcmVkID0gJHtUfSgke0tlKFwidGhyZWFkU2hhcmVkWzBdXCIsXyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGZpbmFsIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHJvd1xuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpIC8gcm93U3VtU2hhcmVkO1xuICAgICAgICAgIHNldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1gLGs9ZS5jb21wdXRlKHtuYW1lOlwiU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke199OyR7d31gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZixkYXRhVHlwZTpsLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp5fSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjYsZGF0YTpifV19KSxnZXRTaGFkZXJTb3VyY2U6QX0se2lucHV0czpbbF0sb3V0cHV0czpbZD8tMTowXX0pWzBdO2QmJmUuY29tcHV0ZShPZShrLHApLHtpbnB1dHM6W2tdfSl9LFBjPShlLHQpPT57R3koZS5pbnB1dHMpLEh5KGUsdCl9LHpjPWU9PnJlKHtheGlzOmUuYXhpc30pfSk7dmFyIERjLEZ5LHF5LEt5LEJjLE1jPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtEYz1lPT5BcnJheS5mcm9tKGUuZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksRnk9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCYmZVswXS5kYXRhVHlwZSE9PTYmJmVbMF0uZGF0YVR5cGUhPT0xMil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIG9ubHkgc3VwcG9ydCBmbG9hdCwgZmxvYXQxNiwgaW50MzIsIGFuZCB1aW50MzIgZGF0YSB0eXBlc1wiKTtpZihlWzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgb2YgaW50NjQgZGF0YSB0eXBlXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSAxLURcIik7aWYoRGMoZVsxXSkubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgaGF2ZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cyBhcyByYW5rIG9mIGlucHV0IGRhdGEgdGVuc29yXCIpfSxxeT0oZSx0KT0+e2xldCBuPVtdO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKW4ucHVzaChlW3JdKnRbcl0pO3JldHVybiBufSxLeT0oZSx0KT0+e2xldCBuPWVbMF0uZGltcyxyPXQ/P0RjKGVbMV0pLG89cXkobixyKSxhPUUuc2l6ZShvKSxzPWVbMF0uZGF0YVR5cGUsZD1QKFwiaW5wdXRcIixzLG4ubGVuZ3RoKSxsPU4oXCJvdXRwdXRcIixzLG8ubGVuZ3RoKSxwPWY9PmBcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSAke2QuaW5kaWNlcyguLi5uKX07XG4gICAgICAke2YucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGQsbCl9XG4gICAgICAke2YubWFpblN0YXJ0KCl9XG4gICAgICAke2YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtsLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke24ubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9kaW1faSA9ICR7ZC5pbmRpY2VzR2V0KFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIil9O1xuICAgICAgICBsZXQgaW5wdXRfZGltX3ZhbHVlID0gJHtsLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX0gICUgaW5wdXRfZGltX2k7XG5cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9kaW1fdmFsdWVcIil9XG4gICAgICB9XG4gICAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZC5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cbiAgICB9YDtyZXR1cm57bmFtZTpcIlRpbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtyfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmF9LC4uLkgoZVswXS5kaW1zLG8pXX0pLGdldFNoYWRlclNvdXJjZTpwfX0sQmM9ZT0+e0Z5KGUuaW5wdXRzKSxlLmNvbXB1dGUoS3koZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIGp5LFp5LFJjLFVjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2FlKCk7Y2UoKTtqeT0oZSx0LG4scixvKT0+e2xldCBhPU4oXCJvdXRwdXRfZGF0YVwiLG8sbi5sZW5ndGgsNCkscz1QKFwiYV9kYXRhXCIsdFsxXS5kYXRhVHlwZSx0WzFdLmRpbXMubGVuZ3RoLDQpLGQ9UChcImJfZGF0YVwiLHRbMl0uZGF0YVR5cGUsdFsyXS5kaW1zLmxlbmd0aCw0KSxsPVAoXCJjX2RhdGFcIix0WzBdLmRhdGFUeXBlLHRbMF0uZGltcy5sZW5ndGgsNCkscCxmPShoLHksXyk9PmBzZWxlY3QoJHt5fSwgJHtofSwgJHtffSlgO2lmKCFyKXA9YS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixmKHMuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLGQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLGwuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtsZXQgaD0oeSxfLGI9XCJcIik9PntsZXQgdz1gYV9kYXRhW2luZGV4X2Eke199XVtjb21wb25lbnRfYSR7X31dYCxTPWBiX2RhdGFbaW5kZXhfYiR7X31dW2NvbXBvbmVudF9iJHtffV1gLCQ9YGJvb2woY19kYXRhW2luZGV4X2Mke199XSAmICgweGZmdSA8PCAoY29tcG9uZW50X2Mke199ICogOCkpKWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzJHtffSA9ICR7YS5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiA0dSArICR7X311YCl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9hJHtffSA9ICR7cy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxhKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Ike199ID0gJHtkLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGEpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYyR7X30gPSAke2wuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsYSl9O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Eke199ID0gb2Zmc2V0X2Eke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYiR7X30gPSBvZmZzZXRfYiR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9jJHtffSA9IG9mZnNldF9jJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9hJHtffSA9IG9mZnNldF9hJHtffSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9iJHtffSA9IG9mZnNldF9iJHtffSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudF9jJHtffSA9IG9mZnNldF9jJHtffSAlIDR1O1xuICAgICAgICAgICAgJHt5fVske199XSA9ICR7Yn0oJHtmKHcsUywkKX0pO1xuICAgICAgICAgIGB9O289PT05P3A9YFxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICAgICAke2goXCJkYXRhXCIsMCxcInUzMlwiKX1cbiAgICAgICAgICAgICR7aChcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAgICAgJHtoKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICAgICAke2goXCJkYXRhXCIsMyxcInUzMlwiKX1cbiAgICAgICAgICAgIG91dHB1dF9kYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6cD1gXG4gICAgICAgICAgICAke2goXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHtoKFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwxKX1cbiAgICAgICAgICAgICR7aChcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke2goXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGwscyxkLGEpfVxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgICAgICR7cH1cbiAgICAgIH1gfSxaeT1lPT57bGV0IHQ9ZVsxXS5kaW1zLG49ZVsyXS5kaW1zLHI9ZVswXS5kaW1zLG89ZVsxXS5kYXRhVHlwZSxhPSEoRS5hcmVFcXVhbCh0LG4pJiZFLmFyZUVxdWFsKG4scikpLHM9dCxkPUUuc2l6ZSh0KTtpZihhKXtsZXQgcD1ydC5jYWxjU2hhcGUocnQuY2FsY1NoYXBlKHQsbiwhMSksciwhMSk7aWYoIXApdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSB3aGVyZSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTtzPXAsZD1FLnNpemUocyl9bGV0IGw9TWF0aC5jZWlsKGQvNCk7cmV0dXJue25hbWU6XCJXaGVyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cD0+ankocCxlLHMsYSxvKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnMsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpsfSwuLi5IKHIsdCxuLHMpXX0pfX0sUmM9ZT0+e2UuY29tcHV0ZShaeShlLmlucHV0cykpfX0pO3ZhciBOYyxWYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3UoKTtxcigpOyR1KCk7U3UoKTtkZCgpO3dkKCk7eGQoKTtOZCgpO3FkKCk7WmQoKTtYZCgpO25sKCk7YWwoKTt1bCgpO2NsKCk7ZmwoKTt5bCgpO3dsKCk7eGwoKTtDbCgpO0RsKCk7UmwoKTtObCgpO1dsKCk7SGwoKTtTbygpO3FsKCk7ZGMoKTtwYygpO2ZjKCk7eWMoKTtIcigpOyRjKCk7U2MoKTtDYygpO0VjKCk7T2MoKTtDbygpO01jKCk7Y3QoKTtqcigpO1VjKCk7TmM9bmV3IE1hcChbW1wiQWJzXCIsW1R1XV0sW1wiQWNvc1wiLFtDdV1dLFtcIkFjb3NoXCIsW0l1XV0sW1wiQWRkXCIsW2xkXV0sW1wiQXJnTWF4XCIsW2J1LGNvXV0sW1wiQXJnTWluXCIsW3l1LGNvXV0sW1wiQXNpblwiLFtBdV1dLFtcIkFzaW5oXCIsW2t1XV0sW1wiQXRhblwiLFtFdV1dLFtcIkF0YW5oXCIsW1B1XV0sW1wiQXR0ZW50aW9uXCIsW3d1XV0sW1wiQXZlcmFnZVBvb2xcIixbZWMsSmxdXSxbXCJCYXRjaE5vcm1hbGl6YXRpb25cIixbdnVdXSxbXCJCaWFzQWRkXCIsW3h1XV0sW1wiQmlhc1NwbGl0R2VsdVwiLFt1ZF1dLFtcIkNhc3RcIixbT3UsenVdXSxbXCJDZWlsXCIsW0J1XV0sW1wiQ2xpcFwiLFtEdV1dLFtcIkNvbmNhdFwiLFt2ZCwkZF1dLFtcIkNvbnZcIixbd28sX29dXSxbXCJDb252VHJhbnNwb3NlXCIsW0ZkLEdkXV0sW1wiQ29zXCIsW011XV0sW1wiQ29zaFwiLFtSdV1dLFtcIkN1bVN1bVwiLFtLZCxqZF1dLFtcIkRlcHRoVG9TcGFjZVwiLFtRZCxZZF1dLFtcIkRlcXVhbnRpemVMaW5lYXJcIixbbGMsY2NdXSxbXCJEaXZcIixbY2RdXSxbXCJFaW5zdW1cIixbdGwscmxdXSxbXCJFbHVcIixbVXUsdHJdXSxbXCJFcXVhbFwiLFtwZF1dLFtcIkVyZlwiLFtOdV1dLFtcIkV4cFwiLFtWdV1dLFtcIkV4cGFuZFwiLFtpbF1dLFtcIkZhc3RHZWx1XCIsW3NsXV0sW1wiRmxvb3JcIixbV3VdXSxbXCJGdXNlZENvbnZcIixbd28sX29dXSxbXCJHYXRoZXJcIixbbGwsZGxdXSxbXCJHYXRoZXJFbGVtZW50c1wiLFtfbCxibF1dLFtcIkdhdGhlckJsb2NrUXVhbnRpemVkXCIsW2hsLGdsXV0sW1wiR2F0aGVyTkRcIixbcGwsbWxdXSxbXCJHZWx1XCIsW0x1XV0sW1wiR2VtbVwiLFskbCx2bF1dLFtcIkdsb2JhbEF2ZXJhZ2VQb29sXCIsW25jLHJjXV0sW1wiR2xvYmFsTWF4UG9vbFwiLFt1YyxzY11dLFtcIkdyZWF0ZXJcIixbZ2RdXSxbXCJHcmVhdGVyT3JFcXVhbFwiLFtiZF1dLFtcIkdyaWRTYW1wbGVcIixbU2wsVGxdXSxbXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIsW09sXV0sW1wiSGFyZFNpZ21vaWRcIixbUXUsWnVdXSxbXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixbTWxdXSxbXCJMYXllck5vcm1hbGl6YXRpb25cIixbVWxdXSxbXCJMZWFreVJlbHVcIixbR3UsdHJdXSxbXCJMZXNzXCIsW3lkXV0sW1wiTGVzc09yRXF1YWxcIixbX2RdXSxbXCJMb2dcIixbaWRdXSxbXCJNYXRNdWxcIixbVmxdXSxbXCJNYXRNdWxOQml0c1wiLFtMbCxHbF1dLFtcIk1heFBvb2xcIixbaWMsYWNdXSxbXCJNdWxcIixbbWRdXSxbXCJNdWx0aUhlYWRBdHRlbnRpb25cIixba2wsQWxdXSxbXCJOZWdcIixbRnVdXSxbXCJOb3RcIixbSHVdXSxbXCJQYWRcIixbRmxdXSxbXCJQb3dcIixbZmRdXSxbXCJRdWlja0dlbHVcIixbYWQsdHJdXSxbXCJSYW5nZVwiLFttY11dLFtcIlJlY2lwcm9jYWxcIixbcXVdXSxbXCJSZWR1Y2VNaW5cIixbY3VdXSxbXCJSZWR1Y2VNZWFuXCIsW2F1XV0sW1wiUmVkdWNlTWF4XCIsW2x1XV0sW1wiUmVkdWNlU3VtXCIsW211XV0sW1wiUmVkdWNlUHJvZFwiLFtwdV1dLFtcIlJlZHVjZUwxXCIsW3N1XV0sW1wiUmVkdWNlTDJcIixbdXVdXSxbXCJSZWR1Y2VMb2dTdW1cIixbaHVdXSxbXCJSZWR1Y2VMb2dTdW1FeHBcIixbZHVdXSxbXCJSZWR1Y2VTdW1TcXVhcmVcIixbZnVdXSxbXCJSZWx1XCIsW0t1XV0sW1wiUmVzaXplXCIsW3djLHZjXV0sW1wiUm90YXJ5RW1iZWRkaW5nXCIsW3hjXV0sW1wiU2NhdHRlck5EXCIsW2djLGhjXV0sW1wiU2lnbW9pZFwiLFtqdV1dLFtcIlNpblwiLFtZdV1dLFtcIlNpbmhcIixbWHVdXSxbXCJTbGljZVwiLFtBYyxrY11dLFtcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixbVGNdXSxbXCJTcGxpdFwiLFtFbCxQbF1dLFtcIlNxcnRcIixbSnVdXSxbXCJTb2Z0bWF4XCIsW1BjLHpjXV0sW1wiU3ViXCIsW2hkXV0sW1wiVGFuXCIsW2VkXV0sW1wiVGFuaFwiLFtyZF1dLFtcIlRocmVzaG9sZGVkUmVsdVwiLFtvZCx0cl1dLFtcIlRpbGVcIixbQmNdXSxbXCJUcmFuc3Bvc2VcIixbS3MsanNdXSxbXCJXaGVyZVwiLFtSY11dXSl9KTt2YXIgb24sV2M9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7dHQoKTtjZSgpO29uPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMucmVwbz1uZXcgTWFwLHRoaXMuYXR0cmlidXRlc0JvdW5kPSExfWdldEFydGlmYWN0KHQpe3JldHVybiB0aGlzLnJlcG8uZ2V0KHQpfXNldEFydGlmYWN0KHQsbil7dGhpcy5yZXBvLnNldCh0LG4pfXJ1bih0LG4scixvLGEpe05lKHQucHJvZ3JhbUluZm8ubmFtZSk7bGV0IHM9dGhpcy5iYWNrZW5kLmRldmljZSxkPXRoaXMuYmFja2VuZC5nZXRDb21wdXRlUGFzc0VuY29kZXIoKTt0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKTtsZXQgbD1bXTtmb3IobGV0IGYgb2YgbilsLnB1c2goe2JpbmRpbmc6bC5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpmLmJ1ZmZlcn19KTtmb3IobGV0IGYgb2YgcilsLnB1c2goe2JpbmRpbmc6bC5sZW5ndGgscmVzb3VyY2U6e2J1ZmZlcjpmLmJ1ZmZlcn19KTthJiZsLnB1c2goe2JpbmRpbmc6bC5sZW5ndGgscmVzb3VyY2U6YX0pO2xldCBwPXMuY3JlYXRlQmluZEdyb3VwKHtsYXlvdXQ6dC5jb21wdXRlUGlwZWxpbmUuZ2V0QmluZEdyb3VwTGF5b3V0KDApLGVudHJpZXM6bCxsYWJlbDp0LnByb2dyYW1JbmZvLm5hbWV9KTtpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBmPXtrZXJuZWxJZDp0aGlzLmJhY2tlbmQuY3VycmVudEtlcm5lbElkLGNvbXB1dGVQaXBlbGluZTp0LmNvbXB1dGVQaXBlbGluZSxiaW5kR3JvdXA6cCxkaXNwYXRjaEdyb3VwOm99O3RoaXMuYmFja2VuZC5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCkucHVzaChmKX1kLnNldFBpcGVsaW5lKHQuY29tcHV0ZVBpcGVsaW5lKSxkLnNldEJpbmRHcm91cCgwLHApLGQuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLm8pLHRoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcisrLCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXJ8fHRoaXMuYmFja2VuZC5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5iYWNrZW5kLmVuZENvbXB1dGVQYXNzKCksdGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmJhY2tlbmQuZmx1c2goKSxCZSh0LnByb2dyYW1JbmZvLm5hbWUpfWRpc3Bvc2UoKXt9YnVpbGQodCxuKXtOZSh0Lm5hbWUpO2xldCByPXRoaXMuYmFja2VuZC5kZXZpY2Usbz1bXTtbe2ZlYXR1cmU6XCJzaGFkZXItZjE2XCIsZXh0ZW5zaW9uOlwiZjE2XCJ9LHtmZWF0dXJlOlwic3ViZ3JvdXBzXCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzXCJ9LHtmZWF0dXJlOlwic3ViZ3JvdXBzLWYxNlwiLGV4dGVuc2lvbjpcInN1Ymdyb3Vwc19mMTZcIn1dLmZvckVhY2goaD0+e3IuZmVhdHVyZXMuaGFzKGguZmVhdHVyZSkmJm8ucHVzaChgZW5hYmxlICR7aC5leHRlbnNpb259O2ApfSk7bGV0IHM9RnMobix0aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cyksZD10LmdldFNoYWRlclNvdXJjZShzKSxsPWAke28uam9pbihgXG5gKX1cbiR7cy5hZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zfVxuJHtkfWAscD1yLmNyZWF0ZVNoYWRlck1vZHVsZSh7Y29kZTpsLGxhYmVsOnQubmFtZX0pO21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gJHt0Lm5hbWV9IHNoYWRlciBjb2RlOiAke2x9YCk7bGV0IGY9ci5jcmVhdGVDb21wdXRlUGlwZWxpbmUoe2NvbXB1dGU6e21vZHVsZTpwLGVudHJ5UG9pbnQ6XCJtYWluXCJ9LGxheW91dDpcImF1dG9cIixsYWJlbDp0Lm5hbWV9KTtyZXR1cm4gQmUodC5uYW1lKSx7cHJvZ3JhbUluZm86dCxjb21wdXRlUGlwZWxpbmU6Zix1bmlmb3JtVmFyaWFibGVzSW5mbzpzLnZhcmlhYmxlc0luZm99fW5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplKHQpe2xldCBuPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC54LHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnl8fDEsbz10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQuenx8MSxhPXRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uO2lmKG48PWEmJnI8PWEmJm88PWEpcmV0dXJuW24scixvXTtsZXQgcz1uKnIqbyxkPU1hdGguY2VpbChNYXRoLnNxcnQocykpO2lmKGQ+YSl7aWYoZD1NYXRoLmNlaWwoTWF0aC5jYnJ0KHMpKSxkPmEpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgZGlzcGF0Y2ggc2l6ZSBleGNlZWRzIFdlYkdQVSBtYXhpbXVtLlwiKTtyZXR1cm5bZCxkLGRdfWVsc2UgcmV0dXJuW2QsZCwxXX19fSk7dmFyIFF5LFl5LElvLEFvLGFuLExjPUcoKCk9PntcInVzZSBzdHJpY3RcIjtHZSgpO3RlKCk7dHQoKTtKbigpO1dzKCk7VmMoKTtXYygpO1F5PShlLHQpPT57aWYodC5sZW5ndGghPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGlucHV0RGVwZW5kZW5jaWVzIGxlbmd0aCAke3QubGVuZ3RofSBpcyBub3QgZXF1YWwgdG8gaW5wdXRUZW5zb3JzIGxlbmd0aCAke2UubGVuZ3RofS5gKTtsZXQgbj1bXTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoOysrcil7bGV0IG89ZVtyXS5kYXRhVHlwZTtzd2l0Y2godFtyXSl7Y2FzZVwibm9uZVwiOntuLnB1c2goXCJcIik7YnJlYWt9Y2FzZVwidHlwZVwiOntuLnB1c2goYCR7b31gKTticmVha31jYXNlXCJyYW5rXCI6e2xldCBhPWVbcl0uZGltcy5sZW5ndGg7bi5wdXNoKGAke299OyR7YX1gKTticmVha31jYXNlXCJkaW1zXCI6e2xldCBhPWVbcl0uZGltcy5qb2luKFwiLFwiKTtuLnB1c2goYCR7b307JHthfWApO2JyZWFrfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBpbnB1dCBkZXBlbmRlbmN5OiAke3Rbcl19YCl9fXJldHVybiBuLmpvaW4oXCJ8XCIpfSxZeT0oZSx0LG4pPT57bGV0IHI9ZS5uYW1lO3JldHVybiBlLnNoYWRlckNhY2hlPy5oaW50JiYocis9XCJbXCIrZS5zaGFkZXJDYWNoZS5oaW50K1wiXVwiKSxyKz1cIjpcIituK2A6JHtReSh0LGUuc2hhZGVyQ2FjaGU/LmlucHV0RGVwZW5kZW5jaWVzPz9uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwoXCJkaW1zXCIpKX1gLHJ9LElvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3QmJih0aGlzLmFyY2hpdGVjdHVyZT10LmFyY2hpdGVjdHVyZSx0aGlzLnZlbmRvcj10LnZlbmRvcil9aXNBcmNoaXRlY3R1cmUodCl7cmV0dXJuIHRoaXMuYXJjaGl0ZWN0dXJlPT09dH1pc1ZlbmRvcih0KXtyZXR1cm4gdGhpcy52ZW5kb3I9PT10fX0sQW89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5zdWJncm91cHNTdXBwb3J0ZWQ9dC5mZWF0dXJlcy5oYXMoXCJzdWJncm91cHNcIiksdGhpcy5zdWJncm91cHNGMTZTdXBwb3J0ZWQ9dC5mZWF0dXJlcy5oYXMoXCJzdWJncm91cHNcIik7bGV0IG49dC5saW1pdHM7IXRoaXMuc3ViZ3JvdXBzU3VwcG9ydGVkfHwhbi5taW5TdWJncm91cFNpemV8fCFuLm1heFN1Ymdyb3VwU2l6ZT90aGlzLnN1Ymdyb3VwU2l6ZVJhbmdlPXZvaWQgMDp0aGlzLnN1Ymdyb3VwU2l6ZVJhbmdlPVtuLm1pblN1Ymdyb3VwU2l6ZSxuLm1heFN1Ymdyb3VwU2l6ZV19fSxhbj1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY3VycmVudFNlc3Npb25JZD1udWxsO3RoaXMuY3VycmVudEtlcm5lbElkPW51bGw7dGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsO3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGw7dGhpcy5tYXhEaXNwYXRjaE51bWJlcj0xNjt0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wO3RoaXMucGVuZGluZ0tlcm5lbHM9W107dGhpcy5wZW5kaW5nUXVlcmllcz1uZXcgTWFwO3RoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIjt0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Q9bmV3IE1hcDt0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHM9bmV3IE1hcDt0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nPW5ldyBNYXB9Z2V0IGN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCl7aWYodGhpcy5jdXJyZW50S2VybmVsSWQ9PT1udWxsKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRLZXJuZWxDdXN0b21EYXRhKCk6IGN1cnJlbnRLZXJuZWxJZCBpcyBudWxsLiAoc2hvdWxkIG5vdCBoYXBwZW4pXCIpO2xldCB0PXRoaXMua2VybmVsQ3VzdG9tRGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO3JldHVybiB0fHwodD17fSx0aGlzLmtlcm5lbEN1c3RvbURhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLHQpKSx0fWFzeW5jIGluaXRpYWxpemUodCxuKXt0aGlzLmVudj10O2xldCByPVtdLG89e3JlcXVpcmVkTGltaXRzOnttYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemU6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplLG1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uLG1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZTpuLmxpbWl0cy5tYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUsbWF4QnVmZmVyU2l6ZTpuLmxpbWl0cy5tYXhCdWZmZXJTaXplLG1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cDpuLmxpbWl0cy5tYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVYOm4ubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVk6bi5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVZLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWjpuLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVp9LHJlcXVpcmVkRmVhdHVyZXM6cn0sYT1zPT5uLmZlYXR1cmVzLmhhcyhzKSYmci5wdXNoKHMpJiYhMDthKFwiY2hyb21pdW0tZXhwZXJpbWVudGFsLXRpbWVzdGFtcC1xdWVyeS1pbnNpZGUtcGFzc2VzXCIpfHxhKFwidGltZXN0YW1wLXF1ZXJ5XCIpLGEoXCJzaGFkZXItZjE2XCIpLGEoXCJzdWJncm91cHNcIikmJmEoXCJzdWJncm91cHMtZjE2XCIpLHRoaXMuZGV2aWNlPWF3YWl0IG4ucmVxdWVzdERldmljZShvKSx0aGlzLmRldmljZUluZm89bmV3IEFvKHRoaXMuZGV2aWNlKSx0aGlzLmFkYXB0ZXJJbmZvPW5ldyBJbyhuLmluZm98fGF3YWl0IG4ucmVxdWVzdEFkYXB0ZXJJbmZvKCkpLHRoaXMuZ3B1RGF0YU1hbmFnZXI9VnModGhpcyksdGhpcy5wcm9ncmFtTWFuYWdlcj1uZXcgb24odGhpcyksdGhpcy5rZXJuZWxzPW5ldyBNYXAsdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YT1uZXcgTWFwLHRoaXMua2VybmVsQ3VzdG9tRGF0YT1uZXcgTWFwLFVyKHQubG9nTGV2ZWwsISF0LmRlYnVnKSx0aGlzLmRldmljZS5vbnVuY2FwdHVyZWRlcnJvcj1zPT57cy5lcnJvciBpbnN0YW5jZW9mIEdQVVZhbGlkYXRpb25FcnJvciYmY29uc29sZS5lcnJvcihgQW4gdW5jYXVnaHQgV2ViR1BVIHZhbGlkYXRpb24gZXJyb3Igd2FzIHJhaXNlZDogJHtzLmVycm9yLm1lc3NhZ2V9YCl9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJkZXZpY2VcIix7dmFsdWU6dGhpcy5kZXZpY2Usd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiYWRhcHRlclwiLHt2YWx1ZTpuLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksdGhpcy5zZXRRdWVyeVR5cGUoKX1kaXNwb3NlKCl7dHlwZW9mIHRoaXMucXVlcnlTZXQ8XCJ1XCImJnRoaXMucXVlcnlTZXQuZGVzdHJveSgpLHRoaXMuZ3B1RGF0YU1hbmFnZXIuZGlzcG9zZSgpfWdldENvbW1hbmRFbmNvZGVyKCl7cmV0dXJuIHRoaXMuY29tbWFuZEVuY29kZXJ8fCh0aGlzLmNvbW1hbmRFbmNvZGVyPXRoaXMuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCkpLHRoaXMuY29tbWFuZEVuY29kZXJ9Z2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCl7aWYoIXRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyKXtsZXQgdD10aGlzLmdldENvbW1hbmRFbmNvZGVyKCksbj17fTt0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCImJihuLnRpbWVzdGFtcFdyaXRlcz17cXVlcnlTZXQ6dGhpcy5xdWVyeVNldCxiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsZW5kT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzF9KSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj10LmJlZ2luQ29tcHV0ZVBhc3Mobil9cmV0dXJuIHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyfWVuZENvbXB1dGVQYXNzKCl7dGhpcy5jb21wdXRlUGFzc0VuY29kZXImJih0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlci5lbmQoKSx0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsKX1mbHVzaCgpe2lmKCF0aGlzLmNvbW1hbmRFbmNvZGVyKXJldHVybjtOZSgpLHRoaXMuZW5kQ29tcHV0ZVBhc3MoKTtsZXQgdDt0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiYodGhpcy5jb21tYW5kRW5jb2Rlci5yZXNvbHZlUXVlcnlTZXQodGhpcy5xdWVyeVNldCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIsdGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCksdD10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfEdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfSksdGhpcy5wZW5kaW5nUXVlcmllcy5zZXQodCx0aGlzLnBlbmRpbmdLZXJuZWxzKSx0aGlzLnBlbmRpbmdLZXJuZWxzPVtdLHRoaXMuY29tbWFuZEVuY29kZXIuY29weUJ1ZmZlclRvQnVmZmVyKHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDAsdCwwLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCkpLHRoaXMuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbdGhpcy5jb21tYW5kRW5jb2Rlci5maW5pc2goKV0pLHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVmcmVzaFBlbmRpbmdCdWZmZXJzKCksdGhpcy5jb21tYW5kRW5jb2Rlcj1udWxsLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTAsdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdC5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpLnRoZW4oKCk9PntsZXQgbj1uZXcgQmlnVWludDY0QXJyYXkodC5nZXRNYXBwZWRSYW5nZSgpKSxyPXRoaXMucGVuZGluZ1F1ZXJpZXMuZ2V0KHQpO2ZvcihsZXQgbz0wO288bi5sZW5ndGgvMjtvKyspe2xldCBhPXJbb10scz1hLmtlcm5lbElkLGQ9dGhpcy5rZXJuZWxzLmdldChzKSxsPWQua2VybmVsVHlwZSxwPWQua2VybmVsTmFtZSxmPWEucHJvZ3JhbU5hbWUsaD1hLmlucHV0VGVuc29yVmlld3MseT1hLm91dHB1dFRlbnNvclZpZXdzLF89bltvKjJdLGI9bltvKjIrMV07dHlwZW9mIHRoaXMucXVlcnlUaW1lQmFzZT5cInVcIiYmKHRoaXMucXVlcnlUaW1lQmFzZT1fKTtsZXQgdz1OdW1iZXIoXy10aGlzLnF1ZXJ5VGltZUJhc2UpLFM9TnVtYmVyKGItdGhpcy5xdWVyeVRpbWVCYXNlKTtpZighTnVtYmVyLmlzU2FmZUludGVnZXIodyl8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihTKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluY29ycmVjdCB0aW1lc3RhbXAgcmFuZ2VcIik7aWYodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ub25kYXRhKXRoaXMuZW52LndlYmdwdS5wcm9maWxpbmcub25kYXRhKHt2ZXJzaW9uOjEsaW5wdXRzTWV0YWRhdGE6aC5tYXAoJD0+KHtkaW1zOiQuZGltcyxkYXRhVHlwZTpfdCgkLmRhdGFUeXBlKX0pKSxvdXRwdXRzTWV0YWRhdGE6eS5tYXAoJD0+KHtkaW1zOiQuZGltcyxkYXRhVHlwZTpfdCgkLmRhdGFUeXBlKX0pKSxrZXJuZWxJZDpzLGtlcm5lbFR5cGU6bCxrZXJuZWxOYW1lOnAscHJvZ3JhbU5hbWU6ZixzdGFydFRpbWU6dyxlbmRUaW1lOlN9KTtlbHNle2xldCAkPVwiXCI7aC5mb3JFYWNoKChULEMpPT57JCs9YGlucHV0WyR7Q31dOiBbJHtULmRpbXN9XSB8ICR7X3QoVC5kYXRhVHlwZSl9LCBgfSk7bGV0IHY9XCJcIjt5LmZvckVhY2goKFQsQyk9Pnt2Kz1gb3V0cHV0WyR7Q31dOiBbJHtULmRpbXN9XSB8ICR7X3QoVC5kYXRhVHlwZSl9LCBgfSksY29uc29sZS5sb2coYFtwcm9maWxpbmddIGtlcm5lbCBcIiR7c318JHtsfXwke3B9fCR7Zn1cIiAkeyR9JHt2fWV4ZWN1dGlvbiB0aW1lOiAke1Mtd30gbnNgKX12cihcIkdQVVwiLGAke2Z9Ojoke199Ojoke2J9YCl9dC51bm1hcCgpLHRoaXMucGVuZGluZ1F1ZXJpZXMuZGVsZXRlKHQpfSksQmUoKX1ydW4odCxuLHIsbyxhLHMpe05lKHQubmFtZSk7bGV0IGQ9W107Zm9yKGxldCBUPTA7VDxuLmxlbmd0aDsrK1Qpe2xldCBDPW5bVF0uZGF0YTtpZihDPT09MCljb250aW51ZTtsZXQgQT10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChDKTtpZighQSl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBpbnB1dDogJHtDfWApO2QucHVzaChBKX1sZXR7b3V0cHV0czpsLGRpc3BhdGNoR3JvdXA6cCxwcm9ncmFtVW5pZm9ybXM6Zn09dC5nZXRSdW5EYXRhKG4pLGg9ci5sZW5ndGg9PT0wP2wubWFwKChULEMpPT5DKTpyO2lmKGgubGVuZ3RoIT09bC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBPdXRwdXQgc2l6ZSAke2gubGVuZ3RofSBtdXN0IGJlIGVxdWFsIHRvICR7bC5sZW5ndGh9LmApO2xldCB5PVtdLF89W107Zm9yKGxldCBUPTA7VDxsLmxlbmd0aDsrK1Qpe2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGhbVF0pfHxoW1RdPC0zfHxoW1RdPj1zKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBvdXRwdXQgaW5kZXg6ICR7aFtUXX1gKTtpZihoW1RdPT09LTMpY29udGludWU7bGV0IEM9aFtUXT09PS0xLEE9aFtUXT09PS0yLGs9Q3x8QT9hKGxbVF0uZGF0YVR5cGUsbFtUXS5kaW1zKTpvKGhbVF0sbFtUXS5kYXRhVHlwZSxsW1RdLmRpbXMpO2lmKHkucHVzaChrKSxrLmRhdGE9PT0wKWNvbnRpbnVlO2xldCBPPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KGsuZGF0YSk7aWYoIU8pdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3Igb3V0cHV0OiAke2suZGF0YX1gKTtpZihDJiZ0aGlzLnRlbXBvcmFyeURhdGEucHVzaChPKSxBKXtsZXQgTT10aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7TXx8KE09W10sdGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsTSkpLE0ucHVzaChPKX1fLnB1c2goTyl9aWYoZC5sZW5ndGghPT1uLmxlbmd0aHx8Xy5sZW5ndGghPT15Lmxlbmd0aCl7aWYoXy5sZW5ndGg9PT0wKXJldHVybiBCZSh0Lm5hbWUpLHk7dGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtICR7dC5uYW1lfSBoYXMgemVyby1zaXplZCB0ZW5zb3IocykgaW4gaW5wdXRzIG9yIG91dHB1dHMuIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBub3cuYCl9bGV0IGI7aWYoZil7bGV0IFQ9MCxDPVtdO2YuZm9yRWFjaChNPT57bGV0IFY9dHlwZW9mIE0uZGF0YT09XCJudW1iZXJcIj9bTS5kYXRhXTpNLmRhdGE7aWYoVi5sZW5ndGg9PT0wKXJldHVybjtsZXQgRj1NLnR5cGU9PT0xMD8yOjQsaixuZTtNLnR5cGU9PT0xMD8obmU9Vi5sZW5ndGg+ND8xNjpWLmxlbmd0aD4yPzg6Vi5sZW5ndGgqRixqPVYubGVuZ3RoPjQ/MTY6RipWLmxlbmd0aCk6KG5lPVYubGVuZ3RoPD0yP1YubGVuZ3RoKkY6MTYsaj0xNiksVD1NYXRoLmNlaWwoVC9uZSkqbmUsQy5wdXNoKFQpO2xldCBXPU0udHlwZT09PTEwPzg6NDtUKz1WLmxlbmd0aD40P01hdGguY2VpbChWLmxlbmd0aC9XKSpqOlYubGVuZ3RoKkZ9KTtsZXQgQT0xNjtUPU1hdGguY2VpbChUL0EpKkE7bGV0IGs9bmV3IEFycmF5QnVmZmVyKFQpO2YuZm9yRWFjaCgoTSxWKT0+e2xldCBGPUNbVl0saj10eXBlb2YgTS5kYXRhPT1cIm51bWJlclwiP1tNLmRhdGFdOk0uZGF0YTtpZihNLnR5cGU9PT02KW5ldyBJbnQzMkFycmF5KGssRixqLmxlbmd0aCkuc2V0KGopO2Vsc2UgaWYoTS50eXBlPT09MTIpbmV3IFVpbnQzMkFycmF5KGssRixqLmxlbmd0aCkuc2V0KGopO2Vsc2UgaWYoTS50eXBlPT09MTApbmV3IFVpbnQxNkFycmF5KGssRixqLmxlbmd0aCkuc2V0KGopO2Vsc2UgaWYoTS50eXBlPT09MSluZXcgRmxvYXQzMkFycmF5KGssRixqLmxlbmd0aCkuc2V0KGopO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7X3QoTS50eXBlKX1gKX0pO2xldCBPPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFQsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoTy5idWZmZXIsMCxrLDAsVCksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKE8uaWQpLGI9e29mZnNldDowLHNpemU6VCxidWZmZXI6Ty5idWZmZXJ9fWxldCB3PXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCksUz13WzFdPT09MSYmd1syXT09PTEsJD1ZeSh0LG4sUyksdj10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KCQpO2lmKHZ8fCh2PXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCx3KSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KCQsdiksbWUoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHskfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxmJiZ2LnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihmLmxlbmd0aCE9PXYudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke3YudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7Zi5sZW5ndGh9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IFQ9MDtUPGYubGVuZ3RoO1QrKyl7bGV0IEM9ZltUXSxBPUMudHlwZSxrPXR5cGVvZiBDLmRhdGE9PVwibnVtYmVyXCI/MTpDLmRhdGEubGVuZ3RoLFtPLE1dPXYudW5pZm9ybVZhcmlhYmxlc0luZm9bVF07aWYoQSE9PU98fGshPT1NKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke1R9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke099IHdpdGggc2l6ZSAke019LCBnb3QgdHlwZSAke0F9IHdpdGggc2l6ZSAke2t9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYobWUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHskfSkgd2l0aCAke3dbMF19eCR7d1sxXX14JHt3WzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBUPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTp2LnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpuLG91dHB1dFRlbnNvclZpZXdzOnl9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChUKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChUKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odixkLF8sdyxiKSxCZSh0Lm5hbWUpLHl9dXBsb2FkKHQsbil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxuKX1tZW1jcHkodCxuKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LG4pfWFzeW5jIGRvd25sb2FkKHQsbil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LG4pfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQsbixyLG8pe2xldCBhPU5jLmdldCh0KTtpZighYSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgcz17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTphWzBdLGF0dHJpYnV0ZXM6W2FbMV0scl19O3RoaXMua2VybmVscy5zZXQobixzKX1yZWxlYXNlS2VybmVsKHQpe2xldCBuPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKG4pe2ZvcihsZXQgciBvZiBuKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShyLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LG4scil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBhPW8ua2VybmVsVHlwZSxzPW8ua2VybmVsTmFtZSxkPW8ua2VybmVsRW50cnksbD1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7YX1dICR7c31cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGxbMF0mJihsWzFdPWxbMF0obFsxXSksbFswXT12b2lkIDApLG1lKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2F9XSAke3N9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChuLGxbMV0pLDB9Y2F0Y2goZil7cmV0dXJuIHIucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2F9XSAke3N9XCIgZmFpbGVkLiAke2Z9YCkpLDF9ZmluYWxseXtwJiZyLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4oZj0+Zj9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2F9XSAke3N9XCI6ICR7Zi5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgZiBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKGYuaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LG4scixvKXtsZXQgYT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTthfHwoYT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsYSkpO2xldCBzPWEuZ2V0KG4pLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHIsbyxzKTtyZXR1cm4gYS5zZXQobixbZCxyXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgbj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtuJiYobi5mb3JFYWNoKHI9PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHJbMF0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCBuPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiBuLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQsbixyKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBvPWF3YWl0IG5vKHRoaXMsdCxuKTtyZXR1cm4gTnIoby5idWZmZXIscil9fXdyaXRlVGltZXN0YW1wKHQpe3RoaXMucXVlcnlUeXBlPT09XCJpbnNpZGUtcGFzc2VzXCImJnRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsdCl9c2V0UXVlcnlUeXBlKCl7dGhpcy5xdWVyeVR5cGU9XCJub25lXCIsKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGU9PT1cImRlZmF1bHRcInx8KHR5cGVvZiB0aGlzLmVudi50cmFjZT5cInVcIj90aGlzLmVudi53YXNtLnRyYWNlOnRoaXMuZW52LnRyYWNlKSkmJih0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik/dGhpcy5xdWVyeVR5cGU9XCJpbnNpZGUtcGFzc2VzXCI6dGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiYodGhpcy5xdWVyeVR5cGU9XCJhdC1wYXNzZXNcIiksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyfSksdGhpcy5xdWVyeVJlc29sdmVCdWZmZXI9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkV9KSkpfWNhcHR1cmVCZWdpbigpe21lKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7bWUoXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7bWUoXCJpbmZvXCIsXCJyZXBsYXlcIiksdGhpcy5zZXNzaW9uU3RhdHVzPVwicmVwbGF5aW5nXCI7bGV0IHQ9dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLG49dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLHI9dC5sZW5ndGg7dGhpcy5wZW5kaW5nS2VybmVscz1bXTtmb3IobGV0IG89MDtvPHI7bysrKXtsZXQgYT10aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpLHM9dFtvXTt0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpLGEuc2V0UGlwZWxpbmUocy5jb21wdXRlUGlwZWxpbmUpLGEuc2V0QmluZEdyb3VwKDAscy5iaW5kR3JvdXApLGEuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLnMuZGlzcGF0Y2hHcm91cCksdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKG5bb10pLCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmZsdXNoKCl9dGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy51bnJlZ2lzdGVyQnVmZmVycyh0KSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHQpLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXModCkmJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUodCksdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHQpfW9uUnVuU3RhcnQodCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPXQsdGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIFh5LEdjLEp5LEhjLHNuLHVuLGtvLEZjLHFjPUcoKCk9PntcInVzZSBzdHJpY3RcIjt0dCgpO1h5PTEsR2M9KCk9Plh5KyssSnk9bmV3IE1hcChbW1wiZmxvYXQzMlwiLDMyXSxbXCJmbG9hdDE2XCIsMTZdLFtcImludDMyXCIsMzJdLFtcInVpbnQzMlwiLDMyXSxbXCJpbnQ2NFwiLDY0XSxbXCJ1aW50NjRcIiw2NF0sW1wiaW50OFwiLDhdLFtcInVpbnQ4XCIsOF0sW1wiaW50NFwiLDRdLFtcInVpbnQ0XCIsNF1dKSxIYz0oZSx0KT0+e2xldCBuPUp5LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUuXCIpO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgocixvKT0+cipvKSpuLzgpOjB9LHNuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbklkPXQuc2Vzc2lvbklkLHRoaXMubWxDb250ZXh0PXQuY29udGV4dCx0aGlzLm1sVGVuc29yPXQudGVuc29yLHRoaXMuZGF0YVR5cGU9dC5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlPXQuc2hhcGV9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gSGModGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7bWUoXCJ2ZXJib3NlXCIsKCk9PlwiW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3lcIiksdGhpcy5tbFRlbnNvci5kZXN0cm95KCl9d3JpdGUodCl7dGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvcix0KX1hc3luYyByZWFkKHQpe3JldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQsbixyKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09biYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1yLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxhKT0+bz09PXJbYV0pfX0sdW49Y2xhc3N7Y29uc3RydWN0b3IodCxuKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9bn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8pe2xldCBhPXRoaXMudGVuc29yTWFuYWdlci5nZXRNTENvbnRleHQodCk7aWYodGhpcy53cmFwcGVyKXtpZih0aGlzLndyYXBwZXIuY2FuUmV1c2VUZW5zb3IoYSxuLHIpKXJldHVybiB0aGlzLndyYXBwZXIudGVuc29yO2lmKG8pe2lmKHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoIT09SGMobixyKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29weSBkYXRhIHRvIHRlbnNvciB3aXRoIGRpZmZlcmVudCBzaXplLlwiKTt0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheShhd2FpdCB0aGlzLndyYXBwZXIucmVhZCgpKX10aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLndyYXBwZXIpfWxldCBzPXR5cGVvZiBNTFRlbnNvclVzYWdlPlwidVwiP3ZvaWQgMDpNTFRlbnNvclVzYWdlLlJFQUR8TUxUZW5zb3JVc2FnZS5XUklURTtyZXR1cm4gdGhpcy53cmFwcGVyPWF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5nZXRDYWNoZWRUZW5zb3IodCxuLHIscywhMCwhMCksbyYmdGhpcy5hY3RpdmVVcGxvYWQmJih0aGlzLndyYXBwZXIud3JpdGUodGhpcy5hY3RpdmVVcGxvYWQpLHRoaXMuYWN0aXZlVXBsb2FkPXZvaWQgMCksdGhpcy53cmFwcGVyLnRlbnNvcn11cGxvYWQodCl7aWYodGhpcy53cmFwcGVyKWlmKHQuYnl0ZUxlbmd0aD09PXRoaXMud3JhcHBlci5ieXRlTGVuZ3RoKXt0aGlzLndyYXBwZXIud3JpdGUodCk7cmV0dXJufWVsc2UgbWUoXCJ2ZXJib3NlXCIsKCk9PlwiRGF0YSBzaXplIGRvZXMgbm90IG1hdGNoIHRlbnNvciBzaXplLiBSZWxlYXNpbmcgdGVuc29yLlwiKSx0aGlzLnJlbGVhc2VUZW5zb3IoKTt0aGlzLmFjdGl2ZVVwbG9hZD90aGlzLmFjdGl2ZVVwbG9hZC5zZXQodCk6dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkodCl9YXN5bmMgZG93bmxvYWQodCl7aWYodGhpcy5hY3RpdmVVcGxvYWQpaWYodCl7dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP25ldyBVaW50OEFycmF5KHQpLnNldCh0aGlzLmFjdGl2ZVVwbG9hZCk6bmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsdC5ieXRlT2Zmc2V0LHQuYnl0ZUxlbmd0aCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTtyZXR1cm59ZWxzZSByZXR1cm4gdGhpcy5hY3RpdmVVcGxvYWQuYnVmZmVyO2lmKCF0aGlzLndyYXBwZXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIGhhcyBub3QgYmVlbiBjcmVhdGVkLlwiKTtyZXR1cm4gdD90aGlzLndyYXBwZXIucmVhZCh0KTp0aGlzLndyYXBwZXIucmVhZCgpfX0sa289Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQ9bmV3IE1hcDt0aGlzLmZyZWVUZW5zb3JzPVtdO3RoaXMuZXh0ZXJuYWxUZW5zb3JzPW5ldyBTZXR9Z2V0TUxDb250ZXh0KHQpe2xldCBuPXRoaXMuYmFja2VuZC5nZXRNTENvbnRleHQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiTUxDb250ZXh0IG5vdCBmb3VuZCBmb3Igc2Vzc2lvbi5cIik7cmV0dXJuIG59cmVzZXJ2ZVRlbnNvcklkKCl7bGV0IHQ9R2MoKTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KHQsbmV3IHVuKHRoaXMpKSx0fXJlbGVhc2VUZW5zb3JJZCh0KXtsZXQgbj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7biYmKHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmRlbGV0ZSh0KSxuLnRlbnNvcldyYXBwZXImJnRoaXMucmVsZWFzZVRlbnNvcihuLnRlbnNvcldyYXBwZXIpKX1hc3luYyBlbnN1cmVUZW5zb3IodCxuLHIsbyxhKXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke259LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7b30sIGNvcHlPbGQ6ICR7YX19YCk7bGV0IHM9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KG4pO2lmKCFzKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBzLmVuc3VyZVRlbnNvcih0LHIsbyxhKX11cGxvYWQodCxuKXtsZXQgcj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7ci51cGxvYWQobil9YXN5bmMgZG93bmxvYWQodCxuKXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5kb3dubG9hZCB7dGVuc29ySWQ6ICR7dH0sIGRzdEJ1ZmZlcjogJHtuPy5ieXRlTGVuZ3RofX1gKTtsZXQgcj10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7cmV0dXJuIHIuZG93bmxvYWQobil9cmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uKHQpe2ZvcihsZXQgbiBvZiB0aGlzLmZyZWVUZW5zb3JzKW4uc2Vzc2lvbklkPT09dCYmbi5kZXN0cm95KCk7dGhpcy5mcmVlVGVuc29ycz10aGlzLmZyZWVUZW5zb3JzLmZpbHRlcihuPT5uLnNlc3Npb25JZCE9PXQpfXJlZ2lzdGVyVGVuc29yKHQsbixyLG8pe2xldCBhPXRoaXMuZ2V0TUxDb250ZXh0KHQpLHM9R2MoKSxkPW5ldyBzbih7c2Vzc2lvbklkOnQsY29udGV4dDphLHRlbnNvcjpuLGRhdGFUeXBlOnIsc2hhcGU6b30pO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQocyxuZXcgdW4odGhpcyxkKSksdGhpcy5leHRlcm5hbFRlbnNvcnMuYWRkKGQpLHN9YXN5bmMgZ2V0Q2FjaGVkVGVuc29yKHQsbixyLG8sYSxzKXtsZXQgZD10aGlzLmdldE1MQ29udGV4dCh0KTtmb3IobGV0W3AsZl1vZiB0aGlzLmZyZWVUZW5zb3JzLmVudHJpZXMoKSlpZihmLmNhblJldXNlVGVuc29yKGQsbixyKSl7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFJldXNpbmcgdGVuc29yIHtkYXRhVHlwZTogJHtufSwgc2hhcGU6ICR7cn19YCk7bGV0IGg9dGhpcy5mcmVlVGVuc29ycy5zcGxpY2UocCwxKVswXTtyZXR1cm4gaC5zZXNzaW9uSWQ9dCxofW1lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBNTENvbnRleHQuY3JlYXRlVGVuc29yIHtkYXRhVHlwZTogJHtufSwgc2hhcGU6ICR7cn19YCk7bGV0IGw9YXdhaXQgZC5jcmVhdGVUZW5zb3Ioe2RhdGFUeXBlOm4sc2hhcGU6cixkaW1lbnNpb25zOnIsdXNhZ2U6byx3cml0YWJsZTphLHJlYWRhYmxlOnN9KTtyZXR1cm4gbmV3IHNuKHtzZXNzaW9uSWQ6dCxjb250ZXh0OmQsdGVuc29yOmwsZGF0YVR5cGU6bixzaGFwZTpyfSl9cmVsZWFzZVRlbnNvcih0KXt0aGlzLmV4dGVybmFsVGVuc29ycy5oYXModCkmJnRoaXMuZXh0ZXJuYWxUZW5zb3JzLmRlbGV0ZSh0KSx0aGlzLmZyZWVUZW5zb3JzLnB1c2godCl9fSxGYz0oLi4uZSk9Pm5ldyBrbyguLi5lKX0pO3ZhciBFbyxlYixkbixLYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtidCgpO0puKCk7cWMoKTt0dCgpO0VvPW5ldyBNYXAoW1sxLFwiZmxvYXQzMlwiXSxbMTAsXCJmbG9hdDE2XCJdLFs2LFwiaW50MzJcIl0sWzEyLFwidWludDMyXCJdLFs3LFwiaW50NjRcIl0sWzEzLFwidWludDY0XCJdLFsyMixcImludDRcIl0sWzIxLFwidWludDRcIl0sWzMsXCJpbnQ4XCJdLFsyLFwidWludDhcIl0sWzksXCJ1aW50OFwiXV0pLGViPShlLHQpPT57aWYoZT09PXQpcmV0dXJuITA7aWYoZT09PXZvaWQgMHx8dD09PXZvaWQgMClyZXR1cm4hMTtsZXQgbj1PYmplY3Qua2V5cyhlKS5zb3J0KCkscj1PYmplY3Qua2V5cyh0KS5zb3J0KCk7cmV0dXJuIG4ubGVuZ3RoPT09ci5sZW5ndGgmJm4uZXZlcnkoKG8sYSk9Pm89PT1yW2FdJiZlW29dPT09dFtvXSl9LGRuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMudGVuc29yTWFuYWdlcj1GYyh0aGlzKTt0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkPW5ldyBNYXA7dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQ9bmV3IE1hcDt0aGlzLm1sQ29udGV4dENhY2hlPVtdO3RoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzPW5ldyBNYXA7dGhpcy50ZW1wb3JhcnlHcmFwaElucHV0cz1bXTt0aGlzLnRlbXBvcmFyeVNlc3Npb25UZW5zb3JJZHM9bmV3IE1hcDtVcih0LmxvZ0xldmVsLCEhdC5kZWJ1Zyl9Z2V0IGN1cnJlbnRTZXNzaW9uSWQoKXtpZih0aGlzLmFjdGl2ZVNlc3Npb25JZD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgc2Vzc2lvblwiKTtyZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWR9b25SdW5TdGFydCh0KXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gb25SdW5TdGFydCB7c2Vzc2lvbklkOiAke3R9fWApLHRoaXMuYWN0aXZlU2Vzc2lvbklkPXR9b25SdW5FbmQodCl7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIG9uUnVuRW5kIHtzZXNzaW9uSWQ6ICR7dH19YCk7bGV0IG49dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldCh0KTtpZihuKXtmb3IobGV0IHIgb2YgbiltZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzaW5nIHRlbXBvcmFyeSB0ZW5zb3Ige3RlbnNvcklkOiAke3J9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQocik7dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmRlbGV0ZSh0KSx0aGlzLmFjdGl2ZVNlc3Npb25JZD12b2lkIDB9fWFzeW5jIGNyZWF0ZU1MQ29udGV4dCh0KXtpZih0IGluc3RhbmNlb2YgR1BVRGV2aWNlKXtsZXQgcj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLmdwdURldmljZT09PXQpO2lmKHIhPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtyXS5tbENvbnRleHQ7e2xldCBvPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHQpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe2dwdURldmljZTp0LG1sQ29udGV4dDpvfSksb319ZWxzZSBpZih0PT09dm9pZCAwKXtsZXQgcj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLm9wdGlvbnM9PT12b2lkIDAmJm8uZ3B1RGV2aWNlPT09dm9pZCAwKTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe21sQ29udGV4dDpvfSksb319bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgocj0+ZWIoci5vcHRpb25zLHQpKTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgcj1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtvcHRpb25zOnQsbWxDb250ZXh0OnJ9KSxyfX1yZWdpc3Rlck1MQ29udGV4dCh0LG4pe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQsbik7bGV0IHI9dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KG4pO3J8fChyPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KG4scikpLHIuYWRkKHQpLHRoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMubGVuZ3RoPjAmJih0aGlzLnNlc3Npb25HcmFwaElucHV0cy5zZXQodCx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzKSx0aGlzLnRlbXBvcmFyeUdyYXBoSW5wdXRzPVtdKX1vblJlbGVhc2VTZXNzaW9uKHQpe3RoaXMuc2Vzc2lvbkdyYXBoSW5wdXRzLmRlbGV0ZSh0KTtsZXQgbj10aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KTtpZighbilyZXR1cm47dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KSx0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmRlbGV0ZSh0KTtsZXQgcj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQobik7aWYoci5kZWxldGUodCksci5zaXplPT09MCl7dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZGVsZXRlKG4pO2xldCBvPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KGE9PmEubWxDb250ZXh0PT09bik7byE9PS0xJiZ0aGlzLm1sQ29udGV4dENhY2hlLnNwbGljZShvLDEpfX1nZXRNTENvbnRleHQodCl7cmV0dXJuIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHQpfXJlc2VydmVUZW5zb3JJZCgpe3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIucmVzZXJ2ZVRlbnNvcklkKCl9cmVsZWFzZVRlbnNvcklkKHQpe21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3R9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQodCl9YXN5bmMgZW5zdXJlVGVuc29yKHQsbixyLG8sYSl7bGV0IHM9RW8uZ2V0KHIpO2lmKCFzKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgT05OWCBkYXRhIHR5cGU6ICR7cn1gKTtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvcih0Pz90aGlzLmN1cnJlbnRTZXNzaW9uSWQsbixzLG8sYSl9YXN5bmMgY3JlYXRlVGVtcG9yYXJ5VGVuc29yKHQsbixyKXttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gY3JlYXRlVGVtcG9yYXJ5VGVuc29yIHtvbm54RGF0YVR5cGU6ICR7bn0sIHNoYXBlOiAke3J9fWApO2xldCBvPUVvLmdldChuKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke259YCk7bGV0IGE9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpO2F3YWl0IHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodCxhLG8sciwhMSk7bGV0IHM9dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLmdldCh0KTtyZXR1cm4gcz9zLnB1c2goYSk6dGhpcy50ZW1wb3JhcnlTZXNzaW9uVGVuc29ySWRzLnNldCh0LFthXSksYX11cGxvYWRUZW5zb3IodCxuKXtpZighSWUoKS5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IpdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIHVwbG9hZCB0byBhIE1MVGVuc29yIHdoaWxlIHNob3VsZFRyYW5zZmVyVG9NTFRlbnNvciBpcyBmYWxzZVwiKTttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gdXBsb2FkVGVuc29yIHt0ZW5zb3JJZDogJHt0fSwgZGF0YTogJHtuLmJ5dGVMZW5ndGh9fWApLHRoaXMudGVuc29yTWFuYWdlci51cGxvYWQodCxuKX1hc3luYyBkb3dubG9hZFRlbnNvcih0LG4pe3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodCxuKX1jcmVhdGVNTFRlbnNvckRvd25sb2FkZXIodCxuKXtyZXR1cm4gYXN5bmMoKT0+e2xldCByPWF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0KTtyZXR1cm4gTnIocixuKX19cmVnaXN0ZXJNTFRlbnNvcih0LG4scixvKXtsZXQgYT1Fby5nZXQocik7aWYoIWEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO2xldCBzPXRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcih0LG4sYSxvKTtyZXR1cm4gbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHtufSwgZGF0YVR5cGU6ICR7YX0sIGRpbWVuc2lvbnM6ICR7b319IC0+IHt0ZW5zb3JJZDogJHtzfX1gKSxzfXJlZ2lzdGVyTUxDb25zdGFudCh0LG4scixvLGEscyl7aWYoIXMpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IGQ9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGQ9dC5zdWJzdHJpbmcoMikpO2xldCBsPXMuZ2V0KGQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtkfSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKG4rcj5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgcD1sLnNsaWNlKG4sbityKS5idWZmZXIsZjtzd2l0Y2goYS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOmY9bmV3IEZsb2F0MzJBcnJheShwKTticmVhaztjYXNlXCJmbG9hdDE2XCI6Zj1uZXcgVWludDE2QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50MzJcIjpmPW5ldyBJbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQzMlwiOmY9bmV3IFVpbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImludDY0XCI6Zj1uZXcgQmlnSW50NjRBcnJheShwKTticmVhaztjYXNlXCJ1aW50NjRcIjpmPW5ldyBCaWdVaW50NjRBcnJheShwKTticmVhaztjYXNlXCJpbnQ4XCI6Zj1uZXcgSW50OEFycmF5KHApO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6Zj1uZXcgVWludDhBcnJheShwKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2EuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7YS5kYXRhVHlwZX0sIHNoYXBlOiAke2Euc2hhcGV9fX1gKSxvLmNvbnN0YW50KGEsZil9cmVnaXN0ZXJHcmFwaElucHV0KHQpe3RoaXMudGVtcG9yYXJ5R3JhcGhJbnB1dHMucHVzaCh0KX1pc0dyYXBoSW5wdXQodCxuKXtsZXQgcj10aGlzLnNlc3Npb25HcmFwaElucHV0cy5nZXQodCk7cmV0dXJuIHI/ci5pbmNsdWRlcyhuKTohMX1mbHVzaCgpe319fSk7dmFyIGpjPXt9O1p0KGpjLHtpbml0OigpPT50Yn0pO3ZhciBpcixQbyx0YixaYz1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtMYygpO3R0KCk7YWUoKTtLYygpO2lyPWNsYXNzIGV7Y29uc3RydWN0b3IodCxuLHIsbyl7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPW47dGhpcy5kYXRhPXI7dGhpcy5kaW1zPW99Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9RS5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1FLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9RS5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0VWludDE2QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MTAmJnRoaXMuZGF0YVR5cGUhPT00KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUUuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgVWludDE2QXJyYXk6bmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZihFLnNpemUodCkhPT1FLnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSxQbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LG4scil7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9bjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7dGhpcy5hZGFwdGVySW5mbz1uLmFkYXB0ZXJJbmZvLHRoaXMuZGV2aWNlSW5mbz1uLmRldmljZUluZm87bGV0IG89dC5QVFJfU0laRSxhPXIvdC5QVFJfU0laRSxzPW89PT00P1wiaTMyXCI6XCJpNjRcIjt0aGlzLm9wS2VybmVsQ29udGV4dD1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSk7bGV0IGQ9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpO3RoaXMub3V0cHV0Q291bnQ9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxcIipcIikpLHRoaXMuY3VzdG9tRGF0YVNpemU9TnVtYmVyKHQuZ2V0VmFsdWUobyphKysscykpO2xldCBsPVtdO2ZvcihsZXQgcD0wO3A8ZDtwKyspe2xldCBmPU51bWJlcih0LmdldFZhbHVlKG8qYSsrLHMpKSxoPU51bWJlcih0LmdldFZhbHVlKG8qYSsrLFwiKlwiKSkseT1OdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSksXz1bXTtmb3IobGV0IGI9MDtiPHk7YisrKV8ucHVzaChOdW1iZXIodC5nZXRWYWx1ZShvKmErKyxzKSkpO2wucHVzaChuZXcgaXIodCxmLGgsXykpfXRoaXMuaW5wdXRzPWx9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxuKXtsZXQgcj1uPy5pbnB1dHM/Lm1hcChkPT50eXBlb2YgZD09XCJudW1iZXJcIj90aGlzLmlucHV0c1tkXTpkKT8/dGhpcy5pbnB1dHMsbz1uPy5vdXRwdXRzPz9bXSxhPShkLGwscCk9Pm5ldyBpcih0aGlzLm1vZHVsZSxsLHRoaXMub3V0cHV0KGQscCkscCkscz0oZCxsKT0+e2xldCBwPXd0KGQsbCk7aWYoIXApdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZH1gKTtsZXQgZj1wPjA/dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShwKS5pZDowO3JldHVybiBuZXcgaXIodGhpcy5tb2R1bGUsZCxmLGwpfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LHIsbyxhLHMsdGhpcy5vdXRwdXRDb3VudCl9b3V0cHV0KHQsbil7bGV0IHI9dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBvPXRoaXMubW9kdWxlLlBUUl9TSVpFLGE9bz09PTQ/XCJpMzJcIjpcImk2NFwiLHM9dGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMStuLmxlbmd0aCkqbyk7dGhpcy5tb2R1bGUuc2V0VmFsdWUocyxuLmxlbmd0aCxhKTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKyl0aGlzLm1vZHVsZS5zZXRWYWx1ZShzK28qKGQrMSksbltkXSxhKTtyZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQodGhpcy5vcEtlcm5lbENvbnRleHQsdCxzKX1jYXRjaChvKXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWwncyBvdXRwdXRbJHt0fV0gd2l0aCBkaW1zIFske259XS4gSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuIEVycm9yOiAke299YCl9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUocil9fX0sdGI9YXN5bmMoZSx0LG4scik9PntsZXQgbz10LmpzZXBJbml0O2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIEpTRVAuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LlwiKTtpZihlPT09XCJ3ZWJncHVcIil7bGV0IGE9bmV3IGFuO2F3YWl0IGEuaW5pdGlhbGl6ZShuLHIpLG8oXCJ3ZWJncHVcIixbYSxzPT5hLmFsbG9jKE51bWJlcihzKSkscz0+YS5mcmVlKHMpLChzLGQsbCxwPSExKT0+e2lmKHApbWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtOdW1iZXIocyl9LCBkc3Q9JHtOdW1iZXIoZCl9LCBzaXplPSR7TnVtYmVyKGwpfWApLGEubWVtY3B5KE51bWJlcihzKSxOdW1iZXIoZCkpO2Vsc2V7bWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKHMpfSwgZ3B1RGF0YUlkPSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKTtsZXQgZj10LkhFQVBVOC5zdWJhcnJheShOdW1iZXIocz4+PjApLE51bWJlcihzPj4+MCkrTnVtYmVyKGwpKTthLnVwbG9hZChOdW1iZXIoZCksZil9fSxhc3luYyhzLGQsbCk9PnttZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke3N9LCBkYXRhT2Zmc2V0PSR7ZH0sIHNpemU9JHtsfWApLGF3YWl0IGEuZG93bmxvYWQoTnVtYmVyKHMpLCgpPT50LkhFQVBVOC5zdWJhcnJheShOdW1iZXIoZCk+Pj4wLE51bWJlcihkK2wpPj4+MCkpfSwocyxkLGwpPT5hLmNyZWF0ZUtlcm5lbChzLE51bWJlcihkKSxsLHQuVVRGOFRvU3RyaW5nKHQuX0pzZXBHZXROb2RlTmFtZShOdW1iZXIoZCkpKSkscz0+YS5yZWxlYXNlS2VybmVsKHMpLChzLGQsbCxwKT0+e21lKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke2x9LCBrZXJuZWw9JHtzfSwgY29udGV4dERhdGFPZmZzZXQ9JHtkfWApO2xldCBmPW5ldyBQbyh0LGEsTnVtYmVyKGQpKTtyZXR1cm4gYS5jb21wdXRlS2VybmVsKE51bWJlcihzKSxmLHApfSwoKT0+YS5jYXB0dXJlQmVnaW4oKSwoKT0+YS5jYXB0dXJlRW5kKCksKCk9PmEucmVwbGF5KCldKX1lbHNle2xldCBhPW5ldyBkbihuKTtvKFwid2Vibm5cIixbYSwoKT0+YS5yZXNlcnZlVGVuc29ySWQoKSxzPT5hLnJlbGVhc2VUZW5zb3JJZChzKSxhc3luYyhzLGQsbCxwLGYpPT5hLmVuc3VyZVRlbnNvcihzLGQsbCxwLGYpLChzLGQpPT57YS51cGxvYWRUZW5zb3IocyxkKX0sYXN5bmMocyxkKT0+YS5kb3dubG9hZFRlbnNvcihzLGQpXSl9fX0pO3ZhciByYixDcixJcix6dCxuYixZdCxBcixrcixRYyxFcixQcix6cixxbj1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7enMoKTtEcygpO3RlKCk7YnQoKTtEcigpO1huKCk7cmI9KGUsdCk9PntJZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZoZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxDcj1hc3luYyBlPT57cmIoZS53YXNtLm51bVRocmVhZHMsSnQoZS5sb2dMZXZlbCkpfSxJcj1hc3luYyhlLHQpPT57e2xldCBuPShaYygpLGJyKGpjKSkuaW5pdDtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtsZXQgcj1lLndlYmdwdS5hZGFwdGVyO2lmKHIpe2lmKHR5cGVvZiByLmxpbWl0cyE9XCJvYmplY3RcInx8dHlwZW9mIHIuZmVhdHVyZXMhPVwib2JqZWN0XCJ8fHR5cGVvZiByLnJlcXVlc3REZXZpY2UhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LlwiKX1lbHNle2xldCBvPWUud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtpZihvIT09dm9pZCAwJiZvIT09XCJsb3ctcG93ZXJcIiYmbyE9PVwiaGlnaC1wZXJmb3JtYW5jZVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke299XCJgKTtsZXQgYT1lLndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtpZihhIT09dm9pZCAwJiZ0eXBlb2YgYSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHthfVwiYCk7aWYocj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2U6byxmb3JjZUZhbGxiYWNrQWRhcHRlcjphfSksIXIpdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyl9YXdhaXQgbihcIndlYmdwdVwiLEllKCksZSxyKX1pZih0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLm1sKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTthd2FpdCBuKFwid2Vibm5cIixJZSgpLGUpfX19LHp0PW5ldyBNYXAsbmI9ZT0+e2xldCB0PUllKCksbj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgcj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqcik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytyKSE9PTAmJmhlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgcz1yPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8scykpLE51bWJlcih0LmdldFZhbHVlKG8rcixzKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fSxZdD1lPT57bGV0IHQ9SWUoKSxuPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKG49PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxuKSxbbixlLmJ5dGVMZW5ndGhdfSxBcj1hc3luYyhlLHQpPT57bGV0IG4scixvPUllKCk7QXJyYXkuaXNBcnJheShlKT9bbixyXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tuLHJdPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbbixyXT1ZdChlKTtsZXQgYT0wLHM9MCxkPTAsbD1bXSxwPVtdLGY9W107dHJ5e2lmKFtzLGxdPU9zKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHY9W107Zm9yKGxldCBUIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgQz10eXBlb2YgVD09XCJzdHJpbmdcIj9UOlQucGF0aDt2LnB1c2goZXIodHlwZW9mIFQ9PVwic3RyaW5nXCI/VDpULmRhdGEpLnRoZW4oQT0+e28ubW91bnRFeHRlcm5hbERhdGEoQyxBKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh2KX1mb3IobGV0IHYgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdiE9XCJzdHJpbmdcIil7bGV0IEM9dixBPUM/LmNvbnRleHQsaz1DPy5ncHVEZXZpY2UsTz1DPy5kZXZpY2VUeXBlLE09Qz8ucG93ZXJQcmVmZXJlbmNlO0E/by5jdXJyZW50Q29udGV4dD1BOms/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoayk6by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6Tyxwb3dlclByZWZlcmVuY2U6TX0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31hPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24obixyLHMpLGE9PT0wJiZoZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpLG8uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCksby5jdXJyZW50Q29udGV4dCYmKG8uanNlcFJlZ2lzdGVyTUxDb250ZXh0KGEsby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFtoLHldPW5iKGEpLF89ISF0Py5lbmFibGVHcmFwaENhcHR1cmUsYj1bXSx3PVtdLFM9W107Zm9yKGxldCB2PTA7djxoO3YrKyl7bGV0IFQ9by5fT3J0R2V0SW5wdXROYW1lKGEsdik7VD09PTAmJmhlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLHAucHVzaChUKSxiLnB1c2goby5VVEY4VG9TdHJpbmcoVCkpfWZvcihsZXQgdj0wO3Y8eTt2Kyspe2xldCBUPW8uX09ydEdldE91dHB1dE5hbWUoYSx2KTtUPT09MCYmaGUoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLGYucHVzaChUKTtsZXQgQz1vLlVURjhUb1N0cmluZyhUKTt3LnB1c2goQyk7e2lmKF8mJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXtTLnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bQ10/P1wiY3B1XCI7aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihfJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO1MucHVzaChBKX19bGV0ICQ9bnVsbDtyZXR1cm4gUy5zb21lKHY9PnY9PT1cImdwdS1idWZmZXJcInx8dj09PVwibWwtdGVuc29yXCIpJiYoZD1vLl9PcnRDcmVhdGVCaW5kaW5nKGEpLGQ9PT0wJiZoZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6ZCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6UyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOlMubWFwKHY9PlluKHYpKX0pLHp0LnNldChhLFthLHAsZiwkLF8sITFdKSxbYSxiLHddfWNhdGNoKGgpe3Rocm93IHAuZm9yRWFjaCh5PT5vLl9PcnRGcmVlKHkpKSxmLmZvckVhY2goeT0+by5fT3J0RnJlZSh5KSksZCE9PTAmJm8uX09ydFJlbGVhc2VCaW5kaW5nKGQpIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGEhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihhKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxofWZpbmFsbHl7by5fZnJlZShuKSxzIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHMpIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbC5mb3JFYWNoKGg9Pm8uX2ZyZWUoaCkpLG8udW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxrcj1lPT57bGV0IHQ9SWUoKSxuPXp0LmdldChlKTtpZighbil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtyLG8sYSxzLGRdPW47cyYmKGQmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKHMuaGFuZGxlKSE9PTAmJmhlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcocy5oYW5kbGUpIT09MCYmaGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksby5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLGEuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihyKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx6dC5kZWxldGUoZSl9LFFjPWFzeW5jKGUsdCxuLHIsbyxhPSExKT0+e2lmKCFlKXt0LnB1c2goMCk7cmV0dXJufWxldCBzPUllKCksZD1zLlBUUl9TSVpFLGw9ZVswXSxwPWVbMV0sZj1lWzNdLGg9Zix5LF87aWYobD09PVwic3RyaW5nXCImJihmPT09XCJncHUtYnVmZmVyXCJ8fGY9PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihhJiZmIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7b30gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihmPT09XCJncHUtYnVmZmVyXCIpe2xldCBTPWVbMl0uZ3B1QnVmZmVyO189d3QoUnQobCkscCk7bGV0ICQ9cy5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoISQpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTt5PSQocixvLFMsXyl9ZWxzZSBpZihmPT09XCJtbC10ZW5zb3JcIil7bGV0IFM9ZVsyXS5tbFRlbnNvcjtfPXd0KFJ0KGwpLHApO2xldCAkPXMuanNlcFJlZ2lzdGVyTUxUZW5zb3I7aWYoISQpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7eT0kKHIsUyxSdChsKSxwKX1lbHNle2xldCBTPWVbMl07aWYoQXJyYXkuaXNBcnJheShTKSl7Xz1kKlMubGVuZ3RoLHk9cy5fbWFsbG9jKF8pLG4ucHVzaCh5KTtmb3IobGV0ICQ9MDskPFMubGVuZ3RoOyQrKyl7aWYodHlwZW9mIFNbJF0hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHskfSBpcyBub3QgYSBzdHJpbmdgKTtzLnNldFZhbHVlKHkrJCpkLFBlKFNbJF0sbiksXCIqXCIpfX1lbHNle2xldCAkPXMuanNlcElzR3JhcGhJbnB1dDtpZihsIT09XCJzdHJpbmdcIiYmJCl7bGV0IHY9cy5fT3J0R2V0SW5wdXROYW1lKHIsbyksVD1zLlVURjhUb1N0cmluZyh2KTtpZigkKHIsVCkpe2xldCBDPVJ0KGwpO189d3QoQyxwKSxoPVwibWwtdGVuc29yXCI7bGV0IEE9cy5qc2VwQ3JlYXRlVGVtcG9yYXJ5VGVuc29yLGs9cy5qc2VwVXBsb2FkVGVuc29yO2lmKCFBfHwhayl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtsZXQgTz1hd2FpdCBBKHIsQyxwKTtrKE8sbmV3IFVpbnQ4QXJyYXkoUy5idWZmZXIsUy5ieXRlT2Zmc2V0LFMuYnl0ZUxlbmd0aCkpLHk9T31lbHNlIF89Uy5ieXRlTGVuZ3RoLHk9cy5fbWFsbG9jKF8pLG4ucHVzaCh5KSxzLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoUy5idWZmZXIsUy5ieXRlT2Zmc2V0LF8pLHkpfWVsc2UgXz1TLmJ5dGVMZW5ndGgseT1zLl9tYWxsb2MoXyksbi5wdXNoKHkpLHMuSEVBUFU4LnNldChuZXcgVWludDhBcnJheShTLmJ1ZmZlcixTLmJ5dGVPZmZzZXQsXykseSl9fWxldCBiPXMuc3RhY2tTYXZlKCksdz1zLnN0YWNrQWxsb2MoNCpwLmxlbmd0aCk7dHJ5e3AuZm9yRWFjaCgoJCx2KT0+cy5zZXRWYWx1ZSh3K3YqZCwkLGQ9PT00P1wiaTMyXCI6XCJpNjRcIikpO2xldCBTPXMuX09ydENyZWF0ZVRlbnNvcihSdChsKSx5LF8sdyxwLmxlbmd0aCxZbihoKSk7Uz09PTAmJmhlKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtyfSwgaW5kZXg9JHtvfS5gKSx0LnB1c2goUyl9ZmluYWxseXtzLnN0YWNrUmVzdG9yZShiKX19LEVyPWFzeW5jKGUsdCxuLHIsbyxhKT0+e2xldCBzPUllKCksZD1zLlBUUl9TSVpFLGw9enQuZ2V0KGUpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldCBwPWxbMF0sZj1sWzFdLGg9bFsyXSx5PWxbM10sXz1sWzRdLGI9bFs1XSx3PXQubGVuZ3RoLFM9ci5sZW5ndGgsJD0wLHY9W10sVD1bXSxDPVtdLEE9W10saz1zLnN0YWNrU2F2ZSgpLE89cy5zdGFja0FsbG9jKHcqZCksTT1zLnN0YWNrQWxsb2ModypkKSxWPXMuc3RhY2tBbGxvYyhTKmQpLEY9cy5zdGFja0FsbG9jKFMqZCk7dHJ5e1skLHZdPVBzKGEpO2ZvcihsZXQgVz0wO1c8dztXKyspYXdhaXQgUWMobltXXSxULEEsZSx0W1ddLF8pO2ZvcihsZXQgVz0wO1c8UztXKyspYXdhaXQgUWMob1tXXSxDLEEsZSx3K3JbV10sXyk7Zm9yKGxldCBXPTA7Vzx3O1crKylzLnNldFZhbHVlKE8rVypkLFRbV10sXCIqXCIpLHMuc2V0VmFsdWUoTStXKmQsZlt0W1ddXSxcIipcIik7Zm9yKGxldCBXPTA7VzxTO1crKylzLnNldFZhbHVlKFYrVypkLENbV10sXCIqXCIpLHMuc2V0VmFsdWUoRitXKmQsaFtyW1ddXSxcIipcIik7aWYoeSYmIWIpe2xldHtoYW5kbGU6VyxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6SixvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOnZlfT15O2lmKGYubGVuZ3RoIT09dyl0aHJvdyBuZXcgRXJyb3IoYGlucHV0IGNvdW50IGZyb20gZmVlZHMgKCR7d30pIGlzIGV4cGVjdGVkIHRvIGJlIGFsd2F5cyBlcXVhbCB0byBtb2RlbCdzIGlucHV0IGNvdW50ICgke2YubGVuZ3RofSkuYCk7Zm9yKGxldCBRPTA7UTx3O1ErKyl7bGV0IGVlPXRbUV07YXdhaXQgcy5fT3J0QmluZElucHV0KFcsZltlZV0sVFtRXSkhPT0wJiZoZShgQ2FuJ3QgYmluZCBpbnB1dFske1F9XSBmb3Igc2Vzc2lvbj0ke2V9LmApfWZvcihsZXQgUT0wO1E8UztRKyspe2xldCBlZT1yW1FdO29bUV0/LlszXT9zLl9PcnRCaW5kT3V0cHV0KFcsaFtlZV0sQ1tRXSwwKSE9PTAmJmhlKGBDYW4ndCBiaW5kIHByZS1hbGxvY2F0ZWQgb3V0cHV0WyR7UX1dIGZvciBzZXNzaW9uPSR7ZX0uYCk6cy5fT3J0QmluZE91dHB1dChXLGhbZWVdLDAsdmVbZWVdKSE9PTAmJmhlKGBDYW4ndCBiaW5kIG91dHB1dFske1F9XSB0byAke0pbUV19IGZvciBzZXNzaW9uPSR7ZX0uYCl9enQuc2V0KGUsW3AsZixoLHksXywhMF0pfXMuanNlcE9uUnVuU3RhcnQ/LihwKTtsZXQgajt5P2o9YXdhaXQgcy5fT3J0UnVuV2l0aEJpbmRpbmcocCx5LmhhbmRsZSxTLFYsJCk6aj1hd2FpdCBzLl9PcnRSdW4ocCxNLE8sdyxGLFMsViwkKSxqIT09MCYmaGUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IG5lPVtdO2ZvcihsZXQgVz0wO1c8UztXKyspe2xldCBKPU51bWJlcihzLmdldFZhbHVlKFYrVypkLFwiKlwiKSk7aWYoSj09PUNbV10pe25lLnB1c2gob1tXXSk7Y29udGludWV9bGV0IHZlPXMuc3RhY2tTYXZlKCksUT1zLnN0YWNrQWxsb2MoNCpkKSxlZT0hMSxsZSxaPTA7dHJ5e3MuX09ydEdldFRlbnNvckRhdGEoSixRLFErZCxRKzIqZCxRKzMqZCkhPT0wJiZoZShgQ2FuJ3QgYWNjZXNzIG91dHB1dCB0ZW5zb3IgZGF0YSBvbiBpbmRleCAke1d9LmApO2xldCBrZT1kPT09ND9cImkzMlwiOlwiaTY0XCIsU2U9TnVtYmVyKHMuZ2V0VmFsdWUoUSxrZSkpO1o9cy5nZXRWYWx1ZShRK2QsXCIqXCIpO2xldCBEPXMuZ2V0VmFsdWUoUStkKjIsXCIqXCIpLFI9TnVtYmVyKHMuZ2V0VmFsdWUoUStkKjMsa2UpKSxZPVtdO2ZvcihsZXQgeGU9MDt4ZTxSO3hlKyspWS5wdXNoKE51bWJlcihzLmdldFZhbHVlKEQreGUqZCxrZSkpKTtzLl9PcnRGcmVlKEQpIT09MCYmaGUoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBmZT1ZLnJlZHVjZSgoeGUsYmUpPT54ZSpiZSwxKTtsZT1fdChTZSk7bGV0IEZlPXk/Lm91dHB1dFByZWZlcnJlZExvY2F0aW9uc1tyW1ddXTtpZihsZT09PVwic3RyaW5nXCIpe2lmKEZlPT09XCJncHUtYnVmZmVyXCJ8fEZlPT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgeGU9W107Zm9yKGxldCBiZT0wO2JlPGZlO2JlKyspe2xldCBZZT1zLmdldFZhbHVlKForYmUqZCxcIipcIiksR3Q9cy5nZXRWYWx1ZShaKyhiZSsxKSpkLFwiKlwiKSx4dD1iZT09PWZlLTE/dm9pZCAwOkd0LVllO3hlLnB1c2gocy5VVEY4VG9TdHJpbmcoWWUseHQpKX1uZS5wdXNoKFtsZSxZLHhlLFwiY3B1XCJdKX1lbHNlIGlmKEZlPT09XCJncHUtYnVmZmVyXCImJmZlPjApe2xldCB4ZT1zLmpzZXBHZXRCdWZmZXI7aWYoIXhlKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtsZXQgYmU9eGUoWiksWWU9d3QoU2UsZmUpO2lmKFllPT09dm9pZCAwfHwhTXIobGUpKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2xlfWApO2VlPSEwLG5lLnB1c2goW2xlLFkse2dwdUJ1ZmZlcjpiZSxkb3dubG9hZDpzLmpzZXBDcmVhdGVEb3dubG9hZGVyKGJlLFllLGxlKSxkaXNwb3NlOigpPT57cy5fT3J0UmVsZWFzZVRlbnNvcihKKSE9PTAmJmhlKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNlIGlmKEZlPT09XCJtbC10ZW5zb3JcIiYmZmU+MCl7bGV0IHhlPXMuanNlcEVuc3VyZVRlbnNvcjtpZigheGUpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZih3dChTZSxmZSk9PT12b2lkIDB8fCFScihsZSkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7bGV9YCk7bGV0IFllPWF3YWl0IHhlKGUsWixTZSxZLCExKTtlZT0hMCxuZS5wdXNoKFtsZSxZLHttbFRlbnNvcjpZZSxkb3dubG9hZDpzLmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIoWixsZSksZGlzcG9zZTooKT0+e3MuanNlcFJlbGVhc2VUZW5zb3JJZChaKSxzLl9PcnRSZWxlYXNlVGVuc29yKEopfX0sXCJtbC10ZW5zb3JcIl0pfWVsc2V7bGV0IHhlPUJyKGxlKSxiZT1uZXcgeGUoZmUpO25ldyBVaW50OEFycmF5KGJlLmJ1ZmZlcixiZS5ieXRlT2Zmc2V0LGJlLmJ5dGVMZW5ndGgpLnNldChzLkhFQVBVOC5zdWJhcnJheShaLForYmUuYnl0ZUxlbmd0aCkpLG5lLnB1c2goW2xlLFksYmUsXCJjcHVcIl0pfX1maW5hbGx5e3Muc3RhY2tSZXN0b3JlKHZlKSxsZT09PVwic3RyaW5nXCImJlomJnMuX2ZyZWUoWiksZWV8fHMuX09ydFJlbGVhc2VUZW5zb3IoSikscy5qc2VwT25SdW5FbmQ/LihwKX19cmV0dXJuIHkmJiFfJiYocy5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoeS5oYW5kbGUpIT09MCYmaGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSx6dC5zZXQoZSxbcCxmLGgseSxfLCExXSkpLG5lfWZpbmFsbHl7cy5zdGFja1Jlc3RvcmUoayksVC5mb3JFYWNoKGo9PnMuX09ydFJlbGVhc2VUZW5zb3IoaikpLEMuZm9yRWFjaChqPT5zLl9PcnRSZWxlYXNlVGVuc29yKGopKSxBLmZvckVhY2goaj0+cy5fZnJlZShqKSksJCE9PTAmJnMuX09ydFJlbGVhc2VSdW5PcHRpb25zKCQpLHYuZm9yRWFjaChqPT5zLl9mcmVlKGopKX19LFByPWU9PntsZXQgdD1JZSgpLG49enQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgcj1uWzBdLG89dC5fT3J0RW5kUHJvZmlsaW5nKHIpO289PT0wJiZoZShcIkNhbid0IGdldCBhbiBwcm9maWxlIGZpbGUgbmFtZS5cIiksdC5fT3J0RnJlZShvKX0senI9ZT0+e2xldCB0PVtdO2ZvcihsZXQgbiBvZiBlKXtsZXQgcj1uWzJdOyFBcnJheS5pc0FycmF5KHIpJiZcImJ1ZmZlclwiaW4gciYmdC5wdXNoKHIuYnVmZmVyKX1yZXR1cm4gdH19KTt2YXIgT3QsSGUsYXIsY24scG4sbG4sem8sT28sV3QsTHQsaWIsWWMsWGMsSmMsZXAsdHAscnAsbnAsRG89RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7cW4oKTtidCgpO1NyKCk7T3Q9KCk9PiEhd2Uud2FzbS5wcm94eSYmdHlwZW9mIGRvY3VtZW50PFwidVwiLGFyPSExLGNuPSExLHBuPSExLE9vPW5ldyBNYXAsV3Q9KGUsdCk9PntsZXQgbj1Pby5nZXQoZSk7bj9uLnB1c2godCk6T28uc2V0KGUsW3RdKX0sTHQ9KCk9PntpZihhcnx8IWNufHxwbnx8IUhlKXRocm93IG5ldyBFcnJvcihcIndvcmtlciBub3QgcmVhZHlcIil9LGliPWU9Pntzd2l0Y2goZS5kYXRhLnR5cGUpe2Nhc2VcImluaXQtd2FzbVwiOmFyPSExLGUuZGF0YS5lcnI/KHBuPSEwLHpvWzFdKGUuZGF0YS5lcnIpKTooY249ITAsem9bMF0oKSksbG4mJihVUkwucmV2b2tlT2JqZWN0VVJMKGxuKSxsbj12b2lkIDApO2JyZWFrO2Nhc2VcImluaXQtZXBcIjpjYXNlXCJjb3B5LWZyb21cIjpjYXNlXCJjcmVhdGVcIjpjYXNlXCJyZWxlYXNlXCI6Y2FzZVwicnVuXCI6Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOntsZXQgdD1Pby5nZXQoZS5kYXRhLnR5cGUpO2UuZGF0YS5lcnI/dC5zaGlmdCgpWzFdKGUuZGF0YS5lcnIpOnQuc2hpZnQoKVswXShlLmRhdGEub3V0KTticmVha31kZWZhdWx0On19LFljPWFzeW5jKCk9PntpZighY24pe2lmKGFyKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7aWYocG4pdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtpZihhcj0hMCxPdCgpKXJldHVybiBuZXcgUHJvbWlzZSgoZSx0KT0+e0hlPy50ZXJtaW5hdGUoKSxBcygpLnRoZW4oKFtuLHJdKT0+e3RyeXtIZT1yLEhlLm9uZXJyb3I9YT0+dChhKSxIZS5vbm1lc3NhZ2U9aWIsem89W2UsdF07bGV0IG89e3R5cGU6XCJpbml0LXdhc21cIixpbjp3ZX07IW8uaW4ud2FzbS53YXNtUGF0aHMmJihufHxpbXBvcnQubWV0YS51cmw/LnN0YXJ0c1dpdGgoXCJmaWxlOlwiKSkmJihvLmluLndhc20ud2FzbVBhdGhzPXt3YXNtOm5ldyBVUkwoXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiLGltcG9ydC5tZXRhLnVybCkuaHJlZn0pLEhlLnBvc3RNZXNzYWdlKG8pLGxuPW59Y2F0Y2gobyl7dChvKX19LHQpfSk7dHJ5e2F3YWl0IFRyKHdlLndhc20pLGF3YWl0IENyKHdlKSxjbj0hMH1jYXRjaChlKXt0aHJvdyBwbj0hMCxlfWZpbmFsbHl7YXI9ITF9fX0sWGM9YXN5bmMgZT0+e2lmKE90KCkpcmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHQsbik9PntXdChcImluaXQtZXBcIixbdCxuXSk7bGV0IHI9e3R5cGU6XCJpbml0LWVwXCIsaW46e2VwTmFtZTplLGVudjp3ZX19O0hlLnBvc3RNZXNzYWdlKHIpfSk7YXdhaXQgSXIod2UsZSl9LEpjPWFzeW5jIGU9Pk90KCk/KEx0KCksbmV3IFByb21pc2UoKHQsbik9PntXdChcImNvcHktZnJvbVwiLFt0LG5dKTtsZXQgcj17dHlwZTpcImNvcHktZnJvbVwiLGluOntidWZmZXI6ZX19O0hlLnBvc3RNZXNzYWdlKHIsW2UuYnVmZmVyXSl9KSk6WXQoZSksZXA9YXN5bmMoZSx0KT0+e2lmKE90KCkpe2lmKHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uKXRocm93IG5ldyBFcnJvcignc2Vzc2lvbiBvcHRpb24gXCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvblwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LicpO3JldHVybiBMdCgpLG5ldyBQcm9taXNlKChuLHIpPT57V3QoXCJjcmVhdGVcIixbbixyXSk7bGV0IG89e3R5cGU6XCJjcmVhdGVcIixpbjp7bW9kZWw6ZSxvcHRpb25zOnsuLi50fX19LGE9W107ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkmJmEucHVzaChlLmJ1ZmZlciksSGUucG9zdE1lc3NhZ2UobyxhKX0pfWVsc2UgcmV0dXJuIEFyKGUsdCl9LHRwPWFzeW5jIGU9PntpZihPdCgpKXJldHVybiBMdCgpLG5ldyBQcm9taXNlKCh0LG4pPT57V3QoXCJyZWxlYXNlXCIsW3Qsbl0pO2xldCByPXt0eXBlOlwicmVsZWFzZVwiLGluOmV9O0hlLnBvc3RNZXNzYWdlKHIpfSk7a3IoZSl9LHJwPWFzeW5jKGUsdCxuLHIsbyxhKT0+e2lmKE90KCkpe2lmKG4uc29tZShzPT5zWzNdIT09XCJjcHVcIikpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29yIG9uIEdQVSBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7aWYoby5zb21lKHM9PnMpKXRocm93IG5ldyBFcnJvcihcInByZS1hbGxvY2F0ZWQgb3V0cHV0IHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS5cIik7cmV0dXJuIEx0KCksbmV3IFByb21pc2UoKHMsZCk9PntXdChcInJ1blwiLFtzLGRdKTtsZXQgbD1uLHA9e3R5cGU6XCJydW5cIixpbjp7c2Vzc2lvbklkOmUsaW5wdXRJbmRpY2VzOnQsaW5wdXRzOmwsb3V0cHV0SW5kaWNlczpyLG9wdGlvbnM6YX19O0hlLnBvc3RNZXNzYWdlKHAsenIobCkpfSl9ZWxzZSByZXR1cm4gRXIoZSx0LG4scixvLGEpfSxucD1hc3luYyBlPT57aWYoT3QoKSlyZXR1cm4gTHQoKSxuZXcgUHJvbWlzZSgodCxuKT0+e1d0KFwiZW5kLXByb2ZpbGluZ1wiLFt0LG5dKTtsZXQgcj17dHlwZTpcImVuZC1wcm9maWxpbmdcIixpbjplfTtIZS5wb3N0TWVzc2FnZShyKX0pO1ByKGUpfX0pO3ZhciBvcCxhYixtbixpcD1HKCgpPT57XCJ1c2Ugc3RyaWN0XCI7R2UoKTtEbygpO3RlKCk7eHIoKTtYbigpO29wPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybltlLnR5cGUsZS5kaW1zLGUuZGF0YSxcImNwdVwiXTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse2dwdUJ1ZmZlcjplLmdwdUJ1ZmZlcn0sXCJncHUtYnVmZmVyXCJdO2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHttbFRlbnNvcjplLm1sVGVuc29yfSxcIm1sLXRlbnNvclwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2UubG9jYXRpb259IGZvciAke3QoKX1gKX19LGFiPWU9Pntzd2l0Y2goZVszXSl7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBxZShlWzBdLGVbMl0sZVsxXSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOntsZXQgdD1lWzBdO2lmKCFNcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtsZXR7Z3B1QnVmZmVyOm4sZG93bmxvYWQ6cixkaXNwb3NlOm99PWVbMl07cmV0dXJuIHFlLmZyb21HcHVCdWZmZXIobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cixkaXNwb3NlOm99KX1jYXNlXCJtbC10ZW5zb3JcIjp7bGV0IHQ9ZVswXTtpZighUnIodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBNTFRlbnNvciB0ZW5zb3JgKTtsZXR7bWxUZW5zb3I6bixkb3dubG9hZDpyLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gcWUuZnJvbU1MVGVuc29yKG4se2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOnIsZGlzcG9zZTpvfSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlWzNdfWApfX0sbW49Y2xhc3N7YXN5bmMgZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCl7cmV0dXJuIEpjKGF3YWl0IGVyKHQpKX1hc3luYyBsb2FkTW9kZWwodCxuKXtOZSgpO2xldCByO3R5cGVvZiB0PT1cInN0cmluZ1wiP3I9YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTpyPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBlcChyLG4pLEJlKCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiB0cCh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQsbixyKXtOZSgpO2xldCBvPVtdLGE9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCh5PT57bGV0IF89eVswXSxiPXlbMV0sdz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihfKTtpZih3PT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke199J2ApO28ucHVzaChiKSxhLnB1c2godyl9KTtsZXQgcz1bXSxkPVtdO09iamVjdC5lbnRyaWVzKG4pLmZvckVhY2goeT0+e2xldCBfPXlbMF0sYj15WzFdLHc9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKF8pO2lmKHc9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke199J2ApO3MucHVzaChiKSxkLnB1c2godyl9KTtsZXQgbD1vLm1hcCgoeSxfKT0+b3AoeSwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbYVtfXV19XCJgKSkscD1zLm1hcCgoeSxfKT0+eT9vcCh5LCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2RbX11dfVwiYCk6bnVsbCksZj1hd2FpdCBycCh0aGlzLnNlc3Npb25JZCxhLGwsZCxwLHIpLGg9e307Zm9yKGxldCB5PTA7eTxmLmxlbmd0aDt5KyspaFt0aGlzLm91dHB1dE5hbWVzW2RbeV1dXT1zW3ldPz9hYihmW3ldKTtyZXR1cm4gQmUoKSxofXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe25wKHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIHNwPXt9O1p0KHNwLHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZDooKT0+Zm4saW5pdGlhbGl6ZUZsYWdzOigpPT5hcCx3YXNtQmFja2VuZDooKT0+c2J9KTt2YXIgYXAsZm4sc2IsdXA9RygoKT0+e1widXNlIHN0cmljdFwiO0dlKCk7RG8oKTtpcCgpO2FwPSgpPT57aWYoKHR5cGVvZiB3ZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHx3ZS53YXNtLmluaXRUaW1lb3V0PDApJiYod2Uud2FzbS5pbml0VGltZW91dD0wKSx3ZS53YXNtLnNpbWQ9PT0hMSYmY29uc29sZS53YXJuKCdEZXByZWNhdGVkIHByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byBmYWxzZS4gbm9uLVNJTUQgYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLCBhbmQgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZC4nKSx0eXBlb2Ygd2Uud2FzbS5wcm94eSE9XCJib29sZWFuXCImJih3ZS53YXNtLnByb3h5PSExKSx0eXBlb2Ygd2Uud2FzbS50cmFjZSE9XCJib29sZWFuXCImJih3ZS53YXNtLnRyYWNlPSExKSx0eXBlb2Ygd2Uud2FzbS5udW1UaHJlYWRzIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih3ZS53YXNtLm51bVRocmVhZHMpfHx3ZS53YXNtLm51bVRocmVhZHM8PTApaWYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpd2Uud2FzbS5udW1UaHJlYWRzPTE7ZWxzZXtsZXQgZT10eXBlb2YgbmF2aWdhdG9yPlwidVwiP05uKFwibm9kZTpvc1wiKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3dlLndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0sZm49Y2xhc3N7YXN5bmMgaW5pdCh0KXthcCgpLGF3YWl0IFljKCksYXdhaXQgWGModCl9YXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIodCxuKXtsZXQgcj1uZXcgbW47cmV0dXJuIGF3YWl0IHIubG9hZE1vZGVsKHQsbiksUHJvbWlzZS5yZXNvbHZlKHIpfX0sc2I9bmV3IGZufSk7R2UoKTtHZSgpO0dlKCk7dmFyIGhzPVwiMS4yMS4wXCI7dmFyIGxUPUZuO3tsZXQgZT0odXAoKSxicihzcCkpLndhc21CYWNrZW5kO0N0KFwid2ViZ3B1XCIsZSw1KSxDdChcIndlYm5uXCIsZSw1KSxDdChcImNwdVwiLGUsMTApLEN0KFwid2FzbVwiLGUsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZS52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTpocyxlbnVtZXJhYmxlOiEwfSk7ZXhwb3J0e09mIGFzIEluZmVyZW5jZVNlc3Npb24sdnIgYXMgVFJBQ0UsTmUgYXMgVFJBQ0VfRlVOQ19CRUdJTixCZSBhcyBUUkFDRV9GVU5DX0VORCxxZSBhcyBUZW5zb3IsbFQgYXMgZGVmYXVsdCx3ZSBhcyBlbnYsQ3QgYXMgcmVnaXN0ZXJCYWNrZW5kfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?164a\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?9165":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.69d1be4b.mjs";

/***/ })

}]);